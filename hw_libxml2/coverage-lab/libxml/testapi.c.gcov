        -:    0:Source:testapi.c
        -:    0:Programs:38
        -:    1:/*
        -:    2: * testapi.c: libxml2 API tester program.
        -:    3: *
        -:    4: * Automatically generated by gentest.py from libxml2-api.xml
        -:    5: *
        -:    6: * See Copyright for the status of this software.
        -:    7: *
        -:    8: * daniel@veillard.com
        -:    9: */
        -:   10:
        -:   11:#include "libxml.h"
        -:   12:#include <stdio.h>
        -:   13:
        -:   14:#include <stdlib.h> /* for putenv() */
        -:   15:#include <string.h>
        -:   16:#include <libxml/xmlerror.h>
        -:   17:#include <libxml/relaxng.h>
        -:   18:
        -:   19:
        -:   20:static int testlibxml2(void);
        -:   21:static int test_module(const char *module);
        -:   22:
        -:   23:static int generic_errors = 0;
        -:   24:static int call_tests = 0;
        -:   25:static int function_tests = 0;
        -:   26:
        -:   27:static xmlChar chartab[1024];
        -:   28:static int inttab[1024];
        -:   29:static unsigned long longtab[1024];
        -:   30:
        -:   31:static xmlDocPtr api_doc = NULL;
        -:   32:static xmlDtdPtr api_dtd = NULL;
        -:   33:static xmlNodePtr api_root = NULL;
        -:   34:static xmlAttrPtr api_attr = NULL;
        -:   35:static xmlNsPtr api_ns = NULL;
        -:   36:
        -:   37:static void
    #####:   38:structured_errors(void *userData ATTRIBUTE_UNUSED,
        -:   39:                  xmlErrorPtr error ATTRIBUTE_UNUSED) {
    #####:   40:    generic_errors++;
    #####:   41:}
        -:   42:
        -:   43:static void
    #####:   44:free_api_doc(void) {
    #####:   45:    xmlFreeDoc(api_doc);
    #####:   46:    api_doc = NULL;
    #####:   47:    api_dtd = NULL;
    #####:   48:    api_root = NULL;
    #####:   49:    api_attr = NULL;
    #####:   50:    api_ns = NULL;
    #####:   51:}
        -:   52:
        -:   53:static xmlDocPtr
    #####:   54:get_api_doc(void) {
    #####:   55:    if (api_doc == NULL) {
    #####:   56:        api_doc = xmlReadMemory("<!DOCTYPE root [<!ELEMENT root EMPTY>]><root xmlns:h='http://example.com/' h:foo='bar'/>", 88, "root_test", NULL, 0);
    #####:   57:	api_root = NULL;
    #####:   58:	api_attr = NULL;
        -:   59:    }
    #####:   60:    return(api_doc);
        -:   61:}
        -:   62:
        -:   63:static xmlDtdPtr
    #####:   64:get_api_dtd(void) {
    #####:   65:    if ((api_dtd == NULL) || (api_dtd->type != XML_DTD_NODE)) {
    #####:   66:        get_api_doc();
    #####:   67:	if ((api_doc != NULL) && (api_doc->children != NULL) &&
    #####:   68:	    (api_doc->children->type == XML_DTD_NODE))
    #####:   69:	    api_dtd = (xmlDtdPtr) api_doc->children;
        -:   70:    }
    #####:   71:    return(api_dtd);
        -:   72:}
        -:   73:
        -:   74:static xmlNodePtr
    #####:   75:get_api_root(void) {
    #####:   76:    if ((api_root == NULL) || (api_root->type != XML_ELEMENT_NODE)) {
    #####:   77:        get_api_doc();
    #####:   78:	if ((api_doc != NULL) && (api_doc->children != NULL) &&
    #####:   79:	    (api_doc->children->next != NULL) &&
    #####:   80:	    (api_doc->children->next->type == XML_ELEMENT_NODE))
    #####:   81:	    api_root = api_doc->children->next;
        -:   82:    }
    #####:   83:    return(api_root);
        -:   84:}
        -:   85:
        -:   86:static xmlNsPtr
    #####:   87:get_api_ns(void) {
    #####:   88:    get_api_root();
    #####:   89:    if (api_root != NULL)
    #####:   90:        api_ns = api_root->nsDef;
    #####:   91:    return(api_ns);
        -:   92:}
        -:   93:
        -:   94:static xmlAttrPtr
    #####:   95:get_api_attr(void) {
        -:   96:#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED)
        -:   97:    static int nr = 0;
        -:   98:    xmlChar name[20];
        -:   99:#endif
        -:  100:
    #####:  101:    if ((api_root == NULL) || (api_root->type != XML_ELEMENT_NODE)) {
    #####:  102:        get_api_root();
        -:  103:    }
    #####:  104:    if (api_root == NULL)
    #####:  105:        return(NULL);
    #####:  106:    if (api_root->properties != NULL) {
    #####:  107:        api_attr = api_root->properties;
    #####:  108:        return(api_root->properties);
        -:  109:    }
    #####:  110:    api_attr = NULL;
        -:  111:#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED)
    #####:  112:    snprintf((char *) name, 20, "foo%d", nr++);
    #####:  113:    api_attr = xmlSetProp(api_root, name, (const xmlChar *) "bar");
        -:  114:#endif
    #####:  115:    return(api_attr);
        -:  116:}
        -:  117:
        -:  118:static int quiet = 0;
        -:  119:
    #####:  120:int main(int argc, char **argv) {
        -:  121:    int ret;
        -:  122:    int blocks, mem;
        -:  123:
        -:  124:#ifdef HAVE_PUTENV
        -:  125:    /* access to the proxy can slow up regression tests a lot */
    #####:  126:    putenv((char *) "http_proxy=");
        -:  127:#endif
        -:  128:
    #####:  129:    memset(chartab, 0, sizeof(chartab));
    #####:  130:    strncpy((char *) chartab, "  chartab\n", 20);
    #####:  131:    memset(inttab, 0, sizeof(inttab));
    #####:  132:    memset(longtab, 0, sizeof(longtab));
        -:  133:
    #####:  134:    xmlInitParser();
        -:  135:#ifdef LIBXML_SCHEMAS_ENABLED
    #####:  136:    xmlRelaxNGInitTypes();
        -:  137:#endif
        -:  138:
    #####:  139:    LIBXML_TEST_VERSION
        -:  140:
    #####:  141:    xmlSetStructuredErrorFunc(NULL, structured_errors);
        -:  142:
    #####:  143:    if (argc >= 2) {
    #####:  144:        if (!strcmp(argv[1], "-q")) {
    #####:  145:	    quiet = 1;
    #####:  146:	    if (argc >= 3)
    #####:  147:	        ret = test_module(argv[2]);
        -:  148:	    else
    #####:  149:		ret = testlibxml2();
        -:  150:        } else {
    #####:  151:	   ret = test_module(argv[1]);
        -:  152:	}
        -:  153:    } else
    #####:  154:	ret = testlibxml2();
        -:  155:
    #####:  156:    xmlCleanupParser();
    #####:  157:    blocks = xmlMemBlocks();
    #####:  158:    mem = xmlMemUsed();
    #####:  159:    if ((blocks != 0) || (mem != 0)) {
    #####:  160:        printf("testapi leaked %d bytes in %d blocks\n", mem, blocks);
        -:  161:    }
    #####:  162:    xmlMemoryDump();
        -:  163:
    #####:  164:    return (ret != 0);
        -:  165:}
        -:  166:
        -:  167:#include <libxml/HTMLparser.h>
        -:  168:#include <libxml/HTMLtree.h>
        -:  169:#include <libxml/catalog.h>
        -:  170:#include <libxml/chvalid.h>
        -:  171:#include <libxml/dict.h>
        -:  172:#include <libxml/encoding.h>
        -:  173:#include <libxml/entities.h>
        -:  174:#include <libxml/hash.h>
        -:  175:#include <libxml/list.h>
        -:  176:#include <libxml/nanoftp.h>
        -:  177:#include <libxml/nanohttp.h>
        -:  178:#include <libxml/parser.h>
        -:  179:#include <libxml/parserInternals.h>
        -:  180:#include <libxml/pattern.h>
        -:  181:#include <libxml/relaxng.h>
        -:  182:#include <libxml/schemasInternals.h>
        -:  183:#include <libxml/schematron.h>
        -:  184:#include <libxml/tree.h>
        -:  185:#include <libxml/uri.h>
        -:  186:#include <libxml/valid.h>
        -:  187:#include <libxml/xinclude.h>
        -:  188:#include <libxml/xmlIO.h>
        -:  189:#include <libxml/xmlerror.h>
        -:  190:#include <libxml/xmlreader.h>
        -:  191:#include <libxml/xmlsave.h>
        -:  192:#include <libxml/xmlschemas.h>
        -:  193:#include <libxml/xmlschemastypes.h>
        -:  194:#include <libxml/xmlstring.h>
        -:  195:#include <libxml/xmlwriter.h>
        -:  196:#include <libxml/xpath.h>
        -:  197:#include <libxml/xpointer.h>
        -:  198:#include <libxml/debugXML.h>
        -:  199:
        -:  200:/*
        -:  201:  We manually define xmlErrMemory because it's normal declaration
        -:  202:  is "hidden" by #ifdef IN_LIBXML
        -:  203:*/
        -:  204:void xmlErrMemory(xmlParserCtxtPtr ctxt, const char *extra);
        -:  205:
        -:  206:/*
        -:  207: We need some "remote" addresses, but want to avoid getting into
        -:  208: name resolution delays, so we use these
        -:  209:*/
        -:  210:#define	REMOTE1GOOD	"http://localhost/"
        -:  211:#define	REMOTE1BAD	"http:http://http"
        -:  212:#define	REMOTE2GOOD	"ftp://localhost/foo"
        -:  213:
        -:  214:#define gen_nb_void_ptr 2
        -:  215:
    #####:  216:static void *gen_void_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  217:    return(NULL);
        -:  218:}
    #####:  219:static void des_void_ptr(int no ATTRIBUTE_UNUSED, void *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  220:}
        -:  221:
        -:  222:#if 0
        -:  223:#define gen_nb_const_void_ptr 2
        -:  224:
        -:  225:static const void *gen_const_void_ptr(int no, int nr ATTRIBUTE_UNUSED) {
        -:  226:    if (no == 0) return((const void *) "immutable string");
        -:  227:    return(NULL);
        -:  228:}
        -:  229:static void des_const_void_ptr(int no ATTRIBUTE_UNUSED, const void *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
        -:  230:}
        -:  231:#endif
        -:  232:
        -:  233:#define gen_nb_userdata 3
        -:  234:
    #####:  235:static void *gen_userdata(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  236:    if (no == 0) return((void *) &call_tests);
    #####:  237:    if (no == 1) return((void *) -1);
    #####:  238:    return(NULL);
        -:  239:}
    #####:  240:static void des_userdata(int no ATTRIBUTE_UNUSED, void *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  241:}
        -:  242:
        -:  243:
        -:  244:#define gen_nb_int 4
        -:  245:
    #####:  246:static int gen_int(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  247:    if (no == 0) return(0);
    #####:  248:    if (no == 1) return(1);
    #####:  249:    if (no == 2) return(-1);
    #####:  250:    if (no == 3) return(122);
    #####:  251:    return(-1);
        -:  252:}
        -:  253:
    #####:  254:static void des_int(int no ATTRIBUTE_UNUSED, int val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  255:}
        -:  256:
        -:  257:#define gen_nb_parseroptions 5
        -:  258:
    #####:  259:static int gen_parseroptions(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  260:    if (no == 0) return(XML_PARSE_NOBLANKS | XML_PARSE_RECOVER);
    #####:  261:    if (no == 1) return(XML_PARSE_NOENT | XML_PARSE_DTDLOAD | XML_PARSE_DTDATTR | XML_PARSE_DTDVALID | XML_PARSE_NOCDATA);
    #####:  262:    if (no == 2) return(XML_PARSE_XINCLUDE | XML_PARSE_NOXINCNODE | XML_PARSE_NSCLEAN);
    #####:  263:    if (no == 3) return(XML_PARSE_XINCLUDE | XML_PARSE_NODICT);
    #####:  264:    return(XML_PARSE_SAX1);
        -:  265:}
        -:  266:
    #####:  267:static void des_parseroptions(int no ATTRIBUTE_UNUSED, int val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  268:}
        -:  269:
        -:  270:#if 0
        -:  271:#define gen_nb_long 5
        -:  272:
        -:  273:static long gen_long(int no, int nr ATTRIBUTE_UNUSED) {
        -:  274:    if (no == 0) return(0);
        -:  275:    if (no == 1) return(1);
        -:  276:    if (no == 2) return(-1);
        -:  277:    if (no == 3) return(122);
        -:  278:    return(-1);
        -:  279:}
        -:  280:
        -:  281:static void des_long(int no ATTRIBUTE_UNUSED, long val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
        -:  282:}
        -:  283:#endif
        -:  284:
        -:  285:#define gen_nb_xmlChar 4
        -:  286:
    #####:  287:static xmlChar gen_xmlChar(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  288:    if (no == 0) return('a');
    #####:  289:    if (no == 1) return(' ');
    #####:  290:    if (no == 2) return((xmlChar) '\xf8');
    #####:  291:    return(0);
        -:  292:}
        -:  293:
    #####:  294:static void des_xmlChar(int no ATTRIBUTE_UNUSED, xmlChar val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  295:}
        -:  296:
        -:  297:#define gen_nb_unsigned_int 3
        -:  298:
    #####:  299:static unsigned int gen_unsigned_int(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  300:    if (no == 0) return(0);
    #####:  301:    if (no == 1) return(1);
    #####:  302:    if (no == 2) return(122);
    #####:  303:    return((unsigned int) -1);
        -:  304:}
        -:  305:
    #####:  306:static void des_unsigned_int(int no ATTRIBUTE_UNUSED, unsigned int val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  307:}
        -:  308:
        -:  309:#define gen_nb_unsigned_long 4
        -:  310:
    #####:  311:static unsigned long gen_unsigned_long(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  312:    if (no == 0) return(0);
    #####:  313:    if (no == 1) return(1);
    #####:  314:    if (no == 2) return(122);
    #####:  315:    return((unsigned long) -1);
        -:  316:}
        -:  317:
    #####:  318:static void des_unsigned_long(int no ATTRIBUTE_UNUSED, unsigned long val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  319:}
        -:  320:
        -:  321:#define gen_nb_double 4
        -:  322:
    #####:  323:static double gen_double(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  324:    if (no == 0) return(0);
    #####:  325:    if (no == 1) return(-1.1);
        -:  326:#if defined(LIBXML_XPATH_ENABLED)
    #####:  327:    if (no == 2) return(xmlXPathNAN);
        -:  328:#endif
    #####:  329:    return(-1);
        -:  330:}
        -:  331:
    #####:  332:static void des_double(int no ATTRIBUTE_UNUSED, double val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  333:}
        -:  334:
        -:  335:#define gen_nb_unsigned_long_ptr 2
        -:  336:
    #####:  337:static unsigned long *gen_unsigned_long_ptr(int no, int nr) {
    #####:  338:    if (no == 0) return(&longtab[nr]);
    #####:  339:    return(NULL);
        -:  340:}
        -:  341:
    #####:  342:static void des_unsigned_long_ptr(int no ATTRIBUTE_UNUSED, unsigned long *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  343:}
        -:  344:
        -:  345:#define gen_nb_int_ptr 2
        -:  346:
    #####:  347:static int *gen_int_ptr(int no, int nr) {
    #####:  348:    if (no == 0) return(&inttab[nr]);
    #####:  349:    return(NULL);
        -:  350:}
        -:  351:
    #####:  352:static void des_int_ptr(int no ATTRIBUTE_UNUSED, int *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  353:}
        -:  354:
        -:  355:#define gen_nb_const_char_ptr 4
        -:  356:
    #####:  357:static char *gen_const_char_ptr(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  358:    if (no == 0) return((char *) "foo");
    #####:  359:    if (no == 1) return((char *) "<foo/>");
    #####:  360:    if (no == 2) return((char *) "test/ent2");
    #####:  361:    return(NULL);
        -:  362:}
    #####:  363:static void des_const_char_ptr(int no ATTRIBUTE_UNUSED, const char *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  364:}
        -:  365:
        -:  366:#define gen_nb_xmlChar_ptr 2
        -:  367:
    #####:  368:static xmlChar *gen_xmlChar_ptr(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  369:    if (no == 0) return(&chartab[0]);
    #####:  370:    return(NULL);
        -:  371:}
    #####:  372:static void des_xmlChar_ptr(int no ATTRIBUTE_UNUSED, xmlChar *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  373:}
        -:  374:
        -:  375:#define gen_nb_FILE_ptr 2
        -:  376:
    #####:  377:static FILE *gen_FILE_ptr(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  378:    if (no == 0) return(fopen("test.out", "a+"));
    #####:  379:    return(NULL);
        -:  380:}
    #####:  381:static void des_FILE_ptr(int no ATTRIBUTE_UNUSED, FILE *val, int nr ATTRIBUTE_UNUSED) {
    #####:  382:    if (val != NULL) fclose(val);
    #####:  383:}
        -:  384:
        -:  385:#define gen_nb_debug_FILE_ptr 2
    #####:  386:static FILE *gen_debug_FILE_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  387:    return(fopen("test.out", "a+"));
        -:  388:}
    #####:  389:static void des_debug_FILE_ptr(int no ATTRIBUTE_UNUSED, FILE *val, int nr ATTRIBUTE_UNUSED) {
    #####:  390:    if (val != NULL) fclose(val);
    #####:  391:}
        -:  392:
        -:  393:#define gen_nb_const_xmlChar_ptr 5
        -:  394:
    #####:  395:static xmlChar *gen_const_xmlChar_ptr(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  396:    if (no == 0) return((xmlChar *) "foo");
    #####:  397:    if (no == 1) return((xmlChar *) "<foo/>");
    #####:  398:    if (no == 2) return((xmlChar *) "n" "\xf8" "ne");
    #####:  399:    if (no == 3) return((xmlChar *) " 2ab ");
    #####:  400:    return(NULL);
        -:  401:}
    #####:  402:static void des_const_xmlChar_ptr(int no ATTRIBUTE_UNUSED, const xmlChar *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  403:}
        -:  404:
        -:  405:#define gen_nb_filepath 8
        -:  406:
    #####:  407:static const char *gen_filepath(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  408:    if (no == 0) return("missing.xml");
    #####:  409:    if (no == 1) return("<foo/>");
    #####:  410:    if (no == 2) return("test/ent2");
    #####:  411:    if (no == 3) return("test/valid/REC-xml-19980210.xml");
    #####:  412:    if (no == 4) return("test/valid/dtds/xhtml1-strict.dtd");
    #####:  413:    if (no == 5) return(REMOTE1GOOD);
    #####:  414:    if (no == 6) return(REMOTE1BAD);
    #####:  415:    return(NULL);
        -:  416:}
    #####:  417:static void des_filepath(int no ATTRIBUTE_UNUSED, const char *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  418:}
        -:  419:
        -:  420:#define gen_nb_eaten_name 2
        -:  421:
    #####:  422:static xmlChar *gen_eaten_name(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  423:    if (no == 0) return(xmlStrdup(BAD_CAST "eaten"));
    #####:  424:    return(NULL);
        -:  425:}
    #####:  426:static void des_eaten_name(int no ATTRIBUTE_UNUSED, xmlChar *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  427:}
        -:  428:
        -:  429:#define gen_nb_fileoutput 6
        -:  430:
    #####:  431:static const char *gen_fileoutput(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  432:    if (no == 0) return("/missing.xml");
    #####:  433:    if (no == 1) return("<foo/>");
    #####:  434:    if (no == 2) return(REMOTE2GOOD);
    #####:  435:    if (no == 3) return(REMOTE1GOOD);
    #####:  436:    if (no == 4) return(REMOTE1BAD);
    #####:  437:    return(NULL);
        -:  438:}
    #####:  439:static void des_fileoutput(int no ATTRIBUTE_UNUSED, const char *val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  440:}
        -:  441:
        -:  442:#define gen_nb_xmlParserCtxtPtr 3
    #####:  443:static xmlParserCtxtPtr gen_xmlParserCtxtPtr(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  444:    if (no == 0) return(xmlNewParserCtxt());
    #####:  445:    if (no == 1) return(xmlCreateMemoryParserCtxt("<doc/>", 6));
    #####:  446:    return(NULL);
        -:  447:}
    #####:  448:static void des_xmlParserCtxtPtr(int no ATTRIBUTE_UNUSED, xmlParserCtxtPtr val, int nr ATTRIBUTE_UNUSED) {
    #####:  449:    if (val != NULL)
    #####:  450:        xmlFreeParserCtxt(val);
    #####:  451:}
        -:  452:
        -:  453:#define gen_nb_xmlSAXHandlerPtr 2
    #####:  454:static xmlSAXHandlerPtr gen_xmlSAXHandlerPtr(int no, int nr ATTRIBUTE_UNUSED) {
        -:  455:#ifdef LIBXML_SAX1_ENABLED
    #####:  456:    if (no == 0) return((xmlSAXHandlerPtr) &xmlDefaultSAXHandler);
        -:  457:#endif
    #####:  458:    return(NULL);
        -:  459:}
    #####:  460:static void des_xmlSAXHandlerPtr(int no ATTRIBUTE_UNUSED, xmlSAXHandlerPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  461:}
        -:  462:
        -:  463:#define gen_nb_xmlValidCtxtPtr 2
    #####:  464:static xmlValidCtxtPtr gen_xmlValidCtxtPtr(int no, int nr ATTRIBUTE_UNUSED) {
        -:  465:#ifdef LIBXML_VALID_ENABLED
    #####:  466:    if (no == 0) return(xmlNewValidCtxt());
        -:  467:#endif
    #####:  468:    return(NULL);
        -:  469:}
    #####:  470:static void des_xmlValidCtxtPtr(int no ATTRIBUTE_UNUSED, xmlValidCtxtPtr val, int nr ATTRIBUTE_UNUSED) {
        -:  471:#ifdef LIBXML_VALID_ENABLED
    #####:  472:    if (val != NULL)
    #####:  473:        xmlFreeValidCtxt(val);
        -:  474:#endif
    #####:  475:}
        -:  476:
        -:  477:#define gen_nb_xmlParserInputBufferPtr 8
        -:  478:
    #####:  479:static xmlParserInputBufferPtr gen_xmlParserInputBufferPtr(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  480:    if (no == 0) return(xmlParserInputBufferCreateFilename("missing.xml", XML_CHAR_ENCODING_NONE));
    #####:  481:    if (no == 1) return(xmlParserInputBufferCreateFilename("<foo/>", XML_CHAR_ENCODING_NONE));
    #####:  482:    if (no == 2) return(xmlParserInputBufferCreateFilename("test/ent2", XML_CHAR_ENCODING_NONE));
    #####:  483:    if (no == 3) return(xmlParserInputBufferCreateFilename("test/valid/REC-xml-19980210.xml", XML_CHAR_ENCODING_NONE));
    #####:  484:    if (no == 4) return(xmlParserInputBufferCreateFilename("test/valid/dtds/xhtml1-strict.dtd", XML_CHAR_ENCODING_NONE));
    #####:  485:    if (no == 5) return(xmlParserInputBufferCreateFilename(REMOTE1GOOD, XML_CHAR_ENCODING_NONE));
    #####:  486:    if (no == 6) return(xmlParserInputBufferCreateFilename(REMOTE1BAD, XML_CHAR_ENCODING_NONE));
    #####:  487:    return(NULL);
        -:  488:}
    #####:  489:static void des_xmlParserInputBufferPtr(int no ATTRIBUTE_UNUSED, xmlParserInputBufferPtr val, int nr ATTRIBUTE_UNUSED) {
    #####:  490:    xmlFreeParserInputBuffer(val);
    #####:  491:}
        -:  492:
        -:  493:#define gen_nb_xmlDocPtr 4
    #####:  494:static xmlDocPtr gen_xmlDocPtr(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  495:    if (no == 0) return(xmlNewDoc(BAD_CAST "1.0"));
    #####:  496:    if (no == 1) return(xmlReadMemory("<foo/>", 6, "test", NULL, 0));
    #####:  497:    if (no == 2) return(xmlReadMemory("<!DOCTYPE foo []> <foo/>", 24, "test", NULL, 0));
    #####:  498:    return(NULL);
        -:  499:}
    #####:  500:static void des_xmlDocPtr(int no ATTRIBUTE_UNUSED, xmlDocPtr val, int nr ATTRIBUTE_UNUSED) {
    #####:  501:    if ((val != NULL) && (val != api_doc) && (val->doc != api_doc))
    #####:  502:        xmlFreeDoc(val);
    #####:  503:}
        -:  504:
        -:  505:#define gen_nb_xmlAttrPtr 2
    #####:  506:static xmlAttrPtr gen_xmlAttrPtr(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  507:    if (no == 0) return(get_api_attr());
    #####:  508:    return(NULL);
        -:  509:}
    #####:  510:static void des_xmlAttrPtr(int no, xmlAttrPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  511:    if (no == 0) free_api_doc();
    #####:  512:}
        -:  513:
        -:  514:#define gen_nb_xmlDictPtr 2
    #####:  515:static xmlDictPtr gen_xmlDictPtr(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  516:    if (no == 0) return(xmlDictCreate());
    #####:  517:    return(NULL);
        -:  518:}
    #####:  519:static void des_xmlDictPtr(int no ATTRIBUTE_UNUSED, xmlDictPtr val, int nr ATTRIBUTE_UNUSED) {
    #####:  520:    if (val != NULL)
    #####:  521:        xmlDictFree(val);
    #####:  522:}
        -:  523:
        -:  524:#define gen_nb_xmlNodePtr 3
    #####:  525:static xmlNodePtr gen_xmlNodePtr(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  526:    if (no == 0) return(xmlNewPI(BAD_CAST "test", NULL));
    #####:  527:    if (no == 1) return(get_api_root());
    #####:  528:    return(NULL);
        -:  529:/*     if (no == 2) return((xmlNodePtr) get_api_doc()); */
        -:  530:}
    #####:  531:static void des_xmlNodePtr(int no, xmlNodePtr val, int nr ATTRIBUTE_UNUSED) {
    #####:  532:    if (no == 1) {
    #####:  533:        free_api_doc();
    #####:  534:    } else if (val != NULL) {
    #####:  535:        xmlUnlinkNode(val);
    #####:  536:        xmlFreeNode(val);
        -:  537:    }
    #####:  538:}
        -:  539:
        -:  540:#define gen_nb_xmlDtdPtr 3
    #####:  541:static xmlDtdPtr gen_xmlDtdPtr(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  542:    if (no == 0)
    #####:  543:        return(xmlNewDtd(NULL, BAD_CAST "dtd", BAD_CAST"foo", BAD_CAST"bar"));
    #####:  544:    if (no == 1) return(get_api_dtd());
    #####:  545:    return(NULL);
        -:  546:}
    #####:  547:static void des_xmlDtdPtr(int no, xmlDtdPtr val, int nr ATTRIBUTE_UNUSED) {
    #####:  548:    if (no == 1) free_api_doc();
    #####:  549:    else if (val != NULL) {
    #####:  550:        xmlUnlinkNode((xmlNodePtr) val);
    #####:  551:        xmlFreeNode((xmlNodePtr) val);
        -:  552:    }
    #####:  553:}
        -:  554:
        -:  555:#define gen_nb_xmlNsPtr 2
    #####:  556:static xmlNsPtr gen_xmlNsPtr(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  557:    if (no == 0) return(get_api_ns());
    #####:  558:    return(NULL);
        -:  559:}
    #####:  560:static void des_xmlNsPtr(int no, xmlNsPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  561:    if (no == 0) free_api_doc();
    #####:  562:}
        -:  563:
        -:  564:#define gen_nb_xmlNodePtr_in 3
    #####:  565:static xmlNodePtr gen_xmlNodePtr_in(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  566:    if (no == 0) return(xmlNewPI(BAD_CAST "test", NULL));
    #####:  567:    if (no == 0) return(xmlNewText(BAD_CAST "text"));
    #####:  568:    return(NULL);
        -:  569:}
    #####:  570:static void des_xmlNodePtr_in(int no ATTRIBUTE_UNUSED, xmlNodePtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  571:}
        -:  572:
        -:  573:#ifdef LIBXML_WRITER_ENABLED
        -:  574:#define gen_nb_xmlTextWriterPtr 2
    #####:  575:static xmlTextWriterPtr gen_xmlTextWriterPtr(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  576:    if (no == 0) return(xmlNewTextWriterFilename("test.out", 0));
    #####:  577:    return(NULL);
        -:  578:}
    #####:  579:static void des_xmlTextWriterPtr(int no ATTRIBUTE_UNUSED, xmlTextWriterPtr val, int nr ATTRIBUTE_UNUSED) {
    #####:  580:    if (val != NULL) xmlFreeTextWriter(val);
    #####:  581:}
        -:  582:#endif
        -:  583:
        -:  584:#ifdef LIBXML_READER_ENABLED
        -:  585:#define gen_nb_xmlTextReaderPtr 4
    #####:  586:static xmlTextReaderPtr gen_xmlTextReaderPtr(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  587:    if (no == 0) return(xmlNewTextReaderFilename("test/ent2"));
    #####:  588:    if (no == 1) return(xmlNewTextReaderFilename("test/valid/REC-xml-19980210.xml"));
    #####:  589:    if (no == 2) return(xmlNewTextReaderFilename("test/valid/dtds/xhtml1-strict.dtd"));
    #####:  590:    return(NULL);
        -:  591:}
    #####:  592:static void des_xmlTextReaderPtr(int no ATTRIBUTE_UNUSED, xmlTextReaderPtr val, int nr ATTRIBUTE_UNUSED) {
    #####:  593:    if (val != NULL) xmlFreeTextReader(val);
    #####:  594:}
        -:  595:#endif
        -:  596:
        -:  597:#define gen_nb_xmlBufferPtr 3
        -:  598:static const xmlChar *static_buf_content = (xmlChar *)"a static buffer";
    #####:  599:static xmlBufferPtr gen_xmlBufferPtr(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  600:    if (no == 0) return(xmlBufferCreate());
    #####:  601:    if (no == 1) return(xmlBufferCreateStatic((void *)static_buf_content, 13));
    #####:  602:    return(NULL);
        -:  603:}
    #####:  604:static void des_xmlBufferPtr(int no ATTRIBUTE_UNUSED, xmlBufferPtr val, int nr ATTRIBUTE_UNUSED) {
    #####:  605:    if (val != NULL) {
    #####:  606:        xmlBufferFree(val);
        -:  607:    }
    #####:  608:}
        -:  609:
        -:  610:#define gen_nb_xmlListPtr 2
    #####:  611:static xmlListPtr gen_xmlListPtr(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  612:    if (no == 0) return(xmlListCreate(NULL, NULL));
    #####:  613:    return(NULL);
        -:  614:}
    #####:  615:static void des_xmlListPtr(int no ATTRIBUTE_UNUSED, xmlListPtr val, int nr ATTRIBUTE_UNUSED) {
    #####:  616:    if (val != NULL) {
    #####:  617:        xmlListDelete(val);
        -:  618:    }
    #####:  619:}
        -:  620:
        -:  621:#define gen_nb_xmlHashTablePtr 2
    #####:  622:static xmlHashTablePtr gen_xmlHashTablePtr(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  623:    if (no == 0) return(xmlHashCreate(10));
    #####:  624:    return(NULL);
        -:  625:}
    #####:  626:static void des_xmlHashTablePtr(int no ATTRIBUTE_UNUSED, xmlHashTablePtr val, int nr ATTRIBUTE_UNUSED) {
    #####:  627:    if (val != NULL) {
    #####:  628:        xmlHashFree(val, NULL);
        -:  629:    }
    #####:  630:}
        -:  631:
        -:  632:#include <libxml/xpathInternals.h>
        -:  633:
        -:  634:#ifdef LIBXML_XPATH_ENABLED
        -:  635:#define gen_nb_xmlXPathObjectPtr 5
    #####:  636:static xmlXPathObjectPtr gen_xmlXPathObjectPtr(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  637:    if (no == 0) return(xmlXPathNewString(BAD_CAST "string object"));
    #####:  638:    if (no == 1) return(xmlXPathNewFloat(1.1));
    #####:  639:    if (no == 2) return(xmlXPathNewBoolean(1));
    #####:  640:    if (no == 3) return(xmlXPathNewNodeSet(NULL));
    #####:  641:    return(NULL);
        -:  642:}
    #####:  643:static void des_xmlXPathObjectPtr(int no ATTRIBUTE_UNUSED, xmlXPathObjectPtr val, int nr ATTRIBUTE_UNUSED) {
    #####:  644:    if (val != NULL) {
    #####:  645:        xmlXPathFreeObject(val);
        -:  646:    }
    #####:  647:}
        -:  648:#endif
        -:  649:
        -:  650:#ifdef LIBXML_OUTPUT_ENABLED
        -:  651:#define gen_nb_xmlOutputBufferPtr 2
    #####:  652:static xmlOutputBufferPtr gen_xmlOutputBufferPtr(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  653:    if (no == 0) return(xmlOutputBufferCreateFilename("test.out", NULL, 0));
    #####:  654:    return(NULL);
        -:  655:}
    #####:  656:static void des_xmlOutputBufferPtr(int no ATTRIBUTE_UNUSED, xmlOutputBufferPtr val, int nr ATTRIBUTE_UNUSED) {
    #####:  657:    if (val != NULL) {
    #####:  658:        xmlOutputBufferClose(val);
        -:  659:    }
    #####:  660:}
        -:  661:#endif
        -:  662:
        -:  663:#ifdef LIBXML_FTP_ENABLED
        -:  664:#define gen_nb_xmlNanoFTPCtxtPtr 4
    #####:  665:static void *gen_xmlNanoFTPCtxtPtr(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  666:    if (no == 0) return(xmlNanoFTPNewCtxt(REMOTE2GOOD));
    #####:  667:    if (no == 1) return(xmlNanoFTPNewCtxt(REMOTE1GOOD));
    #####:  668:    if (no == 2) return(xmlNanoFTPNewCtxt("foo"));
    #####:  669:    return(NULL);
        -:  670:}
    #####:  671:static void des_xmlNanoFTPCtxtPtr(int no ATTRIBUTE_UNUSED, void *val, int nr ATTRIBUTE_UNUSED) {
    #####:  672:    if (val != NULL) {
    #####:  673:        xmlNanoFTPFreeCtxt(val);
        -:  674:    }
    #####:  675:}
        -:  676:#endif
        -:  677:
        -:  678:#ifdef LIBXML_HTTP_ENABLED
        -:  679:#define gen_nb_xmlNanoHTTPCtxtPtr 1
    #####:  680:static void *gen_xmlNanoHTTPCtxtPtr(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  681:    if (no == 0) return(xmlNanoHTTPOpen(REMOTE1GOOD, NULL));
    #####:  682:    if (no == 1) return(xmlNanoHTTPOpen(REMOTE2GOOD, NULL));
    #####:  683:    if (no == 2) return(xmlNanoHTTPOpen(REMOTE1BAD, NULL));
    #####:  684:    return(NULL);
        -:  685:}
    #####:  686:static void des_xmlNanoHTTPCtxtPtr(int no ATTRIBUTE_UNUSED, void *val, int nr ATTRIBUTE_UNUSED) {
    #####:  687:    if (val != NULL) {
    #####:  688:	xmlNanoHTTPClose(val);
        -:  689:    }
    #####:  690:}
        -:  691:#endif
        -:  692:
        -:  693:#define gen_nb_xmlCharEncoding 4
    #####:  694:static xmlCharEncoding gen_xmlCharEncoding(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  695:    if (no == 0) return(XML_CHAR_ENCODING_UTF8);
    #####:  696:    if (no == 1) return(XML_CHAR_ENCODING_NONE);
    #####:  697:    if (no == 2) return(XML_CHAR_ENCODING_8859_1);
    #####:  698:    return(XML_CHAR_ENCODING_ERROR);
        -:  699:}
    #####:  700:static void des_xmlCharEncoding(int no ATTRIBUTE_UNUSED, xmlCharEncoding val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  701:}
        -:  702:
        -:  703:#if defined(LIBXML_REGEXP_ENABLED) && defined(LIBXML_EXPR_ENABLED)
        -:  704:
        -:  705:#define gen_nb_xmlExpCtxtPtr 1
    #####:  706:static xmlExpCtxtPtr gen_xmlExpCtxtPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  707:    return(NULL);
        -:  708:}
    #####:  709:static void des_xmlExpCtxtPtr(int no ATTRIBUTE_UNUSED, xmlExpCtxtPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  710:}
        -:  711:
        -:  712:#define gen_nb_xmlExpNodePtr 1
    #####:  713:static xmlExpNodePtr gen_xmlExpNodePtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  714:    return(NULL);
        -:  715:}
    #####:  716:static void des_xmlExpNodePtr(int no ATTRIBUTE_UNUSED, xmlExpNodePtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  717:}
        -:  718:
        -:  719:#endif
        -:  720:
        -:  721:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:  722:#define gen_nb_xmlSchemaPtr 1
    #####:  723:static xmlSchemaPtr gen_xmlSchemaPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  724:    return(NULL);
        -:  725:}
    #####:  726:static void des_xmlSchemaPtr(int no ATTRIBUTE_UNUSED, xmlSchemaPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  727:}
        -:  728:
        -:  729:#define gen_nb_xmlSchemaValidCtxtPtr 1
    #####:  730:static xmlSchemaValidCtxtPtr gen_xmlSchemaValidCtxtPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  731:    return(NULL);
        -:  732:}
    #####:  733:static void des_xmlSchemaValidCtxtPtr(int no ATTRIBUTE_UNUSED, xmlSchemaValidCtxtPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  734:}
        -:  735:
        -:  736:#endif /* LIBXML_SCHEMAS_ENABLED */
        -:  737:
        -:  738:#define gen_nb_xmlHashDeallocator 2
        -:  739:static void
    #####:  740:test_xmlHashDeallocator(void *payload ATTRIBUTE_UNUSED, xmlChar *name ATTRIBUTE_UNUSED) {
    #####:  741:}
        -:  742:
    #####:  743:static xmlHashDeallocator gen_xmlHashDeallocator(int no, int nr ATTRIBUTE_UNUSED) {
    #####:  744:    if (no == 0) return(test_xmlHashDeallocator);
    #####:  745:    return(NULL);
        -:  746:}
    #####:  747:static void des_xmlHashDeallocator(int no ATTRIBUTE_UNUSED, xmlHashDeallocator val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  748:}
        -:  749:
        -:  750:
    #####:  751:static void desret_int(int val ATTRIBUTE_UNUSED) {
    #####:  752:}
    #####:  753:static void desret_xmlChar(xmlChar val ATTRIBUTE_UNUSED) {
    #####:  754:}
    #####:  755:static void desret_long(long val ATTRIBUTE_UNUSED) {
    #####:  756:}
    #####:  757:static void desret_unsigned_long(unsigned long val ATTRIBUTE_UNUSED) {
    #####:  758:}
    #####:  759:static void desret_double(double val ATTRIBUTE_UNUSED) {
    #####:  760:}
    #####:  761:static void desret_xmlCharEncoding(xmlCharEncoding val ATTRIBUTE_UNUSED) {
    #####:  762:}
        -:  763:#if 0
        -:  764:static void desret_const_void_ptr(void *val ATTRIBUTE_UNUSED) {
        -:  765:}
        -:  766:#endif
    #####:  767:static void desret_void_ptr(void *val ATTRIBUTE_UNUSED) {
    #####:  768:}
    #####:  769:static void desret_const_char_ptr(const char *val ATTRIBUTE_UNUSED) {
    #####:  770:}
    #####:  771:static void desret_const_xmlChar_ptr(const xmlChar *val ATTRIBUTE_UNUSED) {
    #####:  772:}
    #####:  773:static void desret_xmlChar_ptr(xmlChar *val) {
    #####:  774:    if (val != NULL)
    #####:  775:	xmlFree(val);
    #####:  776:}
    #####:  777:static void desret_xmlDocPtr(xmlDocPtr val) {
    #####:  778:    if (val != api_doc)
    #####:  779:	xmlFreeDoc(val);
    #####:  780:}
    #####:  781:static void desret_xmlDictPtr(xmlDictPtr val) {
    #####:  782:    xmlDictFree(val);
    #####:  783:}
        -:  784:#ifdef LIBXML_OUTPUT_ENABLED
    #####:  785:static void desret_xmlOutputBufferPtr(xmlOutputBufferPtr val) {
    #####:  786:    xmlOutputBufferClose(val);
    #####:  787:}
        -:  788:#endif
        -:  789:#ifdef LIBXML_READER_ENABLED
    #####:  790:static void desret_xmlTextReaderPtr(xmlTextReaderPtr val) {
    #####:  791:    xmlFreeTextReader(val);
    #####:  792:}
        -:  793:#endif
    #####:  794:static void desret_xmlNodePtr(xmlNodePtr val) {
    #####:  795:    if ((val != NULL) && (val != api_root) && (val != (xmlNodePtr) api_doc)) {
    #####:  796:	xmlUnlinkNode(val);
    #####:  797:	xmlFreeNode(val);
        -:  798:    }
    #####:  799:}
    #####:  800:static void desret_xmlAttrPtr(xmlAttrPtr val) {
    #####:  801:    if (val != NULL) {
    #####:  802:	xmlUnlinkNode((xmlNodePtr) val);
    #####:  803:	xmlFreeNode((xmlNodePtr) val);
        -:  804:    }
    #####:  805:}
    #####:  806:static void desret_xmlEntityPtr(xmlEntityPtr val) {
    #####:  807:    if (val != NULL) {
    #####:  808:	xmlUnlinkNode((xmlNodePtr) val);
    #####:  809:	xmlFreeNode((xmlNodePtr) val);
        -:  810:    }
    #####:  811:}
    #####:  812:static void desret_xmlElementPtr(xmlElementPtr val) {
    #####:  813:    if (val != NULL) {
    #####:  814:	xmlUnlinkNode((xmlNodePtr) val);
        -:  815:    }
    #####:  816:}
    #####:  817:static void desret_xmlAttributePtr(xmlAttributePtr val) {
    #####:  818:    if (val != NULL) {
    #####:  819:	xmlUnlinkNode((xmlNodePtr) val);
        -:  820:    }
    #####:  821:}
    #####:  822:static void desret_xmlNsPtr(xmlNsPtr val ATTRIBUTE_UNUSED) {
    #####:  823:}
    #####:  824:static void desret_xmlDtdPtr(xmlDtdPtr val) {
    #####:  825:    desret_xmlNodePtr((xmlNodePtr)val);
    #####:  826:}
        -:  827:#ifdef LIBXML_XPATH_ENABLED
    #####:  828:static void desret_xmlXPathObjectPtr(xmlXPathObjectPtr val) {
    #####:  829:    xmlXPathFreeObject(val);
    #####:  830:}
    #####:  831:static void desret_xmlNodeSetPtr(xmlNodeSetPtr val) {
    #####:  832:    xmlXPathFreeNodeSet(val);
    #####:  833:}
        -:  834:#endif
    #####:  835:static void desret_xmlParserCtxtPtr(xmlParserCtxtPtr val) {
    #####:  836:    xmlFreeParserCtxt(val);
    #####:  837:}
    #####:  838:static void desret_xmlParserInputBufferPtr(xmlParserInputBufferPtr val) {
    #####:  839:    xmlFreeParserInputBuffer(val);
    #####:  840:}
    #####:  841:static void desret_xmlParserInputPtr(xmlParserInputPtr val) {
    #####:  842:    xmlFreeInputStream(val);
    #####:  843:}
        -:  844:#ifdef LIBXML_WRITER_ENABLED
    #####:  845:static void desret_xmlTextWriterPtr(xmlTextWriterPtr val) {
    #####:  846:    xmlFreeTextWriter(val);
    #####:  847:}
        -:  848:#endif
    #####:  849:static void desret_xmlBufferPtr(xmlBufferPtr val) {
    #####:  850:    xmlBufferFree(val);
    #####:  851:}
        -:  852:#ifdef LIBXML_SCHEMAS_ENABLED
    #####:  853:static void desret_xmlSchemaParserCtxtPtr(xmlSchemaParserCtxtPtr val) {
    #####:  854:    xmlSchemaFreeParserCtxt(val);
    #####:  855:}
    #####:  856:static void desret_xmlSchemaTypePtr(xmlSchemaTypePtr val ATTRIBUTE_UNUSED) {
    #####:  857:}
    #####:  858:static void desret_xmlRelaxNGParserCtxtPtr(xmlRelaxNGParserCtxtPtr val) {
    #####:  859:    xmlRelaxNGFreeParserCtxt(val);
    #####:  860:}
        -:  861:#endif
        -:  862:#ifdef LIBXML_HTML_ENABLED
    #####:  863:static void desret_const_htmlEntityDesc_ptr(const htmlEntityDesc * val ATTRIBUTE_UNUSED) {
    #####:  864:}
        -:  865:#endif
        -:  866:#ifdef LIBXML_HTTP_ENABLED
    #####:  867:static void desret_xmlNanoHTTPCtxtPtr(void *val) {
    #####:  868:    xmlNanoHTTPClose(val);
    #####:  869:}
        -:  870:#endif
        -:  871:#ifdef LIBXML_FTP_ENABLED
    #####:  872:static void desret_xmlNanoFTPCtxtPtr(void *val) {
    #####:  873:    xmlNanoFTPClose(val);
    #####:  874:}
        -:  875:#endif
        -:  876:/* cut and pasted from autogenerated to avoid troubles */
        -:  877:#define gen_nb_const_xmlChar_ptr_ptr 1
    #####:  878:static xmlChar ** gen_const_xmlChar_ptr_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  879:    return(NULL);
        -:  880:}
    #####:  881:static void des_const_xmlChar_ptr_ptr(int no ATTRIBUTE_UNUSED, const xmlChar ** val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  882:}
        -:  883:
        -:  884:#define gen_nb_unsigned_char_ptr 1
    #####:  885:static unsigned char * gen_unsigned_char_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  886:    return(NULL);
        -:  887:}
    #####:  888:static void des_unsigned_char_ptr(int no ATTRIBUTE_UNUSED, unsigned char * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  889:}
        -:  890:
        -:  891:#define gen_nb_const_unsigned_char_ptr 1
    #####:  892:static unsigned char * gen_const_unsigned_char_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  893:    return(NULL);
        -:  894:}
    #####:  895:static void des_const_unsigned_char_ptr(int no ATTRIBUTE_UNUSED, const unsigned char * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  896:}
        -:  897:
        -:  898:#ifdef LIBXML_HTML_ENABLED
        -:  899:#define gen_nb_const_htmlNodePtr 1
    #####:  900:static htmlNodePtr gen_const_htmlNodePtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  901:    return(NULL);
        -:  902:}
    #####:  903:static void des_const_htmlNodePtr(int no ATTRIBUTE_UNUSED, const htmlNodePtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  904:}
        -:  905:#endif
        -:  906:
        -:  907:#ifdef LIBXML_HTML_ENABLED
        -:  908:#define gen_nb_htmlDocPtr 3
    #####:  909:static htmlDocPtr gen_htmlDocPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  910:    if (no == 0) return(htmlNewDoc(NULL, NULL));
    #####:  911:    if (no == 1) return(htmlReadMemory("<html/>", 7, "test", NULL, 0));
    #####:  912:    return(NULL);
        -:  913:}
    #####:  914:static void des_htmlDocPtr(int no ATTRIBUTE_UNUSED, htmlDocPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  915:    if ((val != NULL) && (val != api_doc) && (val->doc != api_doc))
    #####:  916:        xmlFreeDoc(val);
    #####:  917:}
    #####:  918:static void desret_htmlDocPtr(htmlDocPtr val) {
    #####:  919:    if ((val != NULL) && (val != api_doc) && (val->doc != api_doc))
    #####:  920:        xmlFreeDoc(val);
    #####:  921:}
        -:  922:#define gen_nb_htmlParserCtxtPtr 3
    #####:  923:static htmlParserCtxtPtr gen_htmlParserCtxtPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  924:    if (no == 0) return(xmlNewParserCtxt());
    #####:  925:    if (no == 1) return(htmlCreateMemoryParserCtxt("<html/>", 7));
    #####:  926:    return(NULL);
        -:  927:}
    #####:  928:static void des_htmlParserCtxtPtr(int no ATTRIBUTE_UNUSED, htmlParserCtxtPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  929:    if (val != NULL)
    #####:  930:        htmlFreeParserCtxt(val);
    #####:  931:}
    #####:  932:static void desret_htmlParserCtxtPtr(htmlParserCtxtPtr val) {
    #####:  933:    if (val != NULL)
    #####:  934:        htmlFreeParserCtxt(val);
    #####:  935:}
        -:  936:#endif
        -:  937:
        -:  938:#ifdef LIBXML_XPATH_ENABLED
        -:  939:#define gen_nb_xmlNodeSetPtr 1
    #####:  940:static xmlNodeSetPtr gen_xmlNodeSetPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  941:    return(NULL);
        -:  942:}
    #####:  943:static void des_xmlNodeSetPtr(int no ATTRIBUTE_UNUSED, xmlNodeSetPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  944:}
        -:  945:#endif
        -:  946:
        -:  947:#ifdef LIBXML_DEBUG_ENABLED
        -:  948:#ifdef LIBXML_XPATH_ENABLED
        -:  949:#define gen_nb_xmlShellCtxtPtr 1
    #####:  950:static xmlShellCtxtPtr gen_xmlShellCtxtPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  951:    return(NULL);
        -:  952:}
    #####:  953:static void des_xmlShellCtxtPtr(int no ATTRIBUTE_UNUSED, xmlShellCtxtPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  954:}
        -:  955:#endif
        -:  956:#endif
        -:  957:
        -:  958:#ifdef LIBXML_PATTERN_ENABLED
        -:  959:#define gen_nb_xmlPatternPtr 1
    #####:  960:static xmlPatternPtr gen_xmlPatternPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  961:    return(NULL);
        -:  962:}
    #####:  963:static void des_xmlPatternPtr(int no ATTRIBUTE_UNUSED, xmlPatternPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  964:}
        -:  965:#endif
        -:  966:
        -:  967:#define gen_nb_xmlElementContentPtr 1
    #####:  968:static xmlElementContentPtr gen_xmlElementContentPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  969:    return(NULL);
        -:  970:}
    #####:  971:static void des_xmlElementContentPtr(int no ATTRIBUTE_UNUSED, xmlElementContentPtr val, int nr ATTRIBUTE_UNUSED) {
    #####:  972:    if (val != NULL)
    #####:  973:        xmlFreeElementContent(val);
    #####:  974:}
    #####:  975:static void desret_xmlElementContentPtr(xmlElementContentPtr val) {
    #####:  976:    if (val != NULL)
    #####:  977:        xmlFreeElementContent(val);
    #####:  978:}
        -:  979:
        -:  980:#define gen_nb_xmlParserNodeInfoSeqPtr 1
    #####:  981:static xmlParserNodeInfoSeqPtr gen_xmlParserNodeInfoSeqPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  982:    return(NULL);
        -:  983:}
    #####:  984:static void des_xmlParserNodeInfoSeqPtr(int no ATTRIBUTE_UNUSED, xmlParserNodeInfoSeqPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  985:}
        -:  986:
    #####:  987:static void desret_const_xmlParserNodeInfo_ptr(const xmlParserNodeInfo *val ATTRIBUTE_UNUSED) {
    #####:  988:}
        -:  989:
        -:  990:#define gen_nb_void_ptr_ptr 1
    #####:  991:static void ** gen_void_ptr_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  992:    return(NULL);
        -:  993:}
    #####:  994:static void des_void_ptr_ptr(int no ATTRIBUTE_UNUSED, void ** val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:  995:}
        -:  996:
        -:  997:/************************************************************************
        -:  998: *									*
        -:  999: *   WARNING: end of the manually maintained part of the test code	*
        -: 1000: *            do not remove or alter the CUT HERE line			*
        -: 1001: *									*
        -: 1002: ************************************************************************/
        -: 1003:
        -: 1004:/* CUT HERE: everything below that line is generated */
        -: 1005:#ifdef LIBXML_HTML_ENABLED
    #####: 1006:static void desret_htmlStatus(htmlStatus val ATTRIBUTE_UNUSED) {
    #####: 1007:}
        -: 1008:
        -: 1009:#endif
        -: 1010:
        -: 1011:#define gen_nb_xmlAttributeDefault 4
    #####: 1012:static xmlAttributeDefault gen_xmlAttributeDefault(int no, int nr ATTRIBUTE_UNUSED) {
    #####: 1013:    if (no == 1) return(XML_ATTRIBUTE_FIXED);
    #####: 1014:    if (no == 2) return(XML_ATTRIBUTE_IMPLIED);
    #####: 1015:    if (no == 3) return(XML_ATTRIBUTE_NONE);
    #####: 1016:    if (no == 4) return(XML_ATTRIBUTE_REQUIRED);
    #####: 1017:    return(0);
        -: 1018:}
        -: 1019:
    #####: 1020:static void des_xmlAttributeDefault(int no ATTRIBUTE_UNUSED, xmlAttributeDefault val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 1021:}
        -: 1022:
        -: 1023:#define gen_nb_xmlAttributeType 4
    #####: 1024:static xmlAttributeType gen_xmlAttributeType(int no, int nr ATTRIBUTE_UNUSED) {
    #####: 1025:    if (no == 1) return(XML_ATTRIBUTE_CDATA);
    #####: 1026:    if (no == 2) return(XML_ATTRIBUTE_ENTITIES);
    #####: 1027:    if (no == 3) return(XML_ATTRIBUTE_ENTITY);
    #####: 1028:    if (no == 4) return(XML_ATTRIBUTE_ENUMERATION);
    #####: 1029:    return(0);
        -: 1030:}
        -: 1031:
    #####: 1032:static void des_xmlAttributeType(int no ATTRIBUTE_UNUSED, xmlAttributeType val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 1033:}
        -: 1034:
        -: 1035:#define gen_nb_xmlBufferAllocationScheme 4
    #####: 1036:static xmlBufferAllocationScheme gen_xmlBufferAllocationScheme(int no, int nr ATTRIBUTE_UNUSED) {
    #####: 1037:    if (no == 1) return(XML_BUFFER_ALLOC_DOUBLEIT);
    #####: 1038:    if (no == 2) return(XML_BUFFER_ALLOC_EXACT);
    #####: 1039:    if (no == 3) return(XML_BUFFER_ALLOC_HYBRID);
    #####: 1040:    if (no == 4) return(XML_BUFFER_ALLOC_IMMUTABLE);
    #####: 1041:    return(0);
        -: 1042:}
        -: 1043:
    #####: 1044:static void des_xmlBufferAllocationScheme(int no ATTRIBUTE_UNUSED, xmlBufferAllocationScheme val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 1045:}
        -: 1046:
    #####: 1047:static void desret_xmlBufferAllocationScheme(xmlBufferAllocationScheme val ATTRIBUTE_UNUSED) {
    #####: 1048:}
        -: 1049:
        -: 1050:#ifdef LIBXML_CATALOG_ENABLED
        -: 1051:#define gen_nb_xmlCatalogAllow 4
    #####: 1052:static xmlCatalogAllow gen_xmlCatalogAllow(int no, int nr ATTRIBUTE_UNUSED) {
    #####: 1053:    if (no == 1) return(XML_CATA_ALLOW_ALL);
    #####: 1054:    if (no == 2) return(XML_CATA_ALLOW_DOCUMENT);
    #####: 1055:    if (no == 3) return(XML_CATA_ALLOW_GLOBAL);
    #####: 1056:    if (no == 4) return(XML_CATA_ALLOW_NONE);
    #####: 1057:    return(0);
        -: 1058:}
        -: 1059:
    #####: 1060:static void des_xmlCatalogAllow(int no ATTRIBUTE_UNUSED, xmlCatalogAllow val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 1061:}
        -: 1062:
    #####: 1063:static void desret_xmlCatalogAllow(xmlCatalogAllow val ATTRIBUTE_UNUSED) {
    #####: 1064:}
        -: 1065:
        -: 1066:#endif
        -: 1067:
        -: 1068:#ifdef LIBXML_CATALOG_ENABLED
        -: 1069:#define gen_nb_xmlCatalogPrefer 3
    #####: 1070:static xmlCatalogPrefer gen_xmlCatalogPrefer(int no, int nr ATTRIBUTE_UNUSED) {
    #####: 1071:    if (no == 1) return(XML_CATA_PREFER_NONE);
    #####: 1072:    if (no == 2) return(XML_CATA_PREFER_PUBLIC);
    #####: 1073:    if (no == 3) return(XML_CATA_PREFER_SYSTEM);
    #####: 1074:    return(0);
        -: 1075:}
        -: 1076:
    #####: 1077:static void des_xmlCatalogPrefer(int no ATTRIBUTE_UNUSED, xmlCatalogPrefer val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 1078:}
        -: 1079:
    #####: 1080:static void desret_xmlCatalogPrefer(xmlCatalogPrefer val ATTRIBUTE_UNUSED) {
    #####: 1081:}
        -: 1082:
        -: 1083:#endif
        -: 1084:
        -: 1085:#define gen_nb_xmlElementContentType 4
    #####: 1086:static xmlElementContentType gen_xmlElementContentType(int no, int nr ATTRIBUTE_UNUSED) {
    #####: 1087:    if (no == 1) return(XML_ELEMENT_CONTENT_ELEMENT);
    #####: 1088:    if (no == 2) return(XML_ELEMENT_CONTENT_OR);
    #####: 1089:    if (no == 3) return(XML_ELEMENT_CONTENT_PCDATA);
    #####: 1090:    if (no == 4) return(XML_ELEMENT_CONTENT_SEQ);
    #####: 1091:    return(0);
        -: 1092:}
        -: 1093:
    #####: 1094:static void des_xmlElementContentType(int no ATTRIBUTE_UNUSED, xmlElementContentType val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 1095:}
        -: 1096:
        -: 1097:#define gen_nb_xmlElementTypeVal 4
    #####: 1098:static xmlElementTypeVal gen_xmlElementTypeVal(int no, int nr ATTRIBUTE_UNUSED) {
    #####: 1099:    if (no == 1) return(XML_ELEMENT_TYPE_ANY);
    #####: 1100:    if (no == 2) return(XML_ELEMENT_TYPE_ELEMENT);
    #####: 1101:    if (no == 3) return(XML_ELEMENT_TYPE_EMPTY);
    #####: 1102:    if (no == 4) return(XML_ELEMENT_TYPE_MIXED);
    #####: 1103:    return(0);
        -: 1104:}
        -: 1105:
    #####: 1106:static void des_xmlElementTypeVal(int no ATTRIBUTE_UNUSED, xmlElementTypeVal val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 1107:}
        -: 1108:
        -: 1109:#define gen_nb_xmlFeature 4
    #####: 1110:static xmlFeature gen_xmlFeature(int no, int nr ATTRIBUTE_UNUSED) {
    #####: 1111:    if (no == 1) return(XML_WITH_AUTOMATA);
    #####: 1112:    if (no == 2) return(XML_WITH_C14N);
    #####: 1113:    if (no == 3) return(XML_WITH_CATALOG);
    #####: 1114:    if (no == 4) return(XML_WITH_DEBUG);
    #####: 1115:    return(0);
        -: 1116:}
        -: 1117:
    #####: 1118:static void des_xmlFeature(int no ATTRIBUTE_UNUSED, xmlFeature val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 1119:}
        -: 1120:
    #####: 1121:static void desret_xmlParserErrors(xmlParserErrors val ATTRIBUTE_UNUSED) {
    #####: 1122:}
        -: 1123:
        -: 1124:#ifdef LIBXML_SCHEMAS_ENABLED
        -: 1125:#define gen_nb_xmlSchemaValType 4
    #####: 1126:static xmlSchemaValType gen_xmlSchemaValType(int no, int nr ATTRIBUTE_UNUSED) {
    #####: 1127:    if (no == 1) return(XML_SCHEMAS_ANYSIMPLETYPE);
    #####: 1128:    if (no == 2) return(XML_SCHEMAS_ANYTYPE);
    #####: 1129:    if (no == 3) return(XML_SCHEMAS_ANYURI);
    #####: 1130:    if (no == 4) return(XML_SCHEMAS_BASE64BINARY);
    #####: 1131:    return(0);
        -: 1132:}
        -: 1133:
    #####: 1134:static void des_xmlSchemaValType(int no ATTRIBUTE_UNUSED, xmlSchemaValType val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 1135:}
        -: 1136:
    #####: 1137:static void desret_xmlSchemaValType(xmlSchemaValType val ATTRIBUTE_UNUSED) {
    #####: 1138:}
        -: 1139:
        -: 1140:#endif
        -: 1141:
        -: 1142:#ifdef LIBXML_SCHEMAS_ENABLED
        -: 1143:#define gen_nb_xmlSchemaWhitespaceValueType 4
    #####: 1144:static xmlSchemaWhitespaceValueType gen_xmlSchemaWhitespaceValueType(int no, int nr ATTRIBUTE_UNUSED) {
    #####: 1145:    if (no == 1) return(XML_SCHEMA_WHITESPACE_COLLAPSE);
    #####: 1146:    if (no == 2) return(XML_SCHEMA_WHITESPACE_PRESERVE);
    #####: 1147:    if (no == 3) return(XML_SCHEMA_WHITESPACE_REPLACE);
    #####: 1148:    if (no == 4) return(XML_SCHEMA_WHITESPACE_UNKNOWN);
    #####: 1149:    return(0);
        -: 1150:}
        -: 1151:
    #####: 1152:static void des_xmlSchemaWhitespaceValueType(int no ATTRIBUTE_UNUSED, xmlSchemaWhitespaceValueType val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 1153:}
        -: 1154:
        -: 1155:#endif
        -: 1156:
        -: 1157:#include <libxml/HTMLparser.h>
        -: 1158:#include <libxml/HTMLtree.h>
        -: 1159:#include <libxml/SAX2.h>
        -: 1160:#include <libxml/c14n.h>
        -: 1161:#include <libxml/catalog.h>
        -: 1162:#include <libxml/chvalid.h>
        -: 1163:#include <libxml/debugXML.h>
        -: 1164:#include <libxml/dict.h>
        -: 1165:#include <libxml/encoding.h>
        -: 1166:#include <libxml/entities.h>
        -: 1167:#include <libxml/hash.h>
        -: 1168:#include <libxml/list.h>
        -: 1169:#include <libxml/nanoftp.h>
        -: 1170:#include <libxml/nanohttp.h>
        -: 1171:#include <libxml/parser.h>
        -: 1172:#include <libxml/parserInternals.h>
        -: 1173:#include <libxml/pattern.h>
        -: 1174:#include <libxml/relaxng.h>
        -: 1175:#include <libxml/schemasInternals.h>
        -: 1176:#include <libxml/schematron.h>
        -: 1177:#include <libxml/tree.h>
        -: 1178:#include <libxml/uri.h>
        -: 1179:#include <libxml/valid.h>
        -: 1180:#include <libxml/xinclude.h>
        -: 1181:#include <libxml/xmlIO.h>
        -: 1182:#include <libxml/xmlautomata.h>
        -: 1183:#include <libxml/xmlerror.h>
        -: 1184:#include <libxml/xmlmodule.h>
        -: 1185:#include <libxml/xmlreader.h>
        -: 1186:#include <libxml/xmlregexp.h>
        -: 1187:#include <libxml/xmlsave.h>
        -: 1188:#include <libxml/xmlschemas.h>
        -: 1189:#include <libxml/xmlschemastypes.h>
        -: 1190:#include <libxml/xmlstring.h>
        -: 1191:#include <libxml/xmlunicode.h>
        -: 1192:#include <libxml/xmlwriter.h>
        -: 1193:#include <libxml/xpath.h>
        -: 1194:#include <libxml/xpathInternals.h>
        -: 1195:#include <libxml/xpointer.h>
        -: 1196:static int test_HTMLparser(void);
        -: 1197:static int test_HTMLtree(void);
        -: 1198:static int test_SAX2(void);
        -: 1199:static int test_c14n(void);
        -: 1200:static int test_catalog(void);
        -: 1201:static int test_chvalid(void);
        -: 1202:static int test_debugXML(void);
        -: 1203:static int test_dict(void);
        -: 1204:static int test_encoding(void);
        -: 1205:static int test_entities(void);
        -: 1206:static int test_hash(void);
        -: 1207:static int test_list(void);
        -: 1208:static int test_nanoftp(void);
        -: 1209:static int test_nanohttp(void);
        -: 1210:static int test_parser(void);
        -: 1211:static int test_parserInternals(void);
        -: 1212:static int test_pattern(void);
        -: 1213:static int test_relaxng(void);
        -: 1214:static int test_schemasInternals(void);
        -: 1215:static int test_schematron(void);
        -: 1216:static int test_tree(void);
        -: 1217:static int test_uri(void);
        -: 1218:static int test_valid(void);
        -: 1219:static int test_xinclude(void);
        -: 1220:static int test_xmlIO(void);
        -: 1221:static int test_xmlautomata(void);
        -: 1222:static int test_xmlerror(void);
        -: 1223:static int test_xmlmodule(void);
        -: 1224:static int test_xmlreader(void);
        -: 1225:static int test_xmlregexp(void);
        -: 1226:static int test_xmlsave(void);
        -: 1227:static int test_xmlschemas(void);
        -: 1228:static int test_xmlschemastypes(void);
        -: 1229:static int test_xmlstring(void);
        -: 1230:static int test_xmlunicode(void);
        -: 1231:static int test_xmlwriter(void);
        -: 1232:static int test_xpath(void);
        -: 1233:static int test_xpathInternals(void);
        -: 1234:static int test_xpointer(void);
        -: 1235:
        -: 1236:/**
        -: 1237: * testlibxml2:
        -: 1238: *
        -: 1239: * Main entry point of the tester for the full libxml2 module,
        -: 1240: * it calls all the tester entry point for each module.
        -: 1241: *
        -: 1242: * Returns the number of error found
        -: 1243: */
        -: 1244:static int
    #####: 1245:testlibxml2(void)
        -: 1246:{
    #####: 1247:    int test_ret = 0;
        -: 1248:
    #####: 1249:    test_ret += test_HTMLparser();
    #####: 1250:    test_ret += test_HTMLtree();
    #####: 1251:    test_ret += test_SAX2();
    #####: 1252:    test_ret += test_c14n();
    #####: 1253:    test_ret += test_catalog();
    #####: 1254:    test_ret += test_chvalid();
    #####: 1255:    test_ret += test_debugXML();
    #####: 1256:    test_ret += test_dict();
    #####: 1257:    test_ret += test_encoding();
    #####: 1258:    test_ret += test_entities();
    #####: 1259:    test_ret += test_hash();
    #####: 1260:    test_ret += test_list();
    #####: 1261:    test_ret += test_nanoftp();
    #####: 1262:    test_ret += test_nanohttp();
    #####: 1263:    test_ret += test_parser();
    #####: 1264:    test_ret += test_parserInternals();
    #####: 1265:    test_ret += test_pattern();
    #####: 1266:    test_ret += test_relaxng();
    #####: 1267:    test_ret += test_schemasInternals();
    #####: 1268:    test_ret += test_schematron();
    #####: 1269:    test_ret += test_tree();
    #####: 1270:    test_ret += test_uri();
    #####: 1271:    test_ret += test_valid();
    #####: 1272:    test_ret += test_xinclude();
    #####: 1273:    test_ret += test_xmlIO();
    #####: 1274:    test_ret += test_xmlautomata();
    #####: 1275:    test_ret += test_xmlerror();
    #####: 1276:    test_ret += test_xmlmodule();
    #####: 1277:    test_ret += test_xmlreader();
    #####: 1278:    test_ret += test_xmlregexp();
    #####: 1279:    test_ret += test_xmlsave();
    #####: 1280:    test_ret += test_xmlschemas();
    #####: 1281:    test_ret += test_xmlschemastypes();
    #####: 1282:    test_ret += test_xmlstring();
    #####: 1283:    test_ret += test_xmlunicode();
    #####: 1284:    test_ret += test_xmlwriter();
    #####: 1285:    test_ret += test_xpath();
    #####: 1286:    test_ret += test_xpathInternals();
    #####: 1287:    test_ret += test_xpointer();
        -: 1288:
    #####: 1289:    printf("Total: %d functions, %d tests, %d errors\n",
        -: 1290:           function_tests, call_tests, test_ret);
    #####: 1291:    return(test_ret);
        -: 1292:}
        -: 1293:
        -: 1294:
        -: 1295:static int
    #####: 1296:test_UTF8ToHtml(void) {
    #####: 1297:    int test_ret = 0;
        -: 1298:
        -: 1299:#if defined(LIBXML_HTML_ENABLED)
        -: 1300:    int mem_base;
        -: 1301:    int ret_val;
        -: 1302:    unsigned char * out; /* a pointer to an array of bytes to store the result */
        -: 1303:    int n_out;
        -: 1304:    int * outlen; /* the length of @out */
        -: 1305:    int n_outlen;
        -: 1306:    unsigned char * in; /* a pointer to an array of UTF-8 chars */
        -: 1307:    int n_in;
        -: 1308:    int * inlen; /* the length of @in */
        -: 1309:    int n_inlen;
        -: 1310:
    #####: 1311:    for (n_out = 0;n_out < gen_nb_unsigned_char_ptr;n_out++) {
    #####: 1312:    for (n_outlen = 0;n_outlen < gen_nb_int_ptr;n_outlen++) {
    #####: 1313:    for (n_in = 0;n_in < gen_nb_const_unsigned_char_ptr;n_in++) {
    #####: 1314:    for (n_inlen = 0;n_inlen < gen_nb_int_ptr;n_inlen++) {
    #####: 1315:        mem_base = xmlMemBlocks();
    #####: 1316:        out = gen_unsigned_char_ptr(n_out, 0);
    #####: 1317:        outlen = gen_int_ptr(n_outlen, 1);
    #####: 1318:        in = gen_const_unsigned_char_ptr(n_in, 2);
    #####: 1319:        inlen = gen_int_ptr(n_inlen, 3);
        -: 1320:
    #####: 1321:        ret_val = UTF8ToHtml(out, outlen, (const unsigned char *)in, inlen);
    #####: 1322:        desret_int(ret_val);
    #####: 1323:        call_tests++;
    #####: 1324:        des_unsigned_char_ptr(n_out, out, 0);
    #####: 1325:        des_int_ptr(n_outlen, outlen, 1);
    #####: 1326:        des_const_unsigned_char_ptr(n_in, (const unsigned char *)in, 2);
    #####: 1327:        des_int_ptr(n_inlen, inlen, 3);
    #####: 1328:        xmlResetLastError();
    #####: 1329:        if (mem_base != xmlMemBlocks()) {
    #####: 1330:            printf("Leak of %d blocks found in UTF8ToHtml",
    #####: 1331:	           xmlMemBlocks() - mem_base);
    #####: 1332:	    test_ret++;
    #####: 1333:            printf(" %d", n_out);
    #####: 1334:            printf(" %d", n_outlen);
    #####: 1335:            printf(" %d", n_in);
    #####: 1336:            printf(" %d", n_inlen);
    #####: 1337:            printf("\n");
        -: 1338:        }
        -: 1339:    }
        -: 1340:    }
        -: 1341:    }
        -: 1342:    }
    #####: 1343:    function_tests++;
        -: 1344:#endif
        -: 1345:
    #####: 1346:    return(test_ret);
        -: 1347:}
        -: 1348:
        -: 1349:#ifdef LIBXML_HTML_ENABLED
        -: 1350:
        -: 1351:#define gen_nb_const_htmlElemDesc_ptr 1
    #####: 1352:static htmlElemDesc * gen_const_htmlElemDesc_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 1353:    return(NULL);
        -: 1354:}
    #####: 1355:static void des_const_htmlElemDesc_ptr(int no ATTRIBUTE_UNUSED, const htmlElemDesc * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 1356:}
        -: 1357:#endif
        -: 1358:
        -: 1359:
        -: 1360:static int
    #####: 1361:test_htmlAttrAllowed(void) {
    #####: 1362:    int test_ret = 0;
        -: 1363:
        -: 1364:#if defined(LIBXML_HTML_ENABLED)
        -: 1365:    int mem_base;
        -: 1366:    htmlStatus ret_val;
        -: 1367:    htmlElemDesc * elt; /* HTML element */
        -: 1368:    int n_elt;
        -: 1369:    xmlChar * attr; /* HTML attribute */
        -: 1370:    int n_attr;
        -: 1371:    int legacy; /* whether to allow deprecated attributes */
        -: 1372:    int n_legacy;
        -: 1373:
    #####: 1374:    for (n_elt = 0;n_elt < gen_nb_const_htmlElemDesc_ptr;n_elt++) {
    #####: 1375:    for (n_attr = 0;n_attr < gen_nb_const_xmlChar_ptr;n_attr++) {
    #####: 1376:    for (n_legacy = 0;n_legacy < gen_nb_int;n_legacy++) {
    #####: 1377:        mem_base = xmlMemBlocks();
    #####: 1378:        elt = gen_const_htmlElemDesc_ptr(n_elt, 0);
    #####: 1379:        attr = gen_const_xmlChar_ptr(n_attr, 1);
    #####: 1380:        legacy = gen_int(n_legacy, 2);
        -: 1381:
    #####: 1382:        ret_val = htmlAttrAllowed((const htmlElemDesc *)elt, (const xmlChar *)attr, legacy);
    #####: 1383:        desret_htmlStatus(ret_val);
    #####: 1384:        call_tests++;
    #####: 1385:        des_const_htmlElemDesc_ptr(n_elt, (const htmlElemDesc *)elt, 0);
    #####: 1386:        des_const_xmlChar_ptr(n_attr, (const xmlChar *)attr, 1);
    #####: 1387:        des_int(n_legacy, legacy, 2);
    #####: 1388:        xmlResetLastError();
    #####: 1389:        if (mem_base != xmlMemBlocks()) {
    #####: 1390:            printf("Leak of %d blocks found in htmlAttrAllowed",
    #####: 1391:	           xmlMemBlocks() - mem_base);
    #####: 1392:	    test_ret++;
    #####: 1393:            printf(" %d", n_elt);
    #####: 1394:            printf(" %d", n_attr);
    #####: 1395:            printf(" %d", n_legacy);
    #####: 1396:            printf("\n");
        -: 1397:        }
        -: 1398:    }
        -: 1399:    }
        -: 1400:    }
    #####: 1401:    function_tests++;
        -: 1402:#endif
        -: 1403:
    #####: 1404:    return(test_ret);
        -: 1405:}
        -: 1406:
        -: 1407:#ifdef LIBXML_HTML_ENABLED
        -: 1408:
        -: 1409:#define gen_nb_htmlNodePtr 1
    #####: 1410:static htmlNodePtr gen_htmlNodePtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 1411:    return(NULL);
        -: 1412:}
    #####: 1413:static void des_htmlNodePtr(int no ATTRIBUTE_UNUSED, htmlNodePtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 1414:}
        -: 1415:#endif
        -: 1416:
        -: 1417:
        -: 1418:static int
    #####: 1419:test_htmlAutoCloseTag(void) {
    #####: 1420:    int test_ret = 0;
        -: 1421:
        -: 1422:#if defined(LIBXML_HTML_ENABLED)
        -: 1423:    int mem_base;
        -: 1424:    int ret_val;
        -: 1425:    htmlDocPtr doc; /* the HTML document */
        -: 1426:    int n_doc;
        -: 1427:    xmlChar * name; /* The tag name */
        -: 1428:    int n_name;
        -: 1429:    htmlNodePtr elem; /* the HTML element */
        -: 1430:    int n_elem;
        -: 1431:
    #####: 1432:    for (n_doc = 0;n_doc < gen_nb_htmlDocPtr;n_doc++) {
    #####: 1433:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####: 1434:    for (n_elem = 0;n_elem < gen_nb_htmlNodePtr;n_elem++) {
    #####: 1435:        mem_base = xmlMemBlocks();
    #####: 1436:        doc = gen_htmlDocPtr(n_doc, 0);
    #####: 1437:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####: 1438:        elem = gen_htmlNodePtr(n_elem, 2);
        -: 1439:
    #####: 1440:        ret_val = htmlAutoCloseTag(doc, (const xmlChar *)name, elem);
    #####: 1441:        desret_int(ret_val);
    #####: 1442:        call_tests++;
    #####: 1443:        des_htmlDocPtr(n_doc, doc, 0);
    #####: 1444:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####: 1445:        des_htmlNodePtr(n_elem, elem, 2);
    #####: 1446:        xmlResetLastError();
    #####: 1447:        if (mem_base != xmlMemBlocks()) {
    #####: 1448:            printf("Leak of %d blocks found in htmlAutoCloseTag",
    #####: 1449:	           xmlMemBlocks() - mem_base);
    #####: 1450:	    test_ret++;
    #####: 1451:            printf(" %d", n_doc);
    #####: 1452:            printf(" %d", n_name);
    #####: 1453:            printf(" %d", n_elem);
    #####: 1454:            printf("\n");
        -: 1455:        }
        -: 1456:    }
        -: 1457:    }
        -: 1458:    }
    #####: 1459:    function_tests++;
        -: 1460:#endif
        -: 1461:
    #####: 1462:    return(test_ret);
        -: 1463:}
        -: 1464:
        -: 1465:
        -: 1466:static int
    #####: 1467:test_htmlCreateMemoryParserCtxt(void) {
    #####: 1468:    int test_ret = 0;
        -: 1469:
        -: 1470:#if defined(LIBXML_HTML_ENABLED)
        -: 1471:    int mem_base;
        -: 1472:    htmlParserCtxtPtr ret_val;
        -: 1473:    char * buffer; /* a pointer to a char array */
        -: 1474:    int n_buffer;
        -: 1475:    int size; /* the size of the array */
        -: 1476:    int n_size;
        -: 1477:
    #####: 1478:    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    #####: 1479:    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    #####: 1480:        mem_base = xmlMemBlocks();
    #####: 1481:        buffer = gen_const_char_ptr(n_buffer, 0);
    #####: 1482:        size = gen_int(n_size, 1);
        -: 1483:
    #####: 1484:        ret_val = htmlCreateMemoryParserCtxt((const char *)buffer, size);
    #####: 1485:        desret_htmlParserCtxtPtr(ret_val);
    #####: 1486:        call_tests++;
    #####: 1487:        des_const_char_ptr(n_buffer, (const char *)buffer, 0);
    #####: 1488:        des_int(n_size, size, 1);
    #####: 1489:        xmlResetLastError();
    #####: 1490:        if (mem_base != xmlMemBlocks()) {
    #####: 1491:            printf("Leak of %d blocks found in htmlCreateMemoryParserCtxt",
    #####: 1492:	           xmlMemBlocks() - mem_base);
    #####: 1493:	    test_ret++;
    #####: 1494:            printf(" %d", n_buffer);
    #####: 1495:            printf(" %d", n_size);
    #####: 1496:            printf("\n");
        -: 1497:        }
        -: 1498:    }
        -: 1499:    }
    #####: 1500:    function_tests++;
        -: 1501:#endif
        -: 1502:
    #####: 1503:    return(test_ret);
        -: 1504:}
        -: 1505:
        -: 1506:#ifdef LIBXML_HTML_ENABLED
        -: 1507:
        -: 1508:#define gen_nb_htmlSAXHandlerPtr 1
    #####: 1509:static htmlSAXHandlerPtr gen_htmlSAXHandlerPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 1510:    return(NULL);
        -: 1511:}
    #####: 1512:static void des_htmlSAXHandlerPtr(int no ATTRIBUTE_UNUSED, htmlSAXHandlerPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 1513:}
        -: 1514:#endif
        -: 1515:
        -: 1516:
        -: 1517:static int
    #####: 1518:test_htmlCreatePushParserCtxt(void) {
    #####: 1519:    int test_ret = 0;
        -: 1520:
        -: 1521:#if defined(LIBXML_HTML_ENABLED) && defined(LIBXML_PUSH_ENABLED)
        -: 1522:    int mem_base;
        -: 1523:    htmlParserCtxtPtr ret_val;
        -: 1524:    htmlSAXHandlerPtr sax; /* a SAX handler */
        -: 1525:    int n_sax;
        -: 1526:    void * user_data; /* The user data returned on SAX callbacks */
        -: 1527:    int n_user_data;
        -: 1528:    char * chunk; /* a pointer to an array of chars */
        -: 1529:    int n_chunk;
        -: 1530:    int size; /* number of chars in the array */
        -: 1531:    int n_size;
        -: 1532:    const char * filename; /* an optional file name or URI */
        -: 1533:    int n_filename;
        -: 1534:    xmlCharEncoding enc; /* an optional encoding */
        -: 1535:    int n_enc;
        -: 1536:
    #####: 1537:    for (n_sax = 0;n_sax < gen_nb_htmlSAXHandlerPtr;n_sax++) {
    #####: 1538:    for (n_user_data = 0;n_user_data < gen_nb_userdata;n_user_data++) {
    #####: 1539:    for (n_chunk = 0;n_chunk < gen_nb_const_char_ptr;n_chunk++) {
    #####: 1540:    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    #####: 1541:    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    #####: 1542:    for (n_enc = 0;n_enc < gen_nb_xmlCharEncoding;n_enc++) {
    #####: 1543:        mem_base = xmlMemBlocks();
    #####: 1544:        sax = gen_htmlSAXHandlerPtr(n_sax, 0);
    #####: 1545:        user_data = gen_userdata(n_user_data, 1);
    #####: 1546:        chunk = gen_const_char_ptr(n_chunk, 2);
    #####: 1547:        size = gen_int(n_size, 3);
    #####: 1548:        filename = gen_fileoutput(n_filename, 4);
    #####: 1549:        enc = gen_xmlCharEncoding(n_enc, 5);
        -: 1550:
    #####: 1551:        ret_val = htmlCreatePushParserCtxt(sax, user_data, (const char *)chunk, size, filename, enc);
    #####: 1552:        desret_htmlParserCtxtPtr(ret_val);
    #####: 1553:        call_tests++;
    #####: 1554:        des_htmlSAXHandlerPtr(n_sax, sax, 0);
    #####: 1555:        des_userdata(n_user_data, user_data, 1);
    #####: 1556:        des_const_char_ptr(n_chunk, (const char *)chunk, 2);
    #####: 1557:        des_int(n_size, size, 3);
    #####: 1558:        des_fileoutput(n_filename, filename, 4);
    #####: 1559:        des_xmlCharEncoding(n_enc, enc, 5);
    #####: 1560:        xmlResetLastError();
    #####: 1561:        if (mem_base != xmlMemBlocks()) {
    #####: 1562:            printf("Leak of %d blocks found in htmlCreatePushParserCtxt",
    #####: 1563:	           xmlMemBlocks() - mem_base);
    #####: 1564:	    test_ret++;
    #####: 1565:            printf(" %d", n_sax);
    #####: 1566:            printf(" %d", n_user_data);
    #####: 1567:            printf(" %d", n_chunk);
    #####: 1568:            printf(" %d", n_size);
    #####: 1569:            printf(" %d", n_filename);
    #####: 1570:            printf(" %d", n_enc);
    #####: 1571:            printf("\n");
        -: 1572:        }
        -: 1573:    }
        -: 1574:    }
        -: 1575:    }
        -: 1576:    }
        -: 1577:    }
        -: 1578:    }
    #####: 1579:    function_tests++;
        -: 1580:#endif
        -: 1581:
    #####: 1582:    return(test_ret);
        -: 1583:}
        -: 1584:
        -: 1585:
        -: 1586:static int
    #####: 1587:test_htmlCtxtReadDoc(void) {
    #####: 1588:    int test_ret = 0;
        -: 1589:
        -: 1590:#if defined(LIBXML_HTML_ENABLED)
        -: 1591:    int mem_base;
        -: 1592:    htmlDocPtr ret_val;
        -: 1593:    htmlParserCtxtPtr ctxt; /* an HTML parser context */
        -: 1594:    int n_ctxt;
        -: 1595:    xmlChar * cur; /* a pointer to a zero terminated string */
        -: 1596:    int n_cur;
        -: 1597:    const char * URL; /* the base URL to use for the document */
        -: 1598:    int n_URL;
        -: 1599:    char * encoding; /* the document encoding, or NULL */
        -: 1600:    int n_encoding;
        -: 1601:    int options; /* a combination of htmlParserOption(s) */
        -: 1602:    int n_options;
        -: 1603:
    #####: 1604:    for (n_ctxt = 0;n_ctxt < gen_nb_htmlParserCtxtPtr;n_ctxt++) {
    #####: 1605:    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    #####: 1606:    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    #####: 1607:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####: 1608:    for (n_options = 0;n_options < gen_nb_int;n_options++) {
    #####: 1609:        mem_base = xmlMemBlocks();
    #####: 1610:        ctxt = gen_htmlParserCtxtPtr(n_ctxt, 0);
    #####: 1611:        cur = gen_const_xmlChar_ptr(n_cur, 1);
    #####: 1612:        URL = gen_filepath(n_URL, 2);
    #####: 1613:        encoding = gen_const_char_ptr(n_encoding, 3);
    #####: 1614:        options = gen_int(n_options, 4);
        -: 1615:
    #####: 1616:        ret_val = htmlCtxtReadDoc(ctxt, (const xmlChar *)cur, URL, (const char *)encoding, options);
    #####: 1617:        desret_htmlDocPtr(ret_val);
    #####: 1618:        call_tests++;
    #####: 1619:        des_htmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####: 1620:        des_const_xmlChar_ptr(n_cur, (const xmlChar *)cur, 1);
    #####: 1621:        des_filepath(n_URL, URL, 2);
    #####: 1622:        des_const_char_ptr(n_encoding, (const char *)encoding, 3);
    #####: 1623:        des_int(n_options, options, 4);
    #####: 1624:        xmlResetLastError();
    #####: 1625:        if (mem_base != xmlMemBlocks()) {
    #####: 1626:            printf("Leak of %d blocks found in htmlCtxtReadDoc",
    #####: 1627:	           xmlMemBlocks() - mem_base);
    #####: 1628:	    test_ret++;
    #####: 1629:            printf(" %d", n_ctxt);
    #####: 1630:            printf(" %d", n_cur);
    #####: 1631:            printf(" %d", n_URL);
    #####: 1632:            printf(" %d", n_encoding);
    #####: 1633:            printf(" %d", n_options);
    #####: 1634:            printf("\n");
        -: 1635:        }
        -: 1636:    }
        -: 1637:    }
        -: 1638:    }
        -: 1639:    }
        -: 1640:    }
    #####: 1641:    function_tests++;
        -: 1642:#endif
        -: 1643:
    #####: 1644:    return(test_ret);
        -: 1645:}
        -: 1646:
        -: 1647:
        -: 1648:static int
    #####: 1649:test_htmlCtxtReadFile(void) {
    #####: 1650:    int test_ret = 0;
        -: 1651:
        -: 1652:#if defined(LIBXML_HTML_ENABLED)
        -: 1653:    htmlDocPtr ret_val;
        -: 1654:    htmlParserCtxtPtr ctxt; /* an HTML parser context */
        -: 1655:    int n_ctxt;
        -: 1656:    const char * filename; /* a file or URL */
        -: 1657:    int n_filename;
        -: 1658:    char * encoding; /* the document encoding, or NULL */
        -: 1659:    int n_encoding;
        -: 1660:    int options; /* a combination of htmlParserOption(s) */
        -: 1661:    int n_options;
        -: 1662:
    #####: 1663:    for (n_ctxt = 0;n_ctxt < gen_nb_htmlParserCtxtPtr;n_ctxt++) {
    #####: 1664:    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    #####: 1665:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####: 1666:    for (n_options = 0;n_options < gen_nb_int;n_options++) {
    #####: 1667:        ctxt = gen_htmlParserCtxtPtr(n_ctxt, 0);
    #####: 1668:        filename = gen_filepath(n_filename, 1);
    #####: 1669:        encoding = gen_const_char_ptr(n_encoding, 2);
    #####: 1670:        options = gen_int(n_options, 3);
        -: 1671:
    #####: 1672:        ret_val = htmlCtxtReadFile(ctxt, filename, (const char *)encoding, options);
    #####: 1673:        desret_htmlDocPtr(ret_val);
    #####: 1674:        call_tests++;
    #####: 1675:        des_htmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####: 1676:        des_filepath(n_filename, filename, 1);
    #####: 1677:        des_const_char_ptr(n_encoding, (const char *)encoding, 2);
    #####: 1678:        des_int(n_options, options, 3);
    #####: 1679:        xmlResetLastError();
        -: 1680:    }
        -: 1681:    }
        -: 1682:    }
        -: 1683:    }
    #####: 1684:    function_tests++;
        -: 1685:#endif
        -: 1686:
    #####: 1687:    return(test_ret);
        -: 1688:}
        -: 1689:
        -: 1690:
        -: 1691:static int
    #####: 1692:test_htmlCtxtReadMemory(void) {
    #####: 1693:    int test_ret = 0;
        -: 1694:
        -: 1695:#if defined(LIBXML_HTML_ENABLED)
        -: 1696:    int mem_base;
        -: 1697:    htmlDocPtr ret_val;
        -: 1698:    htmlParserCtxtPtr ctxt; /* an HTML parser context */
        -: 1699:    int n_ctxt;
        -: 1700:    char * buffer; /* a pointer to a char array */
        -: 1701:    int n_buffer;
        -: 1702:    int size; /* the size of the array */
        -: 1703:    int n_size;
        -: 1704:    const char * URL; /* the base URL to use for the document */
        -: 1705:    int n_URL;
        -: 1706:    char * encoding; /* the document encoding, or NULL */
        -: 1707:    int n_encoding;
        -: 1708:    int options; /* a combination of htmlParserOption(s) */
        -: 1709:    int n_options;
        -: 1710:
    #####: 1711:    for (n_ctxt = 0;n_ctxt < gen_nb_htmlParserCtxtPtr;n_ctxt++) {
    #####: 1712:    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    #####: 1713:    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    #####: 1714:    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    #####: 1715:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####: 1716:    for (n_options = 0;n_options < gen_nb_int;n_options++) {
    #####: 1717:        mem_base = xmlMemBlocks();
    #####: 1718:        ctxt = gen_htmlParserCtxtPtr(n_ctxt, 0);
    #####: 1719:        buffer = gen_const_char_ptr(n_buffer, 1);
    #####: 1720:        size = gen_int(n_size, 2);
    #####: 1721:        URL = gen_filepath(n_URL, 3);
    #####: 1722:        encoding = gen_const_char_ptr(n_encoding, 4);
    #####: 1723:        options = gen_int(n_options, 5);
        -: 1724:
    #####: 1725:        ret_val = htmlCtxtReadMemory(ctxt, (const char *)buffer, size, URL, (const char *)encoding, options);
    #####: 1726:        desret_htmlDocPtr(ret_val);
    #####: 1727:        call_tests++;
    #####: 1728:        des_htmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####: 1729:        des_const_char_ptr(n_buffer, (const char *)buffer, 1);
    #####: 1730:        des_int(n_size, size, 2);
    #####: 1731:        des_filepath(n_URL, URL, 3);
    #####: 1732:        des_const_char_ptr(n_encoding, (const char *)encoding, 4);
    #####: 1733:        des_int(n_options, options, 5);
    #####: 1734:        xmlResetLastError();
    #####: 1735:        if (mem_base != xmlMemBlocks()) {
    #####: 1736:            printf("Leak of %d blocks found in htmlCtxtReadMemory",
    #####: 1737:	           xmlMemBlocks() - mem_base);
    #####: 1738:	    test_ret++;
    #####: 1739:            printf(" %d", n_ctxt);
    #####: 1740:            printf(" %d", n_buffer);
    #####: 1741:            printf(" %d", n_size);
    #####: 1742:            printf(" %d", n_URL);
    #####: 1743:            printf(" %d", n_encoding);
    #####: 1744:            printf(" %d", n_options);
    #####: 1745:            printf("\n");
        -: 1746:        }
        -: 1747:    }
        -: 1748:    }
        -: 1749:    }
        -: 1750:    }
        -: 1751:    }
        -: 1752:    }
    #####: 1753:    function_tests++;
        -: 1754:#endif
        -: 1755:
    #####: 1756:    return(test_ret);
        -: 1757:}
        -: 1758:
        -: 1759:
        -: 1760:static int
    #####: 1761:test_htmlCtxtReset(void) {
    #####: 1762:    int test_ret = 0;
        -: 1763:
        -: 1764:#if defined(LIBXML_HTML_ENABLED)
        -: 1765:    int mem_base;
        -: 1766:    htmlParserCtxtPtr ctxt; /* an HTML parser context */
        -: 1767:    int n_ctxt;
        -: 1768:
    #####: 1769:    for (n_ctxt = 0;n_ctxt < gen_nb_htmlParserCtxtPtr;n_ctxt++) {
    #####: 1770:        mem_base = xmlMemBlocks();
    #####: 1771:        ctxt = gen_htmlParserCtxtPtr(n_ctxt, 0);
        -: 1772:
    #####: 1773:        htmlCtxtReset(ctxt);
    #####: 1774:        call_tests++;
    #####: 1775:        des_htmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####: 1776:        xmlResetLastError();
    #####: 1777:        if (mem_base != xmlMemBlocks()) {
    #####: 1778:            printf("Leak of %d blocks found in htmlCtxtReset",
    #####: 1779:	           xmlMemBlocks() - mem_base);
    #####: 1780:	    test_ret++;
    #####: 1781:            printf(" %d", n_ctxt);
    #####: 1782:            printf("\n");
        -: 1783:        }
        -: 1784:    }
    #####: 1785:    function_tests++;
        -: 1786:#endif
        -: 1787:
    #####: 1788:    return(test_ret);
        -: 1789:}
        -: 1790:
        -: 1791:
        -: 1792:static int
    #####: 1793:test_htmlCtxtUseOptions(void) {
    #####: 1794:    int test_ret = 0;
        -: 1795:
        -: 1796:#if defined(LIBXML_HTML_ENABLED)
        -: 1797:    int mem_base;
        -: 1798:    int ret_val;
        -: 1799:    htmlParserCtxtPtr ctxt; /* an HTML parser context */
        -: 1800:    int n_ctxt;
        -: 1801:    int options; /* a combination of htmlParserOption(s) */
        -: 1802:    int n_options;
        -: 1803:
    #####: 1804:    for (n_ctxt = 0;n_ctxt < gen_nb_htmlParserCtxtPtr;n_ctxt++) {
    #####: 1805:    for (n_options = 0;n_options < gen_nb_int;n_options++) {
    #####: 1806:        mem_base = xmlMemBlocks();
    #####: 1807:        ctxt = gen_htmlParserCtxtPtr(n_ctxt, 0);
    #####: 1808:        options = gen_int(n_options, 1);
        -: 1809:
    #####: 1810:        ret_val = htmlCtxtUseOptions(ctxt, options);
    #####: 1811:        desret_int(ret_val);
    #####: 1812:        call_tests++;
    #####: 1813:        des_htmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####: 1814:        des_int(n_options, options, 1);
    #####: 1815:        xmlResetLastError();
    #####: 1816:        if (mem_base != xmlMemBlocks()) {
    #####: 1817:            printf("Leak of %d blocks found in htmlCtxtUseOptions",
    #####: 1818:	           xmlMemBlocks() - mem_base);
    #####: 1819:	    test_ret++;
    #####: 1820:            printf(" %d", n_ctxt);
    #####: 1821:            printf(" %d", n_options);
    #####: 1822:            printf("\n");
        -: 1823:        }
        -: 1824:    }
        -: 1825:    }
    #####: 1826:    function_tests++;
        -: 1827:#endif
        -: 1828:
    #####: 1829:    return(test_ret);
        -: 1830:}
        -: 1831:
        -: 1832:
        -: 1833:static int
    #####: 1834:test_htmlElementAllowedHere(void) {
    #####: 1835:    int test_ret = 0;
        -: 1836:
        -: 1837:#if defined(LIBXML_HTML_ENABLED)
        -: 1838:    int mem_base;
        -: 1839:    int ret_val;
        -: 1840:    htmlElemDesc * parent; /* HTML parent element */
        -: 1841:    int n_parent;
        -: 1842:    xmlChar * elt; /* HTML element */
        -: 1843:    int n_elt;
        -: 1844:
    #####: 1845:    for (n_parent = 0;n_parent < gen_nb_const_htmlElemDesc_ptr;n_parent++) {
    #####: 1846:    for (n_elt = 0;n_elt < gen_nb_const_xmlChar_ptr;n_elt++) {
    #####: 1847:        mem_base = xmlMemBlocks();
    #####: 1848:        parent = gen_const_htmlElemDesc_ptr(n_parent, 0);
    #####: 1849:        elt = gen_const_xmlChar_ptr(n_elt, 1);
        -: 1850:
    #####: 1851:        ret_val = htmlElementAllowedHere((const htmlElemDesc *)parent, (const xmlChar *)elt);
    #####: 1852:        desret_int(ret_val);
    #####: 1853:        call_tests++;
    #####: 1854:        des_const_htmlElemDesc_ptr(n_parent, (const htmlElemDesc *)parent, 0);
    #####: 1855:        des_const_xmlChar_ptr(n_elt, (const xmlChar *)elt, 1);
    #####: 1856:        xmlResetLastError();
    #####: 1857:        if (mem_base != xmlMemBlocks()) {
    #####: 1858:            printf("Leak of %d blocks found in htmlElementAllowedHere",
    #####: 1859:	           xmlMemBlocks() - mem_base);
    #####: 1860:	    test_ret++;
    #####: 1861:            printf(" %d", n_parent);
    #####: 1862:            printf(" %d", n_elt);
    #####: 1863:            printf("\n");
        -: 1864:        }
        -: 1865:    }
        -: 1866:    }
    #####: 1867:    function_tests++;
        -: 1868:#endif
        -: 1869:
    #####: 1870:    return(test_ret);
        -: 1871:}
        -: 1872:
        -: 1873:
        -: 1874:static int
    #####: 1875:test_htmlElementStatusHere(void) {
    #####: 1876:    int test_ret = 0;
        -: 1877:
        -: 1878:#if defined(LIBXML_HTML_ENABLED)
        -: 1879:    int mem_base;
        -: 1880:    htmlStatus ret_val;
        -: 1881:    htmlElemDesc * parent; /* HTML parent element */
        -: 1882:    int n_parent;
        -: 1883:    htmlElemDesc * elt; /* HTML element */
        -: 1884:    int n_elt;
        -: 1885:
    #####: 1886:    for (n_parent = 0;n_parent < gen_nb_const_htmlElemDesc_ptr;n_parent++) {
    #####: 1887:    for (n_elt = 0;n_elt < gen_nb_const_htmlElemDesc_ptr;n_elt++) {
    #####: 1888:        mem_base = xmlMemBlocks();
    #####: 1889:        parent = gen_const_htmlElemDesc_ptr(n_parent, 0);
    #####: 1890:        elt = gen_const_htmlElemDesc_ptr(n_elt, 1);
        -: 1891:
    #####: 1892:        ret_val = htmlElementStatusHere((const htmlElemDesc *)parent, (const htmlElemDesc *)elt);
    #####: 1893:        desret_htmlStatus(ret_val);
    #####: 1894:        call_tests++;
    #####: 1895:        des_const_htmlElemDesc_ptr(n_parent, (const htmlElemDesc *)parent, 0);
    #####: 1896:        des_const_htmlElemDesc_ptr(n_elt, (const htmlElemDesc *)elt, 1);
    #####: 1897:        xmlResetLastError();
    #####: 1898:        if (mem_base != xmlMemBlocks()) {
    #####: 1899:            printf("Leak of %d blocks found in htmlElementStatusHere",
    #####: 1900:	           xmlMemBlocks() - mem_base);
    #####: 1901:	    test_ret++;
    #####: 1902:            printf(" %d", n_parent);
    #####: 1903:            printf(" %d", n_elt);
    #####: 1904:            printf("\n");
        -: 1905:        }
        -: 1906:    }
        -: 1907:    }
    #####: 1908:    function_tests++;
        -: 1909:#endif
        -: 1910:
    #####: 1911:    return(test_ret);
        -: 1912:}
        -: 1913:
        -: 1914:
        -: 1915:static int
    #####: 1916:test_htmlEncodeEntities(void) {
    #####: 1917:    int test_ret = 0;
        -: 1918:
        -: 1919:#if defined(LIBXML_HTML_ENABLED)
        -: 1920:    int mem_base;
        -: 1921:    int ret_val;
        -: 1922:    unsigned char * out; /* a pointer to an array of bytes to store the result */
        -: 1923:    int n_out;
        -: 1924:    int * outlen; /* the length of @out */
        -: 1925:    int n_outlen;
        -: 1926:    unsigned char * in; /* a pointer to an array of UTF-8 chars */
        -: 1927:    int n_in;
        -: 1928:    int * inlen; /* the length of @in */
        -: 1929:    int n_inlen;
        -: 1930:    int quoteChar; /* the quote character to escape (' or ") or zero. */
        -: 1931:    int n_quoteChar;
        -: 1932:
    #####: 1933:    for (n_out = 0;n_out < gen_nb_unsigned_char_ptr;n_out++) {
    #####: 1934:    for (n_outlen = 0;n_outlen < gen_nb_int_ptr;n_outlen++) {
    #####: 1935:    for (n_in = 0;n_in < gen_nb_const_unsigned_char_ptr;n_in++) {
    #####: 1936:    for (n_inlen = 0;n_inlen < gen_nb_int_ptr;n_inlen++) {
    #####: 1937:    for (n_quoteChar = 0;n_quoteChar < gen_nb_int;n_quoteChar++) {
    #####: 1938:        mem_base = xmlMemBlocks();
    #####: 1939:        out = gen_unsigned_char_ptr(n_out, 0);
    #####: 1940:        outlen = gen_int_ptr(n_outlen, 1);
    #####: 1941:        in = gen_const_unsigned_char_ptr(n_in, 2);
    #####: 1942:        inlen = gen_int_ptr(n_inlen, 3);
    #####: 1943:        quoteChar = gen_int(n_quoteChar, 4);
        -: 1944:
    #####: 1945:        ret_val = htmlEncodeEntities(out, outlen, (const unsigned char *)in, inlen, quoteChar);
    #####: 1946:        desret_int(ret_val);
    #####: 1947:        call_tests++;
    #####: 1948:        des_unsigned_char_ptr(n_out, out, 0);
    #####: 1949:        des_int_ptr(n_outlen, outlen, 1);
    #####: 1950:        des_const_unsigned_char_ptr(n_in, (const unsigned char *)in, 2);
    #####: 1951:        des_int_ptr(n_inlen, inlen, 3);
    #####: 1952:        des_int(n_quoteChar, quoteChar, 4);
    #####: 1953:        xmlResetLastError();
    #####: 1954:        if (mem_base != xmlMemBlocks()) {
    #####: 1955:            printf("Leak of %d blocks found in htmlEncodeEntities",
    #####: 1956:	           xmlMemBlocks() - mem_base);
    #####: 1957:	    test_ret++;
    #####: 1958:            printf(" %d", n_out);
    #####: 1959:            printf(" %d", n_outlen);
    #####: 1960:            printf(" %d", n_in);
    #####: 1961:            printf(" %d", n_inlen);
    #####: 1962:            printf(" %d", n_quoteChar);
    #####: 1963:            printf("\n");
        -: 1964:        }
        -: 1965:    }
        -: 1966:    }
        -: 1967:    }
        -: 1968:    }
        -: 1969:    }
    #####: 1970:    function_tests++;
        -: 1971:#endif
        -: 1972:
    #####: 1973:    return(test_ret);
        -: 1974:}
        -: 1975:
        -: 1976:
        -: 1977:static int
    #####: 1978:test_htmlEntityLookup(void) {
    #####: 1979:    int test_ret = 0;
        -: 1980:
        -: 1981:#if defined(LIBXML_HTML_ENABLED)
        -: 1982:    int mem_base;
        -: 1983:    const htmlEntityDesc * ret_val;
        -: 1984:    xmlChar * name; /* the entity name */
        -: 1985:    int n_name;
        -: 1986:
    #####: 1987:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####: 1988:        mem_base = xmlMemBlocks();
    #####: 1989:        name = gen_const_xmlChar_ptr(n_name, 0);
        -: 1990:
    #####: 1991:        ret_val = htmlEntityLookup((const xmlChar *)name);
    #####: 1992:        desret_const_htmlEntityDesc_ptr(ret_val);
    #####: 1993:        call_tests++;
    #####: 1994:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 0);
    #####: 1995:        xmlResetLastError();
    #####: 1996:        if (mem_base != xmlMemBlocks()) {
    #####: 1997:            printf("Leak of %d blocks found in htmlEntityLookup",
    #####: 1998:	           xmlMemBlocks() - mem_base);
    #####: 1999:	    test_ret++;
    #####: 2000:            printf(" %d", n_name);
    #####: 2001:            printf("\n");
        -: 2002:        }
        -: 2003:    }
    #####: 2004:    function_tests++;
        -: 2005:#endif
        -: 2006:
    #####: 2007:    return(test_ret);
        -: 2008:}
        -: 2009:
        -: 2010:
        -: 2011:static int
    #####: 2012:test_htmlEntityValueLookup(void) {
    #####: 2013:    int test_ret = 0;
        -: 2014:
        -: 2015:#if defined(LIBXML_HTML_ENABLED)
        -: 2016:    int mem_base;
        -: 2017:    const htmlEntityDesc * ret_val;
        -: 2018:    unsigned int value; /* the entity's unicode value */
        -: 2019:    int n_value;
        -: 2020:
    #####: 2021:    for (n_value = 0;n_value < gen_nb_unsigned_int;n_value++) {
    #####: 2022:        mem_base = xmlMemBlocks();
    #####: 2023:        value = gen_unsigned_int(n_value, 0);
        -: 2024:
    #####: 2025:        ret_val = htmlEntityValueLookup(value);
    #####: 2026:        desret_const_htmlEntityDesc_ptr(ret_val);
    #####: 2027:        call_tests++;
    #####: 2028:        des_unsigned_int(n_value, value, 0);
    #####: 2029:        xmlResetLastError();
    #####: 2030:        if (mem_base != xmlMemBlocks()) {
    #####: 2031:            printf("Leak of %d blocks found in htmlEntityValueLookup",
    #####: 2032:	           xmlMemBlocks() - mem_base);
    #####: 2033:	    test_ret++;
    #####: 2034:            printf(" %d", n_value);
    #####: 2035:            printf("\n");
        -: 2036:        }
        -: 2037:    }
    #####: 2038:    function_tests++;
        -: 2039:#endif
        -: 2040:
    #####: 2041:    return(test_ret);
        -: 2042:}
        -: 2043:
        -: 2044:
        -: 2045:static int
    #####: 2046:test_htmlHandleOmittedElem(void) {
    #####: 2047:    int test_ret = 0;
        -: 2048:
        -: 2049:#if defined(LIBXML_HTML_ENABLED)
        -: 2050:    int mem_base;
        -: 2051:    int ret_val;
        -: 2052:    int val; /* int 0 or 1 */
        -: 2053:    int n_val;
        -: 2054:
    #####: 2055:    for (n_val = 0;n_val < gen_nb_int;n_val++) {
    #####: 2056:        mem_base = xmlMemBlocks();
    #####: 2057:        val = gen_int(n_val, 0);
        -: 2058:
    #####: 2059:        ret_val = htmlHandleOmittedElem(val);
    #####: 2060:        desret_int(ret_val);
    #####: 2061:        call_tests++;
    #####: 2062:        des_int(n_val, val, 0);
    #####: 2063:        xmlResetLastError();
    #####: 2064:        if (mem_base != xmlMemBlocks()) {
    #####: 2065:            printf("Leak of %d blocks found in htmlHandleOmittedElem",
    #####: 2066:	           xmlMemBlocks() - mem_base);
    #####: 2067:	    test_ret++;
    #####: 2068:            printf(" %d", n_val);
    #####: 2069:            printf("\n");
        -: 2070:        }
        -: 2071:    }
    #####: 2072:    function_tests++;
        -: 2073:#endif
        -: 2074:
    #####: 2075:    return(test_ret);
        -: 2076:}
        -: 2077:
        -: 2078:
        -: 2079:static int
    #####: 2080:test_htmlIsAutoClosed(void) {
    #####: 2081:    int test_ret = 0;
        -: 2082:
        -: 2083:#if defined(LIBXML_HTML_ENABLED)
        -: 2084:    int mem_base;
        -: 2085:    int ret_val;
        -: 2086:    htmlDocPtr doc; /* the HTML document */
        -: 2087:    int n_doc;
        -: 2088:    htmlNodePtr elem; /* the HTML element */
        -: 2089:    int n_elem;
        -: 2090:
    #####: 2091:    for (n_doc = 0;n_doc < gen_nb_htmlDocPtr;n_doc++) {
    #####: 2092:    for (n_elem = 0;n_elem < gen_nb_htmlNodePtr;n_elem++) {
    #####: 2093:        mem_base = xmlMemBlocks();
    #####: 2094:        doc = gen_htmlDocPtr(n_doc, 0);
    #####: 2095:        elem = gen_htmlNodePtr(n_elem, 1);
        -: 2096:
    #####: 2097:        ret_val = htmlIsAutoClosed(doc, elem);
    #####: 2098:        desret_int(ret_val);
    #####: 2099:        call_tests++;
    #####: 2100:        des_htmlDocPtr(n_doc, doc, 0);
    #####: 2101:        des_htmlNodePtr(n_elem, elem, 1);
    #####: 2102:        xmlResetLastError();
    #####: 2103:        if (mem_base != xmlMemBlocks()) {
    #####: 2104:            printf("Leak of %d blocks found in htmlIsAutoClosed",
    #####: 2105:	           xmlMemBlocks() - mem_base);
    #####: 2106:	    test_ret++;
    #####: 2107:            printf(" %d", n_doc);
    #####: 2108:            printf(" %d", n_elem);
    #####: 2109:            printf("\n");
        -: 2110:        }
        -: 2111:    }
        -: 2112:    }
    #####: 2113:    function_tests++;
        -: 2114:#endif
        -: 2115:
    #####: 2116:    return(test_ret);
        -: 2117:}
        -: 2118:
        -: 2119:
        -: 2120:static int
    #####: 2121:test_htmlIsScriptAttribute(void) {
    #####: 2122:    int test_ret = 0;
        -: 2123:
        -: 2124:#if defined(LIBXML_HTML_ENABLED)
        -: 2125:    int mem_base;
        -: 2126:    int ret_val;
        -: 2127:    xmlChar * name; /* an attribute name */
        -: 2128:    int n_name;
        -: 2129:
    #####: 2130:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####: 2131:        mem_base = xmlMemBlocks();
    #####: 2132:        name = gen_const_xmlChar_ptr(n_name, 0);
        -: 2133:
    #####: 2134:        ret_val = htmlIsScriptAttribute((const xmlChar *)name);
    #####: 2135:        desret_int(ret_val);
    #####: 2136:        call_tests++;
    #####: 2137:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 0);
    #####: 2138:        xmlResetLastError();
    #####: 2139:        if (mem_base != xmlMemBlocks()) {
    #####: 2140:            printf("Leak of %d blocks found in htmlIsScriptAttribute",
    #####: 2141:	           xmlMemBlocks() - mem_base);
    #####: 2142:	    test_ret++;
    #####: 2143:            printf(" %d", n_name);
    #####: 2144:            printf("\n");
        -: 2145:        }
        -: 2146:    }
    #####: 2147:    function_tests++;
        -: 2148:#endif
        -: 2149:
    #####: 2150:    return(test_ret);
        -: 2151:}
        -: 2152:
        -: 2153:
        -: 2154:static int
    #####: 2155:test_htmlNewParserCtxt(void) {
    #####: 2156:    int test_ret = 0;
        -: 2157:
        -: 2158:#if defined(LIBXML_HTML_ENABLED)
        -: 2159:    int mem_base;
        -: 2160:    htmlParserCtxtPtr ret_val;
        -: 2161:
    #####: 2162:        mem_base = xmlMemBlocks();
        -: 2163:
    #####: 2164:        ret_val = htmlNewParserCtxt();
    #####: 2165:        desret_htmlParserCtxtPtr(ret_val);
    #####: 2166:        call_tests++;
    #####: 2167:        xmlResetLastError();
    #####: 2168:        if (mem_base != xmlMemBlocks()) {
    #####: 2169:            printf("Leak of %d blocks found in htmlNewParserCtxt",
    #####: 2170:	           xmlMemBlocks() - mem_base);
    #####: 2171:	    test_ret++;
    #####: 2172:            printf("\n");
        -: 2173:        }
    #####: 2174:    function_tests++;
        -: 2175:#endif
        -: 2176:
    #####: 2177:    return(test_ret);
        -: 2178:}
        -: 2179:
        -: 2180:
        -: 2181:static int
    #####: 2182:test_htmlNodeStatus(void) {
    #####: 2183:    int test_ret = 0;
        -: 2184:
        -: 2185:#if defined(LIBXML_HTML_ENABLED)
        -: 2186:    int mem_base;
        -: 2187:    htmlStatus ret_val;
        -: 2188:    htmlNodePtr node; /* an htmlNodePtr in a tree */
        -: 2189:    int n_node;
        -: 2190:    int legacy; /* whether to allow deprecated elements (YES is faster here for Element nodes) */
        -: 2191:    int n_legacy;
        -: 2192:
    #####: 2193:    for (n_node = 0;n_node < gen_nb_const_htmlNodePtr;n_node++) {
    #####: 2194:    for (n_legacy = 0;n_legacy < gen_nb_int;n_legacy++) {
    #####: 2195:        mem_base = xmlMemBlocks();
    #####: 2196:        node = gen_const_htmlNodePtr(n_node, 0);
    #####: 2197:        legacy = gen_int(n_legacy, 1);
        -: 2198:
    #####: 2199:        ret_val = htmlNodeStatus((const htmlNodePtr)node, legacy);
    #####: 2200:        desret_htmlStatus(ret_val);
    #####: 2201:        call_tests++;
    #####: 2202:        des_const_htmlNodePtr(n_node, (const htmlNodePtr)node, 0);
    #####: 2203:        des_int(n_legacy, legacy, 1);
    #####: 2204:        xmlResetLastError();
    #####: 2205:        if (mem_base != xmlMemBlocks()) {
    #####: 2206:            printf("Leak of %d blocks found in htmlNodeStatus",
    #####: 2207:	           xmlMemBlocks() - mem_base);
    #####: 2208:	    test_ret++;
    #####: 2209:            printf(" %d", n_node);
    #####: 2210:            printf(" %d", n_legacy);
    #####: 2211:            printf("\n");
        -: 2212:        }
        -: 2213:    }
        -: 2214:    }
    #####: 2215:    function_tests++;
        -: 2216:#endif
        -: 2217:
    #####: 2218:    return(test_ret);
        -: 2219:}
        -: 2220:
        -: 2221:
        -: 2222:static int
    #####: 2223:test_htmlParseCharRef(void) {
    #####: 2224:    int test_ret = 0;
        -: 2225:
        -: 2226:#if defined(LIBXML_HTML_ENABLED)
        -: 2227:    int mem_base;
        -: 2228:    int ret_val;
        -: 2229:    htmlParserCtxtPtr ctxt; /* an HTML parser context */
        -: 2230:    int n_ctxt;
        -: 2231:
    #####: 2232:    for (n_ctxt = 0;n_ctxt < gen_nb_htmlParserCtxtPtr;n_ctxt++) {
    #####: 2233:        mem_base = xmlMemBlocks();
    #####: 2234:        ctxt = gen_htmlParserCtxtPtr(n_ctxt, 0);
        -: 2235:
    #####: 2236:        ret_val = htmlParseCharRef(ctxt);
    #####: 2237:        desret_int(ret_val);
    #####: 2238:        call_tests++;
    #####: 2239:        des_htmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####: 2240:        xmlResetLastError();
    #####: 2241:        if (mem_base != xmlMemBlocks()) {
    #####: 2242:            printf("Leak of %d blocks found in htmlParseCharRef",
    #####: 2243:	           xmlMemBlocks() - mem_base);
    #####: 2244:	    test_ret++;
    #####: 2245:            printf(" %d", n_ctxt);
    #####: 2246:            printf("\n");
        -: 2247:        }
        -: 2248:    }
    #####: 2249:    function_tests++;
        -: 2250:#endif
        -: 2251:
    #####: 2252:    return(test_ret);
        -: 2253:}
        -: 2254:
        -: 2255:
        -: 2256:static int
    #####: 2257:test_htmlParseChunk(void) {
    #####: 2258:    int test_ret = 0;
        -: 2259:
        -: 2260:#if defined(LIBXML_HTML_ENABLED) && defined(LIBXML_PUSH_ENABLED)
        -: 2261:    int mem_base;
        -: 2262:    int ret_val;
        -: 2263:    htmlParserCtxtPtr ctxt; /* an HTML parser context */
        -: 2264:    int n_ctxt;
        -: 2265:    char * chunk; /* an char array */
        -: 2266:    int n_chunk;
        -: 2267:    int size; /* the size in byte of the chunk */
        -: 2268:    int n_size;
        -: 2269:    int terminate; /* last chunk indicator */
        -: 2270:    int n_terminate;
        -: 2271:
    #####: 2272:    for (n_ctxt = 0;n_ctxt < gen_nb_htmlParserCtxtPtr;n_ctxt++) {
    #####: 2273:    for (n_chunk = 0;n_chunk < gen_nb_const_char_ptr;n_chunk++) {
    #####: 2274:    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    #####: 2275:    for (n_terminate = 0;n_terminate < gen_nb_int;n_terminate++) {
    #####: 2276:        mem_base = xmlMemBlocks();
    #####: 2277:        ctxt = gen_htmlParserCtxtPtr(n_ctxt, 0);
    #####: 2278:        chunk = gen_const_char_ptr(n_chunk, 1);
    #####: 2279:        size = gen_int(n_size, 2);
    #####: 2280:        terminate = gen_int(n_terminate, 3);
        -: 2281:
    #####: 2282:        ret_val = htmlParseChunk(ctxt, (const char *)chunk, size, terminate);
    #####: 2283:        if (ctxt != NULL) {xmlFreeDoc(ctxt->myDoc); ctxt->myDoc = NULL;}
    #####: 2284:        desret_int(ret_val);
    #####: 2285:        call_tests++;
    #####: 2286:        des_htmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####: 2287:        des_const_char_ptr(n_chunk, (const char *)chunk, 1);
    #####: 2288:        des_int(n_size, size, 2);
    #####: 2289:        des_int(n_terminate, terminate, 3);
    #####: 2290:        xmlResetLastError();
    #####: 2291:        if (mem_base != xmlMemBlocks()) {
    #####: 2292:            printf("Leak of %d blocks found in htmlParseChunk",
    #####: 2293:	           xmlMemBlocks() - mem_base);
    #####: 2294:	    test_ret++;
    #####: 2295:            printf(" %d", n_ctxt);
    #####: 2296:            printf(" %d", n_chunk);
    #####: 2297:            printf(" %d", n_size);
    #####: 2298:            printf(" %d", n_terminate);
    #####: 2299:            printf("\n");
        -: 2300:        }
        -: 2301:    }
        -: 2302:    }
        -: 2303:    }
        -: 2304:    }
    #####: 2305:    function_tests++;
        -: 2306:#endif
        -: 2307:
    #####: 2308:    return(test_ret);
        -: 2309:}
        -: 2310:
        -: 2311:
        -: 2312:static int
    #####: 2313:test_htmlParseDoc(void) {
    #####: 2314:    int test_ret = 0;
        -: 2315:
        -: 2316:#if defined(LIBXML_HTML_ENABLED)
        -: 2317:    int mem_base;
        -: 2318:    htmlDocPtr ret_val;
        -: 2319:    xmlChar * cur; /* a pointer to an array of xmlChar */
        -: 2320:    int n_cur;
        -: 2321:    char * encoding; /* a free form C string describing the HTML document encoding, or NULL */
        -: 2322:    int n_encoding;
        -: 2323:
    #####: 2324:    for (n_cur = 0;n_cur < gen_nb_xmlChar_ptr;n_cur++) {
    #####: 2325:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####: 2326:        mem_base = xmlMemBlocks();
    #####: 2327:        cur = gen_xmlChar_ptr(n_cur, 0);
    #####: 2328:        encoding = gen_const_char_ptr(n_encoding, 1);
        -: 2329:
    #####: 2330:        ret_val = htmlParseDoc(cur, (const char *)encoding);
    #####: 2331:        desret_htmlDocPtr(ret_val);
    #####: 2332:        call_tests++;
    #####: 2333:        des_xmlChar_ptr(n_cur, cur, 0);
    #####: 2334:        des_const_char_ptr(n_encoding, (const char *)encoding, 1);
    #####: 2335:        xmlResetLastError();
    #####: 2336:        if (mem_base != xmlMemBlocks()) {
    #####: 2337:            printf("Leak of %d blocks found in htmlParseDoc",
    #####: 2338:	           xmlMemBlocks() - mem_base);
    #####: 2339:	    test_ret++;
    #####: 2340:            printf(" %d", n_cur);
    #####: 2341:            printf(" %d", n_encoding);
    #####: 2342:            printf("\n");
        -: 2343:        }
        -: 2344:    }
        -: 2345:    }
    #####: 2346:    function_tests++;
        -: 2347:#endif
        -: 2348:
    #####: 2349:    return(test_ret);
        -: 2350:}
        -: 2351:
        -: 2352:
        -: 2353:static int
    #####: 2354:test_htmlParseDocument(void) {
    #####: 2355:    int test_ret = 0;
        -: 2356:
        -: 2357:#if defined(LIBXML_HTML_ENABLED)
        -: 2358:    int mem_base;
        -: 2359:    int ret_val;
        -: 2360:    htmlParserCtxtPtr ctxt; /* an HTML parser context */
        -: 2361:    int n_ctxt;
        -: 2362:
    #####: 2363:    for (n_ctxt = 0;n_ctxt < gen_nb_htmlParserCtxtPtr;n_ctxt++) {
    #####: 2364:        mem_base = xmlMemBlocks();
    #####: 2365:        ctxt = gen_htmlParserCtxtPtr(n_ctxt, 0);
        -: 2366:
    #####: 2367:        ret_val = htmlParseDocument(ctxt);
    #####: 2368:        if (ctxt != NULL) {xmlFreeDoc(ctxt->myDoc); ctxt->myDoc = NULL;}
    #####: 2369:        desret_int(ret_val);
    #####: 2370:        call_tests++;
    #####: 2371:        des_htmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####: 2372:        xmlResetLastError();
    #####: 2373:        if (mem_base != xmlMemBlocks()) {
    #####: 2374:            printf("Leak of %d blocks found in htmlParseDocument",
    #####: 2375:	           xmlMemBlocks() - mem_base);
    #####: 2376:	    test_ret++;
    #####: 2377:            printf(" %d", n_ctxt);
    #####: 2378:            printf("\n");
        -: 2379:        }
        -: 2380:    }
    #####: 2381:    function_tests++;
        -: 2382:#endif
        -: 2383:
    #####: 2384:    return(test_ret);
        -: 2385:}
        -: 2386:
        -: 2387:
        -: 2388:static int
    #####: 2389:test_htmlParseElement(void) {
    #####: 2390:    int test_ret = 0;
        -: 2391:
        -: 2392:#if defined(LIBXML_HTML_ENABLED)
        -: 2393:    int mem_base;
        -: 2394:    htmlParserCtxtPtr ctxt; /* an HTML parser context */
        -: 2395:    int n_ctxt;
        -: 2396:
    #####: 2397:    for (n_ctxt = 0;n_ctxt < gen_nb_htmlParserCtxtPtr;n_ctxt++) {
    #####: 2398:        mem_base = xmlMemBlocks();
    #####: 2399:        ctxt = gen_htmlParserCtxtPtr(n_ctxt, 0);
        -: 2400:
    #####: 2401:        htmlParseElement(ctxt);
    #####: 2402:        call_tests++;
    #####: 2403:        des_htmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####: 2404:        xmlResetLastError();
    #####: 2405:        if (mem_base != xmlMemBlocks()) {
    #####: 2406:            printf("Leak of %d blocks found in htmlParseElement",
    #####: 2407:	           xmlMemBlocks() - mem_base);
    #####: 2408:	    test_ret++;
    #####: 2409:            printf(" %d", n_ctxt);
    #####: 2410:            printf("\n");
        -: 2411:        }
        -: 2412:    }
    #####: 2413:    function_tests++;
        -: 2414:#endif
        -: 2415:
    #####: 2416:    return(test_ret);
        -: 2417:}
        -: 2418:
        -: 2419:
        -: 2420:static int
    #####: 2421:test_htmlParseEntityRef(void) {
    #####: 2422:    int test_ret = 0;
        -: 2423:
        -: 2424:#if defined(LIBXML_HTML_ENABLED)
        -: 2425:    int mem_base;
        -: 2426:    const htmlEntityDesc * ret_val;
        -: 2427:    htmlParserCtxtPtr ctxt; /* an HTML parser context */
        -: 2428:    int n_ctxt;
        -: 2429:    xmlChar ** str; /* location to store the entity name */
        -: 2430:    int n_str;
        -: 2431:
    #####: 2432:    for (n_ctxt = 0;n_ctxt < gen_nb_htmlParserCtxtPtr;n_ctxt++) {
    #####: 2433:    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr_ptr;n_str++) {
    #####: 2434:        mem_base = xmlMemBlocks();
    #####: 2435:        ctxt = gen_htmlParserCtxtPtr(n_ctxt, 0);
    #####: 2436:        str = gen_const_xmlChar_ptr_ptr(n_str, 1);
        -: 2437:
    #####: 2438:        ret_val = htmlParseEntityRef(ctxt, (const xmlChar **)str);
    #####: 2439:        desret_const_htmlEntityDesc_ptr(ret_val);
    #####: 2440:        call_tests++;
    #####: 2441:        des_htmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####: 2442:        des_const_xmlChar_ptr_ptr(n_str, (const xmlChar **)str, 1);
    #####: 2443:        xmlResetLastError();
    #####: 2444:        if (mem_base != xmlMemBlocks()) {
    #####: 2445:            printf("Leak of %d blocks found in htmlParseEntityRef",
    #####: 2446:	           xmlMemBlocks() - mem_base);
    #####: 2447:	    test_ret++;
    #####: 2448:            printf(" %d", n_ctxt);
    #####: 2449:            printf(" %d", n_str);
    #####: 2450:            printf("\n");
        -: 2451:        }
        -: 2452:    }
        -: 2453:    }
    #####: 2454:    function_tests++;
        -: 2455:#endif
        -: 2456:
    #####: 2457:    return(test_ret);
        -: 2458:}
        -: 2459:
        -: 2460:
        -: 2461:static int
    #####: 2462:test_htmlParseFile(void) {
    #####: 2463:    int test_ret = 0;
        -: 2464:
        -: 2465:#if defined(LIBXML_HTML_ENABLED)
        -: 2466:    htmlDocPtr ret_val;
        -: 2467:    const char * filename; /* the filename */
        -: 2468:    int n_filename;
        -: 2469:    char * encoding; /* a free form C string describing the HTML document encoding, or NULL */
        -: 2470:    int n_encoding;
        -: 2471:
    #####: 2472:    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    #####: 2473:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####: 2474:        filename = gen_filepath(n_filename, 0);
    #####: 2475:        encoding = gen_const_char_ptr(n_encoding, 1);
        -: 2476:
    #####: 2477:        ret_val = htmlParseFile(filename, (const char *)encoding);
    #####: 2478:        desret_htmlDocPtr(ret_val);
    #####: 2479:        call_tests++;
    #####: 2480:        des_filepath(n_filename, filename, 0);
    #####: 2481:        des_const_char_ptr(n_encoding, (const char *)encoding, 1);
    #####: 2482:        xmlResetLastError();
        -: 2483:    }
        -: 2484:    }
    #####: 2485:    function_tests++;
        -: 2486:#endif
        -: 2487:
    #####: 2488:    return(test_ret);
        -: 2489:}
        -: 2490:
        -: 2491:
        -: 2492:static int
    #####: 2493:test_htmlReadDoc(void) {
    #####: 2494:    int test_ret = 0;
        -: 2495:
        -: 2496:#if defined(LIBXML_HTML_ENABLED)
        -: 2497:    int mem_base;
        -: 2498:    htmlDocPtr ret_val;
        -: 2499:    xmlChar * cur; /* a pointer to a zero terminated string */
        -: 2500:    int n_cur;
        -: 2501:    const char * URL; /* the base URL to use for the document */
        -: 2502:    int n_URL;
        -: 2503:    char * encoding; /* the document encoding, or NULL */
        -: 2504:    int n_encoding;
        -: 2505:    int options; /* a combination of htmlParserOption(s) */
        -: 2506:    int n_options;
        -: 2507:
    #####: 2508:    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    #####: 2509:    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    #####: 2510:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####: 2511:    for (n_options = 0;n_options < gen_nb_int;n_options++) {
    #####: 2512:        mem_base = xmlMemBlocks();
    #####: 2513:        cur = gen_const_xmlChar_ptr(n_cur, 0);
    #####: 2514:        URL = gen_filepath(n_URL, 1);
    #####: 2515:        encoding = gen_const_char_ptr(n_encoding, 2);
    #####: 2516:        options = gen_int(n_options, 3);
        -: 2517:
    #####: 2518:        ret_val = htmlReadDoc((const xmlChar *)cur, URL, (const char *)encoding, options);
    #####: 2519:        desret_htmlDocPtr(ret_val);
    #####: 2520:        call_tests++;
    #####: 2521:        des_const_xmlChar_ptr(n_cur, (const xmlChar *)cur, 0);
    #####: 2522:        des_filepath(n_URL, URL, 1);
    #####: 2523:        des_const_char_ptr(n_encoding, (const char *)encoding, 2);
    #####: 2524:        des_int(n_options, options, 3);
    #####: 2525:        xmlResetLastError();
    #####: 2526:        if (mem_base != xmlMemBlocks()) {
    #####: 2527:            printf("Leak of %d blocks found in htmlReadDoc",
    #####: 2528:	           xmlMemBlocks() - mem_base);
    #####: 2529:	    test_ret++;
    #####: 2530:            printf(" %d", n_cur);
    #####: 2531:            printf(" %d", n_URL);
    #####: 2532:            printf(" %d", n_encoding);
    #####: 2533:            printf(" %d", n_options);
    #####: 2534:            printf("\n");
        -: 2535:        }
        -: 2536:    }
        -: 2537:    }
        -: 2538:    }
        -: 2539:    }
    #####: 2540:    function_tests++;
        -: 2541:#endif
        -: 2542:
    #####: 2543:    return(test_ret);
        -: 2544:}
        -: 2545:
        -: 2546:
        -: 2547:static int
    #####: 2548:test_htmlReadFile(void) {
    #####: 2549:    int test_ret = 0;
        -: 2550:
        -: 2551:#if defined(LIBXML_HTML_ENABLED)
        -: 2552:    int mem_base;
        -: 2553:    htmlDocPtr ret_val;
        -: 2554:    const char * filename; /* a file or URL */
        -: 2555:    int n_filename;
        -: 2556:    char * encoding; /* the document encoding, or NULL */
        -: 2557:    int n_encoding;
        -: 2558:    int options; /* a combination of htmlParserOption(s) */
        -: 2559:    int n_options;
        -: 2560:
    #####: 2561:    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    #####: 2562:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####: 2563:    for (n_options = 0;n_options < gen_nb_int;n_options++) {
    #####: 2564:        mem_base = xmlMemBlocks();
    #####: 2565:        filename = gen_filepath(n_filename, 0);
    #####: 2566:        encoding = gen_const_char_ptr(n_encoding, 1);
    #####: 2567:        options = gen_int(n_options, 2);
        -: 2568:
    #####: 2569:        ret_val = htmlReadFile(filename, (const char *)encoding, options);
    #####: 2570:        desret_htmlDocPtr(ret_val);
    #####: 2571:        call_tests++;
    #####: 2572:        des_filepath(n_filename, filename, 0);
    #####: 2573:        des_const_char_ptr(n_encoding, (const char *)encoding, 1);
    #####: 2574:        des_int(n_options, options, 2);
    #####: 2575:        xmlResetLastError();
    #####: 2576:        if (mem_base != xmlMemBlocks()) {
    #####: 2577:            printf("Leak of %d blocks found in htmlReadFile",
    #####: 2578:	           xmlMemBlocks() - mem_base);
    #####: 2579:	    test_ret++;
    #####: 2580:            printf(" %d", n_filename);
    #####: 2581:            printf(" %d", n_encoding);
    #####: 2582:            printf(" %d", n_options);
    #####: 2583:            printf("\n");
        -: 2584:        }
        -: 2585:    }
        -: 2586:    }
        -: 2587:    }
    #####: 2588:    function_tests++;
        -: 2589:#endif
        -: 2590:
    #####: 2591:    return(test_ret);
        -: 2592:}
        -: 2593:
        -: 2594:
        -: 2595:static int
    #####: 2596:test_htmlReadMemory(void) {
    #####: 2597:    int test_ret = 0;
        -: 2598:
        -: 2599:#if defined(LIBXML_HTML_ENABLED)
        -: 2600:    int mem_base;
        -: 2601:    htmlDocPtr ret_val;
        -: 2602:    char * buffer; /* a pointer to a char array */
        -: 2603:    int n_buffer;
        -: 2604:    int size; /* the size of the array */
        -: 2605:    int n_size;
        -: 2606:    const char * URL; /* the base URL to use for the document */
        -: 2607:    int n_URL;
        -: 2608:    char * encoding; /* the document encoding, or NULL */
        -: 2609:    int n_encoding;
        -: 2610:    int options; /* a combination of htmlParserOption(s) */
        -: 2611:    int n_options;
        -: 2612:
    #####: 2613:    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    #####: 2614:    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    #####: 2615:    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    #####: 2616:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####: 2617:    for (n_options = 0;n_options < gen_nb_int;n_options++) {
    #####: 2618:        mem_base = xmlMemBlocks();
    #####: 2619:        buffer = gen_const_char_ptr(n_buffer, 0);
    #####: 2620:        size = gen_int(n_size, 1);
    #####: 2621:        URL = gen_filepath(n_URL, 2);
    #####: 2622:        encoding = gen_const_char_ptr(n_encoding, 3);
    #####: 2623:        options = gen_int(n_options, 4);
        -: 2624:
    #####: 2625:        ret_val = htmlReadMemory((const char *)buffer, size, URL, (const char *)encoding, options);
    #####: 2626:        desret_htmlDocPtr(ret_val);
    #####: 2627:        call_tests++;
    #####: 2628:        des_const_char_ptr(n_buffer, (const char *)buffer, 0);
    #####: 2629:        des_int(n_size, size, 1);
    #####: 2630:        des_filepath(n_URL, URL, 2);
    #####: 2631:        des_const_char_ptr(n_encoding, (const char *)encoding, 3);
    #####: 2632:        des_int(n_options, options, 4);
    #####: 2633:        xmlResetLastError();
    #####: 2634:        if (mem_base != xmlMemBlocks()) {
    #####: 2635:            printf("Leak of %d blocks found in htmlReadMemory",
    #####: 2636:	           xmlMemBlocks() - mem_base);
    #####: 2637:	    test_ret++;
    #####: 2638:            printf(" %d", n_buffer);
    #####: 2639:            printf(" %d", n_size);
    #####: 2640:            printf(" %d", n_URL);
    #####: 2641:            printf(" %d", n_encoding);
    #####: 2642:            printf(" %d", n_options);
    #####: 2643:            printf("\n");
        -: 2644:        }
        -: 2645:    }
        -: 2646:    }
        -: 2647:    }
        -: 2648:    }
        -: 2649:    }
    #####: 2650:    function_tests++;
        -: 2651:#endif
        -: 2652:
    #####: 2653:    return(test_ret);
        -: 2654:}
        -: 2655:
        -: 2656:
        -: 2657:static int
    #####: 2658:test_htmlSAXParseDoc(void) {
    #####: 2659:    int test_ret = 0;
        -: 2660:
        -: 2661:#if defined(LIBXML_HTML_ENABLED)
        -: 2662:    int mem_base;
        -: 2663:    htmlDocPtr ret_val;
        -: 2664:    xmlChar * cur; /* a pointer to an array of xmlChar */
        -: 2665:    int n_cur;
        -: 2666:    char * encoding; /* a free form C string describing the HTML document encoding, or NULL */
        -: 2667:    int n_encoding;
        -: 2668:    htmlSAXHandlerPtr sax; /* the SAX handler block */
        -: 2669:    int n_sax;
        -: 2670:    void * userData; /* if using SAX, this pointer will be provided on callbacks. */
        -: 2671:    int n_userData;
        -: 2672:
    #####: 2673:    for (n_cur = 0;n_cur < gen_nb_xmlChar_ptr;n_cur++) {
    #####: 2674:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####: 2675:    for (n_sax = 0;n_sax < gen_nb_htmlSAXHandlerPtr;n_sax++) {
    #####: 2676:    for (n_userData = 0;n_userData < gen_nb_userdata;n_userData++) {
    #####: 2677:        mem_base = xmlMemBlocks();
    #####: 2678:        cur = gen_xmlChar_ptr(n_cur, 0);
    #####: 2679:        encoding = gen_const_char_ptr(n_encoding, 1);
    #####: 2680:        sax = gen_htmlSAXHandlerPtr(n_sax, 2);
    #####: 2681:        userData = gen_userdata(n_userData, 3);
        -: 2682:
    #####: 2683:        ret_val = htmlSAXParseDoc(cur, (const char *)encoding, sax, userData);
    #####: 2684:        desret_htmlDocPtr(ret_val);
    #####: 2685:        call_tests++;
    #####: 2686:        des_xmlChar_ptr(n_cur, cur, 0);
    #####: 2687:        des_const_char_ptr(n_encoding, (const char *)encoding, 1);
    #####: 2688:        des_htmlSAXHandlerPtr(n_sax, sax, 2);
    #####: 2689:        des_userdata(n_userData, userData, 3);
    #####: 2690:        xmlResetLastError();
    #####: 2691:        if (mem_base != xmlMemBlocks()) {
    #####: 2692:            printf("Leak of %d blocks found in htmlSAXParseDoc",
    #####: 2693:	           xmlMemBlocks() - mem_base);
    #####: 2694:	    test_ret++;
    #####: 2695:            printf(" %d", n_cur);
    #####: 2696:            printf(" %d", n_encoding);
    #####: 2697:            printf(" %d", n_sax);
    #####: 2698:            printf(" %d", n_userData);
    #####: 2699:            printf("\n");
        -: 2700:        }
        -: 2701:    }
        -: 2702:    }
        -: 2703:    }
        -: 2704:    }
    #####: 2705:    function_tests++;
        -: 2706:#endif
        -: 2707:
    #####: 2708:    return(test_ret);
        -: 2709:}
        -: 2710:
        -: 2711:
        -: 2712:static int
    #####: 2713:test_htmlSAXParseFile(void) {
    #####: 2714:    int test_ret = 0;
        -: 2715:
        -: 2716:#if defined(LIBXML_HTML_ENABLED)
        -: 2717:    int mem_base;
        -: 2718:    htmlDocPtr ret_val;
        -: 2719:    const char * filename; /* the filename */
        -: 2720:    int n_filename;
        -: 2721:    char * encoding; /* a free form C string describing the HTML document encoding, or NULL */
        -: 2722:    int n_encoding;
        -: 2723:    htmlSAXHandlerPtr sax; /* the SAX handler block */
        -: 2724:    int n_sax;
        -: 2725:    void * userData; /* if using SAX, this pointer will be provided on callbacks. */
        -: 2726:    int n_userData;
        -: 2727:
    #####: 2728:    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    #####: 2729:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####: 2730:    for (n_sax = 0;n_sax < gen_nb_htmlSAXHandlerPtr;n_sax++) {
    #####: 2731:    for (n_userData = 0;n_userData < gen_nb_userdata;n_userData++) {
    #####: 2732:        mem_base = xmlMemBlocks();
    #####: 2733:        filename = gen_filepath(n_filename, 0);
    #####: 2734:        encoding = gen_const_char_ptr(n_encoding, 1);
    #####: 2735:        sax = gen_htmlSAXHandlerPtr(n_sax, 2);
    #####: 2736:        userData = gen_userdata(n_userData, 3);
        -: 2737:
    #####: 2738:        ret_val = htmlSAXParseFile(filename, (const char *)encoding, sax, userData);
    #####: 2739:        desret_htmlDocPtr(ret_val);
    #####: 2740:        call_tests++;
    #####: 2741:        des_filepath(n_filename, filename, 0);
    #####: 2742:        des_const_char_ptr(n_encoding, (const char *)encoding, 1);
    #####: 2743:        des_htmlSAXHandlerPtr(n_sax, sax, 2);
    #####: 2744:        des_userdata(n_userData, userData, 3);
    #####: 2745:        xmlResetLastError();
    #####: 2746:        if (mem_base != xmlMemBlocks()) {
    #####: 2747:            printf("Leak of %d blocks found in htmlSAXParseFile",
    #####: 2748:	           xmlMemBlocks() - mem_base);
    #####: 2749:	    test_ret++;
    #####: 2750:            printf(" %d", n_filename);
    #####: 2751:            printf(" %d", n_encoding);
    #####: 2752:            printf(" %d", n_sax);
    #####: 2753:            printf(" %d", n_userData);
    #####: 2754:            printf("\n");
        -: 2755:        }
        -: 2756:    }
        -: 2757:    }
        -: 2758:    }
        -: 2759:    }
    #####: 2760:    function_tests++;
        -: 2761:#endif
        -: 2762:
    #####: 2763:    return(test_ret);
        -: 2764:}
        -: 2765:
        -: 2766:
        -: 2767:static int
    #####: 2768:test_htmlTagLookup(void) {
    #####: 2769:    int test_ret = 0;
        -: 2770:
        -: 2771:
        -: 2772:    /* missing type support */
    #####: 2773:    return(test_ret);
        -: 2774:}
        -: 2775:
        -: 2776:static int
    #####: 2777:test_HTMLparser(void) {
    #####: 2778:    int test_ret = 0;
        -: 2779:
    #####: 2780:    if (quiet == 0) printf("Testing HTMLparser : 32 of 38 functions ...\n");
    #####: 2781:    test_ret += test_UTF8ToHtml();
    #####: 2782:    test_ret += test_htmlAttrAllowed();
    #####: 2783:    test_ret += test_htmlAutoCloseTag();
    #####: 2784:    test_ret += test_htmlCreateMemoryParserCtxt();
    #####: 2785:    test_ret += test_htmlCreatePushParserCtxt();
    #####: 2786:    test_ret += test_htmlCtxtReadDoc();
    #####: 2787:    test_ret += test_htmlCtxtReadFile();
    #####: 2788:    test_ret += test_htmlCtxtReadMemory();
    #####: 2789:    test_ret += test_htmlCtxtReset();
    #####: 2790:    test_ret += test_htmlCtxtUseOptions();
    #####: 2791:    test_ret += test_htmlElementAllowedHere();
    #####: 2792:    test_ret += test_htmlElementStatusHere();
    #####: 2793:    test_ret += test_htmlEncodeEntities();
    #####: 2794:    test_ret += test_htmlEntityLookup();
    #####: 2795:    test_ret += test_htmlEntityValueLookup();
    #####: 2796:    test_ret += test_htmlHandleOmittedElem();
    #####: 2797:    test_ret += test_htmlIsAutoClosed();
    #####: 2798:    test_ret += test_htmlIsScriptAttribute();
    #####: 2799:    test_ret += test_htmlNewParserCtxt();
    #####: 2800:    test_ret += test_htmlNodeStatus();
    #####: 2801:    test_ret += test_htmlParseCharRef();
    #####: 2802:    test_ret += test_htmlParseChunk();
    #####: 2803:    test_ret += test_htmlParseDoc();
    #####: 2804:    test_ret += test_htmlParseDocument();
    #####: 2805:    test_ret += test_htmlParseElement();
    #####: 2806:    test_ret += test_htmlParseEntityRef();
    #####: 2807:    test_ret += test_htmlParseFile();
    #####: 2808:    test_ret += test_htmlReadDoc();
    #####: 2809:    test_ret += test_htmlReadFile();
    #####: 2810:    test_ret += test_htmlReadMemory();
    #####: 2811:    test_ret += test_htmlSAXParseDoc();
    #####: 2812:    test_ret += test_htmlSAXParseFile();
    #####: 2813:    test_ret += test_htmlTagLookup();
        -: 2814:
    #####: 2815:    if (test_ret != 0)
    #####: 2816:	printf("Module HTMLparser: %d errors\n", test_ret);
    #####: 2817:    return(test_ret);
        -: 2818:}
        -: 2819:
        -: 2820:static int
    #####: 2821:test_htmlDocContentDumpFormatOutput(void) {
    #####: 2822:    int test_ret = 0;
        -: 2823:
        -: 2824:#if defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
        -: 2825:    int mem_base;
        -: 2826:    xmlOutputBufferPtr buf; /* the HTML buffer output */
        -: 2827:    int n_buf;
        -: 2828:    xmlDocPtr cur; /* the document */
        -: 2829:    int n_cur;
        -: 2830:    char * encoding; /* the encoding string */
        -: 2831:    int n_encoding;
        -: 2832:    int format; /* should formatting spaces been added */
        -: 2833:    int n_format;
        -: 2834:
    #####: 2835:    for (n_buf = 0;n_buf < gen_nb_xmlOutputBufferPtr;n_buf++) {
    #####: 2836:    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    #####: 2837:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####: 2838:    for (n_format = 0;n_format < gen_nb_int;n_format++) {
    #####: 2839:        mem_base = xmlMemBlocks();
    #####: 2840:        buf = gen_xmlOutputBufferPtr(n_buf, 0);
    #####: 2841:        cur = gen_xmlDocPtr(n_cur, 1);
    #####: 2842:        encoding = gen_const_char_ptr(n_encoding, 2);
    #####: 2843:        format = gen_int(n_format, 3);
        -: 2844:
    #####: 2845:        htmlDocContentDumpFormatOutput(buf, cur, (const char *)encoding, format);
    #####: 2846:        call_tests++;
    #####: 2847:        des_xmlOutputBufferPtr(n_buf, buf, 0);
    #####: 2848:        des_xmlDocPtr(n_cur, cur, 1);
    #####: 2849:        des_const_char_ptr(n_encoding, (const char *)encoding, 2);
    #####: 2850:        des_int(n_format, format, 3);
    #####: 2851:        xmlResetLastError();
    #####: 2852:        if (mem_base != xmlMemBlocks()) {
    #####: 2853:            printf("Leak of %d blocks found in htmlDocContentDumpFormatOutput",
    #####: 2854:	           xmlMemBlocks() - mem_base);
    #####: 2855:	    test_ret++;
    #####: 2856:            printf(" %d", n_buf);
    #####: 2857:            printf(" %d", n_cur);
    #####: 2858:            printf(" %d", n_encoding);
    #####: 2859:            printf(" %d", n_format);
    #####: 2860:            printf("\n");
        -: 2861:        }
        -: 2862:    }
        -: 2863:    }
        -: 2864:    }
        -: 2865:    }
    #####: 2866:    function_tests++;
        -: 2867:#endif
        -: 2868:
    #####: 2869:    return(test_ret);
        -: 2870:}
        -: 2871:
        -: 2872:
        -: 2873:static int
    #####: 2874:test_htmlDocContentDumpOutput(void) {
    #####: 2875:    int test_ret = 0;
        -: 2876:
        -: 2877:#if defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
        -: 2878:    int mem_base;
        -: 2879:    xmlOutputBufferPtr buf; /* the HTML buffer output */
        -: 2880:    int n_buf;
        -: 2881:    xmlDocPtr cur; /* the document */
        -: 2882:    int n_cur;
        -: 2883:    char * encoding; /* the encoding string */
        -: 2884:    int n_encoding;
        -: 2885:
    #####: 2886:    for (n_buf = 0;n_buf < gen_nb_xmlOutputBufferPtr;n_buf++) {
    #####: 2887:    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    #####: 2888:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####: 2889:        mem_base = xmlMemBlocks();
    #####: 2890:        buf = gen_xmlOutputBufferPtr(n_buf, 0);
    #####: 2891:        cur = gen_xmlDocPtr(n_cur, 1);
    #####: 2892:        encoding = gen_const_char_ptr(n_encoding, 2);
        -: 2893:
    #####: 2894:        htmlDocContentDumpOutput(buf, cur, (const char *)encoding);
    #####: 2895:        call_tests++;
    #####: 2896:        des_xmlOutputBufferPtr(n_buf, buf, 0);
    #####: 2897:        des_xmlDocPtr(n_cur, cur, 1);
    #####: 2898:        des_const_char_ptr(n_encoding, (const char *)encoding, 2);
    #####: 2899:        xmlResetLastError();
    #####: 2900:        if (mem_base != xmlMemBlocks()) {
    #####: 2901:            printf("Leak of %d blocks found in htmlDocContentDumpOutput",
    #####: 2902:	           xmlMemBlocks() - mem_base);
    #####: 2903:	    test_ret++;
    #####: 2904:            printf(" %d", n_buf);
    #####: 2905:            printf(" %d", n_cur);
    #####: 2906:            printf(" %d", n_encoding);
    #####: 2907:            printf("\n");
        -: 2908:        }
        -: 2909:    }
        -: 2910:    }
        -: 2911:    }
    #####: 2912:    function_tests++;
        -: 2913:#endif
        -: 2914:
    #####: 2915:    return(test_ret);
        -: 2916:}
        -: 2917:
        -: 2918:
        -: 2919:static int
    #####: 2920:test_htmlDocDump(void) {
    #####: 2921:    int test_ret = 0;
        -: 2922:
        -: 2923:#if defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
        -: 2924:    int mem_base;
        -: 2925:    int ret_val;
        -: 2926:    FILE * f; /* the FILE* */
        -: 2927:    int n_f;
        -: 2928:    xmlDocPtr cur; /* the document */
        -: 2929:    int n_cur;
        -: 2930:
    #####: 2931:    for (n_f = 0;n_f < gen_nb_FILE_ptr;n_f++) {
    #####: 2932:    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    #####: 2933:        mem_base = xmlMemBlocks();
    #####: 2934:        f = gen_FILE_ptr(n_f, 0);
    #####: 2935:        cur = gen_xmlDocPtr(n_cur, 1);
        -: 2936:
    #####: 2937:        ret_val = htmlDocDump(f, cur);
    #####: 2938:        desret_int(ret_val);
    #####: 2939:        call_tests++;
    #####: 2940:        des_FILE_ptr(n_f, f, 0);
    #####: 2941:        des_xmlDocPtr(n_cur, cur, 1);
    #####: 2942:        xmlResetLastError();
    #####: 2943:        if (mem_base != xmlMemBlocks()) {
    #####: 2944:            printf("Leak of %d blocks found in htmlDocDump",
    #####: 2945:	           xmlMemBlocks() - mem_base);
    #####: 2946:	    test_ret++;
    #####: 2947:            printf(" %d", n_f);
    #####: 2948:            printf(" %d", n_cur);
    #####: 2949:            printf("\n");
        -: 2950:        }
        -: 2951:    }
        -: 2952:    }
    #####: 2953:    function_tests++;
        -: 2954:#endif
        -: 2955:
    #####: 2956:    return(test_ret);
        -: 2957:}
        -: 2958:
        -: 2959:
        -: 2960:#define gen_nb_xmlChar_ptr_ptr 1
    #####: 2961:static xmlChar ** gen_xmlChar_ptr_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 2962:    return(NULL);
        -: 2963:}
    #####: 2964:static void des_xmlChar_ptr_ptr(int no ATTRIBUTE_UNUSED, xmlChar ** val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 2965:}
        -: 2966:
        -: 2967:static int
    #####: 2968:test_htmlDocDumpMemory(void) {
    #####: 2969:    int test_ret = 0;
        -: 2970:
        -: 2971:#if defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
        -: 2972:    int mem_base;
        -: 2973:    xmlDocPtr cur; /* the document */
        -: 2974:    int n_cur;
        -: 2975:    xmlChar ** mem; /* OUT: the memory pointer */
        -: 2976:    int n_mem;
        -: 2977:    int * size; /* OUT: the memory length */
        -: 2978:    int n_size;
        -: 2979:
    #####: 2980:    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    #####: 2981:    for (n_mem = 0;n_mem < gen_nb_xmlChar_ptr_ptr;n_mem++) {
    #####: 2982:    for (n_size = 0;n_size < gen_nb_int_ptr;n_size++) {
    #####: 2983:        mem_base = xmlMemBlocks();
    #####: 2984:        cur = gen_xmlDocPtr(n_cur, 0);
    #####: 2985:        mem = gen_xmlChar_ptr_ptr(n_mem, 1);
    #####: 2986:        size = gen_int_ptr(n_size, 2);
        -: 2987:
    #####: 2988:        htmlDocDumpMemory(cur, mem, size);
    #####: 2989:        call_tests++;
    #####: 2990:        des_xmlDocPtr(n_cur, cur, 0);
    #####: 2991:        des_xmlChar_ptr_ptr(n_mem, mem, 1);
    #####: 2992:        des_int_ptr(n_size, size, 2);
    #####: 2993:        xmlResetLastError();
    #####: 2994:        if (mem_base != xmlMemBlocks()) {
    #####: 2995:            printf("Leak of %d blocks found in htmlDocDumpMemory",
    #####: 2996:	           xmlMemBlocks() - mem_base);
    #####: 2997:	    test_ret++;
    #####: 2998:            printf(" %d", n_cur);
    #####: 2999:            printf(" %d", n_mem);
    #####: 3000:            printf(" %d", n_size);
    #####: 3001:            printf("\n");
        -: 3002:        }
        -: 3003:    }
        -: 3004:    }
        -: 3005:    }
    #####: 3006:    function_tests++;
        -: 3007:#endif
        -: 3008:
    #####: 3009:    return(test_ret);
        -: 3010:}
        -: 3011:
        -: 3012:
        -: 3013:static int
    #####: 3014:test_htmlDocDumpMemoryFormat(void) {
    #####: 3015:    int test_ret = 0;
        -: 3016:
        -: 3017:#if defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
        -: 3018:    int mem_base;
        -: 3019:    xmlDocPtr cur; /* the document */
        -: 3020:    int n_cur;
        -: 3021:    xmlChar ** mem; /* OUT: the memory pointer */
        -: 3022:    int n_mem;
        -: 3023:    int * size; /* OUT: the memory length */
        -: 3024:    int n_size;
        -: 3025:    int format; /* should formatting spaces been added */
        -: 3026:    int n_format;
        -: 3027:
    #####: 3028:    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    #####: 3029:    for (n_mem = 0;n_mem < gen_nb_xmlChar_ptr_ptr;n_mem++) {
    #####: 3030:    for (n_size = 0;n_size < gen_nb_int_ptr;n_size++) {
    #####: 3031:    for (n_format = 0;n_format < gen_nb_int;n_format++) {
    #####: 3032:        mem_base = xmlMemBlocks();
    #####: 3033:        cur = gen_xmlDocPtr(n_cur, 0);
    #####: 3034:        mem = gen_xmlChar_ptr_ptr(n_mem, 1);
    #####: 3035:        size = gen_int_ptr(n_size, 2);
    #####: 3036:        format = gen_int(n_format, 3);
        -: 3037:
    #####: 3038:        htmlDocDumpMemoryFormat(cur, mem, size, format);
    #####: 3039:        call_tests++;
    #####: 3040:        des_xmlDocPtr(n_cur, cur, 0);
    #####: 3041:        des_xmlChar_ptr_ptr(n_mem, mem, 1);
    #####: 3042:        des_int_ptr(n_size, size, 2);
    #####: 3043:        des_int(n_format, format, 3);
    #####: 3044:        xmlResetLastError();
    #####: 3045:        if (mem_base != xmlMemBlocks()) {
    #####: 3046:            printf("Leak of %d blocks found in htmlDocDumpMemoryFormat",
    #####: 3047:	           xmlMemBlocks() - mem_base);
    #####: 3048:	    test_ret++;
    #####: 3049:            printf(" %d", n_cur);
    #####: 3050:            printf(" %d", n_mem);
    #####: 3051:            printf(" %d", n_size);
    #####: 3052:            printf(" %d", n_format);
    #####: 3053:            printf("\n");
        -: 3054:        }
        -: 3055:    }
        -: 3056:    }
        -: 3057:    }
        -: 3058:    }
    #####: 3059:    function_tests++;
        -: 3060:#endif
        -: 3061:
    #####: 3062:    return(test_ret);
        -: 3063:}
        -: 3064:
        -: 3065:
        -: 3066:static int
    #####: 3067:test_htmlGetMetaEncoding(void) {
    #####: 3068:    int test_ret = 0;
        -: 3069:
        -: 3070:#if defined(LIBXML_HTML_ENABLED)
        -: 3071:    int mem_base;
        -: 3072:    const xmlChar * ret_val;
        -: 3073:    htmlDocPtr doc; /* the document */
        -: 3074:    int n_doc;
        -: 3075:
    #####: 3076:    for (n_doc = 0;n_doc < gen_nb_htmlDocPtr;n_doc++) {
    #####: 3077:        mem_base = xmlMemBlocks();
    #####: 3078:        doc = gen_htmlDocPtr(n_doc, 0);
        -: 3079:
    #####: 3080:        ret_val = htmlGetMetaEncoding(doc);
    #####: 3081:        desret_const_xmlChar_ptr(ret_val);
    #####: 3082:        call_tests++;
    #####: 3083:        des_htmlDocPtr(n_doc, doc, 0);
    #####: 3084:        xmlResetLastError();
    #####: 3085:        if (mem_base != xmlMemBlocks()) {
    #####: 3086:            printf("Leak of %d blocks found in htmlGetMetaEncoding",
    #####: 3087:	           xmlMemBlocks() - mem_base);
    #####: 3088:	    test_ret++;
    #####: 3089:            printf(" %d", n_doc);
    #####: 3090:            printf("\n");
        -: 3091:        }
        -: 3092:    }
    #####: 3093:    function_tests++;
        -: 3094:#endif
        -: 3095:
    #####: 3096:    return(test_ret);
        -: 3097:}
        -: 3098:
        -: 3099:
        -: 3100:static int
    #####: 3101:test_htmlIsBooleanAttr(void) {
    #####: 3102:    int test_ret = 0;
        -: 3103:
        -: 3104:#if defined(LIBXML_HTML_ENABLED)
        -: 3105:    int mem_base;
        -: 3106:    int ret_val;
        -: 3107:    xmlChar * name; /* the name of the attribute to check */
        -: 3108:    int n_name;
        -: 3109:
    #####: 3110:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####: 3111:        mem_base = xmlMemBlocks();
    #####: 3112:        name = gen_const_xmlChar_ptr(n_name, 0);
        -: 3113:
    #####: 3114:        ret_val = htmlIsBooleanAttr((const xmlChar *)name);
    #####: 3115:        desret_int(ret_val);
    #####: 3116:        call_tests++;
    #####: 3117:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 0);
    #####: 3118:        xmlResetLastError();
    #####: 3119:        if (mem_base != xmlMemBlocks()) {
    #####: 3120:            printf("Leak of %d blocks found in htmlIsBooleanAttr",
    #####: 3121:	           xmlMemBlocks() - mem_base);
    #####: 3122:	    test_ret++;
    #####: 3123:            printf(" %d", n_name);
    #####: 3124:            printf("\n");
        -: 3125:        }
        -: 3126:    }
    #####: 3127:    function_tests++;
        -: 3128:#endif
        -: 3129:
    #####: 3130:    return(test_ret);
        -: 3131:}
        -: 3132:
        -: 3133:
        -: 3134:static int
    #####: 3135:test_htmlNewDoc(void) {
    #####: 3136:    int test_ret = 0;
        -: 3137:
        -: 3138:#if defined(LIBXML_HTML_ENABLED)
        -: 3139:    int mem_base;
        -: 3140:    htmlDocPtr ret_val;
        -: 3141:    xmlChar * URI; /* URI for the dtd, or NULL */
        -: 3142:    int n_URI;
        -: 3143:    xmlChar * ExternalID; /* the external ID of the DTD, or NULL */
        -: 3144:    int n_ExternalID;
        -: 3145:
    #####: 3146:    for (n_URI = 0;n_URI < gen_nb_const_xmlChar_ptr;n_URI++) {
    #####: 3147:    for (n_ExternalID = 0;n_ExternalID < gen_nb_const_xmlChar_ptr;n_ExternalID++) {
    #####: 3148:        mem_base = xmlMemBlocks();
    #####: 3149:        URI = gen_const_xmlChar_ptr(n_URI, 0);
    #####: 3150:        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 1);
        -: 3151:
    #####: 3152:        ret_val = htmlNewDoc((const xmlChar *)URI, (const xmlChar *)ExternalID);
    #####: 3153:        desret_htmlDocPtr(ret_val);
    #####: 3154:        call_tests++;
    #####: 3155:        des_const_xmlChar_ptr(n_URI, (const xmlChar *)URI, 0);
    #####: 3156:        des_const_xmlChar_ptr(n_ExternalID, (const xmlChar *)ExternalID, 1);
    #####: 3157:        xmlResetLastError();
    #####: 3158:        if (mem_base != xmlMemBlocks()) {
    #####: 3159:            printf("Leak of %d blocks found in htmlNewDoc",
    #####: 3160:	           xmlMemBlocks() - mem_base);
    #####: 3161:	    test_ret++;
    #####: 3162:            printf(" %d", n_URI);
    #####: 3163:            printf(" %d", n_ExternalID);
    #####: 3164:            printf("\n");
        -: 3165:        }
        -: 3166:    }
        -: 3167:    }
    #####: 3168:    function_tests++;
        -: 3169:#endif
        -: 3170:
    #####: 3171:    return(test_ret);
        -: 3172:}
        -: 3173:
        -: 3174:
        -: 3175:static int
    #####: 3176:test_htmlNewDocNoDtD(void) {
    #####: 3177:    int test_ret = 0;
        -: 3178:
        -: 3179:#if defined(LIBXML_HTML_ENABLED)
        -: 3180:    int mem_base;
        -: 3181:    htmlDocPtr ret_val;
        -: 3182:    xmlChar * URI; /* URI for the dtd, or NULL */
        -: 3183:    int n_URI;
        -: 3184:    xmlChar * ExternalID; /* the external ID of the DTD, or NULL */
        -: 3185:    int n_ExternalID;
        -: 3186:
    #####: 3187:    for (n_URI = 0;n_URI < gen_nb_const_xmlChar_ptr;n_URI++) {
    #####: 3188:    for (n_ExternalID = 0;n_ExternalID < gen_nb_const_xmlChar_ptr;n_ExternalID++) {
    #####: 3189:        mem_base = xmlMemBlocks();
    #####: 3190:        URI = gen_const_xmlChar_ptr(n_URI, 0);
    #####: 3191:        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 1);
        -: 3192:
    #####: 3193:        ret_val = htmlNewDocNoDtD((const xmlChar *)URI, (const xmlChar *)ExternalID);
    #####: 3194:        desret_htmlDocPtr(ret_val);
    #####: 3195:        call_tests++;
    #####: 3196:        des_const_xmlChar_ptr(n_URI, (const xmlChar *)URI, 0);
    #####: 3197:        des_const_xmlChar_ptr(n_ExternalID, (const xmlChar *)ExternalID, 1);
    #####: 3198:        xmlResetLastError();
    #####: 3199:        if (mem_base != xmlMemBlocks()) {
    #####: 3200:            printf("Leak of %d blocks found in htmlNewDocNoDtD",
    #####: 3201:	           xmlMemBlocks() - mem_base);
    #####: 3202:	    test_ret++;
    #####: 3203:            printf(" %d", n_URI);
    #####: 3204:            printf(" %d", n_ExternalID);
    #####: 3205:            printf("\n");
        -: 3206:        }
        -: 3207:    }
        -: 3208:    }
    #####: 3209:    function_tests++;
        -: 3210:#endif
        -: 3211:
    #####: 3212:    return(test_ret);
        -: 3213:}
        -: 3214:
        -: 3215:
        -: 3216:static int
    #####: 3217:test_htmlNodeDump(void) {
    #####: 3218:    int test_ret = 0;
        -: 3219:
        -: 3220:#if defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
        -: 3221:    int mem_base;
        -: 3222:    int ret_val;
        -: 3223:    xmlBufferPtr buf; /* the HTML buffer output */
        -: 3224:    int n_buf;
        -: 3225:    xmlDocPtr doc; /* the document */
        -: 3226:    int n_doc;
        -: 3227:    xmlNodePtr cur; /* the current node */
        -: 3228:    int n_cur;
        -: 3229:
    #####: 3230:    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    #####: 3231:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####: 3232:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####: 3233:        mem_base = xmlMemBlocks();
    #####: 3234:        buf = gen_xmlBufferPtr(n_buf, 0);
    #####: 3235:        doc = gen_xmlDocPtr(n_doc, 1);
    #####: 3236:        cur = gen_xmlNodePtr(n_cur, 2);
        -: 3237:
    #####: 3238:        ret_val = htmlNodeDump(buf, doc, cur);
    #####: 3239:        desret_int(ret_val);
    #####: 3240:        call_tests++;
    #####: 3241:        des_xmlBufferPtr(n_buf, buf, 0);
    #####: 3242:        des_xmlDocPtr(n_doc, doc, 1);
    #####: 3243:        des_xmlNodePtr(n_cur, cur, 2);
    #####: 3244:        xmlResetLastError();
    #####: 3245:        if (mem_base != xmlMemBlocks()) {
    #####: 3246:            printf("Leak of %d blocks found in htmlNodeDump",
    #####: 3247:	           xmlMemBlocks() - mem_base);
    #####: 3248:	    test_ret++;
    #####: 3249:            printf(" %d", n_buf);
    #####: 3250:            printf(" %d", n_doc);
    #####: 3251:            printf(" %d", n_cur);
    #####: 3252:            printf("\n");
        -: 3253:        }
        -: 3254:    }
        -: 3255:    }
        -: 3256:    }
    #####: 3257:    function_tests++;
        -: 3258:#endif
        -: 3259:
    #####: 3260:    return(test_ret);
        -: 3261:}
        -: 3262:
        -: 3263:
        -: 3264:static int
    #####: 3265:test_htmlNodeDumpFile(void) {
    #####: 3266:    int test_ret = 0;
        -: 3267:
        -: 3268:#if defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
        -: 3269:    int mem_base;
        -: 3270:    FILE * out; /* the FILE pointer */
        -: 3271:    int n_out;
        -: 3272:    xmlDocPtr doc; /* the document */
        -: 3273:    int n_doc;
        -: 3274:    xmlNodePtr cur; /* the current node */
        -: 3275:    int n_cur;
        -: 3276:
    #####: 3277:    for (n_out = 0;n_out < gen_nb_FILE_ptr;n_out++) {
    #####: 3278:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####: 3279:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####: 3280:        mem_base = xmlMemBlocks();
    #####: 3281:        out = gen_FILE_ptr(n_out, 0);
    #####: 3282:        doc = gen_xmlDocPtr(n_doc, 1);
    #####: 3283:        cur = gen_xmlNodePtr(n_cur, 2);
        -: 3284:
    #####: 3285:        htmlNodeDumpFile(out, doc, cur);
    #####: 3286:        call_tests++;
    #####: 3287:        des_FILE_ptr(n_out, out, 0);
    #####: 3288:        des_xmlDocPtr(n_doc, doc, 1);
    #####: 3289:        des_xmlNodePtr(n_cur, cur, 2);
    #####: 3290:        xmlResetLastError();
    #####: 3291:        if (mem_base != xmlMemBlocks()) {
    #####: 3292:            printf("Leak of %d blocks found in htmlNodeDumpFile",
    #####: 3293:	           xmlMemBlocks() - mem_base);
    #####: 3294:	    test_ret++;
    #####: 3295:            printf(" %d", n_out);
    #####: 3296:            printf(" %d", n_doc);
    #####: 3297:            printf(" %d", n_cur);
    #####: 3298:            printf("\n");
        -: 3299:        }
        -: 3300:    }
        -: 3301:    }
        -: 3302:    }
    #####: 3303:    function_tests++;
        -: 3304:#endif
        -: 3305:
    #####: 3306:    return(test_ret);
        -: 3307:}
        -: 3308:
        -: 3309:
        -: 3310:static int
    #####: 3311:test_htmlNodeDumpFileFormat(void) {
    #####: 3312:    int test_ret = 0;
        -: 3313:
        -: 3314:#if defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
        -: 3315:    int mem_base;
        -: 3316:    int ret_val;
        -: 3317:    FILE * out; /* the FILE pointer */
        -: 3318:    int n_out;
        -: 3319:    xmlDocPtr doc; /* the document */
        -: 3320:    int n_doc;
        -: 3321:    xmlNodePtr cur; /* the current node */
        -: 3322:    int n_cur;
        -: 3323:    char * encoding; /* the document encoding */
        -: 3324:    int n_encoding;
        -: 3325:    int format; /* should formatting spaces been added */
        -: 3326:    int n_format;
        -: 3327:
    #####: 3328:    for (n_out = 0;n_out < gen_nb_FILE_ptr;n_out++) {
    #####: 3329:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####: 3330:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####: 3331:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####: 3332:    for (n_format = 0;n_format < gen_nb_int;n_format++) {
    #####: 3333:        mem_base = xmlMemBlocks();
    #####: 3334:        out = gen_FILE_ptr(n_out, 0);
    #####: 3335:        doc = gen_xmlDocPtr(n_doc, 1);
    #####: 3336:        cur = gen_xmlNodePtr(n_cur, 2);
    #####: 3337:        encoding = gen_const_char_ptr(n_encoding, 3);
    #####: 3338:        format = gen_int(n_format, 4);
        -: 3339:
    #####: 3340:        ret_val = htmlNodeDumpFileFormat(out, doc, cur, (const char *)encoding, format);
    #####: 3341:        desret_int(ret_val);
    #####: 3342:        call_tests++;
    #####: 3343:        des_FILE_ptr(n_out, out, 0);
    #####: 3344:        des_xmlDocPtr(n_doc, doc, 1);
    #####: 3345:        des_xmlNodePtr(n_cur, cur, 2);
    #####: 3346:        des_const_char_ptr(n_encoding, (const char *)encoding, 3);
    #####: 3347:        des_int(n_format, format, 4);
    #####: 3348:        xmlResetLastError();
    #####: 3349:        if (mem_base != xmlMemBlocks()) {
    #####: 3350:            printf("Leak of %d blocks found in htmlNodeDumpFileFormat",
    #####: 3351:	           xmlMemBlocks() - mem_base);
    #####: 3352:	    test_ret++;
    #####: 3353:            printf(" %d", n_out);
    #####: 3354:            printf(" %d", n_doc);
    #####: 3355:            printf(" %d", n_cur);
    #####: 3356:            printf(" %d", n_encoding);
    #####: 3357:            printf(" %d", n_format);
    #####: 3358:            printf("\n");
        -: 3359:        }
        -: 3360:    }
        -: 3361:    }
        -: 3362:    }
        -: 3363:    }
        -: 3364:    }
    #####: 3365:    function_tests++;
        -: 3366:#endif
        -: 3367:
    #####: 3368:    return(test_ret);
        -: 3369:}
        -: 3370:
        -: 3371:
        -: 3372:static int
    #####: 3373:test_htmlNodeDumpFormatOutput(void) {
    #####: 3374:    int test_ret = 0;
        -: 3375:
        -: 3376:#if defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
        -: 3377:    int mem_base;
        -: 3378:    xmlOutputBufferPtr buf; /* the HTML buffer output */
        -: 3379:    int n_buf;
        -: 3380:    xmlDocPtr doc; /* the document */
        -: 3381:    int n_doc;
        -: 3382:    xmlNodePtr cur; /* the current node */
        -: 3383:    int n_cur;
        -: 3384:    char * encoding; /* the encoding string */
        -: 3385:    int n_encoding;
        -: 3386:    int format; /* should formatting spaces been added */
        -: 3387:    int n_format;
        -: 3388:
    #####: 3389:    for (n_buf = 0;n_buf < gen_nb_xmlOutputBufferPtr;n_buf++) {
    #####: 3390:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####: 3391:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####: 3392:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####: 3393:    for (n_format = 0;n_format < gen_nb_int;n_format++) {
    #####: 3394:        mem_base = xmlMemBlocks();
    #####: 3395:        buf = gen_xmlOutputBufferPtr(n_buf, 0);
    #####: 3396:        doc = gen_xmlDocPtr(n_doc, 1);
    #####: 3397:        cur = gen_xmlNodePtr(n_cur, 2);
    #####: 3398:        encoding = gen_const_char_ptr(n_encoding, 3);
    #####: 3399:        format = gen_int(n_format, 4);
        -: 3400:
    #####: 3401:        htmlNodeDumpFormatOutput(buf, doc, cur, (const char *)encoding, format);
    #####: 3402:        call_tests++;
    #####: 3403:        des_xmlOutputBufferPtr(n_buf, buf, 0);
    #####: 3404:        des_xmlDocPtr(n_doc, doc, 1);
    #####: 3405:        des_xmlNodePtr(n_cur, cur, 2);
    #####: 3406:        des_const_char_ptr(n_encoding, (const char *)encoding, 3);
    #####: 3407:        des_int(n_format, format, 4);
    #####: 3408:        xmlResetLastError();
    #####: 3409:        if (mem_base != xmlMemBlocks()) {
    #####: 3410:            printf("Leak of %d blocks found in htmlNodeDumpFormatOutput",
    #####: 3411:	           xmlMemBlocks() - mem_base);
    #####: 3412:	    test_ret++;
    #####: 3413:            printf(" %d", n_buf);
    #####: 3414:            printf(" %d", n_doc);
    #####: 3415:            printf(" %d", n_cur);
    #####: 3416:            printf(" %d", n_encoding);
    #####: 3417:            printf(" %d", n_format);
    #####: 3418:            printf("\n");
        -: 3419:        }
        -: 3420:    }
        -: 3421:    }
        -: 3422:    }
        -: 3423:    }
        -: 3424:    }
    #####: 3425:    function_tests++;
        -: 3426:#endif
        -: 3427:
    #####: 3428:    return(test_ret);
        -: 3429:}
        -: 3430:
        -: 3431:
        -: 3432:static int
    #####: 3433:test_htmlNodeDumpOutput(void) {
    #####: 3434:    int test_ret = 0;
        -: 3435:
        -: 3436:#if defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
        -: 3437:    int mem_base;
        -: 3438:    xmlOutputBufferPtr buf; /* the HTML buffer output */
        -: 3439:    int n_buf;
        -: 3440:    xmlDocPtr doc; /* the document */
        -: 3441:    int n_doc;
        -: 3442:    xmlNodePtr cur; /* the current node */
        -: 3443:    int n_cur;
        -: 3444:    char * encoding; /* the encoding string */
        -: 3445:    int n_encoding;
        -: 3446:
    #####: 3447:    for (n_buf = 0;n_buf < gen_nb_xmlOutputBufferPtr;n_buf++) {
    #####: 3448:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####: 3449:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####: 3450:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####: 3451:        mem_base = xmlMemBlocks();
    #####: 3452:        buf = gen_xmlOutputBufferPtr(n_buf, 0);
    #####: 3453:        doc = gen_xmlDocPtr(n_doc, 1);
    #####: 3454:        cur = gen_xmlNodePtr(n_cur, 2);
    #####: 3455:        encoding = gen_const_char_ptr(n_encoding, 3);
        -: 3456:
    #####: 3457:        htmlNodeDumpOutput(buf, doc, cur, (const char *)encoding);
    #####: 3458:        call_tests++;
    #####: 3459:        des_xmlOutputBufferPtr(n_buf, buf, 0);
    #####: 3460:        des_xmlDocPtr(n_doc, doc, 1);
    #####: 3461:        des_xmlNodePtr(n_cur, cur, 2);
    #####: 3462:        des_const_char_ptr(n_encoding, (const char *)encoding, 3);
    #####: 3463:        xmlResetLastError();
    #####: 3464:        if (mem_base != xmlMemBlocks()) {
    #####: 3465:            printf("Leak of %d blocks found in htmlNodeDumpOutput",
    #####: 3466:	           xmlMemBlocks() - mem_base);
    #####: 3467:	    test_ret++;
    #####: 3468:            printf(" %d", n_buf);
    #####: 3469:            printf(" %d", n_doc);
    #####: 3470:            printf(" %d", n_cur);
    #####: 3471:            printf(" %d", n_encoding);
    #####: 3472:            printf("\n");
        -: 3473:        }
        -: 3474:    }
        -: 3475:    }
        -: 3476:    }
        -: 3477:    }
    #####: 3478:    function_tests++;
        -: 3479:#endif
        -: 3480:
    #####: 3481:    return(test_ret);
        -: 3482:}
        -: 3483:
        -: 3484:
        -: 3485:static int
    #####: 3486:test_htmlSaveFile(void) {
    #####: 3487:    int test_ret = 0;
        -: 3488:
        -: 3489:#if defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
        -: 3490:    int mem_base;
        -: 3491:    int ret_val;
        -: 3492:    const char * filename; /* the filename (or URL) */
        -: 3493:    int n_filename;
        -: 3494:    xmlDocPtr cur; /* the document */
        -: 3495:    int n_cur;
        -: 3496:
    #####: 3497:    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    #####: 3498:    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    #####: 3499:        mem_base = xmlMemBlocks();
    #####: 3500:        filename = gen_fileoutput(n_filename, 0);
    #####: 3501:        cur = gen_xmlDocPtr(n_cur, 1);
        -: 3502:
    #####: 3503:        ret_val = htmlSaveFile(filename, cur);
    #####: 3504:        desret_int(ret_val);
    #####: 3505:        call_tests++;
    #####: 3506:        des_fileoutput(n_filename, filename, 0);
    #####: 3507:        des_xmlDocPtr(n_cur, cur, 1);
    #####: 3508:        xmlResetLastError();
    #####: 3509:        if (mem_base != xmlMemBlocks()) {
    #####: 3510:            printf("Leak of %d blocks found in htmlSaveFile",
    #####: 3511:	           xmlMemBlocks() - mem_base);
    #####: 3512:	    test_ret++;
    #####: 3513:            printf(" %d", n_filename);
    #####: 3514:            printf(" %d", n_cur);
    #####: 3515:            printf("\n");
        -: 3516:        }
        -: 3517:    }
        -: 3518:    }
    #####: 3519:    function_tests++;
        -: 3520:#endif
        -: 3521:
    #####: 3522:    return(test_ret);
        -: 3523:}
        -: 3524:
        -: 3525:
        -: 3526:static int
    #####: 3527:test_htmlSaveFileEnc(void) {
    #####: 3528:    int test_ret = 0;
        -: 3529:
        -: 3530:#if defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
        -: 3531:    int mem_base;
        -: 3532:    int ret_val;
        -: 3533:    const char * filename; /* the filename */
        -: 3534:    int n_filename;
        -: 3535:    xmlDocPtr cur; /* the document */
        -: 3536:    int n_cur;
        -: 3537:    char * encoding; /* the document encoding */
        -: 3538:    int n_encoding;
        -: 3539:
    #####: 3540:    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    #####: 3541:    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    #####: 3542:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####: 3543:        mem_base = xmlMemBlocks();
    #####: 3544:        filename = gen_fileoutput(n_filename, 0);
    #####: 3545:        cur = gen_xmlDocPtr(n_cur, 1);
    #####: 3546:        encoding = gen_const_char_ptr(n_encoding, 2);
        -: 3547:
    #####: 3548:        ret_val = htmlSaveFileEnc(filename, cur, (const char *)encoding);
    #####: 3549:        desret_int(ret_val);
    #####: 3550:        call_tests++;
    #####: 3551:        des_fileoutput(n_filename, filename, 0);
    #####: 3552:        des_xmlDocPtr(n_cur, cur, 1);
    #####: 3553:        des_const_char_ptr(n_encoding, (const char *)encoding, 2);
    #####: 3554:        xmlResetLastError();
    #####: 3555:        if (mem_base != xmlMemBlocks()) {
    #####: 3556:            printf("Leak of %d blocks found in htmlSaveFileEnc",
    #####: 3557:	           xmlMemBlocks() - mem_base);
    #####: 3558:	    test_ret++;
    #####: 3559:            printf(" %d", n_filename);
    #####: 3560:            printf(" %d", n_cur);
    #####: 3561:            printf(" %d", n_encoding);
    #####: 3562:            printf("\n");
        -: 3563:        }
        -: 3564:    }
        -: 3565:    }
        -: 3566:    }
    #####: 3567:    function_tests++;
        -: 3568:#endif
        -: 3569:
    #####: 3570:    return(test_ret);
        -: 3571:}
        -: 3572:
        -: 3573:
        -: 3574:static int
    #####: 3575:test_htmlSaveFileFormat(void) {
    #####: 3576:    int test_ret = 0;
        -: 3577:
        -: 3578:#if defined(LIBXML_HTML_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
        -: 3579:    int mem_base;
        -: 3580:    int ret_val;
        -: 3581:    const char * filename; /* the filename */
        -: 3582:    int n_filename;
        -: 3583:    xmlDocPtr cur; /* the document */
        -: 3584:    int n_cur;
        -: 3585:    char * encoding; /* the document encoding */
        -: 3586:    int n_encoding;
        -: 3587:    int format; /* should formatting spaces been added */
        -: 3588:    int n_format;
        -: 3589:
    #####: 3590:    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    #####: 3591:    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    #####: 3592:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####: 3593:    for (n_format = 0;n_format < gen_nb_int;n_format++) {
    #####: 3594:        mem_base = xmlMemBlocks();
    #####: 3595:        filename = gen_fileoutput(n_filename, 0);
    #####: 3596:        cur = gen_xmlDocPtr(n_cur, 1);
    #####: 3597:        encoding = gen_const_char_ptr(n_encoding, 2);
    #####: 3598:        format = gen_int(n_format, 3);
        -: 3599:
    #####: 3600:        ret_val = htmlSaveFileFormat(filename, cur, (const char *)encoding, format);
    #####: 3601:        desret_int(ret_val);
    #####: 3602:        call_tests++;
    #####: 3603:        des_fileoutput(n_filename, filename, 0);
    #####: 3604:        des_xmlDocPtr(n_cur, cur, 1);
    #####: 3605:        des_const_char_ptr(n_encoding, (const char *)encoding, 2);
    #####: 3606:        des_int(n_format, format, 3);
    #####: 3607:        xmlResetLastError();
    #####: 3608:        if (mem_base != xmlMemBlocks()) {
    #####: 3609:            printf("Leak of %d blocks found in htmlSaveFileFormat",
    #####: 3610:	           xmlMemBlocks() - mem_base);
    #####: 3611:	    test_ret++;
    #####: 3612:            printf(" %d", n_filename);
    #####: 3613:            printf(" %d", n_cur);
    #####: 3614:            printf(" %d", n_encoding);
    #####: 3615:            printf(" %d", n_format);
    #####: 3616:            printf("\n");
        -: 3617:        }
        -: 3618:    }
        -: 3619:    }
        -: 3620:    }
        -: 3621:    }
    #####: 3622:    function_tests++;
        -: 3623:#endif
        -: 3624:
    #####: 3625:    return(test_ret);
        -: 3626:}
        -: 3627:
        -: 3628:
        -: 3629:static int
    #####: 3630:test_htmlSetMetaEncoding(void) {
    #####: 3631:    int test_ret = 0;
        -: 3632:
        -: 3633:#if defined(LIBXML_HTML_ENABLED)
        -: 3634:    int mem_base;
        -: 3635:    int ret_val;
        -: 3636:    htmlDocPtr doc; /* the document */
        -: 3637:    int n_doc;
        -: 3638:    xmlChar * encoding; /* the encoding string */
        -: 3639:    int n_encoding;
        -: 3640:
    #####: 3641:    for (n_doc = 0;n_doc < gen_nb_htmlDocPtr;n_doc++) {
    #####: 3642:    for (n_encoding = 0;n_encoding < gen_nb_const_xmlChar_ptr;n_encoding++) {
    #####: 3643:        mem_base = xmlMemBlocks();
    #####: 3644:        doc = gen_htmlDocPtr(n_doc, 0);
    #####: 3645:        encoding = gen_const_xmlChar_ptr(n_encoding, 1);
        -: 3646:
    #####: 3647:        ret_val = htmlSetMetaEncoding(doc, (const xmlChar *)encoding);
    #####: 3648:        desret_int(ret_val);
    #####: 3649:        call_tests++;
    #####: 3650:        des_htmlDocPtr(n_doc, doc, 0);
    #####: 3651:        des_const_xmlChar_ptr(n_encoding, (const xmlChar *)encoding, 1);
    #####: 3652:        xmlResetLastError();
    #####: 3653:        if (mem_base != xmlMemBlocks()) {
    #####: 3654:            printf("Leak of %d blocks found in htmlSetMetaEncoding",
    #####: 3655:	           xmlMemBlocks() - mem_base);
    #####: 3656:	    test_ret++;
    #####: 3657:            printf(" %d", n_doc);
    #####: 3658:            printf(" %d", n_encoding);
    #####: 3659:            printf("\n");
        -: 3660:        }
        -: 3661:    }
        -: 3662:    }
    #####: 3663:    function_tests++;
        -: 3664:#endif
        -: 3665:
    #####: 3666:    return(test_ret);
        -: 3667:}
        -: 3668:
        -: 3669:static int
    #####: 3670:test_HTMLtree(void) {
    #####: 3671:    int test_ret = 0;
        -: 3672:
    #####: 3673:    if (quiet == 0) printf("Testing HTMLtree : 18 of 18 functions ...\n");
    #####: 3674:    test_ret += test_htmlDocContentDumpFormatOutput();
    #####: 3675:    test_ret += test_htmlDocContentDumpOutput();
    #####: 3676:    test_ret += test_htmlDocDump();
    #####: 3677:    test_ret += test_htmlDocDumpMemory();
    #####: 3678:    test_ret += test_htmlDocDumpMemoryFormat();
    #####: 3679:    test_ret += test_htmlGetMetaEncoding();
    #####: 3680:    test_ret += test_htmlIsBooleanAttr();
    #####: 3681:    test_ret += test_htmlNewDoc();
    #####: 3682:    test_ret += test_htmlNewDocNoDtD();
    #####: 3683:    test_ret += test_htmlNodeDump();
    #####: 3684:    test_ret += test_htmlNodeDumpFile();
    #####: 3685:    test_ret += test_htmlNodeDumpFileFormat();
    #####: 3686:    test_ret += test_htmlNodeDumpFormatOutput();
    #####: 3687:    test_ret += test_htmlNodeDumpOutput();
    #####: 3688:    test_ret += test_htmlSaveFile();
    #####: 3689:    test_ret += test_htmlSaveFileEnc();
    #####: 3690:    test_ret += test_htmlSaveFileFormat();
    #####: 3691:    test_ret += test_htmlSetMetaEncoding();
        -: 3692:
    #####: 3693:    if (test_ret != 0)
    #####: 3694:	printf("Module HTMLtree: %d errors\n", test_ret);
    #####: 3695:    return(test_ret);
        -: 3696:}
        -: 3697:
        -: 3698:static int
    #####: 3699:test_docbDefaultSAXHandlerInit(void) {
    #####: 3700:    int test_ret = 0;
        -: 3701:
        -: 3702:#if defined(LIBXML_DOCB_ENABLED)
        -: 3703:#ifdef LIBXML_DOCB_ENABLED
        -: 3704:    int mem_base;
        -: 3705:
    #####: 3706:        mem_base = xmlMemBlocks();
        -: 3707:
    #####: 3708:        docbDefaultSAXHandlerInit();
    #####: 3709:        call_tests++;
    #####: 3710:        xmlResetLastError();
    #####: 3711:        if (mem_base != xmlMemBlocks()) {
    #####: 3712:            printf("Leak of %d blocks found in docbDefaultSAXHandlerInit",
    #####: 3713:	           xmlMemBlocks() - mem_base);
    #####: 3714:	    test_ret++;
    #####: 3715:            printf("\n");
        -: 3716:        }
    #####: 3717:    function_tests++;
        -: 3718:#endif
        -: 3719:#endif
        -: 3720:
    #####: 3721:    return(test_ret);
        -: 3722:}
        -: 3723:
        -: 3724:
        -: 3725:static int
    #####: 3726:test_htmlDefaultSAXHandlerInit(void) {
    #####: 3727:    int test_ret = 0;
        -: 3728:
        -: 3729:#if defined(LIBXML_HTML_ENABLED)
        -: 3730:#ifdef LIBXML_HTML_ENABLED
        -: 3731:    int mem_base;
        -: 3732:
    #####: 3733:        mem_base = xmlMemBlocks();
        -: 3734:
    #####: 3735:        htmlDefaultSAXHandlerInit();
    #####: 3736:        call_tests++;
    #####: 3737:        xmlResetLastError();
    #####: 3738:        if (mem_base != xmlMemBlocks()) {
    #####: 3739:            printf("Leak of %d blocks found in htmlDefaultSAXHandlerInit",
    #####: 3740:	           xmlMemBlocks() - mem_base);
    #####: 3741:	    test_ret++;
    #####: 3742:            printf("\n");
        -: 3743:        }
    #####: 3744:    function_tests++;
        -: 3745:#endif
        -: 3746:#endif
        -: 3747:
    #####: 3748:    return(test_ret);
        -: 3749:}
        -: 3750:
        -: 3751:
        -: 3752:static int
    #####: 3753:test_xmlDefaultSAXHandlerInit(void) {
    #####: 3754:    int test_ret = 0;
        -: 3755:
        -: 3756:    int mem_base;
        -: 3757:
    #####: 3758:        mem_base = xmlMemBlocks();
        -: 3759:
    #####: 3760:        xmlDefaultSAXHandlerInit();
    #####: 3761:        call_tests++;
    #####: 3762:        xmlResetLastError();
    #####: 3763:        if (mem_base != xmlMemBlocks()) {
    #####: 3764:            printf("Leak of %d blocks found in xmlDefaultSAXHandlerInit",
    #####: 3765:	           xmlMemBlocks() - mem_base);
    #####: 3766:	    test_ret++;
    #####: 3767:            printf("\n");
        -: 3768:        }
    #####: 3769:    function_tests++;
        -: 3770:
    #####: 3771:    return(test_ret);
        -: 3772:}
        -: 3773:
        -: 3774:
        -: 3775:#define gen_nb_xmlEnumerationPtr 1
    #####: 3776:static xmlEnumerationPtr gen_xmlEnumerationPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 3777:    return(NULL);
        -: 3778:}
    #####: 3779:static void des_xmlEnumerationPtr(int no ATTRIBUTE_UNUSED, xmlEnumerationPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 3780:}
        -: 3781:
        -: 3782:static int
    #####: 3783:test_xmlSAX2AttributeDecl(void) {
    #####: 3784:    int test_ret = 0;
        -: 3785:
        -: 3786:    int mem_base;
        -: 3787:    void * ctx; /* the user data (XML parser context) */
        -: 3788:    int n_ctx;
        -: 3789:    xmlChar * elem; /* the name of the element */
        -: 3790:    int n_elem;
        -: 3791:    xmlChar * fullname; /* the attribute name */
        -: 3792:    int n_fullname;
        -: 3793:    int type; /* the attribute type */
        -: 3794:    int n_type;
        -: 3795:    int def; /* the type of default value */
        -: 3796:    int n_def;
        -: 3797:    xmlChar * defaultValue; /* the attribute default value */
        -: 3798:    int n_defaultValue;
        -: 3799:    xmlEnumerationPtr tree; /* the tree of enumerated value set */
        -: 3800:    int n_tree;
        -: 3801:
    #####: 3802:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####: 3803:    for (n_elem = 0;n_elem < gen_nb_const_xmlChar_ptr;n_elem++) {
    #####: 3804:    for (n_fullname = 0;n_fullname < gen_nb_const_xmlChar_ptr;n_fullname++) {
    #####: 3805:    for (n_type = 0;n_type < gen_nb_int;n_type++) {
    #####: 3806:    for (n_def = 0;n_def < gen_nb_int;n_def++) {
    #####: 3807:    for (n_defaultValue = 0;n_defaultValue < gen_nb_const_xmlChar_ptr;n_defaultValue++) {
    #####: 3808:    for (n_tree = 0;n_tree < gen_nb_xmlEnumerationPtr;n_tree++) {
    #####: 3809:        mem_base = xmlMemBlocks();
    #####: 3810:        ctx = gen_void_ptr(n_ctx, 0);
    #####: 3811:        elem = gen_const_xmlChar_ptr(n_elem, 1);
    #####: 3812:        fullname = gen_const_xmlChar_ptr(n_fullname, 2);
    #####: 3813:        type = gen_int(n_type, 3);
    #####: 3814:        def = gen_int(n_def, 4);
    #####: 3815:        defaultValue = gen_const_xmlChar_ptr(n_defaultValue, 5);
    #####: 3816:        tree = gen_xmlEnumerationPtr(n_tree, 6);
        -: 3817:
    #####: 3818:        xmlSAX2AttributeDecl(ctx, (const xmlChar *)elem, (const xmlChar *)fullname, type, def, (const xmlChar *)defaultValue, tree);
    #####: 3819:        call_tests++;
    #####: 3820:        des_void_ptr(n_ctx, ctx, 0);
    #####: 3821:        des_const_xmlChar_ptr(n_elem, (const xmlChar *)elem, 1);
    #####: 3822:        des_const_xmlChar_ptr(n_fullname, (const xmlChar *)fullname, 2);
    #####: 3823:        des_int(n_type, type, 3);
    #####: 3824:        des_int(n_def, def, 4);
    #####: 3825:        des_const_xmlChar_ptr(n_defaultValue, (const xmlChar *)defaultValue, 5);
    #####: 3826:        des_xmlEnumerationPtr(n_tree, tree, 6);
    #####: 3827:        xmlResetLastError();
    #####: 3828:        if (mem_base != xmlMemBlocks()) {
    #####: 3829:            printf("Leak of %d blocks found in xmlSAX2AttributeDecl",
    #####: 3830:	           xmlMemBlocks() - mem_base);
    #####: 3831:	    test_ret++;
    #####: 3832:            printf(" %d", n_ctx);
    #####: 3833:            printf(" %d", n_elem);
    #####: 3834:            printf(" %d", n_fullname);
    #####: 3835:            printf(" %d", n_type);
    #####: 3836:            printf(" %d", n_def);
    #####: 3837:            printf(" %d", n_defaultValue);
    #####: 3838:            printf(" %d", n_tree);
    #####: 3839:            printf("\n");
        -: 3840:        }
        -: 3841:    }
        -: 3842:    }
        -: 3843:    }
        -: 3844:    }
        -: 3845:    }
        -: 3846:    }
        -: 3847:    }
    #####: 3848:    function_tests++;
        -: 3849:
    #####: 3850:    return(test_ret);
        -: 3851:}
        -: 3852:
        -: 3853:
        -: 3854:static int
    #####: 3855:test_xmlSAX2CDataBlock(void) {
    #####: 3856:    int test_ret = 0;
        -: 3857:
        -: 3858:    int mem_base;
        -: 3859:    void * ctx; /* the user data (XML parser context) */
        -: 3860:    int n_ctx;
        -: 3861:    xmlChar * value; /* The pcdata content */
        -: 3862:    int n_value;
        -: 3863:    int len; /* the block length */
        -: 3864:    int n_len;
        -: 3865:
    #####: 3866:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####: 3867:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####: 3868:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####: 3869:        mem_base = xmlMemBlocks();
    #####: 3870:        ctx = gen_void_ptr(n_ctx, 0);
    #####: 3871:        value = gen_const_xmlChar_ptr(n_value, 1);
    #####: 3872:        len = gen_int(n_len, 2);
        -: 3873:
    #####: 3874:        xmlSAX2CDataBlock(ctx, (const xmlChar *)value, len);
    #####: 3875:        call_tests++;
    #####: 3876:        des_void_ptr(n_ctx, ctx, 0);
    #####: 3877:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 1);
    #####: 3878:        des_int(n_len, len, 2);
    #####: 3879:        xmlResetLastError();
    #####: 3880:        if (mem_base != xmlMemBlocks()) {
    #####: 3881:            printf("Leak of %d blocks found in xmlSAX2CDataBlock",
    #####: 3882:	           xmlMemBlocks() - mem_base);
    #####: 3883:	    test_ret++;
    #####: 3884:            printf(" %d", n_ctx);
    #####: 3885:            printf(" %d", n_value);
    #####: 3886:            printf(" %d", n_len);
    #####: 3887:            printf("\n");
        -: 3888:        }
        -: 3889:    }
        -: 3890:    }
        -: 3891:    }
    #####: 3892:    function_tests++;
        -: 3893:
    #####: 3894:    return(test_ret);
        -: 3895:}
        -: 3896:
        -: 3897:
        -: 3898:static int
    #####: 3899:test_xmlSAX2Characters(void) {
    #####: 3900:    int test_ret = 0;
        -: 3901:
        -: 3902:    int mem_base;
        -: 3903:    void * ctx; /* the user data (XML parser context) */
        -: 3904:    int n_ctx;
        -: 3905:    xmlChar * ch; /* a xmlChar string */
        -: 3906:    int n_ch;
        -: 3907:    int len; /* the number of xmlChar */
        -: 3908:    int n_len;
        -: 3909:
    #####: 3910:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####: 3911:    for (n_ch = 0;n_ch < gen_nb_const_xmlChar_ptr;n_ch++) {
    #####: 3912:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####: 3913:        mem_base = xmlMemBlocks();
    #####: 3914:        ctx = gen_void_ptr(n_ctx, 0);
    #####: 3915:        ch = gen_const_xmlChar_ptr(n_ch, 1);
    #####: 3916:        len = gen_int(n_len, 2);
        -: 3917:
    #####: 3918:        xmlSAX2Characters(ctx, (const xmlChar *)ch, len);
    #####: 3919:        call_tests++;
    #####: 3920:        des_void_ptr(n_ctx, ctx, 0);
    #####: 3921:        des_const_xmlChar_ptr(n_ch, (const xmlChar *)ch, 1);
    #####: 3922:        des_int(n_len, len, 2);
    #####: 3923:        xmlResetLastError();
    #####: 3924:        if (mem_base != xmlMemBlocks()) {
    #####: 3925:            printf("Leak of %d blocks found in xmlSAX2Characters",
    #####: 3926:	           xmlMemBlocks() - mem_base);
    #####: 3927:	    test_ret++;
    #####: 3928:            printf(" %d", n_ctx);
    #####: 3929:            printf(" %d", n_ch);
    #####: 3930:            printf(" %d", n_len);
    #####: 3931:            printf("\n");
        -: 3932:        }
        -: 3933:    }
        -: 3934:    }
        -: 3935:    }
    #####: 3936:    function_tests++;
        -: 3937:
    #####: 3938:    return(test_ret);
        -: 3939:}
        -: 3940:
        -: 3941:
        -: 3942:static int
    #####: 3943:test_xmlSAX2Comment(void) {
    #####: 3944:    int test_ret = 0;
        -: 3945:
        -: 3946:    int mem_base;
        -: 3947:    void * ctx; /* the user data (XML parser context) */
        -: 3948:    int n_ctx;
        -: 3949:    xmlChar * value; /* the xmlSAX2Comment content */
        -: 3950:    int n_value;
        -: 3951:
    #####: 3952:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####: 3953:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####: 3954:        mem_base = xmlMemBlocks();
    #####: 3955:        ctx = gen_void_ptr(n_ctx, 0);
    #####: 3956:        value = gen_const_xmlChar_ptr(n_value, 1);
        -: 3957:
    #####: 3958:        xmlSAX2Comment(ctx, (const xmlChar *)value);
    #####: 3959:        call_tests++;
    #####: 3960:        des_void_ptr(n_ctx, ctx, 0);
    #####: 3961:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 1);
    #####: 3962:        xmlResetLastError();
    #####: 3963:        if (mem_base != xmlMemBlocks()) {
    #####: 3964:            printf("Leak of %d blocks found in xmlSAX2Comment",
    #####: 3965:	           xmlMemBlocks() - mem_base);
    #####: 3966:	    test_ret++;
    #####: 3967:            printf(" %d", n_ctx);
    #####: 3968:            printf(" %d", n_value);
    #####: 3969:            printf("\n");
        -: 3970:        }
        -: 3971:    }
        -: 3972:    }
    #####: 3973:    function_tests++;
        -: 3974:
    #####: 3975:    return(test_ret);
        -: 3976:}
        -: 3977:
        -: 3978:
        -: 3979:static int
    #####: 3980:test_xmlSAX2ElementDecl(void) {
    #####: 3981:    int test_ret = 0;
        -: 3982:
        -: 3983:    int mem_base;
        -: 3984:    void * ctx; /* the user data (XML parser context) */
        -: 3985:    int n_ctx;
        -: 3986:    xmlChar * name; /* the element name */
        -: 3987:    int n_name;
        -: 3988:    int type; /* the element type */
        -: 3989:    int n_type;
        -: 3990:    xmlElementContentPtr content; /* the element value tree */
        -: 3991:    int n_content;
        -: 3992:
    #####: 3993:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####: 3994:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####: 3995:    for (n_type = 0;n_type < gen_nb_int;n_type++) {
    #####: 3996:    for (n_content = 0;n_content < gen_nb_xmlElementContentPtr;n_content++) {
    #####: 3997:        mem_base = xmlMemBlocks();
    #####: 3998:        ctx = gen_void_ptr(n_ctx, 0);
    #####: 3999:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####: 4000:        type = gen_int(n_type, 2);
    #####: 4001:        content = gen_xmlElementContentPtr(n_content, 3);
        -: 4002:
    #####: 4003:        xmlSAX2ElementDecl(ctx, (const xmlChar *)name, type, content);
    #####: 4004:        call_tests++;
    #####: 4005:        des_void_ptr(n_ctx, ctx, 0);
    #####: 4006:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####: 4007:        des_int(n_type, type, 2);
    #####: 4008:        des_xmlElementContentPtr(n_content, content, 3);
    #####: 4009:        xmlResetLastError();
    #####: 4010:        if (mem_base != xmlMemBlocks()) {
    #####: 4011:            printf("Leak of %d blocks found in xmlSAX2ElementDecl",
    #####: 4012:	           xmlMemBlocks() - mem_base);
    #####: 4013:	    test_ret++;
    #####: 4014:            printf(" %d", n_ctx);
    #####: 4015:            printf(" %d", n_name);
    #####: 4016:            printf(" %d", n_type);
    #####: 4017:            printf(" %d", n_content);
    #####: 4018:            printf("\n");
        -: 4019:        }
        -: 4020:    }
        -: 4021:    }
        -: 4022:    }
        -: 4023:    }
    #####: 4024:    function_tests++;
        -: 4025:
    #####: 4026:    return(test_ret);
        -: 4027:}
        -: 4028:
        -: 4029:
        -: 4030:static int
    #####: 4031:test_xmlSAX2EndDocument(void) {
    #####: 4032:    int test_ret = 0;
        -: 4033:
        -: 4034:    int mem_base;
        -: 4035:    void * ctx; /* the user data (XML parser context) */
        -: 4036:    int n_ctx;
        -: 4037:
    #####: 4038:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####: 4039:        mem_base = xmlMemBlocks();
    #####: 4040:        ctx = gen_void_ptr(n_ctx, 0);
        -: 4041:
    #####: 4042:        xmlSAX2EndDocument(ctx);
    #####: 4043:        call_tests++;
    #####: 4044:        des_void_ptr(n_ctx, ctx, 0);
    #####: 4045:        xmlResetLastError();
    #####: 4046:        if (mem_base != xmlMemBlocks()) {
    #####: 4047:            printf("Leak of %d blocks found in xmlSAX2EndDocument",
    #####: 4048:	           xmlMemBlocks() - mem_base);
    #####: 4049:	    test_ret++;
    #####: 4050:            printf(" %d", n_ctx);
    #####: 4051:            printf("\n");
        -: 4052:        }
        -: 4053:    }
    #####: 4054:    function_tests++;
        -: 4055:
    #####: 4056:    return(test_ret);
        -: 4057:}
        -: 4058:
        -: 4059:
        -: 4060:static int
    #####: 4061:test_xmlSAX2EndElement(void) {
    #####: 4062:    int test_ret = 0;
        -: 4063:
        -: 4064:#if defined(LIBXML_SAX1_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_WRITER_ENABLED) || defined(LIBXML_DOCB_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
        -: 4065:#ifdef LIBXML_SAX1_ENABLED
        -: 4066:    int mem_base;
        -: 4067:    void * ctx; /* the user data (XML parser context) */
        -: 4068:    int n_ctx;
        -: 4069:    xmlChar * name; /* The element name */
        -: 4070:    int n_name;
        -: 4071:
    #####: 4072:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####: 4073:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####: 4074:        mem_base = xmlMemBlocks();
    #####: 4075:        ctx = gen_void_ptr(n_ctx, 0);
    #####: 4076:        name = gen_const_xmlChar_ptr(n_name, 1);
        -: 4077:
    #####: 4078:        xmlSAX2EndElement(ctx, (const xmlChar *)name);
    #####: 4079:        call_tests++;
    #####: 4080:        des_void_ptr(n_ctx, ctx, 0);
    #####: 4081:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####: 4082:        xmlResetLastError();
    #####: 4083:        if (mem_base != xmlMemBlocks()) {
    #####: 4084:            printf("Leak of %d blocks found in xmlSAX2EndElement",
    #####: 4085:	           xmlMemBlocks() - mem_base);
    #####: 4086:	    test_ret++;
    #####: 4087:            printf(" %d", n_ctx);
    #####: 4088:            printf(" %d", n_name);
    #####: 4089:            printf("\n");
        -: 4090:        }
        -: 4091:    }
        -: 4092:    }
    #####: 4093:    function_tests++;
        -: 4094:#endif
        -: 4095:#endif
        -: 4096:
    #####: 4097:    return(test_ret);
        -: 4098:}
        -: 4099:
        -: 4100:
        -: 4101:static int
    #####: 4102:test_xmlSAX2EndElementNs(void) {
    #####: 4103:    int test_ret = 0;
        -: 4104:
        -: 4105:    int mem_base;
        -: 4106:    void * ctx; /* the user data (XML parser context) */
        -: 4107:    int n_ctx;
        -: 4108:    xmlChar * localname; /* the local name of the element */
        -: 4109:    int n_localname;
        -: 4110:    xmlChar * prefix; /* the element namespace prefix if available */
        -: 4111:    int n_prefix;
        -: 4112:    xmlChar * URI; /* the element namespace name if available */
        -: 4113:    int n_URI;
        -: 4114:
    #####: 4115:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####: 4116:    for (n_localname = 0;n_localname < gen_nb_const_xmlChar_ptr;n_localname++) {
    #####: 4117:    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    #####: 4118:    for (n_URI = 0;n_URI < gen_nb_const_xmlChar_ptr;n_URI++) {
    #####: 4119:        mem_base = xmlMemBlocks();
    #####: 4120:        ctx = gen_void_ptr(n_ctx, 0);
    #####: 4121:        localname = gen_const_xmlChar_ptr(n_localname, 1);
    #####: 4122:        prefix = gen_const_xmlChar_ptr(n_prefix, 2);
    #####: 4123:        URI = gen_const_xmlChar_ptr(n_URI, 3);
        -: 4124:
    #####: 4125:        xmlSAX2EndElementNs(ctx, (const xmlChar *)localname, (const xmlChar *)prefix, (const xmlChar *)URI);
    #####: 4126:        call_tests++;
    #####: 4127:        des_void_ptr(n_ctx, ctx, 0);
    #####: 4128:        des_const_xmlChar_ptr(n_localname, (const xmlChar *)localname, 1);
    #####: 4129:        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 2);
    #####: 4130:        des_const_xmlChar_ptr(n_URI, (const xmlChar *)URI, 3);
    #####: 4131:        xmlResetLastError();
    #####: 4132:        if (mem_base != xmlMemBlocks()) {
    #####: 4133:            printf("Leak of %d blocks found in xmlSAX2EndElementNs",
    #####: 4134:	           xmlMemBlocks() - mem_base);
    #####: 4135:	    test_ret++;
    #####: 4136:            printf(" %d", n_ctx);
    #####: 4137:            printf(" %d", n_localname);
    #####: 4138:            printf(" %d", n_prefix);
    #####: 4139:            printf(" %d", n_URI);
    #####: 4140:            printf("\n");
        -: 4141:        }
        -: 4142:    }
        -: 4143:    }
        -: 4144:    }
        -: 4145:    }
    #####: 4146:    function_tests++;
        -: 4147:
    #####: 4148:    return(test_ret);
        -: 4149:}
        -: 4150:
        -: 4151:
        -: 4152:static int
    #####: 4153:test_xmlSAX2EntityDecl(void) {
    #####: 4154:    int test_ret = 0;
        -: 4155:
        -: 4156:    int mem_base;
        -: 4157:    void * ctx; /* the user data (XML parser context) */
        -: 4158:    int n_ctx;
        -: 4159:    xmlChar * name; /* the entity name */
        -: 4160:    int n_name;
        -: 4161:    int type; /* the entity type */
        -: 4162:    int n_type;
        -: 4163:    xmlChar * publicId; /* The public ID of the entity */
        -: 4164:    int n_publicId;
        -: 4165:    xmlChar * systemId; /* The system ID of the entity */
        -: 4166:    int n_systemId;
        -: 4167:    xmlChar * content; /* the entity value (without processing). */
        -: 4168:    int n_content;
        -: 4169:
    #####: 4170:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####: 4171:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####: 4172:    for (n_type = 0;n_type < gen_nb_int;n_type++) {
    #####: 4173:    for (n_publicId = 0;n_publicId < gen_nb_const_xmlChar_ptr;n_publicId++) {
    #####: 4174:    for (n_systemId = 0;n_systemId < gen_nb_const_xmlChar_ptr;n_systemId++) {
    #####: 4175:    for (n_content = 0;n_content < gen_nb_xmlChar_ptr;n_content++) {
    #####: 4176:        mem_base = xmlMemBlocks();
    #####: 4177:        ctx = gen_void_ptr(n_ctx, 0);
    #####: 4178:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####: 4179:        type = gen_int(n_type, 2);
    #####: 4180:        publicId = gen_const_xmlChar_ptr(n_publicId, 3);
    #####: 4181:        systemId = gen_const_xmlChar_ptr(n_systemId, 4);
    #####: 4182:        content = gen_xmlChar_ptr(n_content, 5);
        -: 4183:
    #####: 4184:        xmlSAX2EntityDecl(ctx, (const xmlChar *)name, type, (const xmlChar *)publicId, (const xmlChar *)systemId, content);
    #####: 4185:        call_tests++;
    #####: 4186:        des_void_ptr(n_ctx, ctx, 0);
    #####: 4187:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####: 4188:        des_int(n_type, type, 2);
    #####: 4189:        des_const_xmlChar_ptr(n_publicId, (const xmlChar *)publicId, 3);
    #####: 4190:        des_const_xmlChar_ptr(n_systemId, (const xmlChar *)systemId, 4);
    #####: 4191:        des_xmlChar_ptr(n_content, content, 5);
    #####: 4192:        xmlResetLastError();
    #####: 4193:        if (mem_base != xmlMemBlocks()) {
    #####: 4194:            printf("Leak of %d blocks found in xmlSAX2EntityDecl",
    #####: 4195:	           xmlMemBlocks() - mem_base);
    #####: 4196:	    test_ret++;
    #####: 4197:            printf(" %d", n_ctx);
    #####: 4198:            printf(" %d", n_name);
    #####: 4199:            printf(" %d", n_type);
    #####: 4200:            printf(" %d", n_publicId);
    #####: 4201:            printf(" %d", n_systemId);
    #####: 4202:            printf(" %d", n_content);
    #####: 4203:            printf("\n");
        -: 4204:        }
        -: 4205:    }
        -: 4206:    }
        -: 4207:    }
        -: 4208:    }
        -: 4209:    }
        -: 4210:    }
    #####: 4211:    function_tests++;
        -: 4212:
    #####: 4213:    return(test_ret);
        -: 4214:}
        -: 4215:
        -: 4216:
        -: 4217:static int
    #####: 4218:test_xmlSAX2ExternalSubset(void) {
    #####: 4219:    int test_ret = 0;
        -: 4220:
        -: 4221:    int mem_base;
        -: 4222:    void * ctx; /* the user data (XML parser context) */
        -: 4223:    int n_ctx;
        -: 4224:    xmlChar * name; /* the root element name */
        -: 4225:    int n_name;
        -: 4226:    xmlChar * ExternalID; /* the external ID */
        -: 4227:    int n_ExternalID;
        -: 4228:    xmlChar * SystemID; /* the SYSTEM ID (e.g. filename or URL) */
        -: 4229:    int n_SystemID;
        -: 4230:
    #####: 4231:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####: 4232:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####: 4233:    for (n_ExternalID = 0;n_ExternalID < gen_nb_const_xmlChar_ptr;n_ExternalID++) {
    #####: 4234:    for (n_SystemID = 0;n_SystemID < gen_nb_const_xmlChar_ptr;n_SystemID++) {
    #####: 4235:        mem_base = xmlMemBlocks();
    #####: 4236:        ctx = gen_void_ptr(n_ctx, 0);
    #####: 4237:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####: 4238:        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 2);
    #####: 4239:        SystemID = gen_const_xmlChar_ptr(n_SystemID, 3);
        -: 4240:
    #####: 4241:        xmlSAX2ExternalSubset(ctx, (const xmlChar *)name, (const xmlChar *)ExternalID, (const xmlChar *)SystemID);
    #####: 4242:        call_tests++;
    #####: 4243:        des_void_ptr(n_ctx, ctx, 0);
    #####: 4244:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####: 4245:        des_const_xmlChar_ptr(n_ExternalID, (const xmlChar *)ExternalID, 2);
    #####: 4246:        des_const_xmlChar_ptr(n_SystemID, (const xmlChar *)SystemID, 3);
    #####: 4247:        xmlResetLastError();
    #####: 4248:        if (mem_base != xmlMemBlocks()) {
    #####: 4249:            printf("Leak of %d blocks found in xmlSAX2ExternalSubset",
    #####: 4250:	           xmlMemBlocks() - mem_base);
    #####: 4251:	    test_ret++;
    #####: 4252:            printf(" %d", n_ctx);
    #####: 4253:            printf(" %d", n_name);
    #####: 4254:            printf(" %d", n_ExternalID);
    #####: 4255:            printf(" %d", n_SystemID);
    #####: 4256:            printf("\n");
        -: 4257:        }
        -: 4258:    }
        -: 4259:    }
        -: 4260:    }
        -: 4261:    }
    #####: 4262:    function_tests++;
        -: 4263:
    #####: 4264:    return(test_ret);
        -: 4265:}
        -: 4266:
        -: 4267:
        -: 4268:static int
    #####: 4269:test_xmlSAX2GetColumnNumber(void) {
    #####: 4270:    int test_ret = 0;
        -: 4271:
        -: 4272:    int mem_base;
        -: 4273:    int ret_val;
        -: 4274:    void * ctx; /* the user data (XML parser context) */
        -: 4275:    int n_ctx;
        -: 4276:
    #####: 4277:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####: 4278:        mem_base = xmlMemBlocks();
    #####: 4279:        ctx = gen_void_ptr(n_ctx, 0);
        -: 4280:
    #####: 4281:        ret_val = xmlSAX2GetColumnNumber(ctx);
    #####: 4282:        desret_int(ret_val);
    #####: 4283:        call_tests++;
    #####: 4284:        des_void_ptr(n_ctx, ctx, 0);
    #####: 4285:        xmlResetLastError();
    #####: 4286:        if (mem_base != xmlMemBlocks()) {
    #####: 4287:            printf("Leak of %d blocks found in xmlSAX2GetColumnNumber",
    #####: 4288:	           xmlMemBlocks() - mem_base);
    #####: 4289:	    test_ret++;
    #####: 4290:            printf(" %d", n_ctx);
    #####: 4291:            printf("\n");
        -: 4292:        }
        -: 4293:    }
    #####: 4294:    function_tests++;
        -: 4295:
    #####: 4296:    return(test_ret);
        -: 4297:}
        -: 4298:
        -: 4299:
        -: 4300:static int
    #####: 4301:test_xmlSAX2GetEntity(void) {
    #####: 4302:    int test_ret = 0;
        -: 4303:
        -: 4304:    int mem_base;
        -: 4305:    xmlEntityPtr ret_val;
        -: 4306:    void * ctx; /* the user data (XML parser context) */
        -: 4307:    int n_ctx;
        -: 4308:    xmlChar * name; /* The entity name */
        -: 4309:    int n_name;
        -: 4310:
    #####: 4311:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####: 4312:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####: 4313:        mem_base = xmlMemBlocks();
    #####: 4314:        ctx = gen_void_ptr(n_ctx, 0);
    #####: 4315:        name = gen_const_xmlChar_ptr(n_name, 1);
        -: 4316:
    #####: 4317:        ret_val = xmlSAX2GetEntity(ctx, (const xmlChar *)name);
    #####: 4318:        desret_xmlEntityPtr(ret_val);
    #####: 4319:        call_tests++;
    #####: 4320:        des_void_ptr(n_ctx, ctx, 0);
    #####: 4321:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####: 4322:        xmlResetLastError();
    #####: 4323:        if (mem_base != xmlMemBlocks()) {
    #####: 4324:            printf("Leak of %d blocks found in xmlSAX2GetEntity",
    #####: 4325:	           xmlMemBlocks() - mem_base);
    #####: 4326:	    test_ret++;
    #####: 4327:            printf(" %d", n_ctx);
    #####: 4328:            printf(" %d", n_name);
    #####: 4329:            printf("\n");
        -: 4330:        }
        -: 4331:    }
        -: 4332:    }
    #####: 4333:    function_tests++;
        -: 4334:
    #####: 4335:    return(test_ret);
        -: 4336:}
        -: 4337:
        -: 4338:
        -: 4339:static int
    #####: 4340:test_xmlSAX2GetLineNumber(void) {
    #####: 4341:    int test_ret = 0;
        -: 4342:
        -: 4343:    int mem_base;
        -: 4344:    int ret_val;
        -: 4345:    void * ctx; /* the user data (XML parser context) */
        -: 4346:    int n_ctx;
        -: 4347:
    #####: 4348:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####: 4349:        mem_base = xmlMemBlocks();
    #####: 4350:        ctx = gen_void_ptr(n_ctx, 0);
        -: 4351:
    #####: 4352:        ret_val = xmlSAX2GetLineNumber(ctx);
    #####: 4353:        desret_int(ret_val);
    #####: 4354:        call_tests++;
    #####: 4355:        des_void_ptr(n_ctx, ctx, 0);
    #####: 4356:        xmlResetLastError();
    #####: 4357:        if (mem_base != xmlMemBlocks()) {
    #####: 4358:            printf("Leak of %d blocks found in xmlSAX2GetLineNumber",
    #####: 4359:	           xmlMemBlocks() - mem_base);
    #####: 4360:	    test_ret++;
    #####: 4361:            printf(" %d", n_ctx);
    #####: 4362:            printf("\n");
        -: 4363:        }
        -: 4364:    }
    #####: 4365:    function_tests++;
        -: 4366:
    #####: 4367:    return(test_ret);
        -: 4368:}
        -: 4369:
        -: 4370:
        -: 4371:static int
    #####: 4372:test_xmlSAX2GetParameterEntity(void) {
    #####: 4373:    int test_ret = 0;
        -: 4374:
        -: 4375:    int mem_base;
        -: 4376:    xmlEntityPtr ret_val;
        -: 4377:    void * ctx; /* the user data (XML parser context) */
        -: 4378:    int n_ctx;
        -: 4379:    xmlChar * name; /* The entity name */
        -: 4380:    int n_name;
        -: 4381:
    #####: 4382:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####: 4383:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####: 4384:        mem_base = xmlMemBlocks();
    #####: 4385:        ctx = gen_void_ptr(n_ctx, 0);
    #####: 4386:        name = gen_const_xmlChar_ptr(n_name, 1);
        -: 4387:
    #####: 4388:        ret_val = xmlSAX2GetParameterEntity(ctx, (const xmlChar *)name);
    #####: 4389:        desret_xmlEntityPtr(ret_val);
    #####: 4390:        call_tests++;
    #####: 4391:        des_void_ptr(n_ctx, ctx, 0);
    #####: 4392:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####: 4393:        xmlResetLastError();
    #####: 4394:        if (mem_base != xmlMemBlocks()) {
    #####: 4395:            printf("Leak of %d blocks found in xmlSAX2GetParameterEntity",
    #####: 4396:	           xmlMemBlocks() - mem_base);
    #####: 4397:	    test_ret++;
    #####: 4398:            printf(" %d", n_ctx);
    #####: 4399:            printf(" %d", n_name);
    #####: 4400:            printf("\n");
        -: 4401:        }
        -: 4402:    }
        -: 4403:    }
    #####: 4404:    function_tests++;
        -: 4405:
    #####: 4406:    return(test_ret);
        -: 4407:}
        -: 4408:
        -: 4409:
        -: 4410:static int
    #####: 4411:test_xmlSAX2GetPublicId(void) {
    #####: 4412:    int test_ret = 0;
        -: 4413:
        -: 4414:    int mem_base;
        -: 4415:    const xmlChar * ret_val;
        -: 4416:    void * ctx; /* the user data (XML parser context) */
        -: 4417:    int n_ctx;
        -: 4418:
    #####: 4419:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####: 4420:        mem_base = xmlMemBlocks();
    #####: 4421:        ctx = gen_void_ptr(n_ctx, 0);
        -: 4422:
    #####: 4423:        ret_val = xmlSAX2GetPublicId(ctx);
    #####: 4424:        desret_const_xmlChar_ptr(ret_val);
    #####: 4425:        call_tests++;
    #####: 4426:        des_void_ptr(n_ctx, ctx, 0);
    #####: 4427:        xmlResetLastError();
    #####: 4428:        if (mem_base != xmlMemBlocks()) {
    #####: 4429:            printf("Leak of %d blocks found in xmlSAX2GetPublicId",
    #####: 4430:	           xmlMemBlocks() - mem_base);
    #####: 4431:	    test_ret++;
    #####: 4432:            printf(" %d", n_ctx);
    #####: 4433:            printf("\n");
        -: 4434:        }
        -: 4435:    }
    #####: 4436:    function_tests++;
        -: 4437:
    #####: 4438:    return(test_ret);
        -: 4439:}
        -: 4440:
        -: 4441:
        -: 4442:static int
    #####: 4443:test_xmlSAX2GetSystemId(void) {
    #####: 4444:    int test_ret = 0;
        -: 4445:
        -: 4446:    int mem_base;
        -: 4447:    const xmlChar * ret_val;
        -: 4448:    void * ctx; /* the user data (XML parser context) */
        -: 4449:    int n_ctx;
        -: 4450:
    #####: 4451:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####: 4452:        mem_base = xmlMemBlocks();
    #####: 4453:        ctx = gen_void_ptr(n_ctx, 0);
        -: 4454:
    #####: 4455:        ret_val = xmlSAX2GetSystemId(ctx);
    #####: 4456:        desret_const_xmlChar_ptr(ret_val);
    #####: 4457:        call_tests++;
    #####: 4458:        des_void_ptr(n_ctx, ctx, 0);
    #####: 4459:        xmlResetLastError();
    #####: 4460:        if (mem_base != xmlMemBlocks()) {
    #####: 4461:            printf("Leak of %d blocks found in xmlSAX2GetSystemId",
    #####: 4462:	           xmlMemBlocks() - mem_base);
    #####: 4463:	    test_ret++;
    #####: 4464:            printf(" %d", n_ctx);
    #####: 4465:            printf("\n");
        -: 4466:        }
        -: 4467:    }
    #####: 4468:    function_tests++;
        -: 4469:
    #####: 4470:    return(test_ret);
        -: 4471:}
        -: 4472:
        -: 4473:
        -: 4474:static int
    #####: 4475:test_xmlSAX2HasExternalSubset(void) {
    #####: 4476:    int test_ret = 0;
        -: 4477:
        -: 4478:    int mem_base;
        -: 4479:    int ret_val;
        -: 4480:    void * ctx; /* the user data (XML parser context) */
        -: 4481:    int n_ctx;
        -: 4482:
    #####: 4483:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####: 4484:        mem_base = xmlMemBlocks();
    #####: 4485:        ctx = gen_void_ptr(n_ctx, 0);
        -: 4486:
    #####: 4487:        ret_val = xmlSAX2HasExternalSubset(ctx);
    #####: 4488:        desret_int(ret_val);
    #####: 4489:        call_tests++;
    #####: 4490:        des_void_ptr(n_ctx, ctx, 0);
    #####: 4491:        xmlResetLastError();
    #####: 4492:        if (mem_base != xmlMemBlocks()) {
    #####: 4493:            printf("Leak of %d blocks found in xmlSAX2HasExternalSubset",
    #####: 4494:	           xmlMemBlocks() - mem_base);
    #####: 4495:	    test_ret++;
    #####: 4496:            printf(" %d", n_ctx);
    #####: 4497:            printf("\n");
        -: 4498:        }
        -: 4499:    }
    #####: 4500:    function_tests++;
        -: 4501:
    #####: 4502:    return(test_ret);
        -: 4503:}
        -: 4504:
        -: 4505:
        -: 4506:static int
    #####: 4507:test_xmlSAX2HasInternalSubset(void) {
    #####: 4508:    int test_ret = 0;
        -: 4509:
        -: 4510:    int mem_base;
        -: 4511:    int ret_val;
        -: 4512:    void * ctx; /* the user data (XML parser context) */
        -: 4513:    int n_ctx;
        -: 4514:
    #####: 4515:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####: 4516:        mem_base = xmlMemBlocks();
    #####: 4517:        ctx = gen_void_ptr(n_ctx, 0);
        -: 4518:
    #####: 4519:        ret_val = xmlSAX2HasInternalSubset(ctx);
    #####: 4520:        desret_int(ret_val);
    #####: 4521:        call_tests++;
    #####: 4522:        des_void_ptr(n_ctx, ctx, 0);
    #####: 4523:        xmlResetLastError();
    #####: 4524:        if (mem_base != xmlMemBlocks()) {
    #####: 4525:            printf("Leak of %d blocks found in xmlSAX2HasInternalSubset",
    #####: 4526:	           xmlMemBlocks() - mem_base);
    #####: 4527:	    test_ret++;
    #####: 4528:            printf(" %d", n_ctx);
    #####: 4529:            printf("\n");
        -: 4530:        }
        -: 4531:    }
    #####: 4532:    function_tests++;
        -: 4533:
    #####: 4534:    return(test_ret);
        -: 4535:}
        -: 4536:
        -: 4537:
        -: 4538:static int
    #####: 4539:test_xmlSAX2IgnorableWhitespace(void) {
    #####: 4540:    int test_ret = 0;
        -: 4541:
        -: 4542:    int mem_base;
        -: 4543:    void * ctx; /* the user data (XML parser context) */
        -: 4544:    int n_ctx;
        -: 4545:    xmlChar * ch; /* a xmlChar string */
        -: 4546:    int n_ch;
        -: 4547:    int len; /* the number of xmlChar */
        -: 4548:    int n_len;
        -: 4549:
    #####: 4550:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####: 4551:    for (n_ch = 0;n_ch < gen_nb_const_xmlChar_ptr;n_ch++) {
    #####: 4552:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####: 4553:        mem_base = xmlMemBlocks();
    #####: 4554:        ctx = gen_void_ptr(n_ctx, 0);
    #####: 4555:        ch = gen_const_xmlChar_ptr(n_ch, 1);
    #####: 4556:        len = gen_int(n_len, 2);
        -: 4557:
    #####: 4558:        xmlSAX2IgnorableWhitespace(ctx, (const xmlChar *)ch, len);
    #####: 4559:        call_tests++;
    #####: 4560:        des_void_ptr(n_ctx, ctx, 0);
    #####: 4561:        des_const_xmlChar_ptr(n_ch, (const xmlChar *)ch, 1);
    #####: 4562:        des_int(n_len, len, 2);
    #####: 4563:        xmlResetLastError();
    #####: 4564:        if (mem_base != xmlMemBlocks()) {
    #####: 4565:            printf("Leak of %d blocks found in xmlSAX2IgnorableWhitespace",
    #####: 4566:	           xmlMemBlocks() - mem_base);
    #####: 4567:	    test_ret++;
    #####: 4568:            printf(" %d", n_ctx);
    #####: 4569:            printf(" %d", n_ch);
    #####: 4570:            printf(" %d", n_len);
    #####: 4571:            printf("\n");
        -: 4572:        }
        -: 4573:    }
        -: 4574:    }
        -: 4575:    }
    #####: 4576:    function_tests++;
        -: 4577:
    #####: 4578:    return(test_ret);
        -: 4579:}
        -: 4580:
        -: 4581:
        -: 4582:#define gen_nb_xmlSAXHandler_ptr 1
    #####: 4583:static xmlSAXHandler * gen_xmlSAXHandler_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 4584:    return(NULL);
        -: 4585:}
    #####: 4586:static void des_xmlSAXHandler_ptr(int no ATTRIBUTE_UNUSED, xmlSAXHandler * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 4587:}
        -: 4588:
        -: 4589:static int
    #####: 4590:test_xmlSAX2InitDefaultSAXHandler(void) {
    #####: 4591:    int test_ret = 0;
        -: 4592:
        -: 4593:    int mem_base;
        -: 4594:    xmlSAXHandler * hdlr; /* the SAX handler */
        -: 4595:    int n_hdlr;
        -: 4596:    int warning; /* flag if non-zero sets the handler warning procedure */
        -: 4597:    int n_warning;
        -: 4598:
    #####: 4599:    for (n_hdlr = 0;n_hdlr < gen_nb_xmlSAXHandler_ptr;n_hdlr++) {
    #####: 4600:    for (n_warning = 0;n_warning < gen_nb_int;n_warning++) {
    #####: 4601:        mem_base = xmlMemBlocks();
    #####: 4602:        hdlr = gen_xmlSAXHandler_ptr(n_hdlr, 0);
    #####: 4603:        warning = gen_int(n_warning, 1);
        -: 4604:
    #####: 4605:        xmlSAX2InitDefaultSAXHandler(hdlr, warning);
    #####: 4606:        call_tests++;
    #####: 4607:        des_xmlSAXHandler_ptr(n_hdlr, hdlr, 0);
    #####: 4608:        des_int(n_warning, warning, 1);
    #####: 4609:        xmlResetLastError();
    #####: 4610:        if (mem_base != xmlMemBlocks()) {
    #####: 4611:            printf("Leak of %d blocks found in xmlSAX2InitDefaultSAXHandler",
    #####: 4612:	           xmlMemBlocks() - mem_base);
    #####: 4613:	    test_ret++;
    #####: 4614:            printf(" %d", n_hdlr);
    #####: 4615:            printf(" %d", n_warning);
    #####: 4616:            printf("\n");
        -: 4617:        }
        -: 4618:    }
        -: 4619:    }
    #####: 4620:    function_tests++;
        -: 4621:
    #####: 4622:    return(test_ret);
        -: 4623:}
        -: 4624:
        -: 4625:
        -: 4626:static int
    #####: 4627:test_xmlSAX2InitDocbDefaultSAXHandler(void) {
    #####: 4628:    int test_ret = 0;
        -: 4629:
        -: 4630:#if defined(LIBXML_DOCB_ENABLED)
        -: 4631:    int mem_base;
        -: 4632:    xmlSAXHandler * hdlr; /* the SAX handler */
        -: 4633:    int n_hdlr;
        -: 4634:
    #####: 4635:    for (n_hdlr = 0;n_hdlr < gen_nb_xmlSAXHandler_ptr;n_hdlr++) {
    #####: 4636:        mem_base = xmlMemBlocks();
    #####: 4637:        hdlr = gen_xmlSAXHandler_ptr(n_hdlr, 0);
        -: 4638:
    #####: 4639:        xmlSAX2InitDocbDefaultSAXHandler(hdlr);
    #####: 4640:        call_tests++;
    #####: 4641:        des_xmlSAXHandler_ptr(n_hdlr, hdlr, 0);
    #####: 4642:        xmlResetLastError();
    #####: 4643:        if (mem_base != xmlMemBlocks()) {
    #####: 4644:            printf("Leak of %d blocks found in xmlSAX2InitDocbDefaultSAXHandler",
    #####: 4645:	           xmlMemBlocks() - mem_base);
    #####: 4646:	    test_ret++;
    #####: 4647:            printf(" %d", n_hdlr);
    #####: 4648:            printf("\n");
        -: 4649:        }
        -: 4650:    }
    #####: 4651:    function_tests++;
        -: 4652:#endif
        -: 4653:
    #####: 4654:    return(test_ret);
        -: 4655:}
        -: 4656:
        -: 4657:
        -: 4658:static int
    #####: 4659:test_xmlSAX2InitHtmlDefaultSAXHandler(void) {
    #####: 4660:    int test_ret = 0;
        -: 4661:
        -: 4662:#if defined(LIBXML_HTML_ENABLED)
        -: 4663:    int mem_base;
        -: 4664:    xmlSAXHandler * hdlr; /* the SAX handler */
        -: 4665:    int n_hdlr;
        -: 4666:
    #####: 4667:    for (n_hdlr = 0;n_hdlr < gen_nb_xmlSAXHandler_ptr;n_hdlr++) {
    #####: 4668:        mem_base = xmlMemBlocks();
    #####: 4669:        hdlr = gen_xmlSAXHandler_ptr(n_hdlr, 0);
        -: 4670:
    #####: 4671:        xmlSAX2InitHtmlDefaultSAXHandler(hdlr);
    #####: 4672:        call_tests++;
    #####: 4673:        des_xmlSAXHandler_ptr(n_hdlr, hdlr, 0);
    #####: 4674:        xmlResetLastError();
    #####: 4675:        if (mem_base != xmlMemBlocks()) {
    #####: 4676:            printf("Leak of %d blocks found in xmlSAX2InitHtmlDefaultSAXHandler",
    #####: 4677:	           xmlMemBlocks() - mem_base);
    #####: 4678:	    test_ret++;
    #####: 4679:            printf(" %d", n_hdlr);
    #####: 4680:            printf("\n");
        -: 4681:        }
        -: 4682:    }
    #####: 4683:    function_tests++;
        -: 4684:#endif
        -: 4685:
    #####: 4686:    return(test_ret);
        -: 4687:}
        -: 4688:
        -: 4689:
        -: 4690:static int
    #####: 4691:test_xmlSAX2InternalSubset(void) {
    #####: 4692:    int test_ret = 0;
        -: 4693:
        -: 4694:    int mem_base;
        -: 4695:    void * ctx; /* the user data (XML parser context) */
        -: 4696:    int n_ctx;
        -: 4697:    xmlChar * name; /* the root element name */
        -: 4698:    int n_name;
        -: 4699:    xmlChar * ExternalID; /* the external ID */
        -: 4700:    int n_ExternalID;
        -: 4701:    xmlChar * SystemID; /* the SYSTEM ID (e.g. filename or URL) */
        -: 4702:    int n_SystemID;
        -: 4703:
    #####: 4704:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####: 4705:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####: 4706:    for (n_ExternalID = 0;n_ExternalID < gen_nb_const_xmlChar_ptr;n_ExternalID++) {
    #####: 4707:    for (n_SystemID = 0;n_SystemID < gen_nb_const_xmlChar_ptr;n_SystemID++) {
    #####: 4708:        mem_base = xmlMemBlocks();
    #####: 4709:        ctx = gen_void_ptr(n_ctx, 0);
    #####: 4710:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####: 4711:        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 2);
    #####: 4712:        SystemID = gen_const_xmlChar_ptr(n_SystemID, 3);
        -: 4713:
    #####: 4714:        xmlSAX2InternalSubset(ctx, (const xmlChar *)name, (const xmlChar *)ExternalID, (const xmlChar *)SystemID);
    #####: 4715:        call_tests++;
    #####: 4716:        des_void_ptr(n_ctx, ctx, 0);
    #####: 4717:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####: 4718:        des_const_xmlChar_ptr(n_ExternalID, (const xmlChar *)ExternalID, 2);
    #####: 4719:        des_const_xmlChar_ptr(n_SystemID, (const xmlChar *)SystemID, 3);
    #####: 4720:        xmlResetLastError();
    #####: 4721:        if (mem_base != xmlMemBlocks()) {
    #####: 4722:            printf("Leak of %d blocks found in xmlSAX2InternalSubset",
    #####: 4723:	           xmlMemBlocks() - mem_base);
    #####: 4724:	    test_ret++;
    #####: 4725:            printf(" %d", n_ctx);
    #####: 4726:            printf(" %d", n_name);
    #####: 4727:            printf(" %d", n_ExternalID);
    #####: 4728:            printf(" %d", n_SystemID);
    #####: 4729:            printf("\n");
        -: 4730:        }
        -: 4731:    }
        -: 4732:    }
        -: 4733:    }
        -: 4734:    }
    #####: 4735:    function_tests++;
        -: 4736:
    #####: 4737:    return(test_ret);
        -: 4738:}
        -: 4739:
        -: 4740:
        -: 4741:static int
    #####: 4742:test_xmlSAX2IsStandalone(void) {
    #####: 4743:    int test_ret = 0;
        -: 4744:
        -: 4745:    int mem_base;
        -: 4746:    int ret_val;
        -: 4747:    void * ctx; /* the user data (XML parser context) */
        -: 4748:    int n_ctx;
        -: 4749:
    #####: 4750:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####: 4751:        mem_base = xmlMemBlocks();
    #####: 4752:        ctx = gen_void_ptr(n_ctx, 0);
        -: 4753:
    #####: 4754:        ret_val = xmlSAX2IsStandalone(ctx);
    #####: 4755:        desret_int(ret_val);
    #####: 4756:        call_tests++;
    #####: 4757:        des_void_ptr(n_ctx, ctx, 0);
    #####: 4758:        xmlResetLastError();
    #####: 4759:        if (mem_base != xmlMemBlocks()) {
    #####: 4760:            printf("Leak of %d blocks found in xmlSAX2IsStandalone",
    #####: 4761:	           xmlMemBlocks() - mem_base);
    #####: 4762:	    test_ret++;
    #####: 4763:            printf(" %d", n_ctx);
    #####: 4764:            printf("\n");
        -: 4765:        }
        -: 4766:    }
    #####: 4767:    function_tests++;
        -: 4768:
    #####: 4769:    return(test_ret);
        -: 4770:}
        -: 4771:
        -: 4772:
        -: 4773:static int
    #####: 4774:test_xmlSAX2NotationDecl(void) {
    #####: 4775:    int test_ret = 0;
        -: 4776:
        -: 4777:    int mem_base;
        -: 4778:    void * ctx; /* the user data (XML parser context) */
        -: 4779:    int n_ctx;
        -: 4780:    xmlChar * name; /* The name of the notation */
        -: 4781:    int n_name;
        -: 4782:    xmlChar * publicId; /* The public ID of the entity */
        -: 4783:    int n_publicId;
        -: 4784:    xmlChar * systemId; /* The system ID of the entity */
        -: 4785:    int n_systemId;
        -: 4786:
    #####: 4787:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####: 4788:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####: 4789:    for (n_publicId = 0;n_publicId < gen_nb_const_xmlChar_ptr;n_publicId++) {
    #####: 4790:    for (n_systemId = 0;n_systemId < gen_nb_const_xmlChar_ptr;n_systemId++) {
    #####: 4791:        mem_base = xmlMemBlocks();
    #####: 4792:        ctx = gen_void_ptr(n_ctx, 0);
    #####: 4793:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####: 4794:        publicId = gen_const_xmlChar_ptr(n_publicId, 2);
    #####: 4795:        systemId = gen_const_xmlChar_ptr(n_systemId, 3);
        -: 4796:
    #####: 4797:        xmlSAX2NotationDecl(ctx, (const xmlChar *)name, (const xmlChar *)publicId, (const xmlChar *)systemId);
    #####: 4798:        call_tests++;
    #####: 4799:        des_void_ptr(n_ctx, ctx, 0);
    #####: 4800:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####: 4801:        des_const_xmlChar_ptr(n_publicId, (const xmlChar *)publicId, 2);
    #####: 4802:        des_const_xmlChar_ptr(n_systemId, (const xmlChar *)systemId, 3);
    #####: 4803:        xmlResetLastError();
    #####: 4804:        if (mem_base != xmlMemBlocks()) {
    #####: 4805:            printf("Leak of %d blocks found in xmlSAX2NotationDecl",
    #####: 4806:	           xmlMemBlocks() - mem_base);
    #####: 4807:	    test_ret++;
    #####: 4808:            printf(" %d", n_ctx);
    #####: 4809:            printf(" %d", n_name);
    #####: 4810:            printf(" %d", n_publicId);
    #####: 4811:            printf(" %d", n_systemId);
    #####: 4812:            printf("\n");
        -: 4813:        }
        -: 4814:    }
        -: 4815:    }
        -: 4816:    }
        -: 4817:    }
    #####: 4818:    function_tests++;
        -: 4819:
    #####: 4820:    return(test_ret);
        -: 4821:}
        -: 4822:
        -: 4823:
        -: 4824:static int
    #####: 4825:test_xmlSAX2ProcessingInstruction(void) {
    #####: 4826:    int test_ret = 0;
        -: 4827:
        -: 4828:    int mem_base;
        -: 4829:    void * ctx; /* the user data (XML parser context) */
        -: 4830:    int n_ctx;
        -: 4831:    xmlChar * target; /* the target name */
        -: 4832:    int n_target;
        -: 4833:    xmlChar * data; /* the PI data's */
        -: 4834:    int n_data;
        -: 4835:
    #####: 4836:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####: 4837:    for (n_target = 0;n_target < gen_nb_const_xmlChar_ptr;n_target++) {
    #####: 4838:    for (n_data = 0;n_data < gen_nb_const_xmlChar_ptr;n_data++) {
    #####: 4839:        mem_base = xmlMemBlocks();
    #####: 4840:        ctx = gen_void_ptr(n_ctx, 0);
    #####: 4841:        target = gen_const_xmlChar_ptr(n_target, 1);
    #####: 4842:        data = gen_const_xmlChar_ptr(n_data, 2);
        -: 4843:
    #####: 4844:        xmlSAX2ProcessingInstruction(ctx, (const xmlChar *)target, (const xmlChar *)data);
    #####: 4845:        call_tests++;
    #####: 4846:        des_void_ptr(n_ctx, ctx, 0);
    #####: 4847:        des_const_xmlChar_ptr(n_target, (const xmlChar *)target, 1);
    #####: 4848:        des_const_xmlChar_ptr(n_data, (const xmlChar *)data, 2);
    #####: 4849:        xmlResetLastError();
    #####: 4850:        if (mem_base != xmlMemBlocks()) {
    #####: 4851:            printf("Leak of %d blocks found in xmlSAX2ProcessingInstruction",
    #####: 4852:	           xmlMemBlocks() - mem_base);
    #####: 4853:	    test_ret++;
    #####: 4854:            printf(" %d", n_ctx);
    #####: 4855:            printf(" %d", n_target);
    #####: 4856:            printf(" %d", n_data);
    #####: 4857:            printf("\n");
        -: 4858:        }
        -: 4859:    }
        -: 4860:    }
        -: 4861:    }
    #####: 4862:    function_tests++;
        -: 4863:
    #####: 4864:    return(test_ret);
        -: 4865:}
        -: 4866:
        -: 4867:
        -: 4868:static int
    #####: 4869:test_xmlSAX2Reference(void) {
    #####: 4870:    int test_ret = 0;
        -: 4871:
        -: 4872:    int mem_base;
        -: 4873:    void * ctx; /* the user data (XML parser context) */
        -: 4874:    int n_ctx;
        -: 4875:    xmlChar * name; /* The entity name */
        -: 4876:    int n_name;
        -: 4877:
    #####: 4878:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####: 4879:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####: 4880:        mem_base = xmlMemBlocks();
    #####: 4881:        ctx = gen_void_ptr(n_ctx, 0);
    #####: 4882:        name = gen_const_xmlChar_ptr(n_name, 1);
        -: 4883:
    #####: 4884:        xmlSAX2Reference(ctx, (const xmlChar *)name);
    #####: 4885:        call_tests++;
    #####: 4886:        des_void_ptr(n_ctx, ctx, 0);
    #####: 4887:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####: 4888:        xmlResetLastError();
    #####: 4889:        if (mem_base != xmlMemBlocks()) {
    #####: 4890:            printf("Leak of %d blocks found in xmlSAX2Reference",
    #####: 4891:	           xmlMemBlocks() - mem_base);
    #####: 4892:	    test_ret++;
    #####: 4893:            printf(" %d", n_ctx);
    #####: 4894:            printf(" %d", n_name);
    #####: 4895:            printf("\n");
        -: 4896:        }
        -: 4897:    }
        -: 4898:    }
    #####: 4899:    function_tests++;
        -: 4900:
    #####: 4901:    return(test_ret);
        -: 4902:}
        -: 4903:
        -: 4904:
        -: 4905:static int
    #####: 4906:test_xmlSAX2ResolveEntity(void) {
    #####: 4907:    int test_ret = 0;
        -: 4908:
        -: 4909:    int mem_base;
        -: 4910:    xmlParserInputPtr ret_val;
        -: 4911:    void * ctx; /* the user data (XML parser context) */
        -: 4912:    int n_ctx;
        -: 4913:    xmlChar * publicId; /* The public ID of the entity */
        -: 4914:    int n_publicId;
        -: 4915:    xmlChar * systemId; /* The system ID of the entity */
        -: 4916:    int n_systemId;
        -: 4917:
    #####: 4918:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####: 4919:    for (n_publicId = 0;n_publicId < gen_nb_const_xmlChar_ptr;n_publicId++) {
    #####: 4920:    for (n_systemId = 0;n_systemId < gen_nb_const_xmlChar_ptr;n_systemId++) {
    #####: 4921:        mem_base = xmlMemBlocks();
    #####: 4922:        ctx = gen_void_ptr(n_ctx, 0);
    #####: 4923:        publicId = gen_const_xmlChar_ptr(n_publicId, 1);
    #####: 4924:        systemId = gen_const_xmlChar_ptr(n_systemId, 2);
        -: 4925:
    #####: 4926:        ret_val = xmlSAX2ResolveEntity(ctx, (const xmlChar *)publicId, (const xmlChar *)systemId);
    #####: 4927:        desret_xmlParserInputPtr(ret_val);
    #####: 4928:        call_tests++;
    #####: 4929:        des_void_ptr(n_ctx, ctx, 0);
    #####: 4930:        des_const_xmlChar_ptr(n_publicId, (const xmlChar *)publicId, 1);
    #####: 4931:        des_const_xmlChar_ptr(n_systemId, (const xmlChar *)systemId, 2);
    #####: 4932:        xmlResetLastError();
    #####: 4933:        if (mem_base != xmlMemBlocks()) {
    #####: 4934:            printf("Leak of %d blocks found in xmlSAX2ResolveEntity",
    #####: 4935:	           xmlMemBlocks() - mem_base);
    #####: 4936:	    test_ret++;
    #####: 4937:            printf(" %d", n_ctx);
    #####: 4938:            printf(" %d", n_publicId);
    #####: 4939:            printf(" %d", n_systemId);
    #####: 4940:            printf("\n");
        -: 4941:        }
        -: 4942:    }
        -: 4943:    }
        -: 4944:    }
    #####: 4945:    function_tests++;
        -: 4946:
    #####: 4947:    return(test_ret);
        -: 4948:}
        -: 4949:
        -: 4950:
        -: 4951:#define gen_nb_xmlSAXLocatorPtr 1
    #####: 4952:static xmlSAXLocatorPtr gen_xmlSAXLocatorPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 4953:    return(NULL);
        -: 4954:}
    #####: 4955:static void des_xmlSAXLocatorPtr(int no ATTRIBUTE_UNUSED, xmlSAXLocatorPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 4956:}
        -: 4957:
        -: 4958:static int
    #####: 4959:test_xmlSAX2SetDocumentLocator(void) {
    #####: 4960:    int test_ret = 0;
        -: 4961:
        -: 4962:    int mem_base;
        -: 4963:    void * ctx; /* the user data (XML parser context) */
        -: 4964:    int n_ctx;
        -: 4965:    xmlSAXLocatorPtr loc; /* A SAX Locator */
        -: 4966:    int n_loc;
        -: 4967:
    #####: 4968:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####: 4969:    for (n_loc = 0;n_loc < gen_nb_xmlSAXLocatorPtr;n_loc++) {
    #####: 4970:        mem_base = xmlMemBlocks();
    #####: 4971:        ctx = gen_void_ptr(n_ctx, 0);
    #####: 4972:        loc = gen_xmlSAXLocatorPtr(n_loc, 1);
        -: 4973:
    #####: 4974:        xmlSAX2SetDocumentLocator(ctx, loc);
    #####: 4975:        call_tests++;
    #####: 4976:        des_void_ptr(n_ctx, ctx, 0);
    #####: 4977:        des_xmlSAXLocatorPtr(n_loc, loc, 1);
    #####: 4978:        xmlResetLastError();
    #####: 4979:        if (mem_base != xmlMemBlocks()) {
    #####: 4980:            printf("Leak of %d blocks found in xmlSAX2SetDocumentLocator",
    #####: 4981:	           xmlMemBlocks() - mem_base);
    #####: 4982:	    test_ret++;
    #####: 4983:            printf(" %d", n_ctx);
    #####: 4984:            printf(" %d", n_loc);
    #####: 4985:            printf("\n");
        -: 4986:        }
        -: 4987:    }
        -: 4988:    }
    #####: 4989:    function_tests++;
        -: 4990:
    #####: 4991:    return(test_ret);
        -: 4992:}
        -: 4993:
        -: 4994:
        -: 4995:static int
    #####: 4996:test_xmlSAX2StartDocument(void) {
    #####: 4997:    int test_ret = 0;
        -: 4998:
        -: 4999:    int mem_base;
        -: 5000:    void * ctx; /* the user data (XML parser context) */
        -: 5001:    int n_ctx;
        -: 5002:
    #####: 5003:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####: 5004:        mem_base = xmlMemBlocks();
    #####: 5005:        ctx = gen_void_ptr(n_ctx, 0);
        -: 5006:
    #####: 5007:        xmlSAX2StartDocument(ctx);
    #####: 5008:        call_tests++;
    #####: 5009:        des_void_ptr(n_ctx, ctx, 0);
    #####: 5010:        xmlResetLastError();
    #####: 5011:        if (mem_base != xmlMemBlocks()) {
    #####: 5012:            printf("Leak of %d blocks found in xmlSAX2StartDocument",
    #####: 5013:	           xmlMemBlocks() - mem_base);
    #####: 5014:	    test_ret++;
    #####: 5015:            printf(" %d", n_ctx);
    #####: 5016:            printf("\n");
        -: 5017:        }
        -: 5018:    }
    #####: 5019:    function_tests++;
        -: 5020:
    #####: 5021:    return(test_ret);
        -: 5022:}
        -: 5023:
        -: 5024:
        -: 5025:static int
    #####: 5026:test_xmlSAX2StartElement(void) {
    #####: 5027:    int test_ret = 0;
        -: 5028:
        -: 5029:#if defined(LIBXML_SAX1_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_WRITER_ENABLED) || defined(LIBXML_DOCB_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
        -: 5030:#ifdef LIBXML_SAX1_ENABLED
        -: 5031:    int mem_base;
        -: 5032:    void * ctx; /* the user data (XML parser context) */
        -: 5033:    int n_ctx;
        -: 5034:    xmlChar * fullname; /* The element name, including namespace prefix */
        -: 5035:    int n_fullname;
        -: 5036:    xmlChar ** atts; /* An array of name/value attributes pairs, NULL terminated */
        -: 5037:    int n_atts;
        -: 5038:
    #####: 5039:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####: 5040:    for (n_fullname = 0;n_fullname < gen_nb_const_xmlChar_ptr;n_fullname++) {
    #####: 5041:    for (n_atts = 0;n_atts < gen_nb_const_xmlChar_ptr_ptr;n_atts++) {
    #####: 5042:        mem_base = xmlMemBlocks();
    #####: 5043:        ctx = gen_void_ptr(n_ctx, 0);
    #####: 5044:        fullname = gen_const_xmlChar_ptr(n_fullname, 1);
    #####: 5045:        atts = gen_const_xmlChar_ptr_ptr(n_atts, 2);
        -: 5046:
    #####: 5047:        xmlSAX2StartElement(ctx, (const xmlChar *)fullname, (const xmlChar **)atts);
    #####: 5048:        call_tests++;
    #####: 5049:        des_void_ptr(n_ctx, ctx, 0);
    #####: 5050:        des_const_xmlChar_ptr(n_fullname, (const xmlChar *)fullname, 1);
    #####: 5051:        des_const_xmlChar_ptr_ptr(n_atts, (const xmlChar **)atts, 2);
    #####: 5052:        xmlResetLastError();
    #####: 5053:        if (mem_base != xmlMemBlocks()) {
    #####: 5054:            printf("Leak of %d blocks found in xmlSAX2StartElement",
    #####: 5055:	           xmlMemBlocks() - mem_base);
    #####: 5056:	    test_ret++;
    #####: 5057:            printf(" %d", n_ctx);
    #####: 5058:            printf(" %d", n_fullname);
    #####: 5059:            printf(" %d", n_atts);
    #####: 5060:            printf("\n");
        -: 5061:        }
        -: 5062:    }
        -: 5063:    }
        -: 5064:    }
    #####: 5065:    function_tests++;
        -: 5066:#endif
        -: 5067:#endif
        -: 5068:
    #####: 5069:    return(test_ret);
        -: 5070:}
        -: 5071:
        -: 5072:
        -: 5073:static int
    #####: 5074:test_xmlSAX2StartElementNs(void) {
    #####: 5075:    int test_ret = 0;
        -: 5076:
        -: 5077:    int mem_base;
        -: 5078:    void * ctx; /* the user data (XML parser context) */
        -: 5079:    int n_ctx;
        -: 5080:    xmlChar * localname; /* the local name of the element */
        -: 5081:    int n_localname;
        -: 5082:    xmlChar * prefix; /* the element namespace prefix if available */
        -: 5083:    int n_prefix;
        -: 5084:    xmlChar * URI; /* the element namespace name if available */
        -: 5085:    int n_URI;
        -: 5086:    int nb_namespaces; /* number of namespace definitions on that node */
        -: 5087:    int n_nb_namespaces;
        -: 5088:    xmlChar ** namespaces; /* pointer to the array of prefix/URI pairs namespace definitions */
        -: 5089:    int n_namespaces;
        -: 5090:    int nb_attributes; /* the number of attributes on that node */
        -: 5091:    int n_nb_attributes;
        -: 5092:    int nb_defaulted; /* the number of defaulted attributes. */
        -: 5093:    int n_nb_defaulted;
        -: 5094:    xmlChar ** attributes; /* pointer to the array of (localname/prefix/URI/value/end) attribute values. */
        -: 5095:    int n_attributes;
        -: 5096:
    #####: 5097:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####: 5098:    for (n_localname = 0;n_localname < gen_nb_const_xmlChar_ptr;n_localname++) {
    #####: 5099:    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    #####: 5100:    for (n_URI = 0;n_URI < gen_nb_const_xmlChar_ptr;n_URI++) {
    #####: 5101:    for (n_nb_namespaces = 0;n_nb_namespaces < gen_nb_int;n_nb_namespaces++) {
    #####: 5102:    for (n_namespaces = 0;n_namespaces < gen_nb_const_xmlChar_ptr_ptr;n_namespaces++) {
    #####: 5103:    for (n_nb_attributes = 0;n_nb_attributes < gen_nb_int;n_nb_attributes++) {
    #####: 5104:    for (n_nb_defaulted = 0;n_nb_defaulted < gen_nb_int;n_nb_defaulted++) {
    #####: 5105:    for (n_attributes = 0;n_attributes < gen_nb_const_xmlChar_ptr_ptr;n_attributes++) {
    #####: 5106:        mem_base = xmlMemBlocks();
    #####: 5107:        ctx = gen_void_ptr(n_ctx, 0);
    #####: 5108:        localname = gen_const_xmlChar_ptr(n_localname, 1);
    #####: 5109:        prefix = gen_const_xmlChar_ptr(n_prefix, 2);
    #####: 5110:        URI = gen_const_xmlChar_ptr(n_URI, 3);
    #####: 5111:        nb_namespaces = gen_int(n_nb_namespaces, 4);
    #####: 5112:        namespaces = gen_const_xmlChar_ptr_ptr(n_namespaces, 5);
    #####: 5113:        nb_attributes = gen_int(n_nb_attributes, 6);
    #####: 5114:        nb_defaulted = gen_int(n_nb_defaulted, 7);
    #####: 5115:        attributes = gen_const_xmlChar_ptr_ptr(n_attributes, 8);
        -: 5116:
    #####: 5117:        xmlSAX2StartElementNs(ctx, (const xmlChar *)localname, (const xmlChar *)prefix, (const xmlChar *)URI, nb_namespaces, (const xmlChar **)namespaces, nb_attributes, nb_defaulted, (const xmlChar **)attributes);
    #####: 5118:        call_tests++;
    #####: 5119:        des_void_ptr(n_ctx, ctx, 0);
    #####: 5120:        des_const_xmlChar_ptr(n_localname, (const xmlChar *)localname, 1);
    #####: 5121:        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 2);
    #####: 5122:        des_const_xmlChar_ptr(n_URI, (const xmlChar *)URI, 3);
    #####: 5123:        des_int(n_nb_namespaces, nb_namespaces, 4);
    #####: 5124:        des_const_xmlChar_ptr_ptr(n_namespaces, (const xmlChar **)namespaces, 5);
    #####: 5125:        des_int(n_nb_attributes, nb_attributes, 6);
    #####: 5126:        des_int(n_nb_defaulted, nb_defaulted, 7);
    #####: 5127:        des_const_xmlChar_ptr_ptr(n_attributes, (const xmlChar **)attributes, 8);
    #####: 5128:        xmlResetLastError();
    #####: 5129:        if (mem_base != xmlMemBlocks()) {
    #####: 5130:            printf("Leak of %d blocks found in xmlSAX2StartElementNs",
    #####: 5131:	           xmlMemBlocks() - mem_base);
    #####: 5132:	    test_ret++;
    #####: 5133:            printf(" %d", n_ctx);
    #####: 5134:            printf(" %d", n_localname);
    #####: 5135:            printf(" %d", n_prefix);
    #####: 5136:            printf(" %d", n_URI);
    #####: 5137:            printf(" %d", n_nb_namespaces);
    #####: 5138:            printf(" %d", n_namespaces);
    #####: 5139:            printf(" %d", n_nb_attributes);
    #####: 5140:            printf(" %d", n_nb_defaulted);
    #####: 5141:            printf(" %d", n_attributes);
    #####: 5142:            printf("\n");
        -: 5143:        }
        -: 5144:    }
        -: 5145:    }
        -: 5146:    }
        -: 5147:    }
        -: 5148:    }
        -: 5149:    }
        -: 5150:    }
        -: 5151:    }
        -: 5152:    }
    #####: 5153:    function_tests++;
        -: 5154:
    #####: 5155:    return(test_ret);
        -: 5156:}
        -: 5157:
        -: 5158:
        -: 5159:static int
    #####: 5160:test_xmlSAX2UnparsedEntityDecl(void) {
    #####: 5161:    int test_ret = 0;
        -: 5162:
        -: 5163:    int mem_base;
        -: 5164:    void * ctx; /* the user data (XML parser context) */
        -: 5165:    int n_ctx;
        -: 5166:    xmlChar * name; /* The name of the entity */
        -: 5167:    int n_name;
        -: 5168:    xmlChar * publicId; /* The public ID of the entity */
        -: 5169:    int n_publicId;
        -: 5170:    xmlChar * systemId; /* The system ID of the entity */
        -: 5171:    int n_systemId;
        -: 5172:    xmlChar * notationName; /* the name of the notation */
        -: 5173:    int n_notationName;
        -: 5174:
    #####: 5175:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####: 5176:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####: 5177:    for (n_publicId = 0;n_publicId < gen_nb_const_xmlChar_ptr;n_publicId++) {
    #####: 5178:    for (n_systemId = 0;n_systemId < gen_nb_const_xmlChar_ptr;n_systemId++) {
    #####: 5179:    for (n_notationName = 0;n_notationName < gen_nb_const_xmlChar_ptr;n_notationName++) {
    #####: 5180:        mem_base = xmlMemBlocks();
    #####: 5181:        ctx = gen_void_ptr(n_ctx, 0);
    #####: 5182:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####: 5183:        publicId = gen_const_xmlChar_ptr(n_publicId, 2);
    #####: 5184:        systemId = gen_const_xmlChar_ptr(n_systemId, 3);
    #####: 5185:        notationName = gen_const_xmlChar_ptr(n_notationName, 4);
        -: 5186:
    #####: 5187:        xmlSAX2UnparsedEntityDecl(ctx, (const xmlChar *)name, (const xmlChar *)publicId, (const xmlChar *)systemId, (const xmlChar *)notationName);
    #####: 5188:        call_tests++;
    #####: 5189:        des_void_ptr(n_ctx, ctx, 0);
    #####: 5190:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####: 5191:        des_const_xmlChar_ptr(n_publicId, (const xmlChar *)publicId, 2);
    #####: 5192:        des_const_xmlChar_ptr(n_systemId, (const xmlChar *)systemId, 3);
    #####: 5193:        des_const_xmlChar_ptr(n_notationName, (const xmlChar *)notationName, 4);
    #####: 5194:        xmlResetLastError();
    #####: 5195:        if (mem_base != xmlMemBlocks()) {
    #####: 5196:            printf("Leak of %d blocks found in xmlSAX2UnparsedEntityDecl",
    #####: 5197:	           xmlMemBlocks() - mem_base);
    #####: 5198:	    test_ret++;
    #####: 5199:            printf(" %d", n_ctx);
    #####: 5200:            printf(" %d", n_name);
    #####: 5201:            printf(" %d", n_publicId);
    #####: 5202:            printf(" %d", n_systemId);
    #####: 5203:            printf(" %d", n_notationName);
    #####: 5204:            printf("\n");
        -: 5205:        }
        -: 5206:    }
        -: 5207:    }
        -: 5208:    }
        -: 5209:    }
        -: 5210:    }
    #####: 5211:    function_tests++;
        -: 5212:
    #####: 5213:    return(test_ret);
        -: 5214:}
        -: 5215:
        -: 5216:
        -: 5217:static int
    #####: 5218:test_xmlSAXDefaultVersion(void) {
    #####: 5219:    int test_ret = 0;
        -: 5220:
        -: 5221:#if defined(LIBXML_SAX1_ENABLED)
        -: 5222:#ifdef LIBXML_SAX1_ENABLED
        -: 5223:    int mem_base;
        -: 5224:    int ret_val;
        -: 5225:    int version; /* the version, 1 or 2 */
        -: 5226:    int n_version;
        -: 5227:
    #####: 5228:    for (n_version = 0;n_version < gen_nb_int;n_version++) {
    #####: 5229:        mem_base = xmlMemBlocks();
    #####: 5230:        version = gen_int(n_version, 0);
        -: 5231:
    #####: 5232:        ret_val = xmlSAXDefaultVersion(version);
    #####: 5233:        desret_int(ret_val);
    #####: 5234:        call_tests++;
    #####: 5235:        des_int(n_version, version, 0);
    #####: 5236:        xmlResetLastError();
    #####: 5237:        if (mem_base != xmlMemBlocks()) {
    #####: 5238:            printf("Leak of %d blocks found in xmlSAXDefaultVersion",
    #####: 5239:	           xmlMemBlocks() - mem_base);
    #####: 5240:	    test_ret++;
    #####: 5241:            printf(" %d", n_version);
    #####: 5242:            printf("\n");
        -: 5243:        }
        -: 5244:    }
    #####: 5245:    function_tests++;
        -: 5246:#endif
        -: 5247:#endif
        -: 5248:
    #####: 5249:    return(test_ret);
        -: 5250:}
        -: 5251:
        -: 5252:
        -: 5253:static int
    #####: 5254:test_xmlSAXVersion(void) {
    #####: 5255:    int test_ret = 0;
        -: 5256:
        -: 5257:    int mem_base;
        -: 5258:    int ret_val;
        -: 5259:    xmlSAXHandler * hdlr; /* the SAX handler */
        -: 5260:    int n_hdlr;
        -: 5261:    int version; /* the version, 1 or 2 */
        -: 5262:    int n_version;
        -: 5263:
    #####: 5264:    for (n_hdlr = 0;n_hdlr < gen_nb_xmlSAXHandler_ptr;n_hdlr++) {
    #####: 5265:    for (n_version = 0;n_version < gen_nb_int;n_version++) {
    #####: 5266:        mem_base = xmlMemBlocks();
    #####: 5267:        hdlr = gen_xmlSAXHandler_ptr(n_hdlr, 0);
    #####: 5268:        version = gen_int(n_version, 1);
        -: 5269:
    #####: 5270:        ret_val = xmlSAXVersion(hdlr, version);
    #####: 5271:        desret_int(ret_val);
    #####: 5272:        call_tests++;
    #####: 5273:        des_xmlSAXHandler_ptr(n_hdlr, hdlr, 0);
    #####: 5274:        des_int(n_version, version, 1);
    #####: 5275:        xmlResetLastError();
    #####: 5276:        if (mem_base != xmlMemBlocks()) {
    #####: 5277:            printf("Leak of %d blocks found in xmlSAXVersion",
    #####: 5278:	           xmlMemBlocks() - mem_base);
    #####: 5279:	    test_ret++;
    #####: 5280:            printf(" %d", n_hdlr);
    #####: 5281:            printf(" %d", n_version);
    #####: 5282:            printf("\n");
        -: 5283:        }
        -: 5284:    }
        -: 5285:    }
    #####: 5286:    function_tests++;
        -: 5287:
    #####: 5288:    return(test_ret);
        -: 5289:}
        -: 5290:
        -: 5291:static int
    #####: 5292:test_SAX2(void) {
    #####: 5293:    int test_ret = 0;
        -: 5294:
    #####: 5295:    if (quiet == 0) printf("Testing SAX2 : 38 of 38 functions ...\n");
    #####: 5296:    test_ret += test_docbDefaultSAXHandlerInit();
    #####: 5297:    test_ret += test_htmlDefaultSAXHandlerInit();
    #####: 5298:    test_ret += test_xmlDefaultSAXHandlerInit();
    #####: 5299:    test_ret += test_xmlSAX2AttributeDecl();
    #####: 5300:    test_ret += test_xmlSAX2CDataBlock();
    #####: 5301:    test_ret += test_xmlSAX2Characters();
    #####: 5302:    test_ret += test_xmlSAX2Comment();
    #####: 5303:    test_ret += test_xmlSAX2ElementDecl();
    #####: 5304:    test_ret += test_xmlSAX2EndDocument();
    #####: 5305:    test_ret += test_xmlSAX2EndElement();
    #####: 5306:    test_ret += test_xmlSAX2EndElementNs();
    #####: 5307:    test_ret += test_xmlSAX2EntityDecl();
    #####: 5308:    test_ret += test_xmlSAX2ExternalSubset();
    #####: 5309:    test_ret += test_xmlSAX2GetColumnNumber();
    #####: 5310:    test_ret += test_xmlSAX2GetEntity();
    #####: 5311:    test_ret += test_xmlSAX2GetLineNumber();
    #####: 5312:    test_ret += test_xmlSAX2GetParameterEntity();
    #####: 5313:    test_ret += test_xmlSAX2GetPublicId();
    #####: 5314:    test_ret += test_xmlSAX2GetSystemId();
    #####: 5315:    test_ret += test_xmlSAX2HasExternalSubset();
    #####: 5316:    test_ret += test_xmlSAX2HasInternalSubset();
    #####: 5317:    test_ret += test_xmlSAX2IgnorableWhitespace();
    #####: 5318:    test_ret += test_xmlSAX2InitDefaultSAXHandler();
    #####: 5319:    test_ret += test_xmlSAX2InitDocbDefaultSAXHandler();
    #####: 5320:    test_ret += test_xmlSAX2InitHtmlDefaultSAXHandler();
    #####: 5321:    test_ret += test_xmlSAX2InternalSubset();
    #####: 5322:    test_ret += test_xmlSAX2IsStandalone();
    #####: 5323:    test_ret += test_xmlSAX2NotationDecl();
    #####: 5324:    test_ret += test_xmlSAX2ProcessingInstruction();
    #####: 5325:    test_ret += test_xmlSAX2Reference();
    #####: 5326:    test_ret += test_xmlSAX2ResolveEntity();
    #####: 5327:    test_ret += test_xmlSAX2SetDocumentLocator();
    #####: 5328:    test_ret += test_xmlSAX2StartDocument();
    #####: 5329:    test_ret += test_xmlSAX2StartElement();
    #####: 5330:    test_ret += test_xmlSAX2StartElementNs();
    #####: 5331:    test_ret += test_xmlSAX2UnparsedEntityDecl();
    #####: 5332:    test_ret += test_xmlSAXDefaultVersion();
    #####: 5333:    test_ret += test_xmlSAXVersion();
        -: 5334:
    #####: 5335:    if (test_ret != 0)
    #####: 5336:	printf("Module SAX2: %d errors\n", test_ret);
    #####: 5337:    return(test_ret);
        -: 5338:}
        -: 5339:
        -: 5340:static int
    #####: 5341:test_xmlC14NDocDumpMemory(void) {
    #####: 5342:    int test_ret = 0;
        -: 5343:
        -: 5344:#if defined(LIBXML_C14N_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
        -: 5345:    int mem_base;
        -: 5346:    int ret_val;
        -: 5347:    xmlDocPtr doc; /* the XML document for canonization */
        -: 5348:    int n_doc;
        -: 5349:    xmlNodeSetPtr nodes; /* the nodes set to be included in the canonized image or NULL if all document nodes should be included */
        -: 5350:    int n_nodes;
        -: 5351:    int mode; /* the c14n mode (see @xmlC14NMode) */
        -: 5352:    int n_mode;
        -: 5353:    xmlChar ** inclusive_ns_prefixes; /* the list of inclusive namespace prefixes ended with a NULL or NULL if there is no inclusive namespaces (only for exclusive canonicalization, ignored otherwise) */
        -: 5354:    int n_inclusive_ns_prefixes;
        -: 5355:    int with_comments; /* include comments in the result (!=0) or not (==0) */
        -: 5356:    int n_with_comments;
        -: 5357:    xmlChar ** doc_txt_ptr; /* the memory pointer for allocated canonical XML text; the caller of this functions is responsible for calling xmlFree() to free allocated memory */
        -: 5358:    int n_doc_txt_ptr;
        -: 5359:
    #####: 5360:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####: 5361:    for (n_nodes = 0;n_nodes < gen_nb_xmlNodeSetPtr;n_nodes++) {
    #####: 5362:    for (n_mode = 0;n_mode < gen_nb_int;n_mode++) {
    #####: 5363:    for (n_inclusive_ns_prefixes = 0;n_inclusive_ns_prefixes < gen_nb_xmlChar_ptr_ptr;n_inclusive_ns_prefixes++) {
    #####: 5364:    for (n_with_comments = 0;n_with_comments < gen_nb_int;n_with_comments++) {
    #####: 5365:    for (n_doc_txt_ptr = 0;n_doc_txt_ptr < gen_nb_xmlChar_ptr_ptr;n_doc_txt_ptr++) {
    #####: 5366:        mem_base = xmlMemBlocks();
    #####: 5367:        doc = gen_xmlDocPtr(n_doc, 0);
    #####: 5368:        nodes = gen_xmlNodeSetPtr(n_nodes, 1);
    #####: 5369:        mode = gen_int(n_mode, 2);
    #####: 5370:        inclusive_ns_prefixes = gen_xmlChar_ptr_ptr(n_inclusive_ns_prefixes, 3);
    #####: 5371:        with_comments = gen_int(n_with_comments, 4);
    #####: 5372:        doc_txt_ptr = gen_xmlChar_ptr_ptr(n_doc_txt_ptr, 5);
        -: 5373:
    #####: 5374:        ret_val = xmlC14NDocDumpMemory(doc, nodes, mode, inclusive_ns_prefixes, with_comments, doc_txt_ptr);
    #####: 5375:        desret_int(ret_val);
    #####: 5376:        call_tests++;
    #####: 5377:        des_xmlDocPtr(n_doc, doc, 0);
    #####: 5378:        des_xmlNodeSetPtr(n_nodes, nodes, 1);
    #####: 5379:        des_int(n_mode, mode, 2);
    #####: 5380:        des_xmlChar_ptr_ptr(n_inclusive_ns_prefixes, inclusive_ns_prefixes, 3);
    #####: 5381:        des_int(n_with_comments, with_comments, 4);
    #####: 5382:        des_xmlChar_ptr_ptr(n_doc_txt_ptr, doc_txt_ptr, 5);
    #####: 5383:        xmlResetLastError();
    #####: 5384:        if (mem_base != xmlMemBlocks()) {
    #####: 5385:            printf("Leak of %d blocks found in xmlC14NDocDumpMemory",
    #####: 5386:	           xmlMemBlocks() - mem_base);
    #####: 5387:	    test_ret++;
    #####: 5388:            printf(" %d", n_doc);
    #####: 5389:            printf(" %d", n_nodes);
    #####: 5390:            printf(" %d", n_mode);
    #####: 5391:            printf(" %d", n_inclusive_ns_prefixes);
    #####: 5392:            printf(" %d", n_with_comments);
    #####: 5393:            printf(" %d", n_doc_txt_ptr);
    #####: 5394:            printf("\n");
        -: 5395:        }
        -: 5396:    }
        -: 5397:    }
        -: 5398:    }
        -: 5399:    }
        -: 5400:    }
        -: 5401:    }
    #####: 5402:    function_tests++;
        -: 5403:#endif
        -: 5404:
    #####: 5405:    return(test_ret);
        -: 5406:}
        -: 5407:
        -: 5408:
        -: 5409:static int
    #####: 5410:test_xmlC14NDocSave(void) {
    #####: 5411:    int test_ret = 0;
        -: 5412:
        -: 5413:#if defined(LIBXML_C14N_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
        -: 5414:    int mem_base;
        -: 5415:    int ret_val;
        -: 5416:    xmlDocPtr doc; /* the XML document for canonization */
        -: 5417:    int n_doc;
        -: 5418:    xmlNodeSetPtr nodes; /* the nodes set to be included in the canonized image or NULL if all document nodes should be included */
        -: 5419:    int n_nodes;
        -: 5420:    int mode; /* the c14n mode (see @xmlC14NMode) */
        -: 5421:    int n_mode;
        -: 5422:    xmlChar ** inclusive_ns_prefixes; /* the list of inclusive namespace prefixes ended with a NULL or NULL if there is no inclusive namespaces (only for exclusive canonicalization, ignored otherwise) */
        -: 5423:    int n_inclusive_ns_prefixes;
        -: 5424:    int with_comments; /* include comments in the result (!=0) or not (==0) */
        -: 5425:    int n_with_comments;
        -: 5426:    const char * filename; /* the filename to store canonical XML image */
        -: 5427:    int n_filename;
        -: 5428:    int compression; /* the compression level (zlib requred): -1 - libxml default, 0 - uncompressed, >0 - compression level */
        -: 5429:    int n_compression;
        -: 5430:
    #####: 5431:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####: 5432:    for (n_nodes = 0;n_nodes < gen_nb_xmlNodeSetPtr;n_nodes++) {
    #####: 5433:    for (n_mode = 0;n_mode < gen_nb_int;n_mode++) {
    #####: 5434:    for (n_inclusive_ns_prefixes = 0;n_inclusive_ns_prefixes < gen_nb_xmlChar_ptr_ptr;n_inclusive_ns_prefixes++) {
    #####: 5435:    for (n_with_comments = 0;n_with_comments < gen_nb_int;n_with_comments++) {
    #####: 5436:    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    #####: 5437:    for (n_compression = 0;n_compression < gen_nb_int;n_compression++) {
    #####: 5438:        mem_base = xmlMemBlocks();
    #####: 5439:        doc = gen_xmlDocPtr(n_doc, 0);
    #####: 5440:        nodes = gen_xmlNodeSetPtr(n_nodes, 1);
    #####: 5441:        mode = gen_int(n_mode, 2);
    #####: 5442:        inclusive_ns_prefixes = gen_xmlChar_ptr_ptr(n_inclusive_ns_prefixes, 3);
    #####: 5443:        with_comments = gen_int(n_with_comments, 4);
    #####: 5444:        filename = gen_fileoutput(n_filename, 5);
    #####: 5445:        compression = gen_int(n_compression, 6);
        -: 5446:
    #####: 5447:        ret_val = xmlC14NDocSave(doc, nodes, mode, inclusive_ns_prefixes, with_comments, filename, compression);
    #####: 5448:        desret_int(ret_val);
    #####: 5449:        call_tests++;
    #####: 5450:        des_xmlDocPtr(n_doc, doc, 0);
    #####: 5451:        des_xmlNodeSetPtr(n_nodes, nodes, 1);
    #####: 5452:        des_int(n_mode, mode, 2);
    #####: 5453:        des_xmlChar_ptr_ptr(n_inclusive_ns_prefixes, inclusive_ns_prefixes, 3);
    #####: 5454:        des_int(n_with_comments, with_comments, 4);
    #####: 5455:        des_fileoutput(n_filename, filename, 5);
    #####: 5456:        des_int(n_compression, compression, 6);
    #####: 5457:        xmlResetLastError();
    #####: 5458:        if (mem_base != xmlMemBlocks()) {
    #####: 5459:            printf("Leak of %d blocks found in xmlC14NDocSave",
    #####: 5460:	           xmlMemBlocks() - mem_base);
    #####: 5461:	    test_ret++;
    #####: 5462:            printf(" %d", n_doc);
    #####: 5463:            printf(" %d", n_nodes);
    #####: 5464:            printf(" %d", n_mode);
    #####: 5465:            printf(" %d", n_inclusive_ns_prefixes);
    #####: 5466:            printf(" %d", n_with_comments);
    #####: 5467:            printf(" %d", n_filename);
    #####: 5468:            printf(" %d", n_compression);
    #####: 5469:            printf("\n");
        -: 5470:        }
        -: 5471:    }
        -: 5472:    }
        -: 5473:    }
        -: 5474:    }
        -: 5475:    }
        -: 5476:    }
        -: 5477:    }
    #####: 5478:    function_tests++;
        -: 5479:#endif
        -: 5480:
    #####: 5481:    return(test_ret);
        -: 5482:}
        -: 5483:
        -: 5484:
        -: 5485:static int
    #####: 5486:test_xmlC14NDocSaveTo(void) {
    #####: 5487:    int test_ret = 0;
        -: 5488:
        -: 5489:#if defined(LIBXML_C14N_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
        -: 5490:    int mem_base;
        -: 5491:    int ret_val;
        -: 5492:    xmlDocPtr doc; /* the XML document for canonization */
        -: 5493:    int n_doc;
        -: 5494:    xmlNodeSetPtr nodes; /* the nodes set to be included in the canonized image or NULL if all document nodes should be included */
        -: 5495:    int n_nodes;
        -: 5496:    int mode; /* the c14n mode (see @xmlC14NMode) */
        -: 5497:    int n_mode;
        -: 5498:    xmlChar ** inclusive_ns_prefixes; /* the list of inclusive namespace prefixes ended with a NULL or NULL if there is no inclusive namespaces (only for exclusive canonicalization, ignored otherwise) */
        -: 5499:    int n_inclusive_ns_prefixes;
        -: 5500:    int with_comments; /* include comments in the result (!=0) or not (==0) */
        -: 5501:    int n_with_comments;
        -: 5502:    xmlOutputBufferPtr buf; /* the output buffer to store canonical XML; this buffer MUST have encoder==NULL because C14N requires UTF-8 output */
        -: 5503:    int n_buf;
        -: 5504:
    #####: 5505:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####: 5506:    for (n_nodes = 0;n_nodes < gen_nb_xmlNodeSetPtr;n_nodes++) {
    #####: 5507:    for (n_mode = 0;n_mode < gen_nb_int;n_mode++) {
    #####: 5508:    for (n_inclusive_ns_prefixes = 0;n_inclusive_ns_prefixes < gen_nb_xmlChar_ptr_ptr;n_inclusive_ns_prefixes++) {
    #####: 5509:    for (n_with_comments = 0;n_with_comments < gen_nb_int;n_with_comments++) {
    #####: 5510:    for (n_buf = 0;n_buf < gen_nb_xmlOutputBufferPtr;n_buf++) {
    #####: 5511:        mem_base = xmlMemBlocks();
    #####: 5512:        doc = gen_xmlDocPtr(n_doc, 0);
    #####: 5513:        nodes = gen_xmlNodeSetPtr(n_nodes, 1);
    #####: 5514:        mode = gen_int(n_mode, 2);
    #####: 5515:        inclusive_ns_prefixes = gen_xmlChar_ptr_ptr(n_inclusive_ns_prefixes, 3);
    #####: 5516:        with_comments = gen_int(n_with_comments, 4);
    #####: 5517:        buf = gen_xmlOutputBufferPtr(n_buf, 5);
        -: 5518:
    #####: 5519:        ret_val = xmlC14NDocSaveTo(doc, nodes, mode, inclusive_ns_prefixes, with_comments, buf);
    #####: 5520:        desret_int(ret_val);
    #####: 5521:        call_tests++;
    #####: 5522:        des_xmlDocPtr(n_doc, doc, 0);
    #####: 5523:        des_xmlNodeSetPtr(n_nodes, nodes, 1);
    #####: 5524:        des_int(n_mode, mode, 2);
    #####: 5525:        des_xmlChar_ptr_ptr(n_inclusive_ns_prefixes, inclusive_ns_prefixes, 3);
    #####: 5526:        des_int(n_with_comments, with_comments, 4);
    #####: 5527:        des_xmlOutputBufferPtr(n_buf, buf, 5);
    #####: 5528:        xmlResetLastError();
    #####: 5529:        if (mem_base != xmlMemBlocks()) {
    #####: 5530:            printf("Leak of %d blocks found in xmlC14NDocSaveTo",
    #####: 5531:	           xmlMemBlocks() - mem_base);
    #####: 5532:	    test_ret++;
    #####: 5533:            printf(" %d", n_doc);
    #####: 5534:            printf(" %d", n_nodes);
    #####: 5535:            printf(" %d", n_mode);
    #####: 5536:            printf(" %d", n_inclusive_ns_prefixes);
    #####: 5537:            printf(" %d", n_with_comments);
    #####: 5538:            printf(" %d", n_buf);
    #####: 5539:            printf("\n");
        -: 5540:        }
        -: 5541:    }
        -: 5542:    }
        -: 5543:    }
        -: 5544:    }
        -: 5545:    }
        -: 5546:    }
    #####: 5547:    function_tests++;
        -: 5548:#endif
        -: 5549:
    #####: 5550:    return(test_ret);
        -: 5551:}
        -: 5552:
        -: 5553:
        -: 5554:static int
    #####: 5555:test_xmlC14NExecute(void) {
    #####: 5556:    int test_ret = 0;
        -: 5557:
        -: 5558:
        -: 5559:    /* missing type support */
    #####: 5560:    return(test_ret);
        -: 5561:}
        -: 5562:
        -: 5563:static int
    #####: 5564:test_c14n(void) {
    #####: 5565:    int test_ret = 0;
        -: 5566:
    #####: 5567:    if (quiet == 0) printf("Testing c14n : 3 of 4 functions ...\n");
    #####: 5568:    test_ret += test_xmlC14NDocDumpMemory();
    #####: 5569:    test_ret += test_xmlC14NDocSave();
    #####: 5570:    test_ret += test_xmlC14NDocSaveTo();
    #####: 5571:    test_ret += test_xmlC14NExecute();
        -: 5572:
    #####: 5573:    if (test_ret != 0)
    #####: 5574:	printf("Module c14n: %d errors\n", test_ret);
    #####: 5575:    return(test_ret);
        -: 5576:}
        -: 5577:#ifdef LIBXML_CATALOG_ENABLED
        -: 5578:
        -: 5579:#define gen_nb_xmlCatalogPtr 1
    #####: 5580:static xmlCatalogPtr gen_xmlCatalogPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 5581:    return(NULL);
        -: 5582:}
    #####: 5583:static void des_xmlCatalogPtr(int no ATTRIBUTE_UNUSED, xmlCatalogPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 5584:}
        -: 5585:#endif
        -: 5586:
        -: 5587:
        -: 5588:static int
    #####: 5589:test_xmlACatalogAdd(void) {
    #####: 5590:    int test_ret = 0;
        -: 5591:
        -: 5592:#if defined(LIBXML_CATALOG_ENABLED)
        -: 5593:    int mem_base;
        -: 5594:    int ret_val;
        -: 5595:    xmlCatalogPtr catal; /* a Catalog */
        -: 5596:    int n_catal;
        -: 5597:    xmlChar * type; /* the type of record to add to the catalog */
        -: 5598:    int n_type;
        -: 5599:    xmlChar * orig; /* the system, public or prefix to match */
        -: 5600:    int n_orig;
        -: 5601:    xmlChar * replace; /* the replacement value for the match */
        -: 5602:    int n_replace;
        -: 5603:
    #####: 5604:    for (n_catal = 0;n_catal < gen_nb_xmlCatalogPtr;n_catal++) {
    #####: 5605:    for (n_type = 0;n_type < gen_nb_const_xmlChar_ptr;n_type++) {
    #####: 5606:    for (n_orig = 0;n_orig < gen_nb_const_xmlChar_ptr;n_orig++) {
    #####: 5607:    for (n_replace = 0;n_replace < gen_nb_const_xmlChar_ptr;n_replace++) {
    #####: 5608:        mem_base = xmlMemBlocks();
    #####: 5609:        catal = gen_xmlCatalogPtr(n_catal, 0);
    #####: 5610:        type = gen_const_xmlChar_ptr(n_type, 1);
    #####: 5611:        orig = gen_const_xmlChar_ptr(n_orig, 2);
    #####: 5612:        replace = gen_const_xmlChar_ptr(n_replace, 3);
        -: 5613:
    #####: 5614:        ret_val = xmlACatalogAdd(catal, (const xmlChar *)type, (const xmlChar *)orig, (const xmlChar *)replace);
    #####: 5615:        desret_int(ret_val);
    #####: 5616:        call_tests++;
    #####: 5617:        des_xmlCatalogPtr(n_catal, catal, 0);
    #####: 5618:        des_const_xmlChar_ptr(n_type, (const xmlChar *)type, 1);
    #####: 5619:        des_const_xmlChar_ptr(n_orig, (const xmlChar *)orig, 2);
    #####: 5620:        des_const_xmlChar_ptr(n_replace, (const xmlChar *)replace, 3);
    #####: 5621:        xmlResetLastError();
    #####: 5622:        if (mem_base != xmlMemBlocks()) {
    #####: 5623:            printf("Leak of %d blocks found in xmlACatalogAdd",
    #####: 5624:	           xmlMemBlocks() - mem_base);
    #####: 5625:	    test_ret++;
    #####: 5626:            printf(" %d", n_catal);
    #####: 5627:            printf(" %d", n_type);
    #####: 5628:            printf(" %d", n_orig);
    #####: 5629:            printf(" %d", n_replace);
    #####: 5630:            printf("\n");
        -: 5631:        }
        -: 5632:    }
        -: 5633:    }
        -: 5634:    }
        -: 5635:    }
    #####: 5636:    function_tests++;
        -: 5637:#endif
        -: 5638:
    #####: 5639:    return(test_ret);
        -: 5640:}
        -: 5641:
        -: 5642:
        -: 5643:static int
    #####: 5644:test_xmlACatalogDump(void) {
    #####: 5645:    int test_ret = 0;
        -: 5646:
        -: 5647:#if defined(LIBXML_CATALOG_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
        -: 5648:    int mem_base;
        -: 5649:    xmlCatalogPtr catal; /* a Catalog */
        -: 5650:    int n_catal;
        -: 5651:    FILE * out; /* the file. */
        -: 5652:    int n_out;
        -: 5653:
    #####: 5654:    for (n_catal = 0;n_catal < gen_nb_xmlCatalogPtr;n_catal++) {
    #####: 5655:    for (n_out = 0;n_out < gen_nb_FILE_ptr;n_out++) {
    #####: 5656:        mem_base = xmlMemBlocks();
    #####: 5657:        catal = gen_xmlCatalogPtr(n_catal, 0);
    #####: 5658:        out = gen_FILE_ptr(n_out, 1);
        -: 5659:
    #####: 5660:        xmlACatalogDump(catal, out);
    #####: 5661:        call_tests++;
    #####: 5662:        des_xmlCatalogPtr(n_catal, catal, 0);
    #####: 5663:        des_FILE_ptr(n_out, out, 1);
    #####: 5664:        xmlResetLastError();
    #####: 5665:        if (mem_base != xmlMemBlocks()) {
    #####: 5666:            printf("Leak of %d blocks found in xmlACatalogDump",
    #####: 5667:	           xmlMemBlocks() - mem_base);
    #####: 5668:	    test_ret++;
    #####: 5669:            printf(" %d", n_catal);
    #####: 5670:            printf(" %d", n_out);
    #####: 5671:            printf("\n");
        -: 5672:        }
        -: 5673:    }
        -: 5674:    }
    #####: 5675:    function_tests++;
        -: 5676:#endif
        -: 5677:
    #####: 5678:    return(test_ret);
        -: 5679:}
        -: 5680:
        -: 5681:
        -: 5682:static int
    #####: 5683:test_xmlACatalogRemove(void) {
    #####: 5684:    int test_ret = 0;
        -: 5685:
        -: 5686:#if defined(LIBXML_CATALOG_ENABLED)
        -: 5687:    int mem_base;
        -: 5688:    int ret_val;
        -: 5689:    xmlCatalogPtr catal; /* a Catalog */
        -: 5690:    int n_catal;
        -: 5691:    xmlChar * value; /* the value to remove */
        -: 5692:    int n_value;
        -: 5693:
    #####: 5694:    for (n_catal = 0;n_catal < gen_nb_xmlCatalogPtr;n_catal++) {
    #####: 5695:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####: 5696:        mem_base = xmlMemBlocks();
    #####: 5697:        catal = gen_xmlCatalogPtr(n_catal, 0);
    #####: 5698:        value = gen_const_xmlChar_ptr(n_value, 1);
        -: 5699:
    #####: 5700:        ret_val = xmlACatalogRemove(catal, (const xmlChar *)value);
    #####: 5701:        desret_int(ret_val);
    #####: 5702:        call_tests++;
    #####: 5703:        des_xmlCatalogPtr(n_catal, catal, 0);
    #####: 5704:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 1);
    #####: 5705:        xmlResetLastError();
    #####: 5706:        if (mem_base != xmlMemBlocks()) {
    #####: 5707:            printf("Leak of %d blocks found in xmlACatalogRemove",
    #####: 5708:	           xmlMemBlocks() - mem_base);
    #####: 5709:	    test_ret++;
    #####: 5710:            printf(" %d", n_catal);
    #####: 5711:            printf(" %d", n_value);
    #####: 5712:            printf("\n");
        -: 5713:        }
        -: 5714:    }
        -: 5715:    }
    #####: 5716:    function_tests++;
        -: 5717:#endif
        -: 5718:
    #####: 5719:    return(test_ret);
        -: 5720:}
        -: 5721:
        -: 5722:
        -: 5723:static int
    #####: 5724:test_xmlACatalogResolve(void) {
    #####: 5725:    int test_ret = 0;
        -: 5726:
        -: 5727:#if defined(LIBXML_CATALOG_ENABLED)
        -: 5728:    int mem_base;
        -: 5729:    xmlChar * ret_val;
        -: 5730:    xmlCatalogPtr catal; /* a Catalog */
        -: 5731:    int n_catal;
        -: 5732:    xmlChar * pubID; /* the public ID string */
        -: 5733:    int n_pubID;
        -: 5734:    xmlChar * sysID; /* the system ID string */
        -: 5735:    int n_sysID;
        -: 5736:
    #####: 5737:    for (n_catal = 0;n_catal < gen_nb_xmlCatalogPtr;n_catal++) {
    #####: 5738:    for (n_pubID = 0;n_pubID < gen_nb_const_xmlChar_ptr;n_pubID++) {
    #####: 5739:    for (n_sysID = 0;n_sysID < gen_nb_const_xmlChar_ptr;n_sysID++) {
    #####: 5740:        mem_base = xmlMemBlocks();
    #####: 5741:        catal = gen_xmlCatalogPtr(n_catal, 0);
    #####: 5742:        pubID = gen_const_xmlChar_ptr(n_pubID, 1);
    #####: 5743:        sysID = gen_const_xmlChar_ptr(n_sysID, 2);
        -: 5744:
    #####: 5745:        ret_val = xmlACatalogResolve(catal, (const xmlChar *)pubID, (const xmlChar *)sysID);
    #####: 5746:        desret_xmlChar_ptr(ret_val);
    #####: 5747:        call_tests++;
    #####: 5748:        des_xmlCatalogPtr(n_catal, catal, 0);
    #####: 5749:        des_const_xmlChar_ptr(n_pubID, (const xmlChar *)pubID, 1);
    #####: 5750:        des_const_xmlChar_ptr(n_sysID, (const xmlChar *)sysID, 2);
    #####: 5751:        xmlResetLastError();
    #####: 5752:        if (mem_base != xmlMemBlocks()) {
    #####: 5753:            printf("Leak of %d blocks found in xmlACatalogResolve",
    #####: 5754:	           xmlMemBlocks() - mem_base);
    #####: 5755:	    test_ret++;
    #####: 5756:            printf(" %d", n_catal);
    #####: 5757:            printf(" %d", n_pubID);
    #####: 5758:            printf(" %d", n_sysID);
    #####: 5759:            printf("\n");
        -: 5760:        }
        -: 5761:    }
        -: 5762:    }
        -: 5763:    }
    #####: 5764:    function_tests++;
        -: 5765:#endif
        -: 5766:
    #####: 5767:    return(test_ret);
        -: 5768:}
        -: 5769:
        -: 5770:
        -: 5771:static int
    #####: 5772:test_xmlACatalogResolvePublic(void) {
    #####: 5773:    int test_ret = 0;
        -: 5774:
        -: 5775:#if defined(LIBXML_CATALOG_ENABLED)
        -: 5776:    int mem_base;
        -: 5777:    xmlChar * ret_val;
        -: 5778:    xmlCatalogPtr catal; /* a Catalog */
        -: 5779:    int n_catal;
        -: 5780:    xmlChar * pubID; /* the public ID string */
        -: 5781:    int n_pubID;
        -: 5782:
    #####: 5783:    for (n_catal = 0;n_catal < gen_nb_xmlCatalogPtr;n_catal++) {
    #####: 5784:    for (n_pubID = 0;n_pubID < gen_nb_const_xmlChar_ptr;n_pubID++) {
    #####: 5785:        mem_base = xmlMemBlocks();
    #####: 5786:        catal = gen_xmlCatalogPtr(n_catal, 0);
    #####: 5787:        pubID = gen_const_xmlChar_ptr(n_pubID, 1);
        -: 5788:
    #####: 5789:        ret_val = xmlACatalogResolvePublic(catal, (const xmlChar *)pubID);
    #####: 5790:        desret_xmlChar_ptr(ret_val);
    #####: 5791:        call_tests++;
    #####: 5792:        des_xmlCatalogPtr(n_catal, catal, 0);
    #####: 5793:        des_const_xmlChar_ptr(n_pubID, (const xmlChar *)pubID, 1);
    #####: 5794:        xmlResetLastError();
    #####: 5795:        if (mem_base != xmlMemBlocks()) {
    #####: 5796:            printf("Leak of %d blocks found in xmlACatalogResolvePublic",
    #####: 5797:	           xmlMemBlocks() - mem_base);
    #####: 5798:	    test_ret++;
    #####: 5799:            printf(" %d", n_catal);
    #####: 5800:            printf(" %d", n_pubID);
    #####: 5801:            printf("\n");
        -: 5802:        }
        -: 5803:    }
        -: 5804:    }
    #####: 5805:    function_tests++;
        -: 5806:#endif
        -: 5807:
    #####: 5808:    return(test_ret);
        -: 5809:}
        -: 5810:
        -: 5811:
        -: 5812:static int
    #####: 5813:test_xmlACatalogResolveSystem(void) {
    #####: 5814:    int test_ret = 0;
        -: 5815:
        -: 5816:#if defined(LIBXML_CATALOG_ENABLED)
        -: 5817:    int mem_base;
        -: 5818:    xmlChar * ret_val;
        -: 5819:    xmlCatalogPtr catal; /* a Catalog */
        -: 5820:    int n_catal;
        -: 5821:    xmlChar * sysID; /* the system ID string */
        -: 5822:    int n_sysID;
        -: 5823:
    #####: 5824:    for (n_catal = 0;n_catal < gen_nb_xmlCatalogPtr;n_catal++) {
    #####: 5825:    for (n_sysID = 0;n_sysID < gen_nb_const_xmlChar_ptr;n_sysID++) {
    #####: 5826:        mem_base = xmlMemBlocks();
    #####: 5827:        catal = gen_xmlCatalogPtr(n_catal, 0);
    #####: 5828:        sysID = gen_const_xmlChar_ptr(n_sysID, 1);
        -: 5829:
    #####: 5830:        ret_val = xmlACatalogResolveSystem(catal, (const xmlChar *)sysID);
    #####: 5831:        desret_xmlChar_ptr(ret_val);
    #####: 5832:        call_tests++;
    #####: 5833:        des_xmlCatalogPtr(n_catal, catal, 0);
    #####: 5834:        des_const_xmlChar_ptr(n_sysID, (const xmlChar *)sysID, 1);
    #####: 5835:        xmlResetLastError();
    #####: 5836:        if (mem_base != xmlMemBlocks()) {
    #####: 5837:            printf("Leak of %d blocks found in xmlACatalogResolveSystem",
    #####: 5838:	           xmlMemBlocks() - mem_base);
    #####: 5839:	    test_ret++;
    #####: 5840:            printf(" %d", n_catal);
    #####: 5841:            printf(" %d", n_sysID);
    #####: 5842:            printf("\n");
        -: 5843:        }
        -: 5844:    }
        -: 5845:    }
    #####: 5846:    function_tests++;
        -: 5847:#endif
        -: 5848:
    #####: 5849:    return(test_ret);
        -: 5850:}
        -: 5851:
        -: 5852:
        -: 5853:static int
    #####: 5854:test_xmlACatalogResolveURI(void) {
    #####: 5855:    int test_ret = 0;
        -: 5856:
        -: 5857:#if defined(LIBXML_CATALOG_ENABLED)
        -: 5858:    int mem_base;
        -: 5859:    xmlChar * ret_val;
        -: 5860:    xmlCatalogPtr catal; /* a Catalog */
        -: 5861:    int n_catal;
        -: 5862:    xmlChar * URI; /* the URI */
        -: 5863:    int n_URI;
        -: 5864:
    #####: 5865:    for (n_catal = 0;n_catal < gen_nb_xmlCatalogPtr;n_catal++) {
    #####: 5866:    for (n_URI = 0;n_URI < gen_nb_const_xmlChar_ptr;n_URI++) {
    #####: 5867:        mem_base = xmlMemBlocks();
    #####: 5868:        catal = gen_xmlCatalogPtr(n_catal, 0);
    #####: 5869:        URI = gen_const_xmlChar_ptr(n_URI, 1);
        -: 5870:
    #####: 5871:        ret_val = xmlACatalogResolveURI(catal, (const xmlChar *)URI);
    #####: 5872:        desret_xmlChar_ptr(ret_val);
    #####: 5873:        call_tests++;
    #####: 5874:        des_xmlCatalogPtr(n_catal, catal, 0);
    #####: 5875:        des_const_xmlChar_ptr(n_URI, (const xmlChar *)URI, 1);
    #####: 5876:        xmlResetLastError();
    #####: 5877:        if (mem_base != xmlMemBlocks()) {
    #####: 5878:            printf("Leak of %d blocks found in xmlACatalogResolveURI",
    #####: 5879:	           xmlMemBlocks() - mem_base);
    #####: 5880:	    test_ret++;
    #####: 5881:            printf(" %d", n_catal);
    #####: 5882:            printf(" %d", n_URI);
    #####: 5883:            printf("\n");
        -: 5884:        }
        -: 5885:    }
        -: 5886:    }
    #####: 5887:    function_tests++;
        -: 5888:#endif
        -: 5889:
    #####: 5890:    return(test_ret);
        -: 5891:}
        -: 5892:
        -: 5893:
        -: 5894:static int
    #####: 5895:test_xmlCatalogAdd(void) {
    #####: 5896:    int test_ret = 0;
        -: 5897:
        -: 5898:#if defined(LIBXML_CATALOG_ENABLED)
        -: 5899:    int mem_base;
        -: 5900:    int ret_val;
        -: 5901:    xmlChar * type; /* the type of record to add to the catalog */
        -: 5902:    int n_type;
        -: 5903:    xmlChar * orig; /* the system, public or prefix to match */
        -: 5904:    int n_orig;
        -: 5905:    xmlChar * replace; /* the replacement value for the match */
        -: 5906:    int n_replace;
        -: 5907:
    #####: 5908:    for (n_type = 0;n_type < gen_nb_const_xmlChar_ptr;n_type++) {
    #####: 5909:    for (n_orig = 0;n_orig < gen_nb_const_xmlChar_ptr;n_orig++) {
    #####: 5910:    for (n_replace = 0;n_replace < gen_nb_const_xmlChar_ptr;n_replace++) {
    #####: 5911:        mem_base = xmlMemBlocks();
    #####: 5912:        type = gen_const_xmlChar_ptr(n_type, 0);
    #####: 5913:        orig = gen_const_xmlChar_ptr(n_orig, 1);
    #####: 5914:        replace = gen_const_xmlChar_ptr(n_replace, 2);
        -: 5915:
    #####: 5916:        ret_val = xmlCatalogAdd((const xmlChar *)type, (const xmlChar *)orig, (const xmlChar *)replace);
    #####: 5917:        desret_int(ret_val);
    #####: 5918:        call_tests++;
    #####: 5919:        des_const_xmlChar_ptr(n_type, (const xmlChar *)type, 0);
    #####: 5920:        des_const_xmlChar_ptr(n_orig, (const xmlChar *)orig, 1);
    #####: 5921:        des_const_xmlChar_ptr(n_replace, (const xmlChar *)replace, 2);
    #####: 5922:        xmlResetLastError();
    #####: 5923:        if (mem_base != xmlMemBlocks()) {
    #####: 5924:            printf("Leak of %d blocks found in xmlCatalogAdd",
    #####: 5925:	           xmlMemBlocks() - mem_base);
    #####: 5926:	    test_ret++;
    #####: 5927:            printf(" %d", n_type);
    #####: 5928:            printf(" %d", n_orig);
    #####: 5929:            printf(" %d", n_replace);
    #####: 5930:            printf("\n");
        -: 5931:        }
        -: 5932:    }
        -: 5933:    }
        -: 5934:    }
    #####: 5935:    function_tests++;
        -: 5936:#endif
        -: 5937:
    #####: 5938:    return(test_ret);
        -: 5939:}
        -: 5940:
        -: 5941:
        -: 5942:static int
    #####: 5943:test_xmlCatalogCleanup(void) {
    #####: 5944:    int test_ret = 0;
        -: 5945:
        -: 5946:#if defined(LIBXML_CATALOG_ENABLED)
        -: 5947:
        -: 5948:
    #####: 5949:        xmlCatalogCleanup();
    #####: 5950:        call_tests++;
    #####: 5951:        xmlResetLastError();
    #####: 5952:    function_tests++;
        -: 5953:#endif
        -: 5954:
    #####: 5955:    return(test_ret);
        -: 5956:}
        -: 5957:
        -: 5958:
        -: 5959:static int
    #####: 5960:test_xmlCatalogConvert(void) {
    #####: 5961:    int test_ret = 0;
        -: 5962:
        -: 5963:#if defined(LIBXML_CATALOG_ENABLED)
        -: 5964:    int ret_val;
        -: 5965:
        -: 5966:
    #####: 5967:        ret_val = xmlCatalogConvert();
    #####: 5968:        desret_int(ret_val);
    #####: 5969:        call_tests++;
    #####: 5970:        xmlResetLastError();
    #####: 5971:    function_tests++;
        -: 5972:#endif
        -: 5973:
    #####: 5974:    return(test_ret);
        -: 5975:}
        -: 5976:
        -: 5977:
        -: 5978:static int
    #####: 5979:test_xmlCatalogDump(void) {
    #####: 5980:    int test_ret = 0;
        -: 5981:
        -: 5982:#if defined(LIBXML_CATALOG_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
        -: 5983:    int mem_base;
        -: 5984:    FILE * out; /* the file. */
        -: 5985:    int n_out;
        -: 5986:
    #####: 5987:    for (n_out = 0;n_out < gen_nb_FILE_ptr;n_out++) {
    #####: 5988:        mem_base = xmlMemBlocks();
    #####: 5989:        out = gen_FILE_ptr(n_out, 0);
        -: 5990:
    #####: 5991:        xmlCatalogDump(out);
    #####: 5992:        call_tests++;
    #####: 5993:        des_FILE_ptr(n_out, out, 0);
    #####: 5994:        xmlResetLastError();
    #####: 5995:        if (mem_base != xmlMemBlocks()) {
    #####: 5996:            printf("Leak of %d blocks found in xmlCatalogDump",
    #####: 5997:	           xmlMemBlocks() - mem_base);
    #####: 5998:	    test_ret++;
    #####: 5999:            printf(" %d", n_out);
    #####: 6000:            printf("\n");
        -: 6001:        }
        -: 6002:    }
    #####: 6003:    function_tests++;
        -: 6004:#endif
        -: 6005:
    #####: 6006:    return(test_ret);
        -: 6007:}
        -: 6008:
        -: 6009:
        -: 6010:static int
    #####: 6011:test_xmlCatalogGetDefaults(void) {
    #####: 6012:    int test_ret = 0;
        -: 6013:
        -: 6014:#if defined(LIBXML_CATALOG_ENABLED)
        -: 6015:    int mem_base;
        -: 6016:    xmlCatalogAllow ret_val;
        -: 6017:
    #####: 6018:        mem_base = xmlMemBlocks();
        -: 6019:
    #####: 6020:        ret_val = xmlCatalogGetDefaults();
    #####: 6021:        desret_xmlCatalogAllow(ret_val);
    #####: 6022:        call_tests++;
    #####: 6023:        xmlResetLastError();
    #####: 6024:        if (mem_base != xmlMemBlocks()) {
    #####: 6025:            printf("Leak of %d blocks found in xmlCatalogGetDefaults",
    #####: 6026:	           xmlMemBlocks() - mem_base);
    #####: 6027:	    test_ret++;
    #####: 6028:            printf("\n");
        -: 6029:        }
    #####: 6030:    function_tests++;
        -: 6031:#endif
        -: 6032:
    #####: 6033:    return(test_ret);
        -: 6034:}
        -: 6035:
        -: 6036:
        -: 6037:static int
    #####: 6038:test_xmlCatalogIsEmpty(void) {
    #####: 6039:    int test_ret = 0;
        -: 6040:
        -: 6041:#if defined(LIBXML_CATALOG_ENABLED)
        -: 6042:    int mem_base;
        -: 6043:    int ret_val;
        -: 6044:    xmlCatalogPtr catal; /* should this create an SGML catalog */
        -: 6045:    int n_catal;
        -: 6046:
    #####: 6047:    for (n_catal = 0;n_catal < gen_nb_xmlCatalogPtr;n_catal++) {
    #####: 6048:        mem_base = xmlMemBlocks();
    #####: 6049:        catal = gen_xmlCatalogPtr(n_catal, 0);
        -: 6050:
    #####: 6051:        ret_val = xmlCatalogIsEmpty(catal);
    #####: 6052:        desret_int(ret_val);
    #####: 6053:        call_tests++;
    #####: 6054:        des_xmlCatalogPtr(n_catal, catal, 0);
    #####: 6055:        xmlResetLastError();
    #####: 6056:        if (mem_base != xmlMemBlocks()) {
    #####: 6057:            printf("Leak of %d blocks found in xmlCatalogIsEmpty",
    #####: 6058:	           xmlMemBlocks() - mem_base);
    #####: 6059:	    test_ret++;
    #####: 6060:            printf(" %d", n_catal);
    #####: 6061:            printf("\n");
        -: 6062:        }
        -: 6063:    }
    #####: 6064:    function_tests++;
        -: 6065:#endif
        -: 6066:
    #####: 6067:    return(test_ret);
        -: 6068:}
        -: 6069:
        -: 6070:
        -: 6071:static int
    #####: 6072:test_xmlCatalogLocalResolve(void) {
    #####: 6073:    int test_ret = 0;
        -: 6074:
        -: 6075:#if defined(LIBXML_CATALOG_ENABLED)
        -: 6076:    int mem_base;
        -: 6077:    xmlChar * ret_val;
        -: 6078:    void * catalogs; /* a document's list of catalogs */
        -: 6079:    int n_catalogs;
        -: 6080:    xmlChar * pubID; /* the public ID string */
        -: 6081:    int n_pubID;
        -: 6082:    xmlChar * sysID; /* the system ID string */
        -: 6083:    int n_sysID;
        -: 6084:
    #####: 6085:    for (n_catalogs = 0;n_catalogs < gen_nb_void_ptr;n_catalogs++) {
    #####: 6086:    for (n_pubID = 0;n_pubID < gen_nb_const_xmlChar_ptr;n_pubID++) {
    #####: 6087:    for (n_sysID = 0;n_sysID < gen_nb_const_xmlChar_ptr;n_sysID++) {
    #####: 6088:        mem_base = xmlMemBlocks();
    #####: 6089:        catalogs = gen_void_ptr(n_catalogs, 0);
    #####: 6090:        pubID = gen_const_xmlChar_ptr(n_pubID, 1);
    #####: 6091:        sysID = gen_const_xmlChar_ptr(n_sysID, 2);
        -: 6092:
    #####: 6093:        ret_val = xmlCatalogLocalResolve(catalogs, (const xmlChar *)pubID, (const xmlChar *)sysID);
    #####: 6094:        desret_xmlChar_ptr(ret_val);
    #####: 6095:        call_tests++;
    #####: 6096:        des_void_ptr(n_catalogs, catalogs, 0);
    #####: 6097:        des_const_xmlChar_ptr(n_pubID, (const xmlChar *)pubID, 1);
    #####: 6098:        des_const_xmlChar_ptr(n_sysID, (const xmlChar *)sysID, 2);
    #####: 6099:        xmlResetLastError();
    #####: 6100:        if (mem_base != xmlMemBlocks()) {
    #####: 6101:            printf("Leak of %d blocks found in xmlCatalogLocalResolve",
    #####: 6102:	           xmlMemBlocks() - mem_base);
    #####: 6103:	    test_ret++;
    #####: 6104:            printf(" %d", n_catalogs);
    #####: 6105:            printf(" %d", n_pubID);
    #####: 6106:            printf(" %d", n_sysID);
    #####: 6107:            printf("\n");
        -: 6108:        }
        -: 6109:    }
        -: 6110:    }
        -: 6111:    }
    #####: 6112:    function_tests++;
        -: 6113:#endif
        -: 6114:
    #####: 6115:    return(test_ret);
        -: 6116:}
        -: 6117:
        -: 6118:
        -: 6119:static int
    #####: 6120:test_xmlCatalogLocalResolveURI(void) {
    #####: 6121:    int test_ret = 0;
        -: 6122:
        -: 6123:#if defined(LIBXML_CATALOG_ENABLED)
        -: 6124:    int mem_base;
        -: 6125:    xmlChar * ret_val;
        -: 6126:    void * catalogs; /* a document's list of catalogs */
        -: 6127:    int n_catalogs;
        -: 6128:    xmlChar * URI; /* the URI */
        -: 6129:    int n_URI;
        -: 6130:
    #####: 6131:    for (n_catalogs = 0;n_catalogs < gen_nb_void_ptr;n_catalogs++) {
    #####: 6132:    for (n_URI = 0;n_URI < gen_nb_const_xmlChar_ptr;n_URI++) {
    #####: 6133:        mem_base = xmlMemBlocks();
    #####: 6134:        catalogs = gen_void_ptr(n_catalogs, 0);
    #####: 6135:        URI = gen_const_xmlChar_ptr(n_URI, 1);
        -: 6136:
    #####: 6137:        ret_val = xmlCatalogLocalResolveURI(catalogs, (const xmlChar *)URI);
    #####: 6138:        desret_xmlChar_ptr(ret_val);
    #####: 6139:        call_tests++;
    #####: 6140:        des_void_ptr(n_catalogs, catalogs, 0);
    #####: 6141:        des_const_xmlChar_ptr(n_URI, (const xmlChar *)URI, 1);
    #####: 6142:        xmlResetLastError();
    #####: 6143:        if (mem_base != xmlMemBlocks()) {
    #####: 6144:            printf("Leak of %d blocks found in xmlCatalogLocalResolveURI",
    #####: 6145:	           xmlMemBlocks() - mem_base);
    #####: 6146:	    test_ret++;
    #####: 6147:            printf(" %d", n_catalogs);
    #####: 6148:            printf(" %d", n_URI);
    #####: 6149:            printf("\n");
        -: 6150:        }
        -: 6151:    }
        -: 6152:    }
    #####: 6153:    function_tests++;
        -: 6154:#endif
        -: 6155:
    #####: 6156:    return(test_ret);
        -: 6157:}
        -: 6158:
        -: 6159:
        -: 6160:static int
    #####: 6161:test_xmlCatalogRemove(void) {
    #####: 6162:    int test_ret = 0;
        -: 6163:
        -: 6164:#if defined(LIBXML_CATALOG_ENABLED)
        -: 6165:    int ret_val;
        -: 6166:    xmlChar * value; /* the value to remove */
        -: 6167:    int n_value;
        -: 6168:
    #####: 6169:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####: 6170:        value = gen_const_xmlChar_ptr(n_value, 0);
        -: 6171:
    #####: 6172:        ret_val = xmlCatalogRemove((const xmlChar *)value);
    #####: 6173:        desret_int(ret_val);
    #####: 6174:        call_tests++;
    #####: 6175:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 0);
    #####: 6176:        xmlResetLastError();
        -: 6177:    }
    #####: 6178:    function_tests++;
        -: 6179:#endif
        -: 6180:
    #####: 6181:    return(test_ret);
        -: 6182:}
        -: 6183:
        -: 6184:
        -: 6185:static int
    #####: 6186:test_xmlCatalogResolve(void) {
    #####: 6187:    int test_ret = 0;
        -: 6188:
        -: 6189:#if defined(LIBXML_CATALOG_ENABLED)
        -: 6190:    xmlChar * ret_val;
        -: 6191:    xmlChar * pubID; /* the public ID string */
        -: 6192:    int n_pubID;
        -: 6193:    xmlChar * sysID; /* the system ID string */
        -: 6194:    int n_sysID;
        -: 6195:
    #####: 6196:    for (n_pubID = 0;n_pubID < gen_nb_const_xmlChar_ptr;n_pubID++) {
    #####: 6197:    for (n_sysID = 0;n_sysID < gen_nb_const_xmlChar_ptr;n_sysID++) {
    #####: 6198:        pubID = gen_const_xmlChar_ptr(n_pubID, 0);
    #####: 6199:        sysID = gen_const_xmlChar_ptr(n_sysID, 1);
        -: 6200:
    #####: 6201:        ret_val = xmlCatalogResolve((const xmlChar *)pubID, (const xmlChar *)sysID);
    #####: 6202:        desret_xmlChar_ptr(ret_val);
    #####: 6203:        call_tests++;
    #####: 6204:        des_const_xmlChar_ptr(n_pubID, (const xmlChar *)pubID, 0);
    #####: 6205:        des_const_xmlChar_ptr(n_sysID, (const xmlChar *)sysID, 1);
    #####: 6206:        xmlResetLastError();
        -: 6207:    }
        -: 6208:    }
    #####: 6209:    function_tests++;
        -: 6210:#endif
        -: 6211:
    #####: 6212:    return(test_ret);
        -: 6213:}
        -: 6214:
        -: 6215:
        -: 6216:static int
    #####: 6217:test_xmlCatalogResolvePublic(void) {
    #####: 6218:    int test_ret = 0;
        -: 6219:
        -: 6220:#if defined(LIBXML_CATALOG_ENABLED)
        -: 6221:    int mem_base;
        -: 6222:    xmlChar * ret_val;
        -: 6223:    xmlChar * pubID; /* the public ID string */
        -: 6224:    int n_pubID;
        -: 6225:
    #####: 6226:    for (n_pubID = 0;n_pubID < gen_nb_const_xmlChar_ptr;n_pubID++) {
    #####: 6227:        mem_base = xmlMemBlocks();
    #####: 6228:        pubID = gen_const_xmlChar_ptr(n_pubID, 0);
        -: 6229:
    #####: 6230:        ret_val = xmlCatalogResolvePublic((const xmlChar *)pubID);
    #####: 6231:        desret_xmlChar_ptr(ret_val);
    #####: 6232:        call_tests++;
    #####: 6233:        des_const_xmlChar_ptr(n_pubID, (const xmlChar *)pubID, 0);
    #####: 6234:        xmlResetLastError();
    #####: 6235:        if (mem_base != xmlMemBlocks()) {
    #####: 6236:            printf("Leak of %d blocks found in xmlCatalogResolvePublic",
    #####: 6237:	           xmlMemBlocks() - mem_base);
    #####: 6238:	    test_ret++;
    #####: 6239:            printf(" %d", n_pubID);
    #####: 6240:            printf("\n");
        -: 6241:        }
        -: 6242:    }
    #####: 6243:    function_tests++;
        -: 6244:#endif
        -: 6245:
    #####: 6246:    return(test_ret);
        -: 6247:}
        -: 6248:
        -: 6249:
        -: 6250:static int
    #####: 6251:test_xmlCatalogResolveSystem(void) {
    #####: 6252:    int test_ret = 0;
        -: 6253:
        -: 6254:#if defined(LIBXML_CATALOG_ENABLED)
        -: 6255:    int mem_base;
        -: 6256:    xmlChar * ret_val;
        -: 6257:    xmlChar * sysID; /* the system ID string */
        -: 6258:    int n_sysID;
        -: 6259:
    #####: 6260:    for (n_sysID = 0;n_sysID < gen_nb_const_xmlChar_ptr;n_sysID++) {
    #####: 6261:        mem_base = xmlMemBlocks();
    #####: 6262:        sysID = gen_const_xmlChar_ptr(n_sysID, 0);
        -: 6263:
    #####: 6264:        ret_val = xmlCatalogResolveSystem((const xmlChar *)sysID);
    #####: 6265:        desret_xmlChar_ptr(ret_val);
    #####: 6266:        call_tests++;
    #####: 6267:        des_const_xmlChar_ptr(n_sysID, (const xmlChar *)sysID, 0);
    #####: 6268:        xmlResetLastError();
    #####: 6269:        if (mem_base != xmlMemBlocks()) {
    #####: 6270:            printf("Leak of %d blocks found in xmlCatalogResolveSystem",
    #####: 6271:	           xmlMemBlocks() - mem_base);
    #####: 6272:	    test_ret++;
    #####: 6273:            printf(" %d", n_sysID);
    #####: 6274:            printf("\n");
        -: 6275:        }
        -: 6276:    }
    #####: 6277:    function_tests++;
        -: 6278:#endif
        -: 6279:
    #####: 6280:    return(test_ret);
        -: 6281:}
        -: 6282:
        -: 6283:
        -: 6284:static int
    #####: 6285:test_xmlCatalogResolveURI(void) {
    #####: 6286:    int test_ret = 0;
        -: 6287:
        -: 6288:#if defined(LIBXML_CATALOG_ENABLED)
        -: 6289:    int mem_base;
        -: 6290:    xmlChar * ret_val;
        -: 6291:    xmlChar * URI; /* the URI */
        -: 6292:    int n_URI;
        -: 6293:
    #####: 6294:    for (n_URI = 0;n_URI < gen_nb_const_xmlChar_ptr;n_URI++) {
    #####: 6295:        mem_base = xmlMemBlocks();
    #####: 6296:        URI = gen_const_xmlChar_ptr(n_URI, 0);
        -: 6297:
    #####: 6298:        ret_val = xmlCatalogResolveURI((const xmlChar *)URI);
    #####: 6299:        desret_xmlChar_ptr(ret_val);
    #####: 6300:        call_tests++;
    #####: 6301:        des_const_xmlChar_ptr(n_URI, (const xmlChar *)URI, 0);
    #####: 6302:        xmlResetLastError();
    #####: 6303:        if (mem_base != xmlMemBlocks()) {
    #####: 6304:            printf("Leak of %d blocks found in xmlCatalogResolveURI",
    #####: 6305:	           xmlMemBlocks() - mem_base);
    #####: 6306:	    test_ret++;
    #####: 6307:            printf(" %d", n_URI);
    #####: 6308:            printf("\n");
        -: 6309:        }
        -: 6310:    }
    #####: 6311:    function_tests++;
        -: 6312:#endif
        -: 6313:
    #####: 6314:    return(test_ret);
        -: 6315:}
        -: 6316:
        -: 6317:
        -: 6318:static int
    #####: 6319:test_xmlCatalogSetDefaultPrefer(void) {
    #####: 6320:    int test_ret = 0;
        -: 6321:
        -: 6322:#if defined(LIBXML_CATALOG_ENABLED)
        -: 6323:    int mem_base;
        -: 6324:    xmlCatalogPrefer ret_val;
        -: 6325:    xmlCatalogPrefer prefer; /* the default preference for delegation */
        -: 6326:    int n_prefer;
        -: 6327:
    #####: 6328:    for (n_prefer = 0;n_prefer < gen_nb_xmlCatalogPrefer;n_prefer++) {
    #####: 6329:        mem_base = xmlMemBlocks();
    #####: 6330:        prefer = gen_xmlCatalogPrefer(n_prefer, 0);
        -: 6331:
    #####: 6332:        ret_val = xmlCatalogSetDefaultPrefer(prefer);
    #####: 6333:        desret_xmlCatalogPrefer(ret_val);
    #####: 6334:        call_tests++;
    #####: 6335:        des_xmlCatalogPrefer(n_prefer, prefer, 0);
    #####: 6336:        xmlResetLastError();
    #####: 6337:        if (mem_base != xmlMemBlocks()) {
    #####: 6338:            printf("Leak of %d blocks found in xmlCatalogSetDefaultPrefer",
    #####: 6339:	           xmlMemBlocks() - mem_base);
    #####: 6340:	    test_ret++;
    #####: 6341:            printf(" %d", n_prefer);
    #####: 6342:            printf("\n");
        -: 6343:        }
        -: 6344:    }
    #####: 6345:    function_tests++;
        -: 6346:#endif
        -: 6347:
    #####: 6348:    return(test_ret);
        -: 6349:}
        -: 6350:
        -: 6351:
        -: 6352:static int
    #####: 6353:test_xmlCatalogSetDefaults(void) {
    #####: 6354:    int test_ret = 0;
        -: 6355:
        -: 6356:#if defined(LIBXML_CATALOG_ENABLED)
        -: 6357:    int mem_base;
        -: 6358:    xmlCatalogAllow allow; /* what catalogs should be accepted */
        -: 6359:    int n_allow;
        -: 6360:
    #####: 6361:    for (n_allow = 0;n_allow < gen_nb_xmlCatalogAllow;n_allow++) {
    #####: 6362:        mem_base = xmlMemBlocks();
    #####: 6363:        allow = gen_xmlCatalogAllow(n_allow, 0);
        -: 6364:
    #####: 6365:        xmlCatalogSetDefaults(allow);
    #####: 6366:        call_tests++;
    #####: 6367:        des_xmlCatalogAllow(n_allow, allow, 0);
    #####: 6368:        xmlResetLastError();
    #####: 6369:        if (mem_base != xmlMemBlocks()) {
    #####: 6370:            printf("Leak of %d blocks found in xmlCatalogSetDefaults",
    #####: 6371:	           xmlMemBlocks() - mem_base);
    #####: 6372:	    test_ret++;
    #####: 6373:            printf(" %d", n_allow);
    #####: 6374:            printf("\n");
        -: 6375:        }
        -: 6376:    }
    #####: 6377:    function_tests++;
        -: 6378:#endif
        -: 6379:
    #####: 6380:    return(test_ret);
        -: 6381:}
        -: 6382:
        -: 6383:
        -: 6384:static int
    #####: 6385:test_xmlConvertSGMLCatalog(void) {
    #####: 6386:    int test_ret = 0;
        -: 6387:
        -: 6388:#if defined(LIBXML_CATALOG_ENABLED)
        -: 6389:    int mem_base;
        -: 6390:    int ret_val;
        -: 6391:    xmlCatalogPtr catal; /* the catalog */
        -: 6392:    int n_catal;
        -: 6393:
    #####: 6394:    for (n_catal = 0;n_catal < gen_nb_xmlCatalogPtr;n_catal++) {
    #####: 6395:        mem_base = xmlMemBlocks();
    #####: 6396:        catal = gen_xmlCatalogPtr(n_catal, 0);
        -: 6397:
    #####: 6398:        ret_val = xmlConvertSGMLCatalog(catal);
    #####: 6399:        desret_int(ret_val);
    #####: 6400:        call_tests++;
    #####: 6401:        des_xmlCatalogPtr(n_catal, catal, 0);
    #####: 6402:        xmlResetLastError();
    #####: 6403:        if (mem_base != xmlMemBlocks()) {
    #####: 6404:            printf("Leak of %d blocks found in xmlConvertSGMLCatalog",
    #####: 6405:	           xmlMemBlocks() - mem_base);
    #####: 6406:	    test_ret++;
    #####: 6407:            printf(" %d", n_catal);
    #####: 6408:            printf("\n");
        -: 6409:        }
        -: 6410:    }
    #####: 6411:    function_tests++;
        -: 6412:#endif
        -: 6413:
    #####: 6414:    return(test_ret);
        -: 6415:}
        -: 6416:
        -: 6417:
        -: 6418:static int
    #####: 6419:test_xmlInitializeCatalog(void) {
    #####: 6420:    int test_ret = 0;
        -: 6421:
        -: 6422:#if defined(LIBXML_CATALOG_ENABLED)
        -: 6423:    int mem_base;
        -: 6424:
    #####: 6425:        mem_base = xmlMemBlocks();
        -: 6426:
    #####: 6427:        xmlInitializeCatalog();
    #####: 6428:        call_tests++;
    #####: 6429:        xmlResetLastError();
    #####: 6430:        if (mem_base != xmlMemBlocks()) {
    #####: 6431:            printf("Leak of %d blocks found in xmlInitializeCatalog",
    #####: 6432:	           xmlMemBlocks() - mem_base);
    #####: 6433:	    test_ret++;
    #####: 6434:            printf("\n");
        -: 6435:        }
    #####: 6436:    function_tests++;
        -: 6437:#endif
        -: 6438:
    #####: 6439:    return(test_ret);
        -: 6440:}
        -: 6441:
        -: 6442:
        -: 6443:static int
    #####: 6444:test_xmlLoadACatalog(void) {
    #####: 6445:    int test_ret = 0;
        -: 6446:
        -: 6447:
        -: 6448:    /* missing type support */
    #####: 6449:    return(test_ret);
        -: 6450:}
        -: 6451:
        -: 6452:
        -: 6453:static int
    #####: 6454:test_xmlLoadCatalog(void) {
    #####: 6455:    int test_ret = 0;
        -: 6456:
        -: 6457:#if defined(LIBXML_CATALOG_ENABLED)
        -: 6458:    int ret_val;
        -: 6459:    const char * filename; /* a file path */
        -: 6460:    int n_filename;
        -: 6461:
    #####: 6462:    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    #####: 6463:        filename = gen_filepath(n_filename, 0);
        -: 6464:
    #####: 6465:        ret_val = xmlLoadCatalog(filename);
    #####: 6466:        desret_int(ret_val);
    #####: 6467:        call_tests++;
    #####: 6468:        des_filepath(n_filename, filename, 0);
    #####: 6469:        xmlResetLastError();
        -: 6470:    }
    #####: 6471:    function_tests++;
        -: 6472:#endif
        -: 6473:
    #####: 6474:    return(test_ret);
        -: 6475:}
        -: 6476:
        -: 6477:
        -: 6478:static int
    #####: 6479:test_xmlLoadCatalogs(void) {
    #####: 6480:    int test_ret = 0;
        -: 6481:
        -: 6482:#if defined(LIBXML_CATALOG_ENABLED)
        -: 6483:    char * pathss; /* a list of directories separated by a colon or a space. */
        -: 6484:    int n_pathss;
        -: 6485:
    #####: 6486:    for (n_pathss = 0;n_pathss < gen_nb_const_char_ptr;n_pathss++) {
    #####: 6487:        pathss = gen_const_char_ptr(n_pathss, 0);
        -: 6488:
    #####: 6489:        xmlLoadCatalogs((const char *)pathss);
    #####: 6490:        call_tests++;
    #####: 6491:        des_const_char_ptr(n_pathss, (const char *)pathss, 0);
    #####: 6492:        xmlResetLastError();
        -: 6493:    }
    #####: 6494:    function_tests++;
        -: 6495:#endif
        -: 6496:
    #####: 6497:    return(test_ret);
        -: 6498:}
        -: 6499:
        -: 6500:
        -: 6501:static int
    #####: 6502:test_xmlLoadSGMLSuperCatalog(void) {
    #####: 6503:    int test_ret = 0;
        -: 6504:
        -: 6505:
        -: 6506:    /* missing type support */
    #####: 6507:    return(test_ret);
        -: 6508:}
        -: 6509:
        -: 6510:
        -: 6511:static int
    #####: 6512:test_xmlNewCatalog(void) {
    #####: 6513:    int test_ret = 0;
        -: 6514:
        -: 6515:
        -: 6516:    /* missing type support */
    #####: 6517:    return(test_ret);
        -: 6518:}
        -: 6519:
        -: 6520:
        -: 6521:static int
    #####: 6522:test_xmlParseCatalogFile(void) {
    #####: 6523:    int test_ret = 0;
        -: 6524:
        -: 6525:#if defined(LIBXML_CATALOG_ENABLED)
        -: 6526:    int mem_base;
        -: 6527:    xmlDocPtr ret_val;
        -: 6528:    const char * filename; /* the filename */
        -: 6529:    int n_filename;
        -: 6530:
    #####: 6531:    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    #####: 6532:        mem_base = xmlMemBlocks();
    #####: 6533:        filename = gen_filepath(n_filename, 0);
        -: 6534:
    #####: 6535:        ret_val = xmlParseCatalogFile(filename);
    #####: 6536:        desret_xmlDocPtr(ret_val);
    #####: 6537:        call_tests++;
    #####: 6538:        des_filepath(n_filename, filename, 0);
    #####: 6539:        xmlResetLastError();
    #####: 6540:        if (mem_base != xmlMemBlocks()) {
    #####: 6541:            printf("Leak of %d blocks found in xmlParseCatalogFile",
    #####: 6542:	           xmlMemBlocks() - mem_base);
    #####: 6543:	    test_ret++;
    #####: 6544:            printf(" %d", n_filename);
    #####: 6545:            printf("\n");
        -: 6546:        }
        -: 6547:    }
    #####: 6548:    function_tests++;
        -: 6549:#endif
        -: 6550:
    #####: 6551:    return(test_ret);
        -: 6552:}
        -: 6553:
        -: 6554:static int
    #####: 6555:test_catalog(void) {
    #####: 6556:    int test_ret = 0;
        -: 6557:
    #####: 6558:    if (quiet == 0) printf("Testing catalog : 27 of 36 functions ...\n");
    #####: 6559:    test_ret += test_xmlACatalogAdd();
    #####: 6560:    test_ret += test_xmlACatalogDump();
    #####: 6561:    test_ret += test_xmlACatalogRemove();
    #####: 6562:    test_ret += test_xmlACatalogResolve();
    #####: 6563:    test_ret += test_xmlACatalogResolvePublic();
    #####: 6564:    test_ret += test_xmlACatalogResolveSystem();
    #####: 6565:    test_ret += test_xmlACatalogResolveURI();
    #####: 6566:    test_ret += test_xmlCatalogAdd();
    #####: 6567:    test_ret += test_xmlCatalogCleanup();
    #####: 6568:    test_ret += test_xmlCatalogConvert();
    #####: 6569:    test_ret += test_xmlCatalogDump();
    #####: 6570:    test_ret += test_xmlCatalogGetDefaults();
    #####: 6571:    test_ret += test_xmlCatalogIsEmpty();
    #####: 6572:    test_ret += test_xmlCatalogLocalResolve();
    #####: 6573:    test_ret += test_xmlCatalogLocalResolveURI();
    #####: 6574:    test_ret += test_xmlCatalogRemove();
    #####: 6575:    test_ret += test_xmlCatalogResolve();
    #####: 6576:    test_ret += test_xmlCatalogResolvePublic();
    #####: 6577:    test_ret += test_xmlCatalogResolveSystem();
    #####: 6578:    test_ret += test_xmlCatalogResolveURI();
    #####: 6579:    test_ret += test_xmlCatalogSetDefaultPrefer();
    #####: 6580:    test_ret += test_xmlCatalogSetDefaults();
    #####: 6581:    test_ret += test_xmlConvertSGMLCatalog();
    #####: 6582:    test_ret += test_xmlInitializeCatalog();
    #####: 6583:    test_ret += test_xmlLoadACatalog();
    #####: 6584:    test_ret += test_xmlLoadCatalog();
    #####: 6585:    test_ret += test_xmlLoadCatalogs();
    #####: 6586:    test_ret += test_xmlLoadSGMLSuperCatalog();
    #####: 6587:    test_ret += test_xmlNewCatalog();
    #####: 6588:    test_ret += test_xmlParseCatalogFile();
        -: 6589:
    #####: 6590:    if (test_ret != 0)
    #####: 6591:	printf("Module catalog: %d errors\n", test_ret);
    #####: 6592:    return(test_ret);
        -: 6593:}
        -: 6594:
        -: 6595:#define gen_nb_const_xmlChRangeGroup_ptr 1
    #####: 6596:static xmlChRangeGroup * gen_const_xmlChRangeGroup_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 6597:    return(NULL);
        -: 6598:}
    #####: 6599:static void des_const_xmlChRangeGroup_ptr(int no ATTRIBUTE_UNUSED, const xmlChRangeGroup * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 6600:}
        -: 6601:
        -: 6602:static int
    #####: 6603:test_xmlCharInRange(void) {
    #####: 6604:    int test_ret = 0;
        -: 6605:
        -: 6606:    int mem_base;
        -: 6607:    int ret_val;
        -: 6608:    unsigned int val; /* character to be validated */
        -: 6609:    int n_val;
        -: 6610:    xmlChRangeGroup * rptr; /* pointer to range to be used to validate */
        -: 6611:    int n_rptr;
        -: 6612:
    #####: 6613:    for (n_val = 0;n_val < gen_nb_unsigned_int;n_val++) {
    #####: 6614:    for (n_rptr = 0;n_rptr < gen_nb_const_xmlChRangeGroup_ptr;n_rptr++) {
    #####: 6615:        mem_base = xmlMemBlocks();
    #####: 6616:        val = gen_unsigned_int(n_val, 0);
    #####: 6617:        rptr = gen_const_xmlChRangeGroup_ptr(n_rptr, 1);
        -: 6618:
    #####: 6619:        ret_val = xmlCharInRange(val, (const xmlChRangeGroup *)rptr);
    #####: 6620:        desret_int(ret_val);
    #####: 6621:        call_tests++;
    #####: 6622:        des_unsigned_int(n_val, val, 0);
    #####: 6623:        des_const_xmlChRangeGroup_ptr(n_rptr, (const xmlChRangeGroup *)rptr, 1);
    #####: 6624:        xmlResetLastError();
    #####: 6625:        if (mem_base != xmlMemBlocks()) {
    #####: 6626:            printf("Leak of %d blocks found in xmlCharInRange",
    #####: 6627:	           xmlMemBlocks() - mem_base);
    #####: 6628:	    test_ret++;
    #####: 6629:            printf(" %d", n_val);
    #####: 6630:            printf(" %d", n_rptr);
    #####: 6631:            printf("\n");
        -: 6632:        }
        -: 6633:    }
        -: 6634:    }
    #####: 6635:    function_tests++;
        -: 6636:
    #####: 6637:    return(test_ret);
        -: 6638:}
        -: 6639:
        -: 6640:
        -: 6641:static int
    #####: 6642:test_xmlIsBaseChar(void) {
    #####: 6643:    int test_ret = 0;
        -: 6644:
        -: 6645:    int mem_base;
        -: 6646:    int ret_val;
        -: 6647:    unsigned int ch; /* character to validate */
        -: 6648:    int n_ch;
        -: 6649:
    #####: 6650:    for (n_ch = 0;n_ch < gen_nb_unsigned_int;n_ch++) {
    #####: 6651:        mem_base = xmlMemBlocks();
    #####: 6652:        ch = gen_unsigned_int(n_ch, 0);
        -: 6653:
    #####: 6654:        ret_val = xmlIsBaseChar(ch);
    #####: 6655:        desret_int(ret_val);
    #####: 6656:        call_tests++;
    #####: 6657:        des_unsigned_int(n_ch, ch, 0);
    #####: 6658:        xmlResetLastError();
    #####: 6659:        if (mem_base != xmlMemBlocks()) {
    #####: 6660:            printf("Leak of %d blocks found in xmlIsBaseChar",
    #####: 6661:	           xmlMemBlocks() - mem_base);
    #####: 6662:	    test_ret++;
    #####: 6663:            printf(" %d", n_ch);
    #####: 6664:            printf("\n");
        -: 6665:        }
        -: 6666:    }
    #####: 6667:    function_tests++;
        -: 6668:
    #####: 6669:    return(test_ret);
        -: 6670:}
        -: 6671:
        -: 6672:
        -: 6673:static int
    #####: 6674:test_xmlIsBlank(void) {
    #####: 6675:    int test_ret = 0;
        -: 6676:
        -: 6677:    int mem_base;
        -: 6678:    int ret_val;
        -: 6679:    unsigned int ch; /* character to validate */
        -: 6680:    int n_ch;
        -: 6681:
    #####: 6682:    for (n_ch = 0;n_ch < gen_nb_unsigned_int;n_ch++) {
    #####: 6683:        mem_base = xmlMemBlocks();
    #####: 6684:        ch = gen_unsigned_int(n_ch, 0);
        -: 6685:
    #####: 6686:        ret_val = xmlIsBlank(ch);
    #####: 6687:        desret_int(ret_val);
    #####: 6688:        call_tests++;
    #####: 6689:        des_unsigned_int(n_ch, ch, 0);
    #####: 6690:        xmlResetLastError();
    #####: 6691:        if (mem_base != xmlMemBlocks()) {
    #####: 6692:            printf("Leak of %d blocks found in xmlIsBlank",
    #####: 6693:	           xmlMemBlocks() - mem_base);
    #####: 6694:	    test_ret++;
    #####: 6695:            printf(" %d", n_ch);
    #####: 6696:            printf("\n");
        -: 6697:        }
        -: 6698:    }
    #####: 6699:    function_tests++;
        -: 6700:
    #####: 6701:    return(test_ret);
        -: 6702:}
        -: 6703:
        -: 6704:
        -: 6705:static int
    #####: 6706:test_xmlIsChar(void) {
    #####: 6707:    int test_ret = 0;
        -: 6708:
        -: 6709:    int mem_base;
        -: 6710:    int ret_val;
        -: 6711:    unsigned int ch; /* character to validate */
        -: 6712:    int n_ch;
        -: 6713:
    #####: 6714:    for (n_ch = 0;n_ch < gen_nb_unsigned_int;n_ch++) {
    #####: 6715:        mem_base = xmlMemBlocks();
    #####: 6716:        ch = gen_unsigned_int(n_ch, 0);
        -: 6717:
    #####: 6718:        ret_val = xmlIsChar(ch);
    #####: 6719:        desret_int(ret_val);
    #####: 6720:        call_tests++;
    #####: 6721:        des_unsigned_int(n_ch, ch, 0);
    #####: 6722:        xmlResetLastError();
    #####: 6723:        if (mem_base != xmlMemBlocks()) {
    #####: 6724:            printf("Leak of %d blocks found in xmlIsChar",
    #####: 6725:	           xmlMemBlocks() - mem_base);
    #####: 6726:	    test_ret++;
    #####: 6727:            printf(" %d", n_ch);
    #####: 6728:            printf("\n");
        -: 6729:        }
        -: 6730:    }
    #####: 6731:    function_tests++;
        -: 6732:
    #####: 6733:    return(test_ret);
        -: 6734:}
        -: 6735:
        -: 6736:
        -: 6737:static int
    #####: 6738:test_xmlIsCombining(void) {
    #####: 6739:    int test_ret = 0;
        -: 6740:
        -: 6741:    int mem_base;
        -: 6742:    int ret_val;
        -: 6743:    unsigned int ch; /* character to validate */
        -: 6744:    int n_ch;
        -: 6745:
    #####: 6746:    for (n_ch = 0;n_ch < gen_nb_unsigned_int;n_ch++) {
    #####: 6747:        mem_base = xmlMemBlocks();
    #####: 6748:        ch = gen_unsigned_int(n_ch, 0);
        -: 6749:
    #####: 6750:        ret_val = xmlIsCombining(ch);
    #####: 6751:        desret_int(ret_val);
    #####: 6752:        call_tests++;
    #####: 6753:        des_unsigned_int(n_ch, ch, 0);
    #####: 6754:        xmlResetLastError();
    #####: 6755:        if (mem_base != xmlMemBlocks()) {
    #####: 6756:            printf("Leak of %d blocks found in xmlIsCombining",
    #####: 6757:	           xmlMemBlocks() - mem_base);
    #####: 6758:	    test_ret++;
    #####: 6759:            printf(" %d", n_ch);
    #####: 6760:            printf("\n");
        -: 6761:        }
        -: 6762:    }
    #####: 6763:    function_tests++;
        -: 6764:
    #####: 6765:    return(test_ret);
        -: 6766:}
        -: 6767:
        -: 6768:
        -: 6769:static int
    #####: 6770:test_xmlIsDigit(void) {
    #####: 6771:    int test_ret = 0;
        -: 6772:
        -: 6773:    int mem_base;
        -: 6774:    int ret_val;
        -: 6775:    unsigned int ch; /* character to validate */
        -: 6776:    int n_ch;
        -: 6777:
    #####: 6778:    for (n_ch = 0;n_ch < gen_nb_unsigned_int;n_ch++) {
    #####: 6779:        mem_base = xmlMemBlocks();
    #####: 6780:        ch = gen_unsigned_int(n_ch, 0);
        -: 6781:
    #####: 6782:        ret_val = xmlIsDigit(ch);
    #####: 6783:        desret_int(ret_val);
    #####: 6784:        call_tests++;
    #####: 6785:        des_unsigned_int(n_ch, ch, 0);
    #####: 6786:        xmlResetLastError();
    #####: 6787:        if (mem_base != xmlMemBlocks()) {
    #####: 6788:            printf("Leak of %d blocks found in xmlIsDigit",
    #####: 6789:	           xmlMemBlocks() - mem_base);
    #####: 6790:	    test_ret++;
    #####: 6791:            printf(" %d", n_ch);
    #####: 6792:            printf("\n");
        -: 6793:        }
        -: 6794:    }
    #####: 6795:    function_tests++;
        -: 6796:
    #####: 6797:    return(test_ret);
        -: 6798:}
        -: 6799:
        -: 6800:
        -: 6801:static int
    #####: 6802:test_xmlIsExtender(void) {
    #####: 6803:    int test_ret = 0;
        -: 6804:
        -: 6805:    int mem_base;
        -: 6806:    int ret_val;
        -: 6807:    unsigned int ch; /* character to validate */
        -: 6808:    int n_ch;
        -: 6809:
    #####: 6810:    for (n_ch = 0;n_ch < gen_nb_unsigned_int;n_ch++) {
    #####: 6811:        mem_base = xmlMemBlocks();
    #####: 6812:        ch = gen_unsigned_int(n_ch, 0);
        -: 6813:
    #####: 6814:        ret_val = xmlIsExtender(ch);
    #####: 6815:        desret_int(ret_val);
    #####: 6816:        call_tests++;
    #####: 6817:        des_unsigned_int(n_ch, ch, 0);
    #####: 6818:        xmlResetLastError();
    #####: 6819:        if (mem_base != xmlMemBlocks()) {
    #####: 6820:            printf("Leak of %d blocks found in xmlIsExtender",
    #####: 6821:	           xmlMemBlocks() - mem_base);
    #####: 6822:	    test_ret++;
    #####: 6823:            printf(" %d", n_ch);
    #####: 6824:            printf("\n");
        -: 6825:        }
        -: 6826:    }
    #####: 6827:    function_tests++;
        -: 6828:
    #####: 6829:    return(test_ret);
        -: 6830:}
        -: 6831:
        -: 6832:
        -: 6833:static int
    #####: 6834:test_xmlIsIdeographic(void) {
    #####: 6835:    int test_ret = 0;
        -: 6836:
        -: 6837:    int mem_base;
        -: 6838:    int ret_val;
        -: 6839:    unsigned int ch; /* character to validate */
        -: 6840:    int n_ch;
        -: 6841:
    #####: 6842:    for (n_ch = 0;n_ch < gen_nb_unsigned_int;n_ch++) {
    #####: 6843:        mem_base = xmlMemBlocks();
    #####: 6844:        ch = gen_unsigned_int(n_ch, 0);
        -: 6845:
    #####: 6846:        ret_val = xmlIsIdeographic(ch);
    #####: 6847:        desret_int(ret_val);
    #####: 6848:        call_tests++;
    #####: 6849:        des_unsigned_int(n_ch, ch, 0);
    #####: 6850:        xmlResetLastError();
    #####: 6851:        if (mem_base != xmlMemBlocks()) {
    #####: 6852:            printf("Leak of %d blocks found in xmlIsIdeographic",
    #####: 6853:	           xmlMemBlocks() - mem_base);
    #####: 6854:	    test_ret++;
    #####: 6855:            printf(" %d", n_ch);
    #####: 6856:            printf("\n");
        -: 6857:        }
        -: 6858:    }
    #####: 6859:    function_tests++;
        -: 6860:
    #####: 6861:    return(test_ret);
        -: 6862:}
        -: 6863:
        -: 6864:
        -: 6865:static int
    #####: 6866:test_xmlIsPubidChar(void) {
    #####: 6867:    int test_ret = 0;
        -: 6868:
        -: 6869:    int mem_base;
        -: 6870:    int ret_val;
        -: 6871:    unsigned int ch; /* character to validate */
        -: 6872:    int n_ch;
        -: 6873:
    #####: 6874:    for (n_ch = 0;n_ch < gen_nb_unsigned_int;n_ch++) {
    #####: 6875:        mem_base = xmlMemBlocks();
    #####: 6876:        ch = gen_unsigned_int(n_ch, 0);
        -: 6877:
    #####: 6878:        ret_val = xmlIsPubidChar(ch);
    #####: 6879:        desret_int(ret_val);
    #####: 6880:        call_tests++;
    #####: 6881:        des_unsigned_int(n_ch, ch, 0);
    #####: 6882:        xmlResetLastError();
    #####: 6883:        if (mem_base != xmlMemBlocks()) {
    #####: 6884:            printf("Leak of %d blocks found in xmlIsPubidChar",
    #####: 6885:	           xmlMemBlocks() - mem_base);
    #####: 6886:	    test_ret++;
    #####: 6887:            printf(" %d", n_ch);
    #####: 6888:            printf("\n");
        -: 6889:        }
        -: 6890:    }
    #####: 6891:    function_tests++;
        -: 6892:
    #####: 6893:    return(test_ret);
        -: 6894:}
        -: 6895:
        -: 6896:static int
    #####: 6897:test_chvalid(void) {
    #####: 6898:    int test_ret = 0;
        -: 6899:
    #####: 6900:    if (quiet == 0) printf("Testing chvalid : 9 of 9 functions ...\n");
    #####: 6901:    test_ret += test_xmlCharInRange();
    #####: 6902:    test_ret += test_xmlIsBaseChar();
    #####: 6903:    test_ret += test_xmlIsBlank();
    #####: 6904:    test_ret += test_xmlIsChar();
    #####: 6905:    test_ret += test_xmlIsCombining();
    #####: 6906:    test_ret += test_xmlIsDigit();
    #####: 6907:    test_ret += test_xmlIsExtender();
    #####: 6908:    test_ret += test_xmlIsIdeographic();
    #####: 6909:    test_ret += test_xmlIsPubidChar();
        -: 6910:
    #####: 6911:    if (test_ret != 0)
    #####: 6912:	printf("Module chvalid: %d errors\n", test_ret);
    #####: 6913:    return(test_ret);
        -: 6914:}
        -: 6915:
        -: 6916:static int
    #####: 6917:test_xmlBoolToText(void) {
    #####: 6918:    int test_ret = 0;
        -: 6919:
        -: 6920:#if defined(LIBXML_DEBUG_ENABLED)
        -: 6921:    int mem_base;
        -: 6922:    const char * ret_val;
        -: 6923:    int boolval; /* a bool to turn into text */
        -: 6924:    int n_boolval;
        -: 6925:
    #####: 6926:    for (n_boolval = 0;n_boolval < gen_nb_int;n_boolval++) {
    #####: 6927:        mem_base = xmlMemBlocks();
    #####: 6928:        boolval = gen_int(n_boolval, 0);
        -: 6929:
    #####: 6930:        ret_val = xmlBoolToText(boolval);
    #####: 6931:        desret_const_char_ptr(ret_val);
    #####: 6932:        call_tests++;
    #####: 6933:        des_int(n_boolval, boolval, 0);
    #####: 6934:        xmlResetLastError();
    #####: 6935:        if (mem_base != xmlMemBlocks()) {
    #####: 6936:            printf("Leak of %d blocks found in xmlBoolToText",
    #####: 6937:	           xmlMemBlocks() - mem_base);
    #####: 6938:	    test_ret++;
    #####: 6939:            printf(" %d", n_boolval);
    #####: 6940:            printf("\n");
        -: 6941:        }
        -: 6942:    }
    #####: 6943:    function_tests++;
        -: 6944:#endif
        -: 6945:
    #####: 6946:    return(test_ret);
        -: 6947:}
        -: 6948:
        -: 6949:
        -: 6950:static int
    #####: 6951:test_xmlDebugCheckDocument(void) {
    #####: 6952:    int test_ret = 0;
        -: 6953:
        -: 6954:#if defined(LIBXML_DEBUG_ENABLED)
        -: 6955:    int mem_base;
        -: 6956:    int ret_val;
        -: 6957:    FILE * output; /* the FILE * for the output */
        -: 6958:    int n_output;
        -: 6959:    xmlDocPtr doc; /* the document */
        -: 6960:    int n_doc;
        -: 6961:
    #####: 6962:    for (n_output = 0;n_output < gen_nb_debug_FILE_ptr;n_output++) {
    #####: 6963:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####: 6964:        mem_base = xmlMemBlocks();
    #####: 6965:        output = gen_debug_FILE_ptr(n_output, 0);
    #####: 6966:        doc = gen_xmlDocPtr(n_doc, 1);
        -: 6967:
    #####: 6968:        ret_val = xmlDebugCheckDocument(output, doc);
    #####: 6969:        desret_int(ret_val);
    #####: 6970:        call_tests++;
    #####: 6971:        des_debug_FILE_ptr(n_output, output, 0);
    #####: 6972:        des_xmlDocPtr(n_doc, doc, 1);
    #####: 6973:        xmlResetLastError();
    #####: 6974:        if (mem_base != xmlMemBlocks()) {
    #####: 6975:            printf("Leak of %d blocks found in xmlDebugCheckDocument",
    #####: 6976:	           xmlMemBlocks() - mem_base);
    #####: 6977:	    test_ret++;
    #####: 6978:            printf(" %d", n_output);
    #####: 6979:            printf(" %d", n_doc);
    #####: 6980:            printf("\n");
        -: 6981:        }
        -: 6982:    }
        -: 6983:    }
    #####: 6984:    function_tests++;
        -: 6985:#endif
        -: 6986:
    #####: 6987:    return(test_ret);
        -: 6988:}
        -: 6989:
        -: 6990:
        -: 6991:static int
    #####: 6992:test_xmlDebugDumpAttr(void) {
    #####: 6993:    int test_ret = 0;
        -: 6994:
        -: 6995:#if defined(LIBXML_DEBUG_ENABLED)
        -: 6996:    int mem_base;
        -: 6997:    FILE * output; /* the FILE * for the output */
        -: 6998:    int n_output;
        -: 6999:    xmlAttrPtr attr; /* the attribute */
        -: 7000:    int n_attr;
        -: 7001:    int depth; /* the indentation level. */
        -: 7002:    int n_depth;
        -: 7003:
    #####: 7004:    for (n_output = 0;n_output < gen_nb_debug_FILE_ptr;n_output++) {
    #####: 7005:    for (n_attr = 0;n_attr < gen_nb_xmlAttrPtr;n_attr++) {
    #####: 7006:    for (n_depth = 0;n_depth < gen_nb_int;n_depth++) {
    #####: 7007:        mem_base = xmlMemBlocks();
    #####: 7008:        output = gen_debug_FILE_ptr(n_output, 0);
    #####: 7009:        attr = gen_xmlAttrPtr(n_attr, 1);
    #####: 7010:        depth = gen_int(n_depth, 2);
        -: 7011:
    #####: 7012:        xmlDebugDumpAttr(output, attr, depth);
    #####: 7013:        call_tests++;
    #####: 7014:        des_debug_FILE_ptr(n_output, output, 0);
    #####: 7015:        des_xmlAttrPtr(n_attr, attr, 1);
    #####: 7016:        des_int(n_depth, depth, 2);
    #####: 7017:        xmlResetLastError();
    #####: 7018:        if (mem_base != xmlMemBlocks()) {
    #####: 7019:            printf("Leak of %d blocks found in xmlDebugDumpAttr",
    #####: 7020:	           xmlMemBlocks() - mem_base);
    #####: 7021:	    test_ret++;
    #####: 7022:            printf(" %d", n_output);
    #####: 7023:            printf(" %d", n_attr);
    #####: 7024:            printf(" %d", n_depth);
    #####: 7025:            printf("\n");
        -: 7026:        }
        -: 7027:    }
        -: 7028:    }
        -: 7029:    }
    #####: 7030:    function_tests++;
        -: 7031:#endif
        -: 7032:
    #####: 7033:    return(test_ret);
        -: 7034:}
        -: 7035:
        -: 7036:
        -: 7037:static int
    #####: 7038:test_xmlDebugDumpAttrList(void) {
    #####: 7039:    int test_ret = 0;
        -: 7040:
        -: 7041:#if defined(LIBXML_DEBUG_ENABLED)
        -: 7042:    int mem_base;
        -: 7043:    FILE * output; /* the FILE * for the output */
        -: 7044:    int n_output;
        -: 7045:    xmlAttrPtr attr; /* the attribute list */
        -: 7046:    int n_attr;
        -: 7047:    int depth; /* the indentation level. */
        -: 7048:    int n_depth;
        -: 7049:
    #####: 7050:    for (n_output = 0;n_output < gen_nb_debug_FILE_ptr;n_output++) {
    #####: 7051:    for (n_attr = 0;n_attr < gen_nb_xmlAttrPtr;n_attr++) {
    #####: 7052:    for (n_depth = 0;n_depth < gen_nb_int;n_depth++) {
    #####: 7053:        mem_base = xmlMemBlocks();
    #####: 7054:        output = gen_debug_FILE_ptr(n_output, 0);
    #####: 7055:        attr = gen_xmlAttrPtr(n_attr, 1);
    #####: 7056:        depth = gen_int(n_depth, 2);
        -: 7057:
    #####: 7058:        xmlDebugDumpAttrList(output, attr, depth);
    #####: 7059:        call_tests++;
    #####: 7060:        des_debug_FILE_ptr(n_output, output, 0);
    #####: 7061:        des_xmlAttrPtr(n_attr, attr, 1);
    #####: 7062:        des_int(n_depth, depth, 2);
    #####: 7063:        xmlResetLastError();
    #####: 7064:        if (mem_base != xmlMemBlocks()) {
    #####: 7065:            printf("Leak of %d blocks found in xmlDebugDumpAttrList",
    #####: 7066:	           xmlMemBlocks() - mem_base);
    #####: 7067:	    test_ret++;
    #####: 7068:            printf(" %d", n_output);
    #####: 7069:            printf(" %d", n_attr);
    #####: 7070:            printf(" %d", n_depth);
    #####: 7071:            printf("\n");
        -: 7072:        }
        -: 7073:    }
        -: 7074:    }
        -: 7075:    }
    #####: 7076:    function_tests++;
        -: 7077:#endif
        -: 7078:
    #####: 7079:    return(test_ret);
        -: 7080:}
        -: 7081:
        -: 7082:
        -: 7083:static int
    #####: 7084:test_xmlDebugDumpDTD(void) {
    #####: 7085:    int test_ret = 0;
        -: 7086:
        -: 7087:#if defined(LIBXML_DEBUG_ENABLED)
        -: 7088:    int mem_base;
        -: 7089:    FILE * output; /* the FILE * for the output */
        -: 7090:    int n_output;
        -: 7091:    xmlDtdPtr dtd; /* the DTD */
        -: 7092:    int n_dtd;
        -: 7093:
    #####: 7094:    for (n_output = 0;n_output < gen_nb_debug_FILE_ptr;n_output++) {
    #####: 7095:    for (n_dtd = 0;n_dtd < gen_nb_xmlDtdPtr;n_dtd++) {
    #####: 7096:        mem_base = xmlMemBlocks();
    #####: 7097:        output = gen_debug_FILE_ptr(n_output, 0);
    #####: 7098:        dtd = gen_xmlDtdPtr(n_dtd, 1);
        -: 7099:
    #####: 7100:        xmlDebugDumpDTD(output, dtd);
    #####: 7101:        call_tests++;
    #####: 7102:        des_debug_FILE_ptr(n_output, output, 0);
    #####: 7103:        des_xmlDtdPtr(n_dtd, dtd, 1);
    #####: 7104:        xmlResetLastError();
    #####: 7105:        if (mem_base != xmlMemBlocks()) {
    #####: 7106:            printf("Leak of %d blocks found in xmlDebugDumpDTD",
    #####: 7107:	           xmlMemBlocks() - mem_base);
    #####: 7108:	    test_ret++;
    #####: 7109:            printf(" %d", n_output);
    #####: 7110:            printf(" %d", n_dtd);
    #####: 7111:            printf("\n");
        -: 7112:        }
        -: 7113:    }
        -: 7114:    }
    #####: 7115:    function_tests++;
        -: 7116:#endif
        -: 7117:
    #####: 7118:    return(test_ret);
        -: 7119:}
        -: 7120:
        -: 7121:
        -: 7122:static int
    #####: 7123:test_xmlDebugDumpDocument(void) {
    #####: 7124:    int test_ret = 0;
        -: 7125:
        -: 7126:#if defined(LIBXML_DEBUG_ENABLED)
        -: 7127:    int mem_base;
        -: 7128:    FILE * output; /* the FILE * for the output */
        -: 7129:    int n_output;
        -: 7130:    xmlDocPtr doc; /* the document */
        -: 7131:    int n_doc;
        -: 7132:
    #####: 7133:    for (n_output = 0;n_output < gen_nb_debug_FILE_ptr;n_output++) {
    #####: 7134:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####: 7135:        mem_base = xmlMemBlocks();
    #####: 7136:        output = gen_debug_FILE_ptr(n_output, 0);
    #####: 7137:        doc = gen_xmlDocPtr(n_doc, 1);
        -: 7138:
    #####: 7139:        xmlDebugDumpDocument(output, doc);
    #####: 7140:        call_tests++;
    #####: 7141:        des_debug_FILE_ptr(n_output, output, 0);
    #####: 7142:        des_xmlDocPtr(n_doc, doc, 1);
    #####: 7143:        xmlResetLastError();
    #####: 7144:        if (mem_base != xmlMemBlocks()) {
    #####: 7145:            printf("Leak of %d blocks found in xmlDebugDumpDocument",
    #####: 7146:	           xmlMemBlocks() - mem_base);
    #####: 7147:	    test_ret++;
    #####: 7148:            printf(" %d", n_output);
    #####: 7149:            printf(" %d", n_doc);
    #####: 7150:            printf("\n");
        -: 7151:        }
        -: 7152:    }
        -: 7153:    }
    #####: 7154:    function_tests++;
        -: 7155:#endif
        -: 7156:
    #####: 7157:    return(test_ret);
        -: 7158:}
        -: 7159:
        -: 7160:
        -: 7161:static int
    #####: 7162:test_xmlDebugDumpDocumentHead(void) {
    #####: 7163:    int test_ret = 0;
        -: 7164:
        -: 7165:#if defined(LIBXML_DEBUG_ENABLED)
        -: 7166:    int mem_base;
        -: 7167:    FILE * output; /* the FILE * for the output */
        -: 7168:    int n_output;
        -: 7169:    xmlDocPtr doc; /* the document */
        -: 7170:    int n_doc;
        -: 7171:
    #####: 7172:    for (n_output = 0;n_output < gen_nb_debug_FILE_ptr;n_output++) {
    #####: 7173:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####: 7174:        mem_base = xmlMemBlocks();
    #####: 7175:        output = gen_debug_FILE_ptr(n_output, 0);
    #####: 7176:        doc = gen_xmlDocPtr(n_doc, 1);
        -: 7177:
    #####: 7178:        xmlDebugDumpDocumentHead(output, doc);
    #####: 7179:        call_tests++;
    #####: 7180:        des_debug_FILE_ptr(n_output, output, 0);
    #####: 7181:        des_xmlDocPtr(n_doc, doc, 1);
    #####: 7182:        xmlResetLastError();
    #####: 7183:        if (mem_base != xmlMemBlocks()) {
    #####: 7184:            printf("Leak of %d blocks found in xmlDebugDumpDocumentHead",
    #####: 7185:	           xmlMemBlocks() - mem_base);
    #####: 7186:	    test_ret++;
    #####: 7187:            printf(" %d", n_output);
    #####: 7188:            printf(" %d", n_doc);
    #####: 7189:            printf("\n");
        -: 7190:        }
        -: 7191:    }
        -: 7192:    }
    #####: 7193:    function_tests++;
        -: 7194:#endif
        -: 7195:
    #####: 7196:    return(test_ret);
        -: 7197:}
        -: 7198:
        -: 7199:
        -: 7200:static int
    #####: 7201:test_xmlDebugDumpEntities(void) {
    #####: 7202:    int test_ret = 0;
        -: 7203:
        -: 7204:#if defined(LIBXML_DEBUG_ENABLED)
        -: 7205:    int mem_base;
        -: 7206:    FILE * output; /* the FILE * for the output */
        -: 7207:    int n_output;
        -: 7208:    xmlDocPtr doc; /* the document */
        -: 7209:    int n_doc;
        -: 7210:
    #####: 7211:    for (n_output = 0;n_output < gen_nb_debug_FILE_ptr;n_output++) {
    #####: 7212:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####: 7213:        mem_base = xmlMemBlocks();
    #####: 7214:        output = gen_debug_FILE_ptr(n_output, 0);
    #####: 7215:        doc = gen_xmlDocPtr(n_doc, 1);
        -: 7216:
    #####: 7217:        xmlDebugDumpEntities(output, doc);
    #####: 7218:        call_tests++;
    #####: 7219:        des_debug_FILE_ptr(n_output, output, 0);
    #####: 7220:        des_xmlDocPtr(n_doc, doc, 1);
    #####: 7221:        xmlResetLastError();
    #####: 7222:        if (mem_base != xmlMemBlocks()) {
    #####: 7223:            printf("Leak of %d blocks found in xmlDebugDumpEntities",
    #####: 7224:	           xmlMemBlocks() - mem_base);
    #####: 7225:	    test_ret++;
    #####: 7226:            printf(" %d", n_output);
    #####: 7227:            printf(" %d", n_doc);
    #####: 7228:            printf("\n");
        -: 7229:        }
        -: 7230:    }
        -: 7231:    }
    #####: 7232:    function_tests++;
        -: 7233:#endif
        -: 7234:
    #####: 7235:    return(test_ret);
        -: 7236:}
        -: 7237:
        -: 7238:
        -: 7239:static int
    #####: 7240:test_xmlDebugDumpNode(void) {
    #####: 7241:    int test_ret = 0;
        -: 7242:
        -: 7243:#if defined(LIBXML_DEBUG_ENABLED)
        -: 7244:    int mem_base;
        -: 7245:    FILE * output; /* the FILE * for the output */
        -: 7246:    int n_output;
        -: 7247:    xmlNodePtr node; /* the node */
        -: 7248:    int n_node;
        -: 7249:    int depth; /* the indentation level. */
        -: 7250:    int n_depth;
        -: 7251:
    #####: 7252:    for (n_output = 0;n_output < gen_nb_debug_FILE_ptr;n_output++) {
    #####: 7253:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####: 7254:    for (n_depth = 0;n_depth < gen_nb_int;n_depth++) {
    #####: 7255:        mem_base = xmlMemBlocks();
    #####: 7256:        output = gen_debug_FILE_ptr(n_output, 0);
    #####: 7257:        node = gen_xmlNodePtr(n_node, 1);
    #####: 7258:        depth = gen_int(n_depth, 2);
        -: 7259:
    #####: 7260:        xmlDebugDumpNode(output, node, depth);
    #####: 7261:        call_tests++;
    #####: 7262:        des_debug_FILE_ptr(n_output, output, 0);
    #####: 7263:        des_xmlNodePtr(n_node, node, 1);
    #####: 7264:        des_int(n_depth, depth, 2);
    #####: 7265:        xmlResetLastError();
    #####: 7266:        if (mem_base != xmlMemBlocks()) {
    #####: 7267:            printf("Leak of %d blocks found in xmlDebugDumpNode",
    #####: 7268:	           xmlMemBlocks() - mem_base);
    #####: 7269:	    test_ret++;
    #####: 7270:            printf(" %d", n_output);
    #####: 7271:            printf(" %d", n_node);
    #####: 7272:            printf(" %d", n_depth);
    #####: 7273:            printf("\n");
        -: 7274:        }
        -: 7275:    }
        -: 7276:    }
        -: 7277:    }
    #####: 7278:    function_tests++;
        -: 7279:#endif
        -: 7280:
    #####: 7281:    return(test_ret);
        -: 7282:}
        -: 7283:
        -: 7284:
        -: 7285:static int
    #####: 7286:test_xmlDebugDumpNodeList(void) {
    #####: 7287:    int test_ret = 0;
        -: 7288:
        -: 7289:#if defined(LIBXML_DEBUG_ENABLED)
        -: 7290:    int mem_base;
        -: 7291:    FILE * output; /* the FILE * for the output */
        -: 7292:    int n_output;
        -: 7293:    xmlNodePtr node; /* the node list */
        -: 7294:    int n_node;
        -: 7295:    int depth; /* the indentation level. */
        -: 7296:    int n_depth;
        -: 7297:
    #####: 7298:    for (n_output = 0;n_output < gen_nb_debug_FILE_ptr;n_output++) {
    #####: 7299:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####: 7300:    for (n_depth = 0;n_depth < gen_nb_int;n_depth++) {
    #####: 7301:        mem_base = xmlMemBlocks();
    #####: 7302:        output = gen_debug_FILE_ptr(n_output, 0);
    #####: 7303:        node = gen_xmlNodePtr(n_node, 1);
    #####: 7304:        depth = gen_int(n_depth, 2);
        -: 7305:
    #####: 7306:        xmlDebugDumpNodeList(output, node, depth);
    #####: 7307:        call_tests++;
    #####: 7308:        des_debug_FILE_ptr(n_output, output, 0);
    #####: 7309:        des_xmlNodePtr(n_node, node, 1);
    #####: 7310:        des_int(n_depth, depth, 2);
    #####: 7311:        xmlResetLastError();
    #####: 7312:        if (mem_base != xmlMemBlocks()) {
    #####: 7313:            printf("Leak of %d blocks found in xmlDebugDumpNodeList",
    #####: 7314:	           xmlMemBlocks() - mem_base);
    #####: 7315:	    test_ret++;
    #####: 7316:            printf(" %d", n_output);
    #####: 7317:            printf(" %d", n_node);
    #####: 7318:            printf(" %d", n_depth);
    #####: 7319:            printf("\n");
        -: 7320:        }
        -: 7321:    }
        -: 7322:    }
        -: 7323:    }
    #####: 7324:    function_tests++;
        -: 7325:#endif
        -: 7326:
    #####: 7327:    return(test_ret);
        -: 7328:}
        -: 7329:
        -: 7330:
        -: 7331:static int
    #####: 7332:test_xmlDebugDumpOneNode(void) {
    #####: 7333:    int test_ret = 0;
        -: 7334:
        -: 7335:#if defined(LIBXML_DEBUG_ENABLED)
        -: 7336:    int mem_base;
        -: 7337:    FILE * output; /* the FILE * for the output */
        -: 7338:    int n_output;
        -: 7339:    xmlNodePtr node; /* the node */
        -: 7340:    int n_node;
        -: 7341:    int depth; /* the indentation level. */
        -: 7342:    int n_depth;
        -: 7343:
    #####: 7344:    for (n_output = 0;n_output < gen_nb_debug_FILE_ptr;n_output++) {
    #####: 7345:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####: 7346:    for (n_depth = 0;n_depth < gen_nb_int;n_depth++) {
    #####: 7347:        mem_base = xmlMemBlocks();
    #####: 7348:        output = gen_debug_FILE_ptr(n_output, 0);
    #####: 7349:        node = gen_xmlNodePtr(n_node, 1);
    #####: 7350:        depth = gen_int(n_depth, 2);
        -: 7351:
    #####: 7352:        xmlDebugDumpOneNode(output, node, depth);
    #####: 7353:        call_tests++;
    #####: 7354:        des_debug_FILE_ptr(n_output, output, 0);
    #####: 7355:        des_xmlNodePtr(n_node, node, 1);
    #####: 7356:        des_int(n_depth, depth, 2);
    #####: 7357:        xmlResetLastError();
    #####: 7358:        if (mem_base != xmlMemBlocks()) {
    #####: 7359:            printf("Leak of %d blocks found in xmlDebugDumpOneNode",
    #####: 7360:	           xmlMemBlocks() - mem_base);
    #####: 7361:	    test_ret++;
    #####: 7362:            printf(" %d", n_output);
    #####: 7363:            printf(" %d", n_node);
    #####: 7364:            printf(" %d", n_depth);
    #####: 7365:            printf("\n");
        -: 7366:        }
        -: 7367:    }
        -: 7368:    }
        -: 7369:    }
    #####: 7370:    function_tests++;
        -: 7371:#endif
        -: 7372:
    #####: 7373:    return(test_ret);
        -: 7374:}
        -: 7375:
        -: 7376:
        -: 7377:static int
    #####: 7378:test_xmlDebugDumpString(void) {
    #####: 7379:    int test_ret = 0;
        -: 7380:
        -: 7381:#if defined(LIBXML_DEBUG_ENABLED)
        -: 7382:    int mem_base;
        -: 7383:    FILE * output; /* the FILE * for the output */
        -: 7384:    int n_output;
        -: 7385:    xmlChar * str; /* the string */
        -: 7386:    int n_str;
        -: 7387:
    #####: 7388:    for (n_output = 0;n_output < gen_nb_debug_FILE_ptr;n_output++) {
    #####: 7389:    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    #####: 7390:        mem_base = xmlMemBlocks();
    #####: 7391:        output = gen_debug_FILE_ptr(n_output, 0);
    #####: 7392:        str = gen_const_xmlChar_ptr(n_str, 1);
        -: 7393:
    #####: 7394:        xmlDebugDumpString(output, (const xmlChar *)str);
    #####: 7395:        call_tests++;
    #####: 7396:        des_debug_FILE_ptr(n_output, output, 0);
    #####: 7397:        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 1);
    #####: 7398:        xmlResetLastError();
    #####: 7399:        if (mem_base != xmlMemBlocks()) {
    #####: 7400:            printf("Leak of %d blocks found in xmlDebugDumpString",
    #####: 7401:	           xmlMemBlocks() - mem_base);
    #####: 7402:	    test_ret++;
    #####: 7403:            printf(" %d", n_output);
    #####: 7404:            printf(" %d", n_str);
    #####: 7405:            printf("\n");
        -: 7406:        }
        -: 7407:    }
        -: 7408:    }
    #####: 7409:    function_tests++;
        -: 7410:#endif
        -: 7411:
    #####: 7412:    return(test_ret);
        -: 7413:}
        -: 7414:
        -: 7415:
        -: 7416:static int
    #####: 7417:test_xmlLsCountNode(void) {
    #####: 7418:    int test_ret = 0;
        -: 7419:
        -: 7420:#if defined(LIBXML_DEBUG_ENABLED)
        -: 7421:    int mem_base;
        -: 7422:    int ret_val;
        -: 7423:    xmlNodePtr node; /* the node to count */
        -: 7424:    int n_node;
        -: 7425:
    #####: 7426:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####: 7427:        mem_base = xmlMemBlocks();
    #####: 7428:        node = gen_xmlNodePtr(n_node, 0);
        -: 7429:
    #####: 7430:        ret_val = xmlLsCountNode(node);
    #####: 7431:        desret_int(ret_val);
    #####: 7432:        call_tests++;
    #####: 7433:        des_xmlNodePtr(n_node, node, 0);
    #####: 7434:        xmlResetLastError();
    #####: 7435:        if (mem_base != xmlMemBlocks()) {
    #####: 7436:            printf("Leak of %d blocks found in xmlLsCountNode",
    #####: 7437:	           xmlMemBlocks() - mem_base);
    #####: 7438:	    test_ret++;
    #####: 7439:            printf(" %d", n_node);
    #####: 7440:            printf("\n");
        -: 7441:        }
        -: 7442:    }
    #####: 7443:    function_tests++;
        -: 7444:#endif
        -: 7445:
    #####: 7446:    return(test_ret);
        -: 7447:}
        -: 7448:
        -: 7449:
        -: 7450:static int
    #####: 7451:test_xmlLsOneNode(void) {
    #####: 7452:    int test_ret = 0;
        -: 7453:
        -: 7454:#if defined(LIBXML_DEBUG_ENABLED)
        -: 7455:    int mem_base;
        -: 7456:    FILE * output; /* the FILE * for the output */
        -: 7457:    int n_output;
        -: 7458:    xmlNodePtr node; /* the node to dump */
        -: 7459:    int n_node;
        -: 7460:
    #####: 7461:    for (n_output = 0;n_output < gen_nb_debug_FILE_ptr;n_output++) {
    #####: 7462:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####: 7463:        mem_base = xmlMemBlocks();
    #####: 7464:        output = gen_debug_FILE_ptr(n_output, 0);
    #####: 7465:        node = gen_xmlNodePtr(n_node, 1);
        -: 7466:
    #####: 7467:        xmlLsOneNode(output, node);
    #####: 7468:        call_tests++;
    #####: 7469:        des_debug_FILE_ptr(n_output, output, 0);
    #####: 7470:        des_xmlNodePtr(n_node, node, 1);
    #####: 7471:        xmlResetLastError();
    #####: 7472:        if (mem_base != xmlMemBlocks()) {
    #####: 7473:            printf("Leak of %d blocks found in xmlLsOneNode",
    #####: 7474:	           xmlMemBlocks() - mem_base);
    #####: 7475:	    test_ret++;
    #####: 7476:            printf(" %d", n_output);
    #####: 7477:            printf(" %d", n_node);
    #####: 7478:            printf("\n");
        -: 7479:        }
        -: 7480:    }
        -: 7481:    }
    #####: 7482:    function_tests++;
        -: 7483:#endif
        -: 7484:
    #####: 7485:    return(test_ret);
        -: 7486:}
        -: 7487:
        -: 7488:
        -: 7489:#define gen_nb_char_ptr 1
    #####: 7490:static char * gen_char_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 7491:    return(NULL);
        -: 7492:}
    #####: 7493:static void des_char_ptr(int no ATTRIBUTE_UNUSED, char * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 7494:}
        -: 7495:
        -: 7496:static int
    #####: 7497:test_xmlShell(void) {
    #####: 7498:    int test_ret = 0;
        -: 7499:
        -: 7500:
        -: 7501:    /* missing type support */
    #####: 7502:    return(test_ret);
        -: 7503:}
        -: 7504:
        -: 7505:
        -: 7506:static int
    #####: 7507:test_xmlShellBase(void) {
    #####: 7508:    int test_ret = 0;
        -: 7509:
        -: 7510:#if defined(LIBXML_DEBUG_ENABLED) && defined(LIBXML_XPATH_ENABLED)
        -: 7511:    int mem_base;
        -: 7512:    int ret_val;
        -: 7513:    xmlShellCtxtPtr ctxt; /* the shell context */
        -: 7514:    int n_ctxt;
        -: 7515:    char * arg; /* unused */
        -: 7516:    int n_arg;
        -: 7517:    xmlNodePtr node; /* a node */
        -: 7518:    int n_node;
        -: 7519:    xmlNodePtr node2; /* unused */
        -: 7520:    int n_node2;
        -: 7521:
    #####: 7522:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlShellCtxtPtr;n_ctxt++) {
    #####: 7523:    for (n_arg = 0;n_arg < gen_nb_char_ptr;n_arg++) {
    #####: 7524:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####: 7525:    for (n_node2 = 0;n_node2 < gen_nb_xmlNodePtr;n_node2++) {
    #####: 7526:        mem_base = xmlMemBlocks();
    #####: 7527:        ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0);
    #####: 7528:        arg = gen_char_ptr(n_arg, 1);
    #####: 7529:        node = gen_xmlNodePtr(n_node, 2);
    #####: 7530:        node2 = gen_xmlNodePtr(n_node2, 3);
        -: 7531:
    #####: 7532:        ret_val = xmlShellBase(ctxt, arg, node, node2);
    #####: 7533:        desret_int(ret_val);
    #####: 7534:        call_tests++;
    #####: 7535:        des_xmlShellCtxtPtr(n_ctxt, ctxt, 0);
    #####: 7536:        des_char_ptr(n_arg, arg, 1);
    #####: 7537:        des_xmlNodePtr(n_node, node, 2);
    #####: 7538:        des_xmlNodePtr(n_node2, node2, 3);
    #####: 7539:        xmlResetLastError();
    #####: 7540:        if (mem_base != xmlMemBlocks()) {
    #####: 7541:            printf("Leak of %d blocks found in xmlShellBase",
    #####: 7542:	           xmlMemBlocks() - mem_base);
    #####: 7543:	    test_ret++;
    #####: 7544:            printf(" %d", n_ctxt);
    #####: 7545:            printf(" %d", n_arg);
    #####: 7546:            printf(" %d", n_node);
    #####: 7547:            printf(" %d", n_node2);
    #####: 7548:            printf("\n");
        -: 7549:        }
        -: 7550:    }
        -: 7551:    }
        -: 7552:    }
        -: 7553:    }
    #####: 7554:    function_tests++;
        -: 7555:#endif
        -: 7556:
    #####: 7557:    return(test_ret);
        -: 7558:}
        -: 7559:
        -: 7560:
        -: 7561:static int
    #####: 7562:test_xmlShellCat(void) {
    #####: 7563:    int test_ret = 0;
        -: 7564:
        -: 7565:#if defined(LIBXML_DEBUG_ENABLED) && defined(LIBXML_XPATH_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
        -: 7566:    int mem_base;
        -: 7567:    int ret_val;
        -: 7568:    xmlShellCtxtPtr ctxt; /* the shell context */
        -: 7569:    int n_ctxt;
        -: 7570:    char * arg; /* unused */
        -: 7571:    int n_arg;
        -: 7572:    xmlNodePtr node; /* a node */
        -: 7573:    int n_node;
        -: 7574:    xmlNodePtr node2; /* unused */
        -: 7575:    int n_node2;
        -: 7576:
    #####: 7577:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlShellCtxtPtr;n_ctxt++) {
    #####: 7578:    for (n_arg = 0;n_arg < gen_nb_char_ptr;n_arg++) {
    #####: 7579:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####: 7580:    for (n_node2 = 0;n_node2 < gen_nb_xmlNodePtr;n_node2++) {
    #####: 7581:        mem_base = xmlMemBlocks();
    #####: 7582:        ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0);
    #####: 7583:        arg = gen_char_ptr(n_arg, 1);
    #####: 7584:        node = gen_xmlNodePtr(n_node, 2);
    #####: 7585:        node2 = gen_xmlNodePtr(n_node2, 3);
        -: 7586:
    #####: 7587:        ret_val = xmlShellCat(ctxt, arg, node, node2);
    #####: 7588:        desret_int(ret_val);
    #####: 7589:        call_tests++;
    #####: 7590:        des_xmlShellCtxtPtr(n_ctxt, ctxt, 0);
    #####: 7591:        des_char_ptr(n_arg, arg, 1);
    #####: 7592:        des_xmlNodePtr(n_node, node, 2);
    #####: 7593:        des_xmlNodePtr(n_node2, node2, 3);
    #####: 7594:        xmlResetLastError();
    #####: 7595:        if (mem_base != xmlMemBlocks()) {
    #####: 7596:            printf("Leak of %d blocks found in xmlShellCat",
    #####: 7597:	           xmlMemBlocks() - mem_base);
    #####: 7598:	    test_ret++;
    #####: 7599:            printf(" %d", n_ctxt);
    #####: 7600:            printf(" %d", n_arg);
    #####: 7601:            printf(" %d", n_node);
    #####: 7602:            printf(" %d", n_node2);
    #####: 7603:            printf("\n");
        -: 7604:        }
        -: 7605:    }
        -: 7606:    }
        -: 7607:    }
        -: 7608:    }
    #####: 7609:    function_tests++;
        -: 7610:#endif
        -: 7611:
    #####: 7612:    return(test_ret);
        -: 7613:}
        -: 7614:
        -: 7615:
        -: 7616:static int
    #####: 7617:test_xmlShellDir(void) {
    #####: 7618:    int test_ret = 0;
        -: 7619:
        -: 7620:#if defined(LIBXML_DEBUG_ENABLED) && defined(LIBXML_XPATH_ENABLED)
        -: 7621:    int mem_base;
        -: 7622:    int ret_val;
        -: 7623:    xmlShellCtxtPtr ctxt; /* the shell context */
        -: 7624:    int n_ctxt;
        -: 7625:    char * arg; /* unused */
        -: 7626:    int n_arg;
        -: 7627:    xmlNodePtr node; /* a node */
        -: 7628:    int n_node;
        -: 7629:    xmlNodePtr node2; /* unused */
        -: 7630:    int n_node2;
        -: 7631:
    #####: 7632:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlShellCtxtPtr;n_ctxt++) {
    #####: 7633:    for (n_arg = 0;n_arg < gen_nb_char_ptr;n_arg++) {
    #####: 7634:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####: 7635:    for (n_node2 = 0;n_node2 < gen_nb_xmlNodePtr;n_node2++) {
    #####: 7636:        mem_base = xmlMemBlocks();
    #####: 7637:        ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0);
    #####: 7638:        arg = gen_char_ptr(n_arg, 1);
    #####: 7639:        node = gen_xmlNodePtr(n_node, 2);
    #####: 7640:        node2 = gen_xmlNodePtr(n_node2, 3);
        -: 7641:
    #####: 7642:        ret_val = xmlShellDir(ctxt, arg, node, node2);
    #####: 7643:        desret_int(ret_val);
    #####: 7644:        call_tests++;
    #####: 7645:        des_xmlShellCtxtPtr(n_ctxt, ctxt, 0);
    #####: 7646:        des_char_ptr(n_arg, arg, 1);
    #####: 7647:        des_xmlNodePtr(n_node, node, 2);
    #####: 7648:        des_xmlNodePtr(n_node2, node2, 3);
    #####: 7649:        xmlResetLastError();
    #####: 7650:        if (mem_base != xmlMemBlocks()) {
    #####: 7651:            printf("Leak of %d blocks found in xmlShellDir",
    #####: 7652:	           xmlMemBlocks() - mem_base);
    #####: 7653:	    test_ret++;
    #####: 7654:            printf(" %d", n_ctxt);
    #####: 7655:            printf(" %d", n_arg);
    #####: 7656:            printf(" %d", n_node);
    #####: 7657:            printf(" %d", n_node2);
    #####: 7658:            printf("\n");
        -: 7659:        }
        -: 7660:    }
        -: 7661:    }
        -: 7662:    }
        -: 7663:    }
    #####: 7664:    function_tests++;
        -: 7665:#endif
        -: 7666:
    #####: 7667:    return(test_ret);
        -: 7668:}
        -: 7669:
        -: 7670:
        -: 7671:static int
    #####: 7672:test_xmlShellDu(void) {
    #####: 7673:    int test_ret = 0;
        -: 7674:
        -: 7675:#if defined(LIBXML_DEBUG_ENABLED) && defined(LIBXML_XPATH_ENABLED)
        -: 7676:    int mem_base;
        -: 7677:    int ret_val;
        -: 7678:    xmlShellCtxtPtr ctxt; /* the shell context */
        -: 7679:    int n_ctxt;
        -: 7680:    char * arg; /* unused */
        -: 7681:    int n_arg;
        -: 7682:    xmlNodePtr tree; /* a node defining a subtree */
        -: 7683:    int n_tree;
        -: 7684:    xmlNodePtr node2; /* unused */
        -: 7685:    int n_node2;
        -: 7686:
    #####: 7687:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlShellCtxtPtr;n_ctxt++) {
    #####: 7688:    for (n_arg = 0;n_arg < gen_nb_char_ptr;n_arg++) {
    #####: 7689:    for (n_tree = 0;n_tree < gen_nb_xmlNodePtr;n_tree++) {
    #####: 7690:    for (n_node2 = 0;n_node2 < gen_nb_xmlNodePtr;n_node2++) {
    #####: 7691:        mem_base = xmlMemBlocks();
    #####: 7692:        ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0);
    #####: 7693:        arg = gen_char_ptr(n_arg, 1);
    #####: 7694:        tree = gen_xmlNodePtr(n_tree, 2);
    #####: 7695:        node2 = gen_xmlNodePtr(n_node2, 3);
        -: 7696:
    #####: 7697:        ret_val = xmlShellDu(ctxt, arg, tree, node2);
    #####: 7698:        desret_int(ret_val);
    #####: 7699:        call_tests++;
    #####: 7700:        des_xmlShellCtxtPtr(n_ctxt, ctxt, 0);
    #####: 7701:        des_char_ptr(n_arg, arg, 1);
    #####: 7702:        des_xmlNodePtr(n_tree, tree, 2);
    #####: 7703:        des_xmlNodePtr(n_node2, node2, 3);
    #####: 7704:        xmlResetLastError();
    #####: 7705:        if (mem_base != xmlMemBlocks()) {
    #####: 7706:            printf("Leak of %d blocks found in xmlShellDu",
    #####: 7707:	           xmlMemBlocks() - mem_base);
    #####: 7708:	    test_ret++;
    #####: 7709:            printf(" %d", n_ctxt);
    #####: 7710:            printf(" %d", n_arg);
    #####: 7711:            printf(" %d", n_tree);
    #####: 7712:            printf(" %d", n_node2);
    #####: 7713:            printf("\n");
        -: 7714:        }
        -: 7715:    }
        -: 7716:    }
        -: 7717:    }
        -: 7718:    }
    #####: 7719:    function_tests++;
        -: 7720:#endif
        -: 7721:
    #####: 7722:    return(test_ret);
        -: 7723:}
        -: 7724:
        -: 7725:
        -: 7726:static int
    #####: 7727:test_xmlShellList(void) {
    #####: 7728:    int test_ret = 0;
        -: 7729:
        -: 7730:#if defined(LIBXML_DEBUG_ENABLED) && defined(LIBXML_XPATH_ENABLED)
        -: 7731:    int mem_base;
        -: 7732:    int ret_val;
        -: 7733:    xmlShellCtxtPtr ctxt; /* the shell context */
        -: 7734:    int n_ctxt;
        -: 7735:    char * arg; /* unused */
        -: 7736:    int n_arg;
        -: 7737:    xmlNodePtr node; /* a node */
        -: 7738:    int n_node;
        -: 7739:    xmlNodePtr node2; /* unused */
        -: 7740:    int n_node2;
        -: 7741:
    #####: 7742:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlShellCtxtPtr;n_ctxt++) {
    #####: 7743:    for (n_arg = 0;n_arg < gen_nb_char_ptr;n_arg++) {
    #####: 7744:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####: 7745:    for (n_node2 = 0;n_node2 < gen_nb_xmlNodePtr;n_node2++) {
    #####: 7746:        mem_base = xmlMemBlocks();
    #####: 7747:        ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0);
    #####: 7748:        arg = gen_char_ptr(n_arg, 1);
    #####: 7749:        node = gen_xmlNodePtr(n_node, 2);
    #####: 7750:        node2 = gen_xmlNodePtr(n_node2, 3);
        -: 7751:
    #####: 7752:        ret_val = xmlShellList(ctxt, arg, node, node2);
    #####: 7753:        desret_int(ret_val);
    #####: 7754:        call_tests++;
    #####: 7755:        des_xmlShellCtxtPtr(n_ctxt, ctxt, 0);
    #####: 7756:        des_char_ptr(n_arg, arg, 1);
    #####: 7757:        des_xmlNodePtr(n_node, node, 2);
    #####: 7758:        des_xmlNodePtr(n_node2, node2, 3);
    #####: 7759:        xmlResetLastError();
    #####: 7760:        if (mem_base != xmlMemBlocks()) {
    #####: 7761:            printf("Leak of %d blocks found in xmlShellList",
    #####: 7762:	           xmlMemBlocks() - mem_base);
    #####: 7763:	    test_ret++;
    #####: 7764:            printf(" %d", n_ctxt);
    #####: 7765:            printf(" %d", n_arg);
    #####: 7766:            printf(" %d", n_node);
    #####: 7767:            printf(" %d", n_node2);
    #####: 7768:            printf("\n");
        -: 7769:        }
        -: 7770:    }
        -: 7771:    }
        -: 7772:    }
        -: 7773:    }
    #####: 7774:    function_tests++;
        -: 7775:#endif
        -: 7776:
    #####: 7777:    return(test_ret);
        -: 7778:}
        -: 7779:
        -: 7780:
        -: 7781:static int
    #####: 7782:test_xmlShellLoad(void) {
    #####: 7783:    int test_ret = 0;
        -: 7784:
        -: 7785:#if defined(LIBXML_DEBUG_ENABLED) && defined(LIBXML_XPATH_ENABLED)
        -: 7786:    int mem_base;
        -: 7787:    int ret_val;
        -: 7788:    xmlShellCtxtPtr ctxt; /* the shell context */
        -: 7789:    int n_ctxt;
        -: 7790:    char * filename; /* the file name */
        -: 7791:    int n_filename;
        -: 7792:    xmlNodePtr node; /* unused */
        -: 7793:    int n_node;
        -: 7794:    xmlNodePtr node2; /* unused */
        -: 7795:    int n_node2;
        -: 7796:
    #####: 7797:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlShellCtxtPtr;n_ctxt++) {
    #####: 7798:    for (n_filename = 0;n_filename < gen_nb_char_ptr;n_filename++) {
    #####: 7799:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####: 7800:    for (n_node2 = 0;n_node2 < gen_nb_xmlNodePtr;n_node2++) {
    #####: 7801:        mem_base = xmlMemBlocks();
    #####: 7802:        ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0);
    #####: 7803:        filename = gen_char_ptr(n_filename, 1);
    #####: 7804:        node = gen_xmlNodePtr(n_node, 2);
    #####: 7805:        node2 = gen_xmlNodePtr(n_node2, 3);
        -: 7806:
    #####: 7807:        ret_val = xmlShellLoad(ctxt, filename, node, node2);
    #####: 7808:        desret_int(ret_val);
    #####: 7809:        call_tests++;
    #####: 7810:        des_xmlShellCtxtPtr(n_ctxt, ctxt, 0);
    #####: 7811:        des_char_ptr(n_filename, filename, 1);
    #####: 7812:        des_xmlNodePtr(n_node, node, 2);
    #####: 7813:        des_xmlNodePtr(n_node2, node2, 3);
    #####: 7814:        xmlResetLastError();
    #####: 7815:        if (mem_base != xmlMemBlocks()) {
    #####: 7816:            printf("Leak of %d blocks found in xmlShellLoad",
    #####: 7817:	           xmlMemBlocks() - mem_base);
    #####: 7818:	    test_ret++;
    #####: 7819:            printf(" %d", n_ctxt);
    #####: 7820:            printf(" %d", n_filename);
    #####: 7821:            printf(" %d", n_node);
    #####: 7822:            printf(" %d", n_node2);
    #####: 7823:            printf("\n");
        -: 7824:        }
        -: 7825:    }
        -: 7826:    }
        -: 7827:    }
        -: 7828:    }
    #####: 7829:    function_tests++;
        -: 7830:#endif
        -: 7831:
    #####: 7832:    return(test_ret);
        -: 7833:}
        -: 7834:
        -: 7835:
        -: 7836:static int
    #####: 7837:test_xmlShellPrintXPathResult(void) {
    #####: 7838:    int test_ret = 0;
        -: 7839:
        -: 7840:#if defined(LIBXML_DEBUG_ENABLED) && defined(LIBXML_XPATH_ENABLED)
        -: 7841:    int mem_base;
        -: 7842:    xmlXPathObjectPtr list; /* a valid result generated by an xpath evaluation */
        -: 7843:    int n_list;
        -: 7844:
    #####: 7845:    for (n_list = 0;n_list < gen_nb_xmlXPathObjectPtr;n_list++) {
    #####: 7846:        mem_base = xmlMemBlocks();
    #####: 7847:        list = gen_xmlXPathObjectPtr(n_list, 0);
        -: 7848:
    #####: 7849:        xmlShellPrintXPathResult(list);
    #####: 7850:        call_tests++;
    #####: 7851:        des_xmlXPathObjectPtr(n_list, list, 0);
    #####: 7852:        xmlResetLastError();
    #####: 7853:        if (mem_base != xmlMemBlocks()) {
    #####: 7854:            printf("Leak of %d blocks found in xmlShellPrintXPathResult",
    #####: 7855:	           xmlMemBlocks() - mem_base);
    #####: 7856:	    test_ret++;
    #####: 7857:            printf(" %d", n_list);
    #####: 7858:            printf("\n");
        -: 7859:        }
        -: 7860:    }
    #####: 7861:    function_tests++;
        -: 7862:#endif
        -: 7863:
    #####: 7864:    return(test_ret);
        -: 7865:}
        -: 7866:
        -: 7867:
        -: 7868:static int
    #####: 7869:test_xmlShellPwd(void) {
    #####: 7870:    int test_ret = 0;
        -: 7871:
        -: 7872:#if defined(LIBXML_DEBUG_ENABLED) && defined(LIBXML_XPATH_ENABLED)
        -: 7873:    int mem_base;
        -: 7874:    int ret_val;
        -: 7875:    xmlShellCtxtPtr ctxt; /* the shell context */
        -: 7876:    int n_ctxt;
        -: 7877:    char * buffer; /* the output buffer */
        -: 7878:    int n_buffer;
        -: 7879:    xmlNodePtr node; /* a node */
        -: 7880:    int n_node;
        -: 7881:    xmlNodePtr node2; /* unused */
        -: 7882:    int n_node2;
        -: 7883:
    #####: 7884:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlShellCtxtPtr;n_ctxt++) {
    #####: 7885:    for (n_buffer = 0;n_buffer < gen_nb_char_ptr;n_buffer++) {
    #####: 7886:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####: 7887:    for (n_node2 = 0;n_node2 < gen_nb_xmlNodePtr;n_node2++) {
    #####: 7888:        mem_base = xmlMemBlocks();
    #####: 7889:        ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0);
    #####: 7890:        buffer = gen_char_ptr(n_buffer, 1);
    #####: 7891:        node = gen_xmlNodePtr(n_node, 2);
    #####: 7892:        node2 = gen_xmlNodePtr(n_node2, 3);
        -: 7893:
    #####: 7894:        ret_val = xmlShellPwd(ctxt, buffer, node, node2);
    #####: 7895:        desret_int(ret_val);
    #####: 7896:        call_tests++;
    #####: 7897:        des_xmlShellCtxtPtr(n_ctxt, ctxt, 0);
    #####: 7898:        des_char_ptr(n_buffer, buffer, 1);
    #####: 7899:        des_xmlNodePtr(n_node, node, 2);
    #####: 7900:        des_xmlNodePtr(n_node2, node2, 3);
    #####: 7901:        xmlResetLastError();
    #####: 7902:        if (mem_base != xmlMemBlocks()) {
    #####: 7903:            printf("Leak of %d blocks found in xmlShellPwd",
    #####: 7904:	           xmlMemBlocks() - mem_base);
    #####: 7905:	    test_ret++;
    #####: 7906:            printf(" %d", n_ctxt);
    #####: 7907:            printf(" %d", n_buffer);
    #####: 7908:            printf(" %d", n_node);
    #####: 7909:            printf(" %d", n_node2);
    #####: 7910:            printf("\n");
        -: 7911:        }
        -: 7912:    }
        -: 7913:    }
        -: 7914:    }
        -: 7915:    }
    #####: 7916:    function_tests++;
        -: 7917:#endif
        -: 7918:
    #####: 7919:    return(test_ret);
        -: 7920:}
        -: 7921:
        -: 7922:
        -: 7923:static int
    #####: 7924:test_xmlShellSave(void) {
    #####: 7925:    int test_ret = 0;
        -: 7926:
        -: 7927:#if defined(LIBXML_DEBUG_ENABLED) && defined(LIBXML_XPATH_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
        -: 7928:    int mem_base;
        -: 7929:    int ret_val;
        -: 7930:    xmlShellCtxtPtr ctxt; /* the shell context */
        -: 7931:    int n_ctxt;
        -: 7932:    char * filename; /* the file name (optional) */
        -: 7933:    int n_filename;
        -: 7934:    xmlNodePtr node; /* unused */
        -: 7935:    int n_node;
        -: 7936:    xmlNodePtr node2; /* unused */
        -: 7937:    int n_node2;
        -: 7938:
    #####: 7939:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlShellCtxtPtr;n_ctxt++) {
    #####: 7940:    for (n_filename = 0;n_filename < gen_nb_char_ptr;n_filename++) {
    #####: 7941:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####: 7942:    for (n_node2 = 0;n_node2 < gen_nb_xmlNodePtr;n_node2++) {
    #####: 7943:        mem_base = xmlMemBlocks();
    #####: 7944:        ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0);
    #####: 7945:        filename = gen_char_ptr(n_filename, 1);
    #####: 7946:        node = gen_xmlNodePtr(n_node, 2);
    #####: 7947:        node2 = gen_xmlNodePtr(n_node2, 3);
        -: 7948:
    #####: 7949:        ret_val = xmlShellSave(ctxt, filename, node, node2);
    #####: 7950:        desret_int(ret_val);
    #####: 7951:        call_tests++;
    #####: 7952:        des_xmlShellCtxtPtr(n_ctxt, ctxt, 0);
    #####: 7953:        des_char_ptr(n_filename, filename, 1);
    #####: 7954:        des_xmlNodePtr(n_node, node, 2);
    #####: 7955:        des_xmlNodePtr(n_node2, node2, 3);
    #####: 7956:        xmlResetLastError();
    #####: 7957:        if (mem_base != xmlMemBlocks()) {
    #####: 7958:            printf("Leak of %d blocks found in xmlShellSave",
    #####: 7959:	           xmlMemBlocks() - mem_base);
    #####: 7960:	    test_ret++;
    #####: 7961:            printf(" %d", n_ctxt);
    #####: 7962:            printf(" %d", n_filename);
    #####: 7963:            printf(" %d", n_node);
    #####: 7964:            printf(" %d", n_node2);
    #####: 7965:            printf("\n");
        -: 7966:        }
        -: 7967:    }
        -: 7968:    }
        -: 7969:    }
        -: 7970:    }
    #####: 7971:    function_tests++;
        -: 7972:#endif
        -: 7973:
    #####: 7974:    return(test_ret);
        -: 7975:}
        -: 7976:
        -: 7977:
        -: 7978:static int
    #####: 7979:test_xmlShellValidate(void) {
    #####: 7980:    int test_ret = 0;
        -: 7981:
        -: 7982:#if defined(LIBXML_DEBUG_ENABLED) && defined(LIBXML_XPATH_ENABLED) && defined(LIBXML_VALID_ENABLED)
        -: 7983:    int mem_base;
        -: 7984:    int ret_val;
        -: 7985:    xmlShellCtxtPtr ctxt; /* the shell context */
        -: 7986:    int n_ctxt;
        -: 7987:    char * dtd; /* the DTD URI (optional) */
        -: 7988:    int n_dtd;
        -: 7989:    xmlNodePtr node; /* unused */
        -: 7990:    int n_node;
        -: 7991:    xmlNodePtr node2; /* unused */
        -: 7992:    int n_node2;
        -: 7993:
    #####: 7994:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlShellCtxtPtr;n_ctxt++) {
    #####: 7995:    for (n_dtd = 0;n_dtd < gen_nb_char_ptr;n_dtd++) {
    #####: 7996:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####: 7997:    for (n_node2 = 0;n_node2 < gen_nb_xmlNodePtr;n_node2++) {
    #####: 7998:        mem_base = xmlMemBlocks();
    #####: 7999:        ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0);
    #####: 8000:        dtd = gen_char_ptr(n_dtd, 1);
    #####: 8001:        node = gen_xmlNodePtr(n_node, 2);
    #####: 8002:        node2 = gen_xmlNodePtr(n_node2, 3);
        -: 8003:
    #####: 8004:        ret_val = xmlShellValidate(ctxt, dtd, node, node2);
    #####: 8005:        desret_int(ret_val);
    #####: 8006:        call_tests++;
    #####: 8007:        des_xmlShellCtxtPtr(n_ctxt, ctxt, 0);
    #####: 8008:        des_char_ptr(n_dtd, dtd, 1);
    #####: 8009:        des_xmlNodePtr(n_node, node, 2);
    #####: 8010:        des_xmlNodePtr(n_node2, node2, 3);
    #####: 8011:        xmlResetLastError();
    #####: 8012:        if (mem_base != xmlMemBlocks()) {
    #####: 8013:            printf("Leak of %d blocks found in xmlShellValidate",
    #####: 8014:	           xmlMemBlocks() - mem_base);
    #####: 8015:	    test_ret++;
    #####: 8016:            printf(" %d", n_ctxt);
    #####: 8017:            printf(" %d", n_dtd);
    #####: 8018:            printf(" %d", n_node);
    #####: 8019:            printf(" %d", n_node2);
    #####: 8020:            printf("\n");
        -: 8021:        }
        -: 8022:    }
        -: 8023:    }
        -: 8024:    }
        -: 8025:    }
    #####: 8026:    function_tests++;
        -: 8027:#endif
        -: 8028:
    #####: 8029:    return(test_ret);
        -: 8030:}
        -: 8031:
        -: 8032:
        -: 8033:static int
    #####: 8034:test_xmlShellWrite(void) {
    #####: 8035:    int test_ret = 0;
        -: 8036:
        -: 8037:#if defined(LIBXML_DEBUG_ENABLED) && defined(LIBXML_XPATH_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
        -: 8038:    int mem_base;
        -: 8039:    int ret_val;
        -: 8040:    xmlShellCtxtPtr ctxt; /* the shell context */
        -: 8041:    int n_ctxt;
        -: 8042:    char * filename; /* the file name */
        -: 8043:    int n_filename;
        -: 8044:    xmlNodePtr node; /* a node in the tree */
        -: 8045:    int n_node;
        -: 8046:    xmlNodePtr node2; /* unused */
        -: 8047:    int n_node2;
        -: 8048:
    #####: 8049:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlShellCtxtPtr;n_ctxt++) {
    #####: 8050:    for (n_filename = 0;n_filename < gen_nb_char_ptr;n_filename++) {
    #####: 8051:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####: 8052:    for (n_node2 = 0;n_node2 < gen_nb_xmlNodePtr;n_node2++) {
    #####: 8053:        mem_base = xmlMemBlocks();
    #####: 8054:        ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0);
    #####: 8055:        filename = gen_char_ptr(n_filename, 1);
    #####: 8056:        node = gen_xmlNodePtr(n_node, 2);
    #####: 8057:        node2 = gen_xmlNodePtr(n_node2, 3);
        -: 8058:
    #####: 8059:        ret_val = xmlShellWrite(ctxt, filename, node, node2);
    #####: 8060:        desret_int(ret_val);
    #####: 8061:        call_tests++;
    #####: 8062:        des_xmlShellCtxtPtr(n_ctxt, ctxt, 0);
    #####: 8063:        des_char_ptr(n_filename, filename, 1);
    #####: 8064:        des_xmlNodePtr(n_node, node, 2);
    #####: 8065:        des_xmlNodePtr(n_node2, node2, 3);
    #####: 8066:        xmlResetLastError();
    #####: 8067:        if (mem_base != xmlMemBlocks()) {
    #####: 8068:            printf("Leak of %d blocks found in xmlShellWrite",
    #####: 8069:	           xmlMemBlocks() - mem_base);
    #####: 8070:	    test_ret++;
    #####: 8071:            printf(" %d", n_ctxt);
    #####: 8072:            printf(" %d", n_filename);
    #####: 8073:            printf(" %d", n_node);
    #####: 8074:            printf(" %d", n_node2);
    #####: 8075:            printf("\n");
        -: 8076:        }
        -: 8077:    }
        -: 8078:    }
        -: 8079:    }
        -: 8080:    }
    #####: 8081:    function_tests++;
        -: 8082:#endif
        -: 8083:
    #####: 8084:    return(test_ret);
        -: 8085:}
        -: 8086:
        -: 8087:static int
    #####: 8088:test_debugXML(void) {
    #####: 8089:    int test_ret = 0;
        -: 8090:
    #####: 8091:    if (quiet == 0) printf("Testing debugXML : 25 of 28 functions ...\n");
    #####: 8092:    test_ret += test_xmlBoolToText();
    #####: 8093:    test_ret += test_xmlDebugCheckDocument();
    #####: 8094:    test_ret += test_xmlDebugDumpAttr();
    #####: 8095:    test_ret += test_xmlDebugDumpAttrList();
    #####: 8096:    test_ret += test_xmlDebugDumpDTD();
    #####: 8097:    test_ret += test_xmlDebugDumpDocument();
    #####: 8098:    test_ret += test_xmlDebugDumpDocumentHead();
    #####: 8099:    test_ret += test_xmlDebugDumpEntities();
    #####: 8100:    test_ret += test_xmlDebugDumpNode();
    #####: 8101:    test_ret += test_xmlDebugDumpNodeList();
    #####: 8102:    test_ret += test_xmlDebugDumpOneNode();
    #####: 8103:    test_ret += test_xmlDebugDumpString();
    #####: 8104:    test_ret += test_xmlLsCountNode();
    #####: 8105:    test_ret += test_xmlLsOneNode();
    #####: 8106:    test_ret += test_xmlShell();
    #####: 8107:    test_ret += test_xmlShellBase();
    #####: 8108:    test_ret += test_xmlShellCat();
    #####: 8109:    test_ret += test_xmlShellDir();
    #####: 8110:    test_ret += test_xmlShellDu();
    #####: 8111:    test_ret += test_xmlShellList();
    #####: 8112:    test_ret += test_xmlShellLoad();
    #####: 8113:    test_ret += test_xmlShellPrintXPathResult();
    #####: 8114:    test_ret += test_xmlShellPwd();
    #####: 8115:    test_ret += test_xmlShellSave();
    #####: 8116:    test_ret += test_xmlShellValidate();
    #####: 8117:    test_ret += test_xmlShellWrite();
        -: 8118:
    #####: 8119:    if (test_ret != 0)
    #####: 8120:	printf("Module debugXML: %d errors\n", test_ret);
    #####: 8121:    return(test_ret);
        -: 8122:}
        -: 8123:
        -: 8124:static int
    #####: 8125:test_xmlDictCleanup(void) {
    #####: 8126:    int test_ret = 0;
        -: 8127:
        -: 8128:    int mem_base;
        -: 8129:
    #####: 8130:        mem_base = xmlMemBlocks();
        -: 8131:
    #####: 8132:        xmlDictCleanup();
    #####: 8133:        call_tests++;
    #####: 8134:        xmlResetLastError();
    #####: 8135:        if (mem_base != xmlMemBlocks()) {
    #####: 8136:            printf("Leak of %d blocks found in xmlDictCleanup",
    #####: 8137:	           xmlMemBlocks() - mem_base);
    #####: 8138:	    test_ret++;
    #####: 8139:            printf("\n");
        -: 8140:        }
    #####: 8141:    function_tests++;
        -: 8142:
    #####: 8143:    return(test_ret);
        -: 8144:}
        -: 8145:
        -: 8146:
        -: 8147:static int
    #####: 8148:test_xmlDictCreate(void) {
    #####: 8149:    int test_ret = 0;
        -: 8150:
        -: 8151:    int mem_base;
        -: 8152:    xmlDictPtr ret_val;
        -: 8153:
    #####: 8154:        mem_base = xmlMemBlocks();
        -: 8155:
    #####: 8156:        ret_val = xmlDictCreate();
    #####: 8157:        desret_xmlDictPtr(ret_val);
    #####: 8158:        call_tests++;
    #####: 8159:        xmlResetLastError();
    #####: 8160:        if (mem_base != xmlMemBlocks()) {
    #####: 8161:            printf("Leak of %d blocks found in xmlDictCreate",
    #####: 8162:	           xmlMemBlocks() - mem_base);
    #####: 8163:	    test_ret++;
    #####: 8164:            printf("\n");
        -: 8165:        }
    #####: 8166:    function_tests++;
        -: 8167:
    #####: 8168:    return(test_ret);
        -: 8169:}
        -: 8170:
        -: 8171:
        -: 8172:static int
    #####: 8173:test_xmlDictCreateSub(void) {
    #####: 8174:    int test_ret = 0;
        -: 8175:
        -: 8176:    int mem_base;
        -: 8177:    xmlDictPtr ret_val;
        -: 8178:    xmlDictPtr sub; /* an existing dictionnary */
        -: 8179:    int n_sub;
        -: 8180:
    #####: 8181:    for (n_sub = 0;n_sub < gen_nb_xmlDictPtr;n_sub++) {
    #####: 8182:        mem_base = xmlMemBlocks();
    #####: 8183:        sub = gen_xmlDictPtr(n_sub, 0);
        -: 8184:
    #####: 8185:        ret_val = xmlDictCreateSub(sub);
    #####: 8186:        desret_xmlDictPtr(ret_val);
    #####: 8187:        call_tests++;
    #####: 8188:        des_xmlDictPtr(n_sub, sub, 0);
    #####: 8189:        xmlResetLastError();
    #####: 8190:        if (mem_base != xmlMemBlocks()) {
    #####: 8191:            printf("Leak of %d blocks found in xmlDictCreateSub",
    #####: 8192:	           xmlMemBlocks() - mem_base);
    #####: 8193:	    test_ret++;
    #####: 8194:            printf(" %d", n_sub);
    #####: 8195:            printf("\n");
        -: 8196:        }
        -: 8197:    }
    #####: 8198:    function_tests++;
        -: 8199:
    #####: 8200:    return(test_ret);
        -: 8201:}
        -: 8202:
        -: 8203:
        -: 8204:static int
    #####: 8205:test_xmlDictExists(void) {
    #####: 8206:    int test_ret = 0;
        -: 8207:
        -: 8208:    int mem_base;
        -: 8209:    const xmlChar * ret_val;
        -: 8210:    xmlDictPtr dict; /* the dictionnary */
        -: 8211:    int n_dict;
        -: 8212:    xmlChar * name; /* the name of the userdata */
        -: 8213:    int n_name;
        -: 8214:    int len; /* the length of the name, if -1 it is recomputed */
        -: 8215:    int n_len;
        -: 8216:
    #####: 8217:    for (n_dict = 0;n_dict < gen_nb_xmlDictPtr;n_dict++) {
    #####: 8218:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####: 8219:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####: 8220:        mem_base = xmlMemBlocks();
    #####: 8221:        dict = gen_xmlDictPtr(n_dict, 0);
    #####: 8222:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####: 8223:        len = gen_int(n_len, 2);
        -: 8224:
    #####: 8225:        ret_val = xmlDictExists(dict, (const xmlChar *)name, len);
    #####: 8226:        desret_const_xmlChar_ptr(ret_val);
    #####: 8227:        call_tests++;
    #####: 8228:        des_xmlDictPtr(n_dict, dict, 0);
    #####: 8229:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####: 8230:        des_int(n_len, len, 2);
    #####: 8231:        xmlResetLastError();
    #####: 8232:        if (mem_base != xmlMemBlocks()) {
    #####: 8233:            printf("Leak of %d blocks found in xmlDictExists",
    #####: 8234:	           xmlMemBlocks() - mem_base);
    #####: 8235:	    test_ret++;
    #####: 8236:            printf(" %d", n_dict);
    #####: 8237:            printf(" %d", n_name);
    #####: 8238:            printf(" %d", n_len);
    #####: 8239:            printf("\n");
        -: 8240:        }
        -: 8241:    }
        -: 8242:    }
        -: 8243:    }
    #####: 8244:    function_tests++;
        -: 8245:
    #####: 8246:    return(test_ret);
        -: 8247:}
        -: 8248:
        -: 8249:
        -: 8250:static int
    #####: 8251:test_xmlDictGetUsage(void) {
    #####: 8252:    int test_ret = 0;
        -: 8253:
        -: 8254:
        -: 8255:    /* missing type support */
    #####: 8256:    return(test_ret);
        -: 8257:}
        -: 8258:
        -: 8259:
        -: 8260:static int
    #####: 8261:test_xmlDictLookup(void) {
    #####: 8262:    int test_ret = 0;
        -: 8263:
        -: 8264:    int mem_base;
        -: 8265:    const xmlChar * ret_val;
        -: 8266:    xmlDictPtr dict; /* the dictionnary */
        -: 8267:    int n_dict;
        -: 8268:    xmlChar * name; /* the name of the userdata */
        -: 8269:    int n_name;
        -: 8270:    int len; /* the length of the name, if -1 it is recomputed */
        -: 8271:    int n_len;
        -: 8272:
    #####: 8273:    for (n_dict = 0;n_dict < gen_nb_xmlDictPtr;n_dict++) {
    #####: 8274:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####: 8275:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####: 8276:        mem_base = xmlMemBlocks();
    #####: 8277:        dict = gen_xmlDictPtr(n_dict, 0);
    #####: 8278:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####: 8279:        len = gen_int(n_len, 2);
        -: 8280:
    #####: 8281:        ret_val = xmlDictLookup(dict, (const xmlChar *)name, len);
    #####: 8282:        desret_const_xmlChar_ptr(ret_val);
    #####: 8283:        call_tests++;
    #####: 8284:        des_xmlDictPtr(n_dict, dict, 0);
    #####: 8285:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####: 8286:        des_int(n_len, len, 2);
    #####: 8287:        xmlResetLastError();
    #####: 8288:        if (mem_base != xmlMemBlocks()) {
    #####: 8289:            printf("Leak of %d blocks found in xmlDictLookup",
    #####: 8290:	           xmlMemBlocks() - mem_base);
    #####: 8291:	    test_ret++;
    #####: 8292:            printf(" %d", n_dict);
    #####: 8293:            printf(" %d", n_name);
    #####: 8294:            printf(" %d", n_len);
    #####: 8295:            printf("\n");
        -: 8296:        }
        -: 8297:    }
        -: 8298:    }
        -: 8299:    }
    #####: 8300:    function_tests++;
        -: 8301:
    #####: 8302:    return(test_ret);
        -: 8303:}
        -: 8304:
        -: 8305:
        -: 8306:static int
    #####: 8307:test_xmlDictOwns(void) {
    #####: 8308:    int test_ret = 0;
        -: 8309:
        -: 8310:    int mem_base;
        -: 8311:    int ret_val;
        -: 8312:    xmlDictPtr dict; /* the dictionnary */
        -: 8313:    int n_dict;
        -: 8314:    xmlChar * str; /* the string */
        -: 8315:    int n_str;
        -: 8316:
    #####: 8317:    for (n_dict = 0;n_dict < gen_nb_xmlDictPtr;n_dict++) {
    #####: 8318:    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    #####: 8319:        mem_base = xmlMemBlocks();
    #####: 8320:        dict = gen_xmlDictPtr(n_dict, 0);
    #####: 8321:        str = gen_const_xmlChar_ptr(n_str, 1);
        -: 8322:
    #####: 8323:        ret_val = xmlDictOwns(dict, (const xmlChar *)str);
    #####: 8324:        desret_int(ret_val);
    #####: 8325:        call_tests++;
    #####: 8326:        des_xmlDictPtr(n_dict, dict, 0);
    #####: 8327:        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 1);
    #####: 8328:        xmlResetLastError();
    #####: 8329:        if (mem_base != xmlMemBlocks()) {
    #####: 8330:            printf("Leak of %d blocks found in xmlDictOwns",
    #####: 8331:	           xmlMemBlocks() - mem_base);
    #####: 8332:	    test_ret++;
    #####: 8333:            printf(" %d", n_dict);
    #####: 8334:            printf(" %d", n_str);
    #####: 8335:            printf("\n");
        -: 8336:        }
        -: 8337:    }
        -: 8338:    }
    #####: 8339:    function_tests++;
        -: 8340:
    #####: 8341:    return(test_ret);
        -: 8342:}
        -: 8343:
        -: 8344:
        -: 8345:static int
    #####: 8346:test_xmlDictQLookup(void) {
    #####: 8347:    int test_ret = 0;
        -: 8348:
        -: 8349:    int mem_base;
        -: 8350:    const xmlChar * ret_val;
        -: 8351:    xmlDictPtr dict; /* the dictionnary */
        -: 8352:    int n_dict;
        -: 8353:    xmlChar * prefix; /* the prefix */
        -: 8354:    int n_prefix;
        -: 8355:    xmlChar * name; /* the name */
        -: 8356:    int n_name;
        -: 8357:
    #####: 8358:    for (n_dict = 0;n_dict < gen_nb_xmlDictPtr;n_dict++) {
    #####: 8359:    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    #####: 8360:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####: 8361:        mem_base = xmlMemBlocks();
    #####: 8362:        dict = gen_xmlDictPtr(n_dict, 0);
    #####: 8363:        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
    #####: 8364:        name = gen_const_xmlChar_ptr(n_name, 2);
        -: 8365:
    #####: 8366:        ret_val = xmlDictQLookup(dict, (const xmlChar *)prefix, (const xmlChar *)name);
    #####: 8367:        desret_const_xmlChar_ptr(ret_val);
    #####: 8368:        call_tests++;
    #####: 8369:        des_xmlDictPtr(n_dict, dict, 0);
    #####: 8370:        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 1);
    #####: 8371:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
    #####: 8372:        xmlResetLastError();
    #####: 8373:        if (mem_base != xmlMemBlocks()) {
    #####: 8374:            printf("Leak of %d blocks found in xmlDictQLookup",
    #####: 8375:	           xmlMemBlocks() - mem_base);
    #####: 8376:	    test_ret++;
    #####: 8377:            printf(" %d", n_dict);
    #####: 8378:            printf(" %d", n_prefix);
    #####: 8379:            printf(" %d", n_name);
    #####: 8380:            printf("\n");
        -: 8381:        }
        -: 8382:    }
        -: 8383:    }
        -: 8384:    }
    #####: 8385:    function_tests++;
        -: 8386:
    #####: 8387:    return(test_ret);
        -: 8388:}
        -: 8389:
        -: 8390:
        -: 8391:static int
    #####: 8392:test_xmlDictReference(void) {
    #####: 8393:    int test_ret = 0;
        -: 8394:
        -: 8395:    int mem_base;
        -: 8396:    int ret_val;
        -: 8397:    xmlDictPtr dict; /* the dictionnary */
        -: 8398:    int n_dict;
        -: 8399:
    #####: 8400:    for (n_dict = 0;n_dict < gen_nb_xmlDictPtr;n_dict++) {
    #####: 8401:        mem_base = xmlMemBlocks();
    #####: 8402:        dict = gen_xmlDictPtr(n_dict, 0);
        -: 8403:
    #####: 8404:        ret_val = xmlDictReference(dict);
    #####: 8405:        xmlDictFree(dict);
    #####: 8406:        desret_int(ret_val);
    #####: 8407:        call_tests++;
    #####: 8408:        des_xmlDictPtr(n_dict, dict, 0);
    #####: 8409:        xmlResetLastError();
    #####: 8410:        if (mem_base != xmlMemBlocks()) {
    #####: 8411:            printf("Leak of %d blocks found in xmlDictReference",
    #####: 8412:	           xmlMemBlocks() - mem_base);
    #####: 8413:	    test_ret++;
    #####: 8414:            printf(" %d", n_dict);
    #####: 8415:            printf("\n");
        -: 8416:        }
        -: 8417:    }
    #####: 8418:    function_tests++;
        -: 8419:
    #####: 8420:    return(test_ret);
        -: 8421:}
        -: 8422:
        -: 8423:
        -: 8424:static int
    #####: 8425:test_xmlDictSetLimit(void) {
    #####: 8426:    int test_ret = 0;
        -: 8427:
        -: 8428:
        -: 8429:    /* missing type support */
    #####: 8430:    return(test_ret);
        -: 8431:}
        -: 8432:
        -: 8433:
        -: 8434:static int
    #####: 8435:test_xmlDictSize(void) {
    #####: 8436:    int test_ret = 0;
        -: 8437:
        -: 8438:    int mem_base;
        -: 8439:    int ret_val;
        -: 8440:    xmlDictPtr dict; /* the dictionnary */
        -: 8441:    int n_dict;
        -: 8442:
    #####: 8443:    for (n_dict = 0;n_dict < gen_nb_xmlDictPtr;n_dict++) {
    #####: 8444:        mem_base = xmlMemBlocks();
    #####: 8445:        dict = gen_xmlDictPtr(n_dict, 0);
        -: 8446:
    #####: 8447:        ret_val = xmlDictSize(dict);
    #####: 8448:        desret_int(ret_val);
    #####: 8449:        call_tests++;
    #####: 8450:        des_xmlDictPtr(n_dict, dict, 0);
    #####: 8451:        xmlResetLastError();
    #####: 8452:        if (mem_base != xmlMemBlocks()) {
    #####: 8453:            printf("Leak of %d blocks found in xmlDictSize",
    #####: 8454:	           xmlMemBlocks() - mem_base);
    #####: 8455:	    test_ret++;
    #####: 8456:            printf(" %d", n_dict);
    #####: 8457:            printf("\n");
        -: 8458:        }
        -: 8459:    }
    #####: 8460:    function_tests++;
        -: 8461:
    #####: 8462:    return(test_ret);
        -: 8463:}
        -: 8464:
        -: 8465:
        -: 8466:static int
    #####: 8467:test_xmlInitializeDict(void) {
    #####: 8468:    int test_ret = 0;
        -: 8469:
        -: 8470:    int mem_base;
        -: 8471:    int ret_val;
        -: 8472:
    #####: 8473:        mem_base = xmlMemBlocks();
        -: 8474:
    #####: 8475:        ret_val = xmlInitializeDict();
    #####: 8476:        desret_int(ret_val);
    #####: 8477:        call_tests++;
    #####: 8478:        xmlResetLastError();
    #####: 8479:        if (mem_base != xmlMemBlocks()) {
    #####: 8480:            printf("Leak of %d blocks found in xmlInitializeDict",
    #####: 8481:	           xmlMemBlocks() - mem_base);
    #####: 8482:	    test_ret++;
    #####: 8483:            printf("\n");
        -: 8484:        }
    #####: 8485:    function_tests++;
        -: 8486:
    #####: 8487:    return(test_ret);
        -: 8488:}
        -: 8489:
        -: 8490:static int
    #####: 8491:test_dict(void) {
    #####: 8492:    int test_ret = 0;
        -: 8493:
    #####: 8494:    if (quiet == 0) printf("Testing dict : 10 of 13 functions ...\n");
    #####: 8495:    test_ret += test_xmlDictCleanup();
    #####: 8496:    test_ret += test_xmlDictCreate();
    #####: 8497:    test_ret += test_xmlDictCreateSub();
    #####: 8498:    test_ret += test_xmlDictExists();
    #####: 8499:    test_ret += test_xmlDictGetUsage();
    #####: 8500:    test_ret += test_xmlDictLookup();
    #####: 8501:    test_ret += test_xmlDictOwns();
    #####: 8502:    test_ret += test_xmlDictQLookup();
    #####: 8503:    test_ret += test_xmlDictReference();
    #####: 8504:    test_ret += test_xmlDictSetLimit();
    #####: 8505:    test_ret += test_xmlDictSize();
    #####: 8506:    test_ret += test_xmlInitializeDict();
        -: 8507:
    #####: 8508:    if (test_ret != 0)
    #####: 8509:	printf("Module dict: %d errors\n", test_ret);
    #####: 8510:    return(test_ret);
        -: 8511:}
        -: 8512:
        -: 8513:static int
    #####: 8514:test_UTF8Toisolat1(void) {
    #####: 8515:    int test_ret = 0;
        -: 8516:
        -: 8517:#if defined(LIBXML_OUTPUT_ENABLED)
        -: 8518:#ifdef LIBXML_OUTPUT_ENABLED
        -: 8519:    int mem_base;
        -: 8520:    int ret_val;
        -: 8521:    unsigned char * out; /* a pointer to an array of bytes to store the result */
        -: 8522:    int n_out;
        -: 8523:    int * outlen; /* the length of @out */
        -: 8524:    int n_outlen;
        -: 8525:    unsigned char * in; /* a pointer to an array of UTF-8 chars */
        -: 8526:    int n_in;
        -: 8527:    int * inlen; /* the length of @in */
        -: 8528:    int n_inlen;
        -: 8529:
    #####: 8530:    for (n_out = 0;n_out < gen_nb_unsigned_char_ptr;n_out++) {
    #####: 8531:    for (n_outlen = 0;n_outlen < gen_nb_int_ptr;n_outlen++) {
    #####: 8532:    for (n_in = 0;n_in < gen_nb_const_unsigned_char_ptr;n_in++) {
    #####: 8533:    for (n_inlen = 0;n_inlen < gen_nb_int_ptr;n_inlen++) {
    #####: 8534:        mem_base = xmlMemBlocks();
    #####: 8535:        out = gen_unsigned_char_ptr(n_out, 0);
    #####: 8536:        outlen = gen_int_ptr(n_outlen, 1);
    #####: 8537:        in = gen_const_unsigned_char_ptr(n_in, 2);
    #####: 8538:        inlen = gen_int_ptr(n_inlen, 3);
        -: 8539:
    #####: 8540:        ret_val = UTF8Toisolat1(out, outlen, (const unsigned char *)in, inlen);
    #####: 8541:        desret_int(ret_val);
    #####: 8542:        call_tests++;
    #####: 8543:        des_unsigned_char_ptr(n_out, out, 0);
    #####: 8544:        des_int_ptr(n_outlen, outlen, 1);
    #####: 8545:        des_const_unsigned_char_ptr(n_in, (const unsigned char *)in, 2);
    #####: 8546:        des_int_ptr(n_inlen, inlen, 3);
    #####: 8547:        xmlResetLastError();
    #####: 8548:        if (mem_base != xmlMemBlocks()) {
    #####: 8549:            printf("Leak of %d blocks found in UTF8Toisolat1",
    #####: 8550:	           xmlMemBlocks() - mem_base);
    #####: 8551:	    test_ret++;
    #####: 8552:            printf(" %d", n_out);
    #####: 8553:            printf(" %d", n_outlen);
    #####: 8554:            printf(" %d", n_in);
    #####: 8555:            printf(" %d", n_inlen);
    #####: 8556:            printf("\n");
        -: 8557:        }
        -: 8558:    }
        -: 8559:    }
        -: 8560:    }
        -: 8561:    }
    #####: 8562:    function_tests++;
        -: 8563:#endif
        -: 8564:#endif
        -: 8565:
    #####: 8566:    return(test_ret);
        -: 8567:}
        -: 8568:
        -: 8569:
        -: 8570:static int
    #####: 8571:test_isolat1ToUTF8(void) {
    #####: 8572:    int test_ret = 0;
        -: 8573:
        -: 8574:    int mem_base;
        -: 8575:    int ret_val;
        -: 8576:    unsigned char * out; /* a pointer to an array of bytes to store the result */
        -: 8577:    int n_out;
        -: 8578:    int * outlen; /* the length of @out */
        -: 8579:    int n_outlen;
        -: 8580:    unsigned char * in; /* a pointer to an array of ISO Latin 1 chars */
        -: 8581:    int n_in;
        -: 8582:    int * inlen; /* the length of @in */
        -: 8583:    int n_inlen;
        -: 8584:
    #####: 8585:    for (n_out = 0;n_out < gen_nb_unsigned_char_ptr;n_out++) {
    #####: 8586:    for (n_outlen = 0;n_outlen < gen_nb_int_ptr;n_outlen++) {
    #####: 8587:    for (n_in = 0;n_in < gen_nb_const_unsigned_char_ptr;n_in++) {
    #####: 8588:    for (n_inlen = 0;n_inlen < gen_nb_int_ptr;n_inlen++) {
    #####: 8589:        mem_base = xmlMemBlocks();
    #####: 8590:        out = gen_unsigned_char_ptr(n_out, 0);
    #####: 8591:        outlen = gen_int_ptr(n_outlen, 1);
    #####: 8592:        in = gen_const_unsigned_char_ptr(n_in, 2);
    #####: 8593:        inlen = gen_int_ptr(n_inlen, 3);
        -: 8594:
    #####: 8595:        ret_val = isolat1ToUTF8(out, outlen, (const unsigned char *)in, inlen);
    #####: 8596:        desret_int(ret_val);
    #####: 8597:        call_tests++;
    #####: 8598:        des_unsigned_char_ptr(n_out, out, 0);
    #####: 8599:        des_int_ptr(n_outlen, outlen, 1);
    #####: 8600:        des_const_unsigned_char_ptr(n_in, (const unsigned char *)in, 2);
    #####: 8601:        des_int_ptr(n_inlen, inlen, 3);
    #####: 8602:        xmlResetLastError();
    #####: 8603:        if (mem_base != xmlMemBlocks()) {
    #####: 8604:            printf("Leak of %d blocks found in isolat1ToUTF8",
    #####: 8605:	           xmlMemBlocks() - mem_base);
    #####: 8606:	    test_ret++;
    #####: 8607:            printf(" %d", n_out);
    #####: 8608:            printf(" %d", n_outlen);
    #####: 8609:            printf(" %d", n_in);
    #####: 8610:            printf(" %d", n_inlen);
    #####: 8611:            printf("\n");
        -: 8612:        }
        -: 8613:    }
        -: 8614:    }
        -: 8615:    }
        -: 8616:    }
    #####: 8617:    function_tests++;
        -: 8618:
    #####: 8619:    return(test_ret);
        -: 8620:}
        -: 8621:
        -: 8622:
        -: 8623:static int
    #####: 8624:test_xmlAddEncodingAlias(void) {
    #####: 8625:    int test_ret = 0;
        -: 8626:
        -: 8627:    int ret_val;
        -: 8628:    char * name; /* the encoding name as parsed, in UTF-8 format (ASCII actually) */
        -: 8629:    int n_name;
        -: 8630:    char * alias; /* the alias name as parsed, in UTF-8 format (ASCII actually) */
        -: 8631:    int n_alias;
        -: 8632:
    #####: 8633:    for (n_name = 0;n_name < gen_nb_const_char_ptr;n_name++) {
    #####: 8634:    for (n_alias = 0;n_alias < gen_nb_const_char_ptr;n_alias++) {
    #####: 8635:        name = gen_const_char_ptr(n_name, 0);
    #####: 8636:        alias = gen_const_char_ptr(n_alias, 1);
        -: 8637:
    #####: 8638:        ret_val = xmlAddEncodingAlias((const char *)name, (const char *)alias);
    #####: 8639:        desret_int(ret_val);
    #####: 8640:        call_tests++;
    #####: 8641:        des_const_char_ptr(n_name, (const char *)name, 0);
    #####: 8642:        des_const_char_ptr(n_alias, (const char *)alias, 1);
    #####: 8643:        xmlResetLastError();
        -: 8644:    }
        -: 8645:    }
    #####: 8646:    function_tests++;
        -: 8647:
    #####: 8648:    return(test_ret);
        -: 8649:}
        -: 8650:
        -: 8651:
        -: 8652:#define gen_nb_xmlCharEncodingHandler_ptr 1
    #####: 8653:static xmlCharEncodingHandler * gen_xmlCharEncodingHandler_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 8654:    return(NULL);
        -: 8655:}
    #####: 8656:static void des_xmlCharEncodingHandler_ptr(int no ATTRIBUTE_UNUSED, xmlCharEncodingHandler * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 8657:}
        -: 8658:
        -: 8659:static int
    #####: 8660:test_xmlCharEncCloseFunc(void) {
    #####: 8661:    int test_ret = 0;
        -: 8662:
        -: 8663:    int mem_base;
        -: 8664:    int ret_val;
        -: 8665:    xmlCharEncodingHandler * handler; /* char enconding transformation data structure */
        -: 8666:    int n_handler;
        -: 8667:
    #####: 8668:    for (n_handler = 0;n_handler < gen_nb_xmlCharEncodingHandler_ptr;n_handler++) {
    #####: 8669:        mem_base = xmlMemBlocks();
    #####: 8670:        handler = gen_xmlCharEncodingHandler_ptr(n_handler, 0);
        -: 8671:
    #####: 8672:        ret_val = xmlCharEncCloseFunc(handler);
    #####: 8673:        desret_int(ret_val);
    #####: 8674:        call_tests++;
    #####: 8675:        des_xmlCharEncodingHandler_ptr(n_handler, handler, 0);
    #####: 8676:        xmlResetLastError();
    #####: 8677:        if (mem_base != xmlMemBlocks()) {
    #####: 8678:            printf("Leak of %d blocks found in xmlCharEncCloseFunc",
    #####: 8679:	           xmlMemBlocks() - mem_base);
    #####: 8680:	    test_ret++;
    #####: 8681:            printf(" %d", n_handler);
    #####: 8682:            printf("\n");
        -: 8683:        }
        -: 8684:    }
    #####: 8685:    function_tests++;
        -: 8686:
    #####: 8687:    return(test_ret);
        -: 8688:}
        -: 8689:
        -: 8690:
        -: 8691:static int
    #####: 8692:test_xmlCharEncFirstLine(void) {
    #####: 8693:    int test_ret = 0;
        -: 8694:
        -: 8695:    int mem_base;
        -: 8696:    int ret_val;
        -: 8697:    xmlCharEncodingHandler * handler; /* char enconding transformation data structure */
        -: 8698:    int n_handler;
        -: 8699:    xmlBufferPtr out; /* an xmlBuffer for the output. */
        -: 8700:    int n_out;
        -: 8701:    xmlBufferPtr in; /* an xmlBuffer for the input */
        -: 8702:    int n_in;
        -: 8703:
    #####: 8704:    for (n_handler = 0;n_handler < gen_nb_xmlCharEncodingHandler_ptr;n_handler++) {
    #####: 8705:    for (n_out = 0;n_out < gen_nb_xmlBufferPtr;n_out++) {
    #####: 8706:    for (n_in = 0;n_in < gen_nb_xmlBufferPtr;n_in++) {
    #####: 8707:        mem_base = xmlMemBlocks();
    #####: 8708:        handler = gen_xmlCharEncodingHandler_ptr(n_handler, 0);
    #####: 8709:        out = gen_xmlBufferPtr(n_out, 1);
    #####: 8710:        in = gen_xmlBufferPtr(n_in, 2);
        -: 8711:
    #####: 8712:        ret_val = xmlCharEncFirstLine(handler, out, in);
    #####: 8713:        desret_int(ret_val);
    #####: 8714:        call_tests++;
    #####: 8715:        des_xmlCharEncodingHandler_ptr(n_handler, handler, 0);
    #####: 8716:        des_xmlBufferPtr(n_out, out, 1);
    #####: 8717:        des_xmlBufferPtr(n_in, in, 2);
    #####: 8718:        xmlResetLastError();
    #####: 8719:        if (mem_base != xmlMemBlocks()) {
    #####: 8720:            printf("Leak of %d blocks found in xmlCharEncFirstLine",
    #####: 8721:	           xmlMemBlocks() - mem_base);
    #####: 8722:	    test_ret++;
    #####: 8723:            printf(" %d", n_handler);
    #####: 8724:            printf(" %d", n_out);
    #####: 8725:            printf(" %d", n_in);
    #####: 8726:            printf("\n");
        -: 8727:        }
        -: 8728:    }
        -: 8729:    }
        -: 8730:    }
    #####: 8731:    function_tests++;
        -: 8732:
    #####: 8733:    return(test_ret);
        -: 8734:}
        -: 8735:
        -: 8736:
        -: 8737:static int
    #####: 8738:test_xmlCharEncInFunc(void) {
    #####: 8739:    int test_ret = 0;
        -: 8740:
        -: 8741:    int mem_base;
        -: 8742:    int ret_val;
        -: 8743:    xmlCharEncodingHandler * handler; /* char encoding transformation data structure */
        -: 8744:    int n_handler;
        -: 8745:    xmlBufferPtr out; /* an xmlBuffer for the output. */
        -: 8746:    int n_out;
        -: 8747:    xmlBufferPtr in; /* an xmlBuffer for the input */
        -: 8748:    int n_in;
        -: 8749:
    #####: 8750:    for (n_handler = 0;n_handler < gen_nb_xmlCharEncodingHandler_ptr;n_handler++) {
    #####: 8751:    for (n_out = 0;n_out < gen_nb_xmlBufferPtr;n_out++) {
    #####: 8752:    for (n_in = 0;n_in < gen_nb_xmlBufferPtr;n_in++) {
    #####: 8753:        mem_base = xmlMemBlocks();
    #####: 8754:        handler = gen_xmlCharEncodingHandler_ptr(n_handler, 0);
    #####: 8755:        out = gen_xmlBufferPtr(n_out, 1);
    #####: 8756:        in = gen_xmlBufferPtr(n_in, 2);
        -: 8757:
    #####: 8758:        ret_val = xmlCharEncInFunc(handler, out, in);
    #####: 8759:        desret_int(ret_val);
    #####: 8760:        call_tests++;
    #####: 8761:        des_xmlCharEncodingHandler_ptr(n_handler, handler, 0);
    #####: 8762:        des_xmlBufferPtr(n_out, out, 1);
    #####: 8763:        des_xmlBufferPtr(n_in, in, 2);
    #####: 8764:        xmlResetLastError();
    #####: 8765:        if (mem_base != xmlMemBlocks()) {
    #####: 8766:            printf("Leak of %d blocks found in xmlCharEncInFunc",
    #####: 8767:	           xmlMemBlocks() - mem_base);
    #####: 8768:	    test_ret++;
    #####: 8769:            printf(" %d", n_handler);
    #####: 8770:            printf(" %d", n_out);
    #####: 8771:            printf(" %d", n_in);
    #####: 8772:            printf("\n");
        -: 8773:        }
        -: 8774:    }
        -: 8775:    }
        -: 8776:    }
    #####: 8777:    function_tests++;
        -: 8778:
    #####: 8779:    return(test_ret);
        -: 8780:}
        -: 8781:
        -: 8782:
        -: 8783:static int
    #####: 8784:test_xmlCharEncOutFunc(void) {
    #####: 8785:    int test_ret = 0;
        -: 8786:
        -: 8787:    int mem_base;
        -: 8788:    int ret_val;
        -: 8789:    xmlCharEncodingHandler * handler; /* char enconding transformation data structure */
        -: 8790:    int n_handler;
        -: 8791:    xmlBufferPtr out; /* an xmlBuffer for the output. */
        -: 8792:    int n_out;
        -: 8793:    xmlBufferPtr in; /* an xmlBuffer for the input */
        -: 8794:    int n_in;
        -: 8795:
    #####: 8796:    for (n_handler = 0;n_handler < gen_nb_xmlCharEncodingHandler_ptr;n_handler++) {
    #####: 8797:    for (n_out = 0;n_out < gen_nb_xmlBufferPtr;n_out++) {
    #####: 8798:    for (n_in = 0;n_in < gen_nb_xmlBufferPtr;n_in++) {
    #####: 8799:        mem_base = xmlMemBlocks();
    #####: 8800:        handler = gen_xmlCharEncodingHandler_ptr(n_handler, 0);
    #####: 8801:        out = gen_xmlBufferPtr(n_out, 1);
    #####: 8802:        in = gen_xmlBufferPtr(n_in, 2);
        -: 8803:
    #####: 8804:        ret_val = xmlCharEncOutFunc(handler, out, in);
    #####: 8805:        desret_int(ret_val);
    #####: 8806:        call_tests++;
    #####: 8807:        des_xmlCharEncodingHandler_ptr(n_handler, handler, 0);
    #####: 8808:        des_xmlBufferPtr(n_out, out, 1);
    #####: 8809:        des_xmlBufferPtr(n_in, in, 2);
    #####: 8810:        xmlResetLastError();
    #####: 8811:        if (mem_base != xmlMemBlocks()) {
    #####: 8812:            printf("Leak of %d blocks found in xmlCharEncOutFunc",
    #####: 8813:	           xmlMemBlocks() - mem_base);
    #####: 8814:	    test_ret++;
    #####: 8815:            printf(" %d", n_handler);
    #####: 8816:            printf(" %d", n_out);
    #####: 8817:            printf(" %d", n_in);
    #####: 8818:            printf("\n");
        -: 8819:        }
        -: 8820:    }
        -: 8821:    }
        -: 8822:    }
    #####: 8823:    function_tests++;
        -: 8824:
    #####: 8825:    return(test_ret);
        -: 8826:}
        -: 8827:
        -: 8828:
        -: 8829:static int
    #####: 8830:test_xmlCleanupCharEncodingHandlers(void) {
    #####: 8831:    int test_ret = 0;
        -: 8832:
        -: 8833:
        -: 8834:
    #####: 8835:        xmlCleanupCharEncodingHandlers();
    #####: 8836:        call_tests++;
    #####: 8837:        xmlResetLastError();
    #####: 8838:    function_tests++;
        -: 8839:
    #####: 8840:    return(test_ret);
        -: 8841:}
        -: 8842:
        -: 8843:
        -: 8844:static int
    #####: 8845:test_xmlCleanupEncodingAliases(void) {
    #####: 8846:    int test_ret = 0;
        -: 8847:
        -: 8848:    int mem_base;
        -: 8849:
    #####: 8850:        mem_base = xmlMemBlocks();
        -: 8851:
    #####: 8852:        xmlCleanupEncodingAliases();
    #####: 8853:        call_tests++;
    #####: 8854:        xmlResetLastError();
    #####: 8855:        if (mem_base != xmlMemBlocks()) {
    #####: 8856:            printf("Leak of %d blocks found in xmlCleanupEncodingAliases",
    #####: 8857:	           xmlMemBlocks() - mem_base);
    #####: 8858:	    test_ret++;
    #####: 8859:            printf("\n");
        -: 8860:        }
    #####: 8861:    function_tests++;
        -: 8862:
    #####: 8863:    return(test_ret);
        -: 8864:}
        -: 8865:
        -: 8866:
        -: 8867:static int
    #####: 8868:test_xmlDelEncodingAlias(void) {
    #####: 8869:    int test_ret = 0;
        -: 8870:
        -: 8871:    int mem_base;
        -: 8872:    int ret_val;
        -: 8873:    char * alias; /* the alias name as parsed, in UTF-8 format (ASCII actually) */
        -: 8874:    int n_alias;
        -: 8875:
    #####: 8876:    for (n_alias = 0;n_alias < gen_nb_const_char_ptr;n_alias++) {
    #####: 8877:        mem_base = xmlMemBlocks();
    #####: 8878:        alias = gen_const_char_ptr(n_alias, 0);
        -: 8879:
    #####: 8880:        ret_val = xmlDelEncodingAlias((const char *)alias);
    #####: 8881:        desret_int(ret_val);
    #####: 8882:        call_tests++;
    #####: 8883:        des_const_char_ptr(n_alias, (const char *)alias, 0);
    #####: 8884:        xmlResetLastError();
    #####: 8885:        if (mem_base != xmlMemBlocks()) {
    #####: 8886:            printf("Leak of %d blocks found in xmlDelEncodingAlias",
    #####: 8887:	           xmlMemBlocks() - mem_base);
    #####: 8888:	    test_ret++;
    #####: 8889:            printf(" %d", n_alias);
    #####: 8890:            printf("\n");
        -: 8891:        }
        -: 8892:    }
    #####: 8893:    function_tests++;
        -: 8894:
    #####: 8895:    return(test_ret);
        -: 8896:}
        -: 8897:
        -: 8898:
        -: 8899:static int
    #####: 8900:test_xmlDetectCharEncoding(void) {
    #####: 8901:    int test_ret = 0;
        -: 8902:
        -: 8903:    int mem_base;
        -: 8904:    xmlCharEncoding ret_val;
        -: 8905:    unsigned char * in; /* a pointer to the first bytes of the XML entity, must be at least 2 bytes long (at least 4 if encoding is UTF4 variant). */
        -: 8906:    int n_in;
        -: 8907:    int len; /* pointer to the length of the buffer */
        -: 8908:    int n_len;
        -: 8909:
    #####: 8910:    for (n_in = 0;n_in < gen_nb_const_unsigned_char_ptr;n_in++) {
    #####: 8911:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####: 8912:        mem_base = xmlMemBlocks();
    #####: 8913:        in = gen_const_unsigned_char_ptr(n_in, 0);
    #####: 8914:        len = gen_int(n_len, 1);
        -: 8915:
    #####: 8916:        ret_val = xmlDetectCharEncoding((const unsigned char *)in, len);
    #####: 8917:        desret_xmlCharEncoding(ret_val);
    #####: 8918:        call_tests++;
    #####: 8919:        des_const_unsigned_char_ptr(n_in, (const unsigned char *)in, 0);
    #####: 8920:        des_int(n_len, len, 1);
    #####: 8921:        xmlResetLastError();
    #####: 8922:        if (mem_base != xmlMemBlocks()) {
    #####: 8923:            printf("Leak of %d blocks found in xmlDetectCharEncoding",
    #####: 8924:	           xmlMemBlocks() - mem_base);
    #####: 8925:	    test_ret++;
    #####: 8926:            printf(" %d", n_in);
    #####: 8927:            printf(" %d", n_len);
    #####: 8928:            printf("\n");
        -: 8929:        }
        -: 8930:    }
        -: 8931:    }
    #####: 8932:    function_tests++;
        -: 8933:
    #####: 8934:    return(test_ret);
        -: 8935:}
        -: 8936:
        -: 8937:
        -: 8938:static int
    #####: 8939:test_xmlFindCharEncodingHandler(void) {
    #####: 8940:    int test_ret = 0;
        -: 8941:
        -: 8942:
        -: 8943:    /* missing type support */
    #####: 8944:    return(test_ret);
        -: 8945:}
        -: 8946:
        -: 8947:
        -: 8948:static int
    #####: 8949:test_xmlGetCharEncodingHandler(void) {
    #####: 8950:    int test_ret = 0;
        -: 8951:
        -: 8952:
        -: 8953:    /* missing type support */
    #####: 8954:    return(test_ret);
        -: 8955:}
        -: 8956:
        -: 8957:
        -: 8958:static int
    #####: 8959:test_xmlGetCharEncodingName(void) {
    #####: 8960:    int test_ret = 0;
        -: 8961:
        -: 8962:    int mem_base;
        -: 8963:    const char * ret_val;
        -: 8964:    xmlCharEncoding enc; /* the encoding */
        -: 8965:    int n_enc;
        -: 8966:
    #####: 8967:    for (n_enc = 0;n_enc < gen_nb_xmlCharEncoding;n_enc++) {
    #####: 8968:        mem_base = xmlMemBlocks();
    #####: 8969:        enc = gen_xmlCharEncoding(n_enc, 0);
        -: 8970:
    #####: 8971:        ret_val = xmlGetCharEncodingName(enc);
    #####: 8972:        desret_const_char_ptr(ret_val);
    #####: 8973:        call_tests++;
    #####: 8974:        des_xmlCharEncoding(n_enc, enc, 0);
    #####: 8975:        xmlResetLastError();
    #####: 8976:        if (mem_base != xmlMemBlocks()) {
    #####: 8977:            printf("Leak of %d blocks found in xmlGetCharEncodingName",
    #####: 8978:	           xmlMemBlocks() - mem_base);
    #####: 8979:	    test_ret++;
    #####: 8980:            printf(" %d", n_enc);
    #####: 8981:            printf("\n");
        -: 8982:        }
        -: 8983:    }
    #####: 8984:    function_tests++;
        -: 8985:
    #####: 8986:    return(test_ret);
        -: 8987:}
        -: 8988:
        -: 8989:
        -: 8990:static int
    #####: 8991:test_xmlGetEncodingAlias(void) {
    #####: 8992:    int test_ret = 0;
        -: 8993:
        -: 8994:    int mem_base;
        -: 8995:    const char * ret_val;
        -: 8996:    char * alias; /* the alias name as parsed, in UTF-8 format (ASCII actually) */
        -: 8997:    int n_alias;
        -: 8998:
    #####: 8999:    for (n_alias = 0;n_alias < gen_nb_const_char_ptr;n_alias++) {
    #####: 9000:        mem_base = xmlMemBlocks();
    #####: 9001:        alias = gen_const_char_ptr(n_alias, 0);
        -: 9002:
    #####: 9003:        ret_val = xmlGetEncodingAlias((const char *)alias);
    #####: 9004:        desret_const_char_ptr(ret_val);
    #####: 9005:        call_tests++;
    #####: 9006:        des_const_char_ptr(n_alias, (const char *)alias, 0);
    #####: 9007:        xmlResetLastError();
    #####: 9008:        if (mem_base != xmlMemBlocks()) {
    #####: 9009:            printf("Leak of %d blocks found in xmlGetEncodingAlias",
    #####: 9010:	           xmlMemBlocks() - mem_base);
    #####: 9011:	    test_ret++;
    #####: 9012:            printf(" %d", n_alias);
    #####: 9013:            printf("\n");
        -: 9014:        }
        -: 9015:    }
    #####: 9016:    function_tests++;
        -: 9017:
    #####: 9018:    return(test_ret);
        -: 9019:}
        -: 9020:
        -: 9021:
        -: 9022:static int
    #####: 9023:test_xmlInitCharEncodingHandlers(void) {
    #####: 9024:    int test_ret = 0;
        -: 9025:
        -: 9026:
        -: 9027:
    #####: 9028:        xmlInitCharEncodingHandlers();
    #####: 9029:        call_tests++;
    #####: 9030:        xmlResetLastError();
    #####: 9031:    function_tests++;
        -: 9032:
    #####: 9033:    return(test_ret);
        -: 9034:}
        -: 9035:
        -: 9036:
        -: 9037:static int
    #####: 9038:test_xmlNewCharEncodingHandler(void) {
    #####: 9039:    int test_ret = 0;
        -: 9040:
        -: 9041:
        -: 9042:    /* missing type support */
    #####: 9043:    return(test_ret);
        -: 9044:}
        -: 9045:
        -: 9046:
        -: 9047:static int
    #####: 9048:test_xmlParseCharEncoding(void) {
    #####: 9049:    int test_ret = 0;
        -: 9050:
        -: 9051:    int mem_base;
        -: 9052:    xmlCharEncoding ret_val;
        -: 9053:    char * name; /* the encoding name as parsed, in UTF-8 format (ASCII actually) */
        -: 9054:    int n_name;
        -: 9055:
    #####: 9056:    for (n_name = 0;n_name < gen_nb_const_char_ptr;n_name++) {
    #####: 9057:        mem_base = xmlMemBlocks();
    #####: 9058:        name = gen_const_char_ptr(n_name, 0);
        -: 9059:
    #####: 9060:        ret_val = xmlParseCharEncoding((const char *)name);
    #####: 9061:        desret_xmlCharEncoding(ret_val);
    #####: 9062:        call_tests++;
    #####: 9063:        des_const_char_ptr(n_name, (const char *)name, 0);
    #####: 9064:        xmlResetLastError();
    #####: 9065:        if (mem_base != xmlMemBlocks()) {
    #####: 9066:            printf("Leak of %d blocks found in xmlParseCharEncoding",
    #####: 9067:	           xmlMemBlocks() - mem_base);
    #####: 9068:	    test_ret++;
    #####: 9069:            printf(" %d", n_name);
    #####: 9070:            printf("\n");
        -: 9071:        }
        -: 9072:    }
    #####: 9073:    function_tests++;
        -: 9074:
    #####: 9075:    return(test_ret);
        -: 9076:}
        -: 9077:
        -: 9078:
        -: 9079:#define gen_nb_xmlCharEncodingHandlerPtr 1
    #####: 9080:static xmlCharEncodingHandlerPtr gen_xmlCharEncodingHandlerPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 9081:    return(NULL);
        -: 9082:}
    #####: 9083:static void des_xmlCharEncodingHandlerPtr(int no ATTRIBUTE_UNUSED, xmlCharEncodingHandlerPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 9084:}
        -: 9085:
        -: 9086:static int
    #####: 9087:test_xmlRegisterCharEncodingHandler(void) {
    #####: 9088:    int test_ret = 0;
        -: 9089:
        -: 9090:    int mem_base;
        -: 9091:    xmlCharEncodingHandlerPtr handler; /* the xmlCharEncodingHandlerPtr handler block */
        -: 9092:    int n_handler;
        -: 9093:
    #####: 9094:    for (n_handler = 0;n_handler < gen_nb_xmlCharEncodingHandlerPtr;n_handler++) {
    #####: 9095:        mem_base = xmlMemBlocks();
    #####: 9096:        handler = gen_xmlCharEncodingHandlerPtr(n_handler, 0);
        -: 9097:
    #####: 9098:        xmlRegisterCharEncodingHandler(handler);
    #####: 9099:        call_tests++;
    #####: 9100:        des_xmlCharEncodingHandlerPtr(n_handler, handler, 0);
    #####: 9101:        xmlResetLastError();
    #####: 9102:        if (mem_base != xmlMemBlocks()) {
    #####: 9103:            printf("Leak of %d blocks found in xmlRegisterCharEncodingHandler",
    #####: 9104:	           xmlMemBlocks() - mem_base);
    #####: 9105:	    test_ret++;
    #####: 9106:            printf(" %d", n_handler);
    #####: 9107:            printf("\n");
        -: 9108:        }
        -: 9109:    }
    #####: 9110:    function_tests++;
        -: 9111:
    #####: 9112:    return(test_ret);
        -: 9113:}
        -: 9114:
        -: 9115:static int
    #####: 9116:test_encoding(void) {
    #####: 9117:    int test_ret = 0;
        -: 9118:
    #####: 9119:    if (quiet == 0) printf("Testing encoding : 16 of 19 functions ...\n");
    #####: 9120:    test_ret += test_UTF8Toisolat1();
    #####: 9121:    test_ret += test_isolat1ToUTF8();
    #####: 9122:    test_ret += test_xmlAddEncodingAlias();
    #####: 9123:    test_ret += test_xmlCharEncCloseFunc();
    #####: 9124:    test_ret += test_xmlCharEncFirstLine();
    #####: 9125:    test_ret += test_xmlCharEncInFunc();
    #####: 9126:    test_ret += test_xmlCharEncOutFunc();
    #####: 9127:    test_ret += test_xmlCleanupCharEncodingHandlers();
    #####: 9128:    test_ret += test_xmlCleanupEncodingAliases();
    #####: 9129:    test_ret += test_xmlDelEncodingAlias();
    #####: 9130:    test_ret += test_xmlDetectCharEncoding();
    #####: 9131:    test_ret += test_xmlFindCharEncodingHandler();
    #####: 9132:    test_ret += test_xmlGetCharEncodingHandler();
    #####: 9133:    test_ret += test_xmlGetCharEncodingName();
    #####: 9134:    test_ret += test_xmlGetEncodingAlias();
    #####: 9135:    test_ret += test_xmlInitCharEncodingHandlers();
    #####: 9136:    test_ret += test_xmlNewCharEncodingHandler();
    #####: 9137:    test_ret += test_xmlParseCharEncoding();
    #####: 9138:    test_ret += test_xmlRegisterCharEncodingHandler();
        -: 9139:
    #####: 9140:    if (test_ret != 0)
    #####: 9141:	printf("Module encoding: %d errors\n", test_ret);
    #####: 9142:    return(test_ret);
        -: 9143:}
        -: 9144:
        -: 9145:static int
    #####: 9146:test_xmlAddDocEntity(void) {
    #####: 9147:    int test_ret = 0;
        -: 9148:
        -: 9149:    int mem_base;
        -: 9150:    xmlEntityPtr ret_val;
        -: 9151:    xmlDocPtr doc; /* the document */
        -: 9152:    int n_doc;
        -: 9153:    xmlChar * name; /* the entity name */
        -: 9154:    int n_name;
        -: 9155:    int type; /* the entity type XML_xxx_yyy_ENTITY */
        -: 9156:    int n_type;
        -: 9157:    xmlChar * ExternalID; /* the entity external ID if available */
        -: 9158:    int n_ExternalID;
        -: 9159:    xmlChar * SystemID; /* the entity system ID if available */
        -: 9160:    int n_SystemID;
        -: 9161:    xmlChar * content; /* the entity content */
        -: 9162:    int n_content;
        -: 9163:
    #####: 9164:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####: 9165:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####: 9166:    for (n_type = 0;n_type < gen_nb_int;n_type++) {
    #####: 9167:    for (n_ExternalID = 0;n_ExternalID < gen_nb_const_xmlChar_ptr;n_ExternalID++) {
    #####: 9168:    for (n_SystemID = 0;n_SystemID < gen_nb_const_xmlChar_ptr;n_SystemID++) {
    #####: 9169:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####: 9170:        mem_base = xmlMemBlocks();
    #####: 9171:        doc = gen_xmlDocPtr(n_doc, 0);
    #####: 9172:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####: 9173:        type = gen_int(n_type, 2);
    #####: 9174:        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 3);
    #####: 9175:        SystemID = gen_const_xmlChar_ptr(n_SystemID, 4);
    #####: 9176:        content = gen_const_xmlChar_ptr(n_content, 5);
        -: 9177:
    #####: 9178:        ret_val = xmlAddDocEntity(doc, (const xmlChar *)name, type, (const xmlChar *)ExternalID, (const xmlChar *)SystemID, (const xmlChar *)content);
    #####: 9179:        desret_xmlEntityPtr(ret_val);
    #####: 9180:        call_tests++;
    #####: 9181:        des_xmlDocPtr(n_doc, doc, 0);
    #####: 9182:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####: 9183:        des_int(n_type, type, 2);
    #####: 9184:        des_const_xmlChar_ptr(n_ExternalID, (const xmlChar *)ExternalID, 3);
    #####: 9185:        des_const_xmlChar_ptr(n_SystemID, (const xmlChar *)SystemID, 4);
    #####: 9186:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 5);
    #####: 9187:        xmlResetLastError();
    #####: 9188:        if (mem_base != xmlMemBlocks()) {
    #####: 9189:            printf("Leak of %d blocks found in xmlAddDocEntity",
    #####: 9190:	           xmlMemBlocks() - mem_base);
    #####: 9191:	    test_ret++;
    #####: 9192:            printf(" %d", n_doc);
    #####: 9193:            printf(" %d", n_name);
    #####: 9194:            printf(" %d", n_type);
    #####: 9195:            printf(" %d", n_ExternalID);
    #####: 9196:            printf(" %d", n_SystemID);
    #####: 9197:            printf(" %d", n_content);
    #####: 9198:            printf("\n");
        -: 9199:        }
        -: 9200:    }
        -: 9201:    }
        -: 9202:    }
        -: 9203:    }
        -: 9204:    }
        -: 9205:    }
    #####: 9206:    function_tests++;
        -: 9207:
    #####: 9208:    return(test_ret);
        -: 9209:}
        -: 9210:
        -: 9211:
        -: 9212:static int
    #####: 9213:test_xmlAddDtdEntity(void) {
    #####: 9214:    int test_ret = 0;
        -: 9215:
        -: 9216:    int mem_base;
        -: 9217:    xmlEntityPtr ret_val;
        -: 9218:    xmlDocPtr doc; /* the document */
        -: 9219:    int n_doc;
        -: 9220:    xmlChar * name; /* the entity name */
        -: 9221:    int n_name;
        -: 9222:    int type; /* the entity type XML_xxx_yyy_ENTITY */
        -: 9223:    int n_type;
        -: 9224:    xmlChar * ExternalID; /* the entity external ID if available */
        -: 9225:    int n_ExternalID;
        -: 9226:    xmlChar * SystemID; /* the entity system ID if available */
        -: 9227:    int n_SystemID;
        -: 9228:    xmlChar * content; /* the entity content */
        -: 9229:    int n_content;
        -: 9230:
    #####: 9231:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####: 9232:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####: 9233:    for (n_type = 0;n_type < gen_nb_int;n_type++) {
    #####: 9234:    for (n_ExternalID = 0;n_ExternalID < gen_nb_const_xmlChar_ptr;n_ExternalID++) {
    #####: 9235:    for (n_SystemID = 0;n_SystemID < gen_nb_const_xmlChar_ptr;n_SystemID++) {
    #####: 9236:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####: 9237:        mem_base = xmlMemBlocks();
    #####: 9238:        doc = gen_xmlDocPtr(n_doc, 0);
    #####: 9239:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####: 9240:        type = gen_int(n_type, 2);
    #####: 9241:        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 3);
    #####: 9242:        SystemID = gen_const_xmlChar_ptr(n_SystemID, 4);
    #####: 9243:        content = gen_const_xmlChar_ptr(n_content, 5);
        -: 9244:
    #####: 9245:        ret_val = xmlAddDtdEntity(doc, (const xmlChar *)name, type, (const xmlChar *)ExternalID, (const xmlChar *)SystemID, (const xmlChar *)content);
    #####: 9246:        desret_xmlEntityPtr(ret_val);
    #####: 9247:        call_tests++;
    #####: 9248:        des_xmlDocPtr(n_doc, doc, 0);
    #####: 9249:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####: 9250:        des_int(n_type, type, 2);
    #####: 9251:        des_const_xmlChar_ptr(n_ExternalID, (const xmlChar *)ExternalID, 3);
    #####: 9252:        des_const_xmlChar_ptr(n_SystemID, (const xmlChar *)SystemID, 4);
    #####: 9253:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 5);
    #####: 9254:        xmlResetLastError();
    #####: 9255:        if (mem_base != xmlMemBlocks()) {
    #####: 9256:            printf("Leak of %d blocks found in xmlAddDtdEntity",
    #####: 9257:	           xmlMemBlocks() - mem_base);
    #####: 9258:	    test_ret++;
    #####: 9259:            printf(" %d", n_doc);
    #####: 9260:            printf(" %d", n_name);
    #####: 9261:            printf(" %d", n_type);
    #####: 9262:            printf(" %d", n_ExternalID);
    #####: 9263:            printf(" %d", n_SystemID);
    #####: 9264:            printf(" %d", n_content);
    #####: 9265:            printf("\n");
        -: 9266:        }
        -: 9267:    }
        -: 9268:    }
        -: 9269:    }
        -: 9270:    }
        -: 9271:    }
        -: 9272:    }
    #####: 9273:    function_tests++;
        -: 9274:
    #####: 9275:    return(test_ret);
        -: 9276:}
        -: 9277:
        -: 9278:
        -: 9279:static int
    #####: 9280:test_xmlCleanupPredefinedEntities(void) {
    #####: 9281:    int test_ret = 0;
        -: 9282:
        -: 9283:#if defined(LIBXML_LEGACY_ENABLED)
        -: 9284:#ifdef LIBXML_LEGACY_ENABLED
        -: 9285:    int mem_base;
        -: 9286:
    #####: 9287:        mem_base = xmlMemBlocks();
        -: 9288:
    #####: 9289:        xmlCleanupPredefinedEntities();
    #####: 9290:        call_tests++;
    #####: 9291:        xmlResetLastError();
    #####: 9292:        if (mem_base != xmlMemBlocks()) {
    #####: 9293:            printf("Leak of %d blocks found in xmlCleanupPredefinedEntities",
    #####: 9294:	           xmlMemBlocks() - mem_base);
    #####: 9295:	    test_ret++;
    #####: 9296:            printf("\n");
        -: 9297:        }
    #####: 9298:    function_tests++;
        -: 9299:#endif
        -: 9300:#endif
        -: 9301:
    #####: 9302:    return(test_ret);
        -: 9303:}
        -: 9304:
        -: 9305:
        -: 9306:#define gen_nb_xmlEntitiesTablePtr 1
    #####: 9307:static xmlEntitiesTablePtr gen_xmlEntitiesTablePtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 9308:    return(NULL);
        -: 9309:}
    #####: 9310:static void des_xmlEntitiesTablePtr(int no ATTRIBUTE_UNUSED, xmlEntitiesTablePtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 9311:}
        -: 9312:
        -: 9313:static int
    #####: 9314:test_xmlCopyEntitiesTable(void) {
    #####: 9315:    int test_ret = 0;
        -: 9316:
        -: 9317:
        -: 9318:    /* missing type support */
    #####: 9319:    return(test_ret);
        -: 9320:}
        -: 9321:
        -: 9322:
        -: 9323:static int
    #####: 9324:test_xmlCreateEntitiesTable(void) {
    #####: 9325:    int test_ret = 0;
        -: 9326:
        -: 9327:
        -: 9328:    /* missing type support */
    #####: 9329:    return(test_ret);
        -: 9330:}
        -: 9331:
        -: 9332:
        -: 9333:static int
    #####: 9334:test_xmlDumpEntitiesTable(void) {
    #####: 9335:    int test_ret = 0;
        -: 9336:
        -: 9337:#if defined(LIBXML_OUTPUT_ENABLED)
        -: 9338:    int mem_base;
        -: 9339:    xmlBufferPtr buf; /* An XML buffer. */
        -: 9340:    int n_buf;
        -: 9341:    xmlEntitiesTablePtr table; /* An entity table */
        -: 9342:    int n_table;
        -: 9343:
    #####: 9344:    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    #####: 9345:    for (n_table = 0;n_table < gen_nb_xmlEntitiesTablePtr;n_table++) {
    #####: 9346:        mem_base = xmlMemBlocks();
    #####: 9347:        buf = gen_xmlBufferPtr(n_buf, 0);
    #####: 9348:        table = gen_xmlEntitiesTablePtr(n_table, 1);
        -: 9349:
    #####: 9350:        xmlDumpEntitiesTable(buf, table);
    #####: 9351:        call_tests++;
    #####: 9352:        des_xmlBufferPtr(n_buf, buf, 0);
    #####: 9353:        des_xmlEntitiesTablePtr(n_table, table, 1);
    #####: 9354:        xmlResetLastError();
    #####: 9355:        if (mem_base != xmlMemBlocks()) {
    #####: 9356:            printf("Leak of %d blocks found in xmlDumpEntitiesTable",
    #####: 9357:	           xmlMemBlocks() - mem_base);
    #####: 9358:	    test_ret++;
    #####: 9359:            printf(" %d", n_buf);
    #####: 9360:            printf(" %d", n_table);
    #####: 9361:            printf("\n");
        -: 9362:        }
        -: 9363:    }
        -: 9364:    }
    #####: 9365:    function_tests++;
        -: 9366:#endif
        -: 9367:
    #####: 9368:    return(test_ret);
        -: 9369:}
        -: 9370:
        -: 9371:
        -: 9372:#define gen_nb_xmlEntityPtr 1
    #####: 9373:static xmlEntityPtr gen_xmlEntityPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 9374:    return(NULL);
        -: 9375:}
    #####: 9376:static void des_xmlEntityPtr(int no ATTRIBUTE_UNUSED, xmlEntityPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 9377:}
        -: 9378:
        -: 9379:static int
    #####: 9380:test_xmlDumpEntityDecl(void) {
    #####: 9381:    int test_ret = 0;
        -: 9382:
        -: 9383:#if defined(LIBXML_OUTPUT_ENABLED)
        -: 9384:    int mem_base;
        -: 9385:    xmlBufferPtr buf; /* An XML buffer. */
        -: 9386:    int n_buf;
        -: 9387:    xmlEntityPtr ent; /* An entity table */
        -: 9388:    int n_ent;
        -: 9389:
    #####: 9390:    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    #####: 9391:    for (n_ent = 0;n_ent < gen_nb_xmlEntityPtr;n_ent++) {
    #####: 9392:        mem_base = xmlMemBlocks();
    #####: 9393:        buf = gen_xmlBufferPtr(n_buf, 0);
    #####: 9394:        ent = gen_xmlEntityPtr(n_ent, 1);
        -: 9395:
    #####: 9396:        xmlDumpEntityDecl(buf, ent);
    #####: 9397:        call_tests++;
    #####: 9398:        des_xmlBufferPtr(n_buf, buf, 0);
    #####: 9399:        des_xmlEntityPtr(n_ent, ent, 1);
    #####: 9400:        xmlResetLastError();
    #####: 9401:        if (mem_base != xmlMemBlocks()) {
    #####: 9402:            printf("Leak of %d blocks found in xmlDumpEntityDecl",
    #####: 9403:	           xmlMemBlocks() - mem_base);
    #####: 9404:	    test_ret++;
    #####: 9405:            printf(" %d", n_buf);
    #####: 9406:            printf(" %d", n_ent);
    #####: 9407:            printf("\n");
        -: 9408:        }
        -: 9409:    }
        -: 9410:    }
    #####: 9411:    function_tests++;
        -: 9412:#endif
        -: 9413:
    #####: 9414:    return(test_ret);
        -: 9415:}
        -: 9416:
        -: 9417:
        -: 9418:static int
    #####: 9419:test_xmlEncodeEntitiesReentrant(void) {
    #####: 9420:    int test_ret = 0;
        -: 9421:
        -: 9422:    int mem_base;
        -: 9423:    xmlChar * ret_val;
        -: 9424:    xmlDocPtr doc; /* the document containing the string */
        -: 9425:    int n_doc;
        -: 9426:    xmlChar * input; /* A string to convert to XML. */
        -: 9427:    int n_input;
        -: 9428:
    #####: 9429:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####: 9430:    for (n_input = 0;n_input < gen_nb_const_xmlChar_ptr;n_input++) {
    #####: 9431:        mem_base = xmlMemBlocks();
    #####: 9432:        doc = gen_xmlDocPtr(n_doc, 0);
    #####: 9433:        input = gen_const_xmlChar_ptr(n_input, 1);
        -: 9434:
    #####: 9435:        ret_val = xmlEncodeEntitiesReentrant(doc, (const xmlChar *)input);
    #####: 9436:        desret_xmlChar_ptr(ret_val);
    #####: 9437:        call_tests++;
    #####: 9438:        des_xmlDocPtr(n_doc, doc, 0);
    #####: 9439:        des_const_xmlChar_ptr(n_input, (const xmlChar *)input, 1);
    #####: 9440:        xmlResetLastError();
    #####: 9441:        if (mem_base != xmlMemBlocks()) {
    #####: 9442:            printf("Leak of %d blocks found in xmlEncodeEntitiesReentrant",
    #####: 9443:	           xmlMemBlocks() - mem_base);
    #####: 9444:	    test_ret++;
    #####: 9445:            printf(" %d", n_doc);
    #####: 9446:            printf(" %d", n_input);
    #####: 9447:            printf("\n");
        -: 9448:        }
        -: 9449:    }
        -: 9450:    }
    #####: 9451:    function_tests++;
        -: 9452:
    #####: 9453:    return(test_ret);
        -: 9454:}
        -: 9455:
        -: 9456:
        -: 9457:#define gen_nb_const_xmlDoc_ptr 1
    #####: 9458:static xmlDoc * gen_const_xmlDoc_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 9459:    return(NULL);
        -: 9460:}
    #####: 9461:static void des_const_xmlDoc_ptr(int no ATTRIBUTE_UNUSED, const xmlDoc * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####: 9462:}
        -: 9463:
        -: 9464:static int
    #####: 9465:test_xmlEncodeSpecialChars(void) {
    #####: 9466:    int test_ret = 0;
        -: 9467:
        -: 9468:    int mem_base;
        -: 9469:    xmlChar * ret_val;
        -: 9470:    xmlDoc * doc; /* the document containing the string */
        -: 9471:    int n_doc;
        -: 9472:    xmlChar * input; /* A string to convert to XML. */
        -: 9473:    int n_input;
        -: 9474:
    #####: 9475:    for (n_doc = 0;n_doc < gen_nb_const_xmlDoc_ptr;n_doc++) {
    #####: 9476:    for (n_input = 0;n_input < gen_nb_const_xmlChar_ptr;n_input++) {
    #####: 9477:        mem_base = xmlMemBlocks();
    #####: 9478:        doc = gen_const_xmlDoc_ptr(n_doc, 0);
    #####: 9479:        input = gen_const_xmlChar_ptr(n_input, 1);
        -: 9480:
    #####: 9481:        ret_val = xmlEncodeSpecialChars((const xmlDoc *)doc, (const xmlChar *)input);
    #####: 9482:        desret_xmlChar_ptr(ret_val);
    #####: 9483:        call_tests++;
    #####: 9484:        des_const_xmlDoc_ptr(n_doc, (const xmlDoc *)doc, 0);
    #####: 9485:        des_const_xmlChar_ptr(n_input, (const xmlChar *)input, 1);
    #####: 9486:        xmlResetLastError();
    #####: 9487:        if (mem_base != xmlMemBlocks()) {
    #####: 9488:            printf("Leak of %d blocks found in xmlEncodeSpecialChars",
    #####: 9489:	           xmlMemBlocks() - mem_base);
    #####: 9490:	    test_ret++;
    #####: 9491:            printf(" %d", n_doc);
    #####: 9492:            printf(" %d", n_input);
    #####: 9493:            printf("\n");
        -: 9494:        }
        -: 9495:    }
        -: 9496:    }
    #####: 9497:    function_tests++;
        -: 9498:
    #####: 9499:    return(test_ret);
        -: 9500:}
        -: 9501:
        -: 9502:
        -: 9503:static int
    #####: 9504:test_xmlGetDocEntity(void) {
    #####: 9505:    int test_ret = 0;
        -: 9506:
        -: 9507:    int mem_base;
        -: 9508:    xmlEntityPtr ret_val;
        -: 9509:    xmlDoc * doc; /* the document referencing the entity */
        -: 9510:    int n_doc;
        -: 9511:    xmlChar * name; /* the entity name */
        -: 9512:    int n_name;
        -: 9513:
    #####: 9514:    for (n_doc = 0;n_doc < gen_nb_const_xmlDoc_ptr;n_doc++) {
    #####: 9515:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####: 9516:        mem_base = xmlMemBlocks();
    #####: 9517:        doc = gen_const_xmlDoc_ptr(n_doc, 0);
    #####: 9518:        name = gen_const_xmlChar_ptr(n_name, 1);
        -: 9519:
    #####: 9520:        ret_val = xmlGetDocEntity((const xmlDoc *)doc, (const xmlChar *)name);
    #####: 9521:        desret_xmlEntityPtr(ret_val);
    #####: 9522:        call_tests++;
    #####: 9523:        des_const_xmlDoc_ptr(n_doc, (const xmlDoc *)doc, 0);
    #####: 9524:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####: 9525:        xmlResetLastError();
    #####: 9526:        if (mem_base != xmlMemBlocks()) {
    #####: 9527:            printf("Leak of %d blocks found in xmlGetDocEntity",
    #####: 9528:	           xmlMemBlocks() - mem_base);
    #####: 9529:	    test_ret++;
    #####: 9530:            printf(" %d", n_doc);
    #####: 9531:            printf(" %d", n_name);
    #####: 9532:            printf("\n");
        -: 9533:        }
        -: 9534:    }
        -: 9535:    }
    #####: 9536:    function_tests++;
        -: 9537:
    #####: 9538:    return(test_ret);
        -: 9539:}
        -: 9540:
        -: 9541:
        -: 9542:static int
    #####: 9543:test_xmlGetDtdEntity(void) {
    #####: 9544:    int test_ret = 0;
        -: 9545:
        -: 9546:    int mem_base;
        -: 9547:    xmlEntityPtr ret_val;
        -: 9548:    xmlDocPtr doc; /* the document referencing the entity */
        -: 9549:    int n_doc;
        -: 9550:    xmlChar * name; /* the entity name */
        -: 9551:    int n_name;
        -: 9552:
    #####: 9553:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####: 9554:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####: 9555:        mem_base = xmlMemBlocks();
    #####: 9556:        doc = gen_xmlDocPtr(n_doc, 0);
    #####: 9557:        name = gen_const_xmlChar_ptr(n_name, 1);
        -: 9558:
    #####: 9559:        ret_val = xmlGetDtdEntity(doc, (const xmlChar *)name);
    #####: 9560:        desret_xmlEntityPtr(ret_val);
    #####: 9561:        call_tests++;
    #####: 9562:        des_xmlDocPtr(n_doc, doc, 0);
    #####: 9563:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####: 9564:        xmlResetLastError();
    #####: 9565:        if (mem_base != xmlMemBlocks()) {
    #####: 9566:            printf("Leak of %d blocks found in xmlGetDtdEntity",
    #####: 9567:	           xmlMemBlocks() - mem_base);
    #####: 9568:	    test_ret++;
    #####: 9569:            printf(" %d", n_doc);
    #####: 9570:            printf(" %d", n_name);
    #####: 9571:            printf("\n");
        -: 9572:        }
        -: 9573:    }
        -: 9574:    }
    #####: 9575:    function_tests++;
        -: 9576:
    #####: 9577:    return(test_ret);
        -: 9578:}
        -: 9579:
        -: 9580:
        -: 9581:static int
    #####: 9582:test_xmlGetParameterEntity(void) {
    #####: 9583:    int test_ret = 0;
        -: 9584:
        -: 9585:    int mem_base;
        -: 9586:    xmlEntityPtr ret_val;
        -: 9587:    xmlDocPtr doc; /* the document referencing the entity */
        -: 9588:    int n_doc;
        -: 9589:    xmlChar * name; /* the entity name */
        -: 9590:    int n_name;
        -: 9591:
    #####: 9592:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####: 9593:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####: 9594:        mem_base = xmlMemBlocks();
    #####: 9595:        doc = gen_xmlDocPtr(n_doc, 0);
    #####: 9596:        name = gen_const_xmlChar_ptr(n_name, 1);
        -: 9597:
    #####: 9598:        ret_val = xmlGetParameterEntity(doc, (const xmlChar *)name);
    #####: 9599:        desret_xmlEntityPtr(ret_val);
    #####: 9600:        call_tests++;
    #####: 9601:        des_xmlDocPtr(n_doc, doc, 0);
    #####: 9602:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####: 9603:        xmlResetLastError();
    #####: 9604:        if (mem_base != xmlMemBlocks()) {
    #####: 9605:            printf("Leak of %d blocks found in xmlGetParameterEntity",
    #####: 9606:	           xmlMemBlocks() - mem_base);
    #####: 9607:	    test_ret++;
    #####: 9608:            printf(" %d", n_doc);
    #####: 9609:            printf(" %d", n_name);
    #####: 9610:            printf("\n");
        -: 9611:        }
        -: 9612:    }
        -: 9613:    }
    #####: 9614:    function_tests++;
        -: 9615:
    #####: 9616:    return(test_ret);
        -: 9617:}
        -: 9618:
        -: 9619:
        -: 9620:static int
    #####: 9621:test_xmlGetPredefinedEntity(void) {
    #####: 9622:    int test_ret = 0;
        -: 9623:
        -: 9624:    int mem_base;
        -: 9625:    xmlEntityPtr ret_val;
        -: 9626:    xmlChar * name; /* the entity name */
        -: 9627:    int n_name;
        -: 9628:
    #####: 9629:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####: 9630:        mem_base = xmlMemBlocks();
    #####: 9631:        name = gen_const_xmlChar_ptr(n_name, 0);
        -: 9632:
    #####: 9633:        ret_val = xmlGetPredefinedEntity((const xmlChar *)name);
    #####: 9634:        desret_xmlEntityPtr(ret_val);
    #####: 9635:        call_tests++;
    #####: 9636:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 0);
    #####: 9637:        xmlResetLastError();
    #####: 9638:        if (mem_base != xmlMemBlocks()) {
    #####: 9639:            printf("Leak of %d blocks found in xmlGetPredefinedEntity",
    #####: 9640:	           xmlMemBlocks() - mem_base);
    #####: 9641:	    test_ret++;
    #####: 9642:            printf(" %d", n_name);
    #####: 9643:            printf("\n");
        -: 9644:        }
        -: 9645:    }
    #####: 9646:    function_tests++;
        -: 9647:
    #####: 9648:    return(test_ret);
        -: 9649:}
        -: 9650:
        -: 9651:
        -: 9652:static int
    #####: 9653:test_xmlInitializePredefinedEntities(void) {
    #####: 9654:    int test_ret = 0;
        -: 9655:
        -: 9656:#if defined(LIBXML_LEGACY_ENABLED)
        -: 9657:#ifdef LIBXML_LEGACY_ENABLED
        -: 9658:    int mem_base;
        -: 9659:
    #####: 9660:        mem_base = xmlMemBlocks();
        -: 9661:
    #####: 9662:        xmlInitializePredefinedEntities();
    #####: 9663:        call_tests++;
    #####: 9664:        xmlResetLastError();
    #####: 9665:        if (mem_base != xmlMemBlocks()) {
    #####: 9666:            printf("Leak of %d blocks found in xmlInitializePredefinedEntities",
    #####: 9667:	           xmlMemBlocks() - mem_base);
    #####: 9668:	    test_ret++;
    #####: 9669:            printf("\n");
        -: 9670:        }
    #####: 9671:    function_tests++;
        -: 9672:#endif
        -: 9673:#endif
        -: 9674:
    #####: 9675:    return(test_ret);
        -: 9676:}
        -: 9677:
        -: 9678:
        -: 9679:static int
    #####: 9680:test_xmlNewEntity(void) {
    #####: 9681:    int test_ret = 0;
        -: 9682:
        -: 9683:    int mem_base;
        -: 9684:    xmlEntityPtr ret_val;
        -: 9685:    xmlDocPtr doc; /* the document */
        -: 9686:    int n_doc;
        -: 9687:    xmlChar * name; /* the entity name */
        -: 9688:    int n_name;
        -: 9689:    int type; /* the entity type XML_xxx_yyy_ENTITY */
        -: 9690:    int n_type;
        -: 9691:    xmlChar * ExternalID; /* the entity external ID if available */
        -: 9692:    int n_ExternalID;
        -: 9693:    xmlChar * SystemID; /* the entity system ID if available */
        -: 9694:    int n_SystemID;
        -: 9695:    xmlChar * content; /* the entity content */
        -: 9696:    int n_content;
        -: 9697:
    #####: 9698:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####: 9699:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####: 9700:    for (n_type = 0;n_type < gen_nb_int;n_type++) {
    #####: 9701:    for (n_ExternalID = 0;n_ExternalID < gen_nb_const_xmlChar_ptr;n_ExternalID++) {
    #####: 9702:    for (n_SystemID = 0;n_SystemID < gen_nb_const_xmlChar_ptr;n_SystemID++) {
    #####: 9703:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####: 9704:        mem_base = xmlMemBlocks();
    #####: 9705:        doc = gen_xmlDocPtr(n_doc, 0);
    #####: 9706:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####: 9707:        type = gen_int(n_type, 2);
    #####: 9708:        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 3);
    #####: 9709:        SystemID = gen_const_xmlChar_ptr(n_SystemID, 4);
    #####: 9710:        content = gen_const_xmlChar_ptr(n_content, 5);
        -: 9711:
    #####: 9712:        ret_val = xmlNewEntity(doc, (const xmlChar *)name, type, (const xmlChar *)ExternalID, (const xmlChar *)SystemID, (const xmlChar *)content);
    #####: 9713:        desret_xmlEntityPtr(ret_val);
    #####: 9714:        call_tests++;
    #####: 9715:        des_xmlDocPtr(n_doc, doc, 0);
    #####: 9716:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####: 9717:        des_int(n_type, type, 2);
    #####: 9718:        des_const_xmlChar_ptr(n_ExternalID, (const xmlChar *)ExternalID, 3);
    #####: 9719:        des_const_xmlChar_ptr(n_SystemID, (const xmlChar *)SystemID, 4);
    #####: 9720:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 5);
    #####: 9721:        xmlResetLastError();
    #####: 9722:        if (mem_base != xmlMemBlocks()) {
    #####: 9723:            printf("Leak of %d blocks found in xmlNewEntity",
    #####: 9724:	           xmlMemBlocks() - mem_base);
    #####: 9725:	    test_ret++;
    #####: 9726:            printf(" %d", n_doc);
    #####: 9727:            printf(" %d", n_name);
    #####: 9728:            printf(" %d", n_type);
    #####: 9729:            printf(" %d", n_ExternalID);
    #####: 9730:            printf(" %d", n_SystemID);
    #####: 9731:            printf(" %d", n_content);
    #####: 9732:            printf("\n");
        -: 9733:        }
        -: 9734:    }
        -: 9735:    }
        -: 9736:    }
        -: 9737:    }
        -: 9738:    }
        -: 9739:    }
    #####: 9740:    function_tests++;
        -: 9741:
    #####: 9742:    return(test_ret);
        -: 9743:}
        -: 9744:
        -: 9745:static int
    #####: 9746:test_entities(void) {
    #####: 9747:    int test_ret = 0;
        -: 9748:
    #####: 9749:    if (quiet == 0) printf("Testing entities : 13 of 17 functions ...\n");
    #####: 9750:    test_ret += test_xmlAddDocEntity();
    #####: 9751:    test_ret += test_xmlAddDtdEntity();
    #####: 9752:    test_ret += test_xmlCleanupPredefinedEntities();
    #####: 9753:    test_ret += test_xmlCopyEntitiesTable();
    #####: 9754:    test_ret += test_xmlCreateEntitiesTable();
    #####: 9755:    test_ret += test_xmlDumpEntitiesTable();
    #####: 9756:    test_ret += test_xmlDumpEntityDecl();
    #####: 9757:    test_ret += test_xmlEncodeEntitiesReentrant();
    #####: 9758:    test_ret += test_xmlEncodeSpecialChars();
    #####: 9759:    test_ret += test_xmlGetDocEntity();
    #####: 9760:    test_ret += test_xmlGetDtdEntity();
    #####: 9761:    test_ret += test_xmlGetParameterEntity();
    #####: 9762:    test_ret += test_xmlGetPredefinedEntity();
    #####: 9763:    test_ret += test_xmlInitializePredefinedEntities();
    #####: 9764:    test_ret += test_xmlNewEntity();
        -: 9765:
    #####: 9766:    if (test_ret != 0)
    #####: 9767:	printf("Module entities: %d errors\n", test_ret);
    #####: 9768:    return(test_ret);
        -: 9769:}
        -: 9770:
        -: 9771:static int
    #####: 9772:test_xmlHashAddEntry(void) {
    #####: 9773:    int test_ret = 0;
        -: 9774:
        -: 9775:    int mem_base;
        -: 9776:    int ret_val;
        -: 9777:    xmlHashTablePtr table; /* the hash table */
        -: 9778:    int n_table;
        -: 9779:    xmlChar * name; /* the name of the userdata */
        -: 9780:    int n_name;
        -: 9781:    void * userdata; /* a pointer to the userdata */
        -: 9782:    int n_userdata;
        -: 9783:
    #####: 9784:    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    #####: 9785:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####: 9786:    for (n_userdata = 0;n_userdata < gen_nb_userdata;n_userdata++) {
    #####: 9787:        mem_base = xmlMemBlocks();
    #####: 9788:        table = gen_xmlHashTablePtr(n_table, 0);
    #####: 9789:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####: 9790:        userdata = gen_userdata(n_userdata, 2);
        -: 9791:
    #####: 9792:        ret_val = xmlHashAddEntry(table, (const xmlChar *)name, userdata);
    #####: 9793:        desret_int(ret_val);
    #####: 9794:        call_tests++;
    #####: 9795:        des_xmlHashTablePtr(n_table, table, 0);
    #####: 9796:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####: 9797:        des_userdata(n_userdata, userdata, 2);
    #####: 9798:        xmlResetLastError();
    #####: 9799:        if (mem_base != xmlMemBlocks()) {
    #####: 9800:            printf("Leak of %d blocks found in xmlHashAddEntry",
    #####: 9801:	           xmlMemBlocks() - mem_base);
    #####: 9802:	    test_ret++;
    #####: 9803:            printf(" %d", n_table);
    #####: 9804:            printf(" %d", n_name);
    #####: 9805:            printf(" %d", n_userdata);
    #####: 9806:            printf("\n");
        -: 9807:        }
        -: 9808:    }
        -: 9809:    }
        -: 9810:    }
    #####: 9811:    function_tests++;
        -: 9812:
    #####: 9813:    return(test_ret);
        -: 9814:}
        -: 9815:
        -: 9816:
        -: 9817:static int
    #####: 9818:test_xmlHashAddEntry2(void) {
    #####: 9819:    int test_ret = 0;
        -: 9820:
        -: 9821:    int mem_base;
        -: 9822:    int ret_val;
        -: 9823:    xmlHashTablePtr table; /* the hash table */
        -: 9824:    int n_table;
        -: 9825:    xmlChar * name; /* the name of the userdata */
        -: 9826:    int n_name;
        -: 9827:    xmlChar * name2; /* a second name of the userdata */
        -: 9828:    int n_name2;
        -: 9829:    void * userdata; /* a pointer to the userdata */
        -: 9830:    int n_userdata;
        -: 9831:
    #####: 9832:    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    #####: 9833:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####: 9834:    for (n_name2 = 0;n_name2 < gen_nb_const_xmlChar_ptr;n_name2++) {
    #####: 9835:    for (n_userdata = 0;n_userdata < gen_nb_userdata;n_userdata++) {
    #####: 9836:        mem_base = xmlMemBlocks();
    #####: 9837:        table = gen_xmlHashTablePtr(n_table, 0);
    #####: 9838:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####: 9839:        name2 = gen_const_xmlChar_ptr(n_name2, 2);
    #####: 9840:        userdata = gen_userdata(n_userdata, 3);
        -: 9841:
    #####: 9842:        ret_val = xmlHashAddEntry2(table, (const xmlChar *)name, (const xmlChar *)name2, userdata);
    #####: 9843:        desret_int(ret_val);
    #####: 9844:        call_tests++;
    #####: 9845:        des_xmlHashTablePtr(n_table, table, 0);
    #####: 9846:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####: 9847:        des_const_xmlChar_ptr(n_name2, (const xmlChar *)name2, 2);
    #####: 9848:        des_userdata(n_userdata, userdata, 3);
    #####: 9849:        xmlResetLastError();
    #####: 9850:        if (mem_base != xmlMemBlocks()) {
    #####: 9851:            printf("Leak of %d blocks found in xmlHashAddEntry2",
    #####: 9852:	           xmlMemBlocks() - mem_base);
    #####: 9853:	    test_ret++;
    #####: 9854:            printf(" %d", n_table);
    #####: 9855:            printf(" %d", n_name);
    #####: 9856:            printf(" %d", n_name2);
    #####: 9857:            printf(" %d", n_userdata);
    #####: 9858:            printf("\n");
        -: 9859:        }
        -: 9860:    }
        -: 9861:    }
        -: 9862:    }
        -: 9863:    }
    #####: 9864:    function_tests++;
        -: 9865:
    #####: 9866:    return(test_ret);
        -: 9867:}
        -: 9868:
        -: 9869:
        -: 9870:static int
    #####: 9871:test_xmlHashAddEntry3(void) {
    #####: 9872:    int test_ret = 0;
        -: 9873:
        -: 9874:    int mem_base;
        -: 9875:    int ret_val;
        -: 9876:    xmlHashTablePtr table; /* the hash table */
        -: 9877:    int n_table;
        -: 9878:    xmlChar * name; /* the name of the userdata */
        -: 9879:    int n_name;
        -: 9880:    xmlChar * name2; /* a second name of the userdata */
        -: 9881:    int n_name2;
        -: 9882:    xmlChar * name3; /* a third name of the userdata */
        -: 9883:    int n_name3;
        -: 9884:    void * userdata; /* a pointer to the userdata */
        -: 9885:    int n_userdata;
        -: 9886:
    #####: 9887:    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    #####: 9888:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####: 9889:    for (n_name2 = 0;n_name2 < gen_nb_const_xmlChar_ptr;n_name2++) {
    #####: 9890:    for (n_name3 = 0;n_name3 < gen_nb_const_xmlChar_ptr;n_name3++) {
    #####: 9891:    for (n_userdata = 0;n_userdata < gen_nb_userdata;n_userdata++) {
    #####: 9892:        mem_base = xmlMemBlocks();
    #####: 9893:        table = gen_xmlHashTablePtr(n_table, 0);
    #####: 9894:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####: 9895:        name2 = gen_const_xmlChar_ptr(n_name2, 2);
    #####: 9896:        name3 = gen_const_xmlChar_ptr(n_name3, 3);
    #####: 9897:        userdata = gen_userdata(n_userdata, 4);
        -: 9898:
    #####: 9899:        ret_val = xmlHashAddEntry3(table, (const xmlChar *)name, (const xmlChar *)name2, (const xmlChar *)name3, userdata);
    #####: 9900:        desret_int(ret_val);
    #####: 9901:        call_tests++;
    #####: 9902:        des_xmlHashTablePtr(n_table, table, 0);
    #####: 9903:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####: 9904:        des_const_xmlChar_ptr(n_name2, (const xmlChar *)name2, 2);
    #####: 9905:        des_const_xmlChar_ptr(n_name3, (const xmlChar *)name3, 3);
    #####: 9906:        des_userdata(n_userdata, userdata, 4);
    #####: 9907:        xmlResetLastError();
    #####: 9908:        if (mem_base != xmlMemBlocks()) {
    #####: 9909:            printf("Leak of %d blocks found in xmlHashAddEntry3",
    #####: 9910:	           xmlMemBlocks() - mem_base);
    #####: 9911:	    test_ret++;
    #####: 9912:            printf(" %d", n_table);
    #####: 9913:            printf(" %d", n_name);
    #####: 9914:            printf(" %d", n_name2);
    #####: 9915:            printf(" %d", n_name3);
    #####: 9916:            printf(" %d", n_userdata);
    #####: 9917:            printf("\n");
        -: 9918:        }
        -: 9919:    }
        -: 9920:    }
        -: 9921:    }
        -: 9922:    }
        -: 9923:    }
    #####: 9924:    function_tests++;
        -: 9925:
    #####: 9926:    return(test_ret);
        -: 9927:}
        -: 9928:
        -: 9929:
        -: 9930:static int
    #####: 9931:test_xmlHashCopy(void) {
    #####: 9932:    int test_ret = 0;
        -: 9933:
        -: 9934:
        -: 9935:    /* missing type support */
    #####: 9936:    return(test_ret);
        -: 9937:}
        -: 9938:
        -: 9939:
        -: 9940:static int
    #####: 9941:test_xmlHashCreate(void) {
    #####: 9942:    int test_ret = 0;
        -: 9943:
        -: 9944:
        -: 9945:    /* missing type support */
    #####: 9946:    return(test_ret);
        -: 9947:}
        -: 9948:
        -: 9949:
        -: 9950:static int
    #####: 9951:test_xmlHashCreateDict(void) {
    #####: 9952:    int test_ret = 0;
        -: 9953:
        -: 9954:
        -: 9955:    /* missing type support */
    #####: 9956:    return(test_ret);
        -: 9957:}
        -: 9958:
        -: 9959:
        -: 9960:static int
    #####: 9961:test_xmlHashLookup(void) {
    #####: 9962:    int test_ret = 0;
        -: 9963:
        -: 9964:    int mem_base;
        -: 9965:    void * ret_val;
        -: 9966:    xmlHashTablePtr table; /* the hash table */
        -: 9967:    int n_table;
        -: 9968:    xmlChar * name; /* the name of the userdata */
        -: 9969:    int n_name;
        -: 9970:
    #####: 9971:    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    #####: 9972:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####: 9973:        mem_base = xmlMemBlocks();
    #####: 9974:        table = gen_xmlHashTablePtr(n_table, 0);
    #####: 9975:        name = gen_const_xmlChar_ptr(n_name, 1);
        -: 9976:
    #####: 9977:        ret_val = xmlHashLookup(table, (const xmlChar *)name);
    #####: 9978:        desret_void_ptr(ret_val);
    #####: 9979:        call_tests++;
    #####: 9980:        des_xmlHashTablePtr(n_table, table, 0);
    #####: 9981:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####: 9982:        xmlResetLastError();
    #####: 9983:        if (mem_base != xmlMemBlocks()) {
    #####: 9984:            printf("Leak of %d blocks found in xmlHashLookup",
    #####: 9985:	           xmlMemBlocks() - mem_base);
    #####: 9986:	    test_ret++;
    #####: 9987:            printf(" %d", n_table);
    #####: 9988:            printf(" %d", n_name);
    #####: 9989:            printf("\n");
        -: 9990:        }
        -: 9991:    }
        -: 9992:    }
    #####: 9993:    function_tests++;
        -: 9994:
    #####: 9995:    return(test_ret);
        -: 9996:}
        -: 9997:
        -: 9998:
        -: 9999:static int
    #####:10000:test_xmlHashLookup2(void) {
    #####:10001:    int test_ret = 0;
        -:10002:
        -:10003:    int mem_base;
        -:10004:    void * ret_val;
        -:10005:    xmlHashTablePtr table; /* the hash table */
        -:10006:    int n_table;
        -:10007:    xmlChar * name; /* the name of the userdata */
        -:10008:    int n_name;
        -:10009:    xmlChar * name2; /* a second name of the userdata */
        -:10010:    int n_name2;
        -:10011:
    #####:10012:    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    #####:10013:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:10014:    for (n_name2 = 0;n_name2 < gen_nb_const_xmlChar_ptr;n_name2++) {
    #####:10015:        mem_base = xmlMemBlocks();
    #####:10016:        table = gen_xmlHashTablePtr(n_table, 0);
    #####:10017:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:10018:        name2 = gen_const_xmlChar_ptr(n_name2, 2);
        -:10019:
    #####:10020:        ret_val = xmlHashLookup2(table, (const xmlChar *)name, (const xmlChar *)name2);
    #####:10021:        desret_void_ptr(ret_val);
    #####:10022:        call_tests++;
    #####:10023:        des_xmlHashTablePtr(n_table, table, 0);
    #####:10024:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:10025:        des_const_xmlChar_ptr(n_name2, (const xmlChar *)name2, 2);
    #####:10026:        xmlResetLastError();
    #####:10027:        if (mem_base != xmlMemBlocks()) {
    #####:10028:            printf("Leak of %d blocks found in xmlHashLookup2",
    #####:10029:	           xmlMemBlocks() - mem_base);
    #####:10030:	    test_ret++;
    #####:10031:            printf(" %d", n_table);
    #####:10032:            printf(" %d", n_name);
    #####:10033:            printf(" %d", n_name2);
    #####:10034:            printf("\n");
        -:10035:        }
        -:10036:    }
        -:10037:    }
        -:10038:    }
    #####:10039:    function_tests++;
        -:10040:
    #####:10041:    return(test_ret);
        -:10042:}
        -:10043:
        -:10044:
        -:10045:static int
    #####:10046:test_xmlHashLookup3(void) {
    #####:10047:    int test_ret = 0;
        -:10048:
        -:10049:    int mem_base;
        -:10050:    void * ret_val;
        -:10051:    xmlHashTablePtr table; /* the hash table */
        -:10052:    int n_table;
        -:10053:    xmlChar * name; /* the name of the userdata */
        -:10054:    int n_name;
        -:10055:    xmlChar * name2; /* a second name of the userdata */
        -:10056:    int n_name2;
        -:10057:    xmlChar * name3; /* a third name of the userdata */
        -:10058:    int n_name3;
        -:10059:
    #####:10060:    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    #####:10061:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:10062:    for (n_name2 = 0;n_name2 < gen_nb_const_xmlChar_ptr;n_name2++) {
    #####:10063:    for (n_name3 = 0;n_name3 < gen_nb_const_xmlChar_ptr;n_name3++) {
    #####:10064:        mem_base = xmlMemBlocks();
    #####:10065:        table = gen_xmlHashTablePtr(n_table, 0);
    #####:10066:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:10067:        name2 = gen_const_xmlChar_ptr(n_name2, 2);
    #####:10068:        name3 = gen_const_xmlChar_ptr(n_name3, 3);
        -:10069:
    #####:10070:        ret_val = xmlHashLookup3(table, (const xmlChar *)name, (const xmlChar *)name2, (const xmlChar *)name3);
    #####:10071:        desret_void_ptr(ret_val);
    #####:10072:        call_tests++;
    #####:10073:        des_xmlHashTablePtr(n_table, table, 0);
    #####:10074:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:10075:        des_const_xmlChar_ptr(n_name2, (const xmlChar *)name2, 2);
    #####:10076:        des_const_xmlChar_ptr(n_name3, (const xmlChar *)name3, 3);
    #####:10077:        xmlResetLastError();
    #####:10078:        if (mem_base != xmlMemBlocks()) {
    #####:10079:            printf("Leak of %d blocks found in xmlHashLookup3",
    #####:10080:	           xmlMemBlocks() - mem_base);
    #####:10081:	    test_ret++;
    #####:10082:            printf(" %d", n_table);
    #####:10083:            printf(" %d", n_name);
    #####:10084:            printf(" %d", n_name2);
    #####:10085:            printf(" %d", n_name3);
    #####:10086:            printf("\n");
        -:10087:        }
        -:10088:    }
        -:10089:    }
        -:10090:    }
        -:10091:    }
    #####:10092:    function_tests++;
        -:10093:
    #####:10094:    return(test_ret);
        -:10095:}
        -:10096:
        -:10097:
        -:10098:static int
    #####:10099:test_xmlHashQLookup(void) {
    #####:10100:    int test_ret = 0;
        -:10101:
        -:10102:    int mem_base;
        -:10103:    void * ret_val;
        -:10104:    xmlHashTablePtr table; /* the hash table */
        -:10105:    int n_table;
        -:10106:    xmlChar * prefix; /* the prefix of the userdata */
        -:10107:    int n_prefix;
        -:10108:    xmlChar * name; /* the name of the userdata */
        -:10109:    int n_name;
        -:10110:
    #####:10111:    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    #####:10112:    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    #####:10113:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:10114:        mem_base = xmlMemBlocks();
    #####:10115:        table = gen_xmlHashTablePtr(n_table, 0);
    #####:10116:        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
    #####:10117:        name = gen_const_xmlChar_ptr(n_name, 2);
        -:10118:
    #####:10119:        ret_val = xmlHashQLookup(table, (const xmlChar *)prefix, (const xmlChar *)name);
    #####:10120:        desret_void_ptr(ret_val);
    #####:10121:        call_tests++;
    #####:10122:        des_xmlHashTablePtr(n_table, table, 0);
    #####:10123:        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 1);
    #####:10124:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
    #####:10125:        xmlResetLastError();
    #####:10126:        if (mem_base != xmlMemBlocks()) {
    #####:10127:            printf("Leak of %d blocks found in xmlHashQLookup",
    #####:10128:	           xmlMemBlocks() - mem_base);
    #####:10129:	    test_ret++;
    #####:10130:            printf(" %d", n_table);
    #####:10131:            printf(" %d", n_prefix);
    #####:10132:            printf(" %d", n_name);
    #####:10133:            printf("\n");
        -:10134:        }
        -:10135:    }
        -:10136:    }
        -:10137:    }
    #####:10138:    function_tests++;
        -:10139:
    #####:10140:    return(test_ret);
        -:10141:}
        -:10142:
        -:10143:
        -:10144:static int
    #####:10145:test_xmlHashQLookup2(void) {
    #####:10146:    int test_ret = 0;
        -:10147:
        -:10148:    int mem_base;
        -:10149:    void * ret_val;
        -:10150:    xmlHashTablePtr table; /* the hash table */
        -:10151:    int n_table;
        -:10152:    xmlChar * prefix; /* the prefix of the userdata */
        -:10153:    int n_prefix;
        -:10154:    xmlChar * name; /* the name of the userdata */
        -:10155:    int n_name;
        -:10156:    xmlChar * prefix2; /* the second prefix of the userdata */
        -:10157:    int n_prefix2;
        -:10158:    xmlChar * name2; /* a second name of the userdata */
        -:10159:    int n_name2;
        -:10160:
    #####:10161:    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    #####:10162:    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    #####:10163:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:10164:    for (n_prefix2 = 0;n_prefix2 < gen_nb_const_xmlChar_ptr;n_prefix2++) {
    #####:10165:    for (n_name2 = 0;n_name2 < gen_nb_const_xmlChar_ptr;n_name2++) {
    #####:10166:        mem_base = xmlMemBlocks();
    #####:10167:        table = gen_xmlHashTablePtr(n_table, 0);
    #####:10168:        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
    #####:10169:        name = gen_const_xmlChar_ptr(n_name, 2);
    #####:10170:        prefix2 = gen_const_xmlChar_ptr(n_prefix2, 3);
    #####:10171:        name2 = gen_const_xmlChar_ptr(n_name2, 4);
        -:10172:
    #####:10173:        ret_val = xmlHashQLookup2(table, (const xmlChar *)prefix, (const xmlChar *)name, (const xmlChar *)prefix2, (const xmlChar *)name2);
    #####:10174:        desret_void_ptr(ret_val);
    #####:10175:        call_tests++;
    #####:10176:        des_xmlHashTablePtr(n_table, table, 0);
    #####:10177:        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 1);
    #####:10178:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
    #####:10179:        des_const_xmlChar_ptr(n_prefix2, (const xmlChar *)prefix2, 3);
    #####:10180:        des_const_xmlChar_ptr(n_name2, (const xmlChar *)name2, 4);
    #####:10181:        xmlResetLastError();
    #####:10182:        if (mem_base != xmlMemBlocks()) {
    #####:10183:            printf("Leak of %d blocks found in xmlHashQLookup2",
    #####:10184:	           xmlMemBlocks() - mem_base);
    #####:10185:	    test_ret++;
    #####:10186:            printf(" %d", n_table);
    #####:10187:            printf(" %d", n_prefix);
    #####:10188:            printf(" %d", n_name);
    #####:10189:            printf(" %d", n_prefix2);
    #####:10190:            printf(" %d", n_name2);
    #####:10191:            printf("\n");
        -:10192:        }
        -:10193:    }
        -:10194:    }
        -:10195:    }
        -:10196:    }
        -:10197:    }
    #####:10198:    function_tests++;
        -:10199:
    #####:10200:    return(test_ret);
        -:10201:}
        -:10202:
        -:10203:
        -:10204:static int
    #####:10205:test_xmlHashQLookup3(void) {
    #####:10206:    int test_ret = 0;
        -:10207:
        -:10208:    int mem_base;
        -:10209:    void * ret_val;
        -:10210:    xmlHashTablePtr table; /* the hash table */
        -:10211:    int n_table;
        -:10212:    xmlChar * prefix; /* the prefix of the userdata */
        -:10213:    int n_prefix;
        -:10214:    xmlChar * name; /* the name of the userdata */
        -:10215:    int n_name;
        -:10216:    xmlChar * prefix2; /* the second prefix of the userdata */
        -:10217:    int n_prefix2;
        -:10218:    xmlChar * name2; /* a second name of the userdata */
        -:10219:    int n_name2;
        -:10220:    xmlChar * prefix3; /* the third prefix of the userdata */
        -:10221:    int n_prefix3;
        -:10222:    xmlChar * name3; /* a third name of the userdata */
        -:10223:    int n_name3;
        -:10224:
    #####:10225:    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    #####:10226:    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    #####:10227:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:10228:    for (n_prefix2 = 0;n_prefix2 < gen_nb_const_xmlChar_ptr;n_prefix2++) {
    #####:10229:    for (n_name2 = 0;n_name2 < gen_nb_const_xmlChar_ptr;n_name2++) {
    #####:10230:    for (n_prefix3 = 0;n_prefix3 < gen_nb_const_xmlChar_ptr;n_prefix3++) {
    #####:10231:    for (n_name3 = 0;n_name3 < gen_nb_const_xmlChar_ptr;n_name3++) {
    #####:10232:        mem_base = xmlMemBlocks();
    #####:10233:        table = gen_xmlHashTablePtr(n_table, 0);
    #####:10234:        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
    #####:10235:        name = gen_const_xmlChar_ptr(n_name, 2);
    #####:10236:        prefix2 = gen_const_xmlChar_ptr(n_prefix2, 3);
    #####:10237:        name2 = gen_const_xmlChar_ptr(n_name2, 4);
    #####:10238:        prefix3 = gen_const_xmlChar_ptr(n_prefix3, 5);
    #####:10239:        name3 = gen_const_xmlChar_ptr(n_name3, 6);
        -:10240:
    #####:10241:        ret_val = xmlHashQLookup3(table, (const xmlChar *)prefix, (const xmlChar *)name, (const xmlChar *)prefix2, (const xmlChar *)name2, (const xmlChar *)prefix3, (const xmlChar *)name3);
    #####:10242:        desret_void_ptr(ret_val);
    #####:10243:        call_tests++;
    #####:10244:        des_xmlHashTablePtr(n_table, table, 0);
    #####:10245:        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 1);
    #####:10246:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
    #####:10247:        des_const_xmlChar_ptr(n_prefix2, (const xmlChar *)prefix2, 3);
    #####:10248:        des_const_xmlChar_ptr(n_name2, (const xmlChar *)name2, 4);
    #####:10249:        des_const_xmlChar_ptr(n_prefix3, (const xmlChar *)prefix3, 5);
    #####:10250:        des_const_xmlChar_ptr(n_name3, (const xmlChar *)name3, 6);
    #####:10251:        xmlResetLastError();
    #####:10252:        if (mem_base != xmlMemBlocks()) {
    #####:10253:            printf("Leak of %d blocks found in xmlHashQLookup3",
    #####:10254:	           xmlMemBlocks() - mem_base);
    #####:10255:	    test_ret++;
    #####:10256:            printf(" %d", n_table);
    #####:10257:            printf(" %d", n_prefix);
    #####:10258:            printf(" %d", n_name);
    #####:10259:            printf(" %d", n_prefix2);
    #####:10260:            printf(" %d", n_name2);
    #####:10261:            printf(" %d", n_prefix3);
    #####:10262:            printf(" %d", n_name3);
    #####:10263:            printf("\n");
        -:10264:        }
        -:10265:    }
        -:10266:    }
        -:10267:    }
        -:10268:    }
        -:10269:    }
        -:10270:    }
        -:10271:    }
    #####:10272:    function_tests++;
        -:10273:
    #####:10274:    return(test_ret);
        -:10275:}
        -:10276:
        -:10277:
        -:10278:static int
    #####:10279:test_xmlHashRemoveEntry(void) {
    #####:10280:    int test_ret = 0;
        -:10281:
        -:10282:    int mem_base;
        -:10283:    int ret_val;
        -:10284:    xmlHashTablePtr table; /* the hash table */
        -:10285:    int n_table;
        -:10286:    xmlChar * name; /* the name of the userdata */
        -:10287:    int n_name;
        -:10288:    xmlHashDeallocator f; /* the deallocator function for removed item (if any) */
        -:10289:    int n_f;
        -:10290:
    #####:10291:    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    #####:10292:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:10293:    for (n_f = 0;n_f < gen_nb_xmlHashDeallocator;n_f++) {
    #####:10294:        mem_base = xmlMemBlocks();
    #####:10295:        table = gen_xmlHashTablePtr(n_table, 0);
    #####:10296:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:10297:        f = gen_xmlHashDeallocator(n_f, 2);
        -:10298:
    #####:10299:        ret_val = xmlHashRemoveEntry(table, (const xmlChar *)name, f);
    #####:10300:        desret_int(ret_val);
    #####:10301:        call_tests++;
    #####:10302:        des_xmlHashTablePtr(n_table, table, 0);
    #####:10303:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:10304:        des_xmlHashDeallocator(n_f, f, 2);
    #####:10305:        xmlResetLastError();
    #####:10306:        if (mem_base != xmlMemBlocks()) {
    #####:10307:            printf("Leak of %d blocks found in xmlHashRemoveEntry",
    #####:10308:	           xmlMemBlocks() - mem_base);
    #####:10309:	    test_ret++;
    #####:10310:            printf(" %d", n_table);
    #####:10311:            printf(" %d", n_name);
    #####:10312:            printf(" %d", n_f);
    #####:10313:            printf("\n");
        -:10314:        }
        -:10315:    }
        -:10316:    }
        -:10317:    }
    #####:10318:    function_tests++;
        -:10319:
    #####:10320:    return(test_ret);
        -:10321:}
        -:10322:
        -:10323:
        -:10324:static int
    #####:10325:test_xmlHashRemoveEntry2(void) {
    #####:10326:    int test_ret = 0;
        -:10327:
        -:10328:    int mem_base;
        -:10329:    int ret_val;
        -:10330:    xmlHashTablePtr table; /* the hash table */
        -:10331:    int n_table;
        -:10332:    xmlChar * name; /* the name of the userdata */
        -:10333:    int n_name;
        -:10334:    xmlChar * name2; /* a second name of the userdata */
        -:10335:    int n_name2;
        -:10336:    xmlHashDeallocator f; /* the deallocator function for removed item (if any) */
        -:10337:    int n_f;
        -:10338:
    #####:10339:    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    #####:10340:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:10341:    for (n_name2 = 0;n_name2 < gen_nb_const_xmlChar_ptr;n_name2++) {
    #####:10342:    for (n_f = 0;n_f < gen_nb_xmlHashDeallocator;n_f++) {
    #####:10343:        mem_base = xmlMemBlocks();
    #####:10344:        table = gen_xmlHashTablePtr(n_table, 0);
    #####:10345:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:10346:        name2 = gen_const_xmlChar_ptr(n_name2, 2);
    #####:10347:        f = gen_xmlHashDeallocator(n_f, 3);
        -:10348:
    #####:10349:        ret_val = xmlHashRemoveEntry2(table, (const xmlChar *)name, (const xmlChar *)name2, f);
    #####:10350:        desret_int(ret_val);
    #####:10351:        call_tests++;
    #####:10352:        des_xmlHashTablePtr(n_table, table, 0);
    #####:10353:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:10354:        des_const_xmlChar_ptr(n_name2, (const xmlChar *)name2, 2);
    #####:10355:        des_xmlHashDeallocator(n_f, f, 3);
    #####:10356:        xmlResetLastError();
    #####:10357:        if (mem_base != xmlMemBlocks()) {
    #####:10358:            printf("Leak of %d blocks found in xmlHashRemoveEntry2",
    #####:10359:	           xmlMemBlocks() - mem_base);
    #####:10360:	    test_ret++;
    #####:10361:            printf(" %d", n_table);
    #####:10362:            printf(" %d", n_name);
    #####:10363:            printf(" %d", n_name2);
    #####:10364:            printf(" %d", n_f);
    #####:10365:            printf("\n");
        -:10366:        }
        -:10367:    }
        -:10368:    }
        -:10369:    }
        -:10370:    }
    #####:10371:    function_tests++;
        -:10372:
    #####:10373:    return(test_ret);
        -:10374:}
        -:10375:
        -:10376:
        -:10377:static int
    #####:10378:test_xmlHashRemoveEntry3(void) {
    #####:10379:    int test_ret = 0;
        -:10380:
        -:10381:    int mem_base;
        -:10382:    int ret_val;
        -:10383:    xmlHashTablePtr table; /* the hash table */
        -:10384:    int n_table;
        -:10385:    xmlChar * name; /* the name of the userdata */
        -:10386:    int n_name;
        -:10387:    xmlChar * name2; /* a second name of the userdata */
        -:10388:    int n_name2;
        -:10389:    xmlChar * name3; /* a third name of the userdata */
        -:10390:    int n_name3;
        -:10391:    xmlHashDeallocator f; /* the deallocator function for removed item (if any) */
        -:10392:    int n_f;
        -:10393:
    #####:10394:    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    #####:10395:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:10396:    for (n_name2 = 0;n_name2 < gen_nb_const_xmlChar_ptr;n_name2++) {
    #####:10397:    for (n_name3 = 0;n_name3 < gen_nb_const_xmlChar_ptr;n_name3++) {
    #####:10398:    for (n_f = 0;n_f < gen_nb_xmlHashDeallocator;n_f++) {
    #####:10399:        mem_base = xmlMemBlocks();
    #####:10400:        table = gen_xmlHashTablePtr(n_table, 0);
    #####:10401:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:10402:        name2 = gen_const_xmlChar_ptr(n_name2, 2);
    #####:10403:        name3 = gen_const_xmlChar_ptr(n_name3, 3);
    #####:10404:        f = gen_xmlHashDeallocator(n_f, 4);
        -:10405:
    #####:10406:        ret_val = xmlHashRemoveEntry3(table, (const xmlChar *)name, (const xmlChar *)name2, (const xmlChar *)name3, f);
    #####:10407:        desret_int(ret_val);
    #####:10408:        call_tests++;
    #####:10409:        des_xmlHashTablePtr(n_table, table, 0);
    #####:10410:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:10411:        des_const_xmlChar_ptr(n_name2, (const xmlChar *)name2, 2);
    #####:10412:        des_const_xmlChar_ptr(n_name3, (const xmlChar *)name3, 3);
    #####:10413:        des_xmlHashDeallocator(n_f, f, 4);
    #####:10414:        xmlResetLastError();
    #####:10415:        if (mem_base != xmlMemBlocks()) {
    #####:10416:            printf("Leak of %d blocks found in xmlHashRemoveEntry3",
    #####:10417:	           xmlMemBlocks() - mem_base);
    #####:10418:	    test_ret++;
    #####:10419:            printf(" %d", n_table);
    #####:10420:            printf(" %d", n_name);
    #####:10421:            printf(" %d", n_name2);
    #####:10422:            printf(" %d", n_name3);
    #####:10423:            printf(" %d", n_f);
    #####:10424:            printf("\n");
        -:10425:        }
        -:10426:    }
        -:10427:    }
        -:10428:    }
        -:10429:    }
        -:10430:    }
    #####:10431:    function_tests++;
        -:10432:
    #####:10433:    return(test_ret);
        -:10434:}
        -:10435:
        -:10436:
        -:10437:static int
    #####:10438:test_xmlHashScan(void) {
    #####:10439:    int test_ret = 0;
        -:10440:
        -:10441:
        -:10442:    /* missing type support */
    #####:10443:    return(test_ret);
        -:10444:}
        -:10445:
        -:10446:
        -:10447:static int
    #####:10448:test_xmlHashScan3(void) {
    #####:10449:    int test_ret = 0;
        -:10450:
        -:10451:
        -:10452:    /* missing type support */
    #####:10453:    return(test_ret);
        -:10454:}
        -:10455:
        -:10456:
        -:10457:static int
    #####:10458:test_xmlHashScanFull(void) {
    #####:10459:    int test_ret = 0;
        -:10460:
        -:10461:
        -:10462:    /* missing type support */
    #####:10463:    return(test_ret);
        -:10464:}
        -:10465:
        -:10466:
        -:10467:static int
    #####:10468:test_xmlHashScanFull3(void) {
    #####:10469:    int test_ret = 0;
        -:10470:
        -:10471:
        -:10472:    /* missing type support */
    #####:10473:    return(test_ret);
        -:10474:}
        -:10475:
        -:10476:
        -:10477:static int
    #####:10478:test_xmlHashSize(void) {
    #####:10479:    int test_ret = 0;
        -:10480:
        -:10481:    int mem_base;
        -:10482:    int ret_val;
        -:10483:    xmlHashTablePtr table; /* the hash table */
        -:10484:    int n_table;
        -:10485:
    #####:10486:    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    #####:10487:        mem_base = xmlMemBlocks();
    #####:10488:        table = gen_xmlHashTablePtr(n_table, 0);
        -:10489:
    #####:10490:        ret_val = xmlHashSize(table);
    #####:10491:        desret_int(ret_val);
    #####:10492:        call_tests++;
    #####:10493:        des_xmlHashTablePtr(n_table, table, 0);
    #####:10494:        xmlResetLastError();
    #####:10495:        if (mem_base != xmlMemBlocks()) {
    #####:10496:            printf("Leak of %d blocks found in xmlHashSize",
    #####:10497:	           xmlMemBlocks() - mem_base);
    #####:10498:	    test_ret++;
    #####:10499:            printf(" %d", n_table);
    #####:10500:            printf("\n");
        -:10501:        }
        -:10502:    }
    #####:10503:    function_tests++;
        -:10504:
    #####:10505:    return(test_ret);
        -:10506:}
        -:10507:
        -:10508:
        -:10509:static int
    #####:10510:test_xmlHashUpdateEntry(void) {
    #####:10511:    int test_ret = 0;
        -:10512:
        -:10513:    int mem_base;
        -:10514:    int ret_val;
        -:10515:    xmlHashTablePtr table; /* the hash table */
        -:10516:    int n_table;
        -:10517:    xmlChar * name; /* the name of the userdata */
        -:10518:    int n_name;
        -:10519:    void * userdata; /* a pointer to the userdata */
        -:10520:    int n_userdata;
        -:10521:    xmlHashDeallocator f; /* the deallocator function for replaced item (if any) */
        -:10522:    int n_f;
        -:10523:
    #####:10524:    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    #####:10525:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:10526:    for (n_userdata = 0;n_userdata < gen_nb_userdata;n_userdata++) {
    #####:10527:    for (n_f = 0;n_f < gen_nb_xmlHashDeallocator;n_f++) {
    #####:10528:        mem_base = xmlMemBlocks();
    #####:10529:        table = gen_xmlHashTablePtr(n_table, 0);
    #####:10530:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:10531:        userdata = gen_userdata(n_userdata, 2);
    #####:10532:        f = gen_xmlHashDeallocator(n_f, 3);
        -:10533:
    #####:10534:        ret_val = xmlHashUpdateEntry(table, (const xmlChar *)name, userdata, f);
    #####:10535:        desret_int(ret_val);
    #####:10536:        call_tests++;
    #####:10537:        des_xmlHashTablePtr(n_table, table, 0);
    #####:10538:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:10539:        des_userdata(n_userdata, userdata, 2);
    #####:10540:        des_xmlHashDeallocator(n_f, f, 3);
    #####:10541:        xmlResetLastError();
    #####:10542:        if (mem_base != xmlMemBlocks()) {
    #####:10543:            printf("Leak of %d blocks found in xmlHashUpdateEntry",
    #####:10544:	           xmlMemBlocks() - mem_base);
    #####:10545:	    test_ret++;
    #####:10546:            printf(" %d", n_table);
    #####:10547:            printf(" %d", n_name);
    #####:10548:            printf(" %d", n_userdata);
    #####:10549:            printf(" %d", n_f);
    #####:10550:            printf("\n");
        -:10551:        }
        -:10552:    }
        -:10553:    }
        -:10554:    }
        -:10555:    }
    #####:10556:    function_tests++;
        -:10557:
    #####:10558:    return(test_ret);
        -:10559:}
        -:10560:
        -:10561:
        -:10562:static int
    #####:10563:test_xmlHashUpdateEntry2(void) {
    #####:10564:    int test_ret = 0;
        -:10565:
        -:10566:    int mem_base;
        -:10567:    int ret_val;
        -:10568:    xmlHashTablePtr table; /* the hash table */
        -:10569:    int n_table;
        -:10570:    xmlChar * name; /* the name of the userdata */
        -:10571:    int n_name;
        -:10572:    xmlChar * name2; /* a second name of the userdata */
        -:10573:    int n_name2;
        -:10574:    void * userdata; /* a pointer to the userdata */
        -:10575:    int n_userdata;
        -:10576:    xmlHashDeallocator f; /* the deallocator function for replaced item (if any) */
        -:10577:    int n_f;
        -:10578:
    #####:10579:    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    #####:10580:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:10581:    for (n_name2 = 0;n_name2 < gen_nb_const_xmlChar_ptr;n_name2++) {
    #####:10582:    for (n_userdata = 0;n_userdata < gen_nb_userdata;n_userdata++) {
    #####:10583:    for (n_f = 0;n_f < gen_nb_xmlHashDeallocator;n_f++) {
    #####:10584:        mem_base = xmlMemBlocks();
    #####:10585:        table = gen_xmlHashTablePtr(n_table, 0);
    #####:10586:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:10587:        name2 = gen_const_xmlChar_ptr(n_name2, 2);
    #####:10588:        userdata = gen_userdata(n_userdata, 3);
    #####:10589:        f = gen_xmlHashDeallocator(n_f, 4);
        -:10590:
    #####:10591:        ret_val = xmlHashUpdateEntry2(table, (const xmlChar *)name, (const xmlChar *)name2, userdata, f);
    #####:10592:        desret_int(ret_val);
    #####:10593:        call_tests++;
    #####:10594:        des_xmlHashTablePtr(n_table, table, 0);
    #####:10595:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:10596:        des_const_xmlChar_ptr(n_name2, (const xmlChar *)name2, 2);
    #####:10597:        des_userdata(n_userdata, userdata, 3);
    #####:10598:        des_xmlHashDeallocator(n_f, f, 4);
    #####:10599:        xmlResetLastError();
    #####:10600:        if (mem_base != xmlMemBlocks()) {
    #####:10601:            printf("Leak of %d blocks found in xmlHashUpdateEntry2",
    #####:10602:	           xmlMemBlocks() - mem_base);
    #####:10603:	    test_ret++;
    #####:10604:            printf(" %d", n_table);
    #####:10605:            printf(" %d", n_name);
    #####:10606:            printf(" %d", n_name2);
    #####:10607:            printf(" %d", n_userdata);
    #####:10608:            printf(" %d", n_f);
    #####:10609:            printf("\n");
        -:10610:        }
        -:10611:    }
        -:10612:    }
        -:10613:    }
        -:10614:    }
        -:10615:    }
    #####:10616:    function_tests++;
        -:10617:
    #####:10618:    return(test_ret);
        -:10619:}
        -:10620:
        -:10621:
        -:10622:static int
    #####:10623:test_xmlHashUpdateEntry3(void) {
    #####:10624:    int test_ret = 0;
        -:10625:
        -:10626:    int mem_base;
        -:10627:    int ret_val;
        -:10628:    xmlHashTablePtr table; /* the hash table */
        -:10629:    int n_table;
        -:10630:    xmlChar * name; /* the name of the userdata */
        -:10631:    int n_name;
        -:10632:    xmlChar * name2; /* a second name of the userdata */
        -:10633:    int n_name2;
        -:10634:    xmlChar * name3; /* a third name of the userdata */
        -:10635:    int n_name3;
        -:10636:    void * userdata; /* a pointer to the userdata */
        -:10637:    int n_userdata;
        -:10638:    xmlHashDeallocator f; /* the deallocator function for replaced item (if any) */
        -:10639:    int n_f;
        -:10640:
    #####:10641:    for (n_table = 0;n_table < gen_nb_xmlHashTablePtr;n_table++) {
    #####:10642:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:10643:    for (n_name2 = 0;n_name2 < gen_nb_const_xmlChar_ptr;n_name2++) {
    #####:10644:    for (n_name3 = 0;n_name3 < gen_nb_const_xmlChar_ptr;n_name3++) {
    #####:10645:    for (n_userdata = 0;n_userdata < gen_nb_userdata;n_userdata++) {
    #####:10646:    for (n_f = 0;n_f < gen_nb_xmlHashDeallocator;n_f++) {
    #####:10647:        mem_base = xmlMemBlocks();
    #####:10648:        table = gen_xmlHashTablePtr(n_table, 0);
    #####:10649:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:10650:        name2 = gen_const_xmlChar_ptr(n_name2, 2);
    #####:10651:        name3 = gen_const_xmlChar_ptr(n_name3, 3);
    #####:10652:        userdata = gen_userdata(n_userdata, 4);
    #####:10653:        f = gen_xmlHashDeallocator(n_f, 5);
        -:10654:
    #####:10655:        ret_val = xmlHashUpdateEntry3(table, (const xmlChar *)name, (const xmlChar *)name2, (const xmlChar *)name3, userdata, f);
    #####:10656:        desret_int(ret_val);
    #####:10657:        call_tests++;
    #####:10658:        des_xmlHashTablePtr(n_table, table, 0);
    #####:10659:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:10660:        des_const_xmlChar_ptr(n_name2, (const xmlChar *)name2, 2);
    #####:10661:        des_const_xmlChar_ptr(n_name3, (const xmlChar *)name3, 3);
    #####:10662:        des_userdata(n_userdata, userdata, 4);
    #####:10663:        des_xmlHashDeallocator(n_f, f, 5);
    #####:10664:        xmlResetLastError();
    #####:10665:        if (mem_base != xmlMemBlocks()) {
    #####:10666:            printf("Leak of %d blocks found in xmlHashUpdateEntry3",
    #####:10667:	           xmlMemBlocks() - mem_base);
    #####:10668:	    test_ret++;
    #####:10669:            printf(" %d", n_table);
    #####:10670:            printf(" %d", n_name);
    #####:10671:            printf(" %d", n_name2);
    #####:10672:            printf(" %d", n_name3);
    #####:10673:            printf(" %d", n_userdata);
    #####:10674:            printf(" %d", n_f);
    #####:10675:            printf("\n");
        -:10676:        }
        -:10677:    }
        -:10678:    }
        -:10679:    }
        -:10680:    }
        -:10681:    }
        -:10682:    }
    #####:10683:    function_tests++;
        -:10684:
    #####:10685:    return(test_ret);
        -:10686:}
        -:10687:
        -:10688:static int
    #####:10689:test_hash(void) {
    #####:10690:    int test_ret = 0;
        -:10691:
    #####:10692:    if (quiet == 0) printf("Testing hash : 16 of 24 functions ...\n");
    #####:10693:    test_ret += test_xmlHashAddEntry();
    #####:10694:    test_ret += test_xmlHashAddEntry2();
    #####:10695:    test_ret += test_xmlHashAddEntry3();
    #####:10696:    test_ret += test_xmlHashCopy();
    #####:10697:    test_ret += test_xmlHashCreate();
    #####:10698:    test_ret += test_xmlHashCreateDict();
    #####:10699:    test_ret += test_xmlHashLookup();
    #####:10700:    test_ret += test_xmlHashLookup2();
    #####:10701:    test_ret += test_xmlHashLookup3();
    #####:10702:    test_ret += test_xmlHashQLookup();
    #####:10703:    test_ret += test_xmlHashQLookup2();
    #####:10704:    test_ret += test_xmlHashQLookup3();
    #####:10705:    test_ret += test_xmlHashRemoveEntry();
    #####:10706:    test_ret += test_xmlHashRemoveEntry2();
    #####:10707:    test_ret += test_xmlHashRemoveEntry3();
    #####:10708:    test_ret += test_xmlHashScan();
    #####:10709:    test_ret += test_xmlHashScan3();
    #####:10710:    test_ret += test_xmlHashScanFull();
    #####:10711:    test_ret += test_xmlHashScanFull3();
    #####:10712:    test_ret += test_xmlHashSize();
    #####:10713:    test_ret += test_xmlHashUpdateEntry();
    #####:10714:    test_ret += test_xmlHashUpdateEntry2();
    #####:10715:    test_ret += test_xmlHashUpdateEntry3();
        -:10716:
    #####:10717:    if (test_ret != 0)
    #####:10718:	printf("Module hash: %d errors\n", test_ret);
    #####:10719:    return(test_ret);
        -:10720:}
        -:10721:
        -:10722:#define gen_nb_xmlLinkPtr 1
    #####:10723:static xmlLinkPtr gen_xmlLinkPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:10724:    return(NULL);
        -:10725:}
    #####:10726:static void des_xmlLinkPtr(int no ATTRIBUTE_UNUSED, xmlLinkPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:10727:}
        -:10728:
        -:10729:static int
    #####:10730:test_xmlLinkGetData(void) {
    #####:10731:    int test_ret = 0;
        -:10732:
        -:10733:    int mem_base;
        -:10734:    void * ret_val;
        -:10735:    xmlLinkPtr lk; /* a link */
        -:10736:    int n_lk;
        -:10737:
    #####:10738:    for (n_lk = 0;n_lk < gen_nb_xmlLinkPtr;n_lk++) {
    #####:10739:        mem_base = xmlMemBlocks();
    #####:10740:        lk = gen_xmlLinkPtr(n_lk, 0);
        -:10741:
    #####:10742:        ret_val = xmlLinkGetData(lk);
    #####:10743:        desret_void_ptr(ret_val);
    #####:10744:        call_tests++;
    #####:10745:        des_xmlLinkPtr(n_lk, lk, 0);
    #####:10746:        xmlResetLastError();
    #####:10747:        if (mem_base != xmlMemBlocks()) {
    #####:10748:            printf("Leak of %d blocks found in xmlLinkGetData",
    #####:10749:	           xmlMemBlocks() - mem_base);
    #####:10750:	    test_ret++;
    #####:10751:            printf(" %d", n_lk);
    #####:10752:            printf("\n");
        -:10753:        }
        -:10754:    }
    #####:10755:    function_tests++;
        -:10756:
    #####:10757:    return(test_ret);
        -:10758:}
        -:10759:
        -:10760:
        -:10761:static int
    #####:10762:test_xmlListAppend(void) {
    #####:10763:    int test_ret = 0;
        -:10764:
        -:10765:    int mem_base;
        -:10766:    int ret_val;
        -:10767:    xmlListPtr l; /* a list */
        -:10768:    int n_l;
        -:10769:    void * data; /* the data */
        -:10770:    int n_data;
        -:10771:
    #####:10772:    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    #####:10773:    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
    #####:10774:        mem_base = xmlMemBlocks();
    #####:10775:        l = gen_xmlListPtr(n_l, 0);
    #####:10776:        data = gen_userdata(n_data, 1);
        -:10777:
    #####:10778:        ret_val = xmlListAppend(l, data);
    #####:10779:        desret_int(ret_val);
    #####:10780:        call_tests++;
    #####:10781:        des_xmlListPtr(n_l, l, 0);
    #####:10782:        des_userdata(n_data, data, 1);
    #####:10783:        xmlResetLastError();
    #####:10784:        if (mem_base != xmlMemBlocks()) {
    #####:10785:            printf("Leak of %d blocks found in xmlListAppend",
    #####:10786:	           xmlMemBlocks() - mem_base);
    #####:10787:	    test_ret++;
    #####:10788:            printf(" %d", n_l);
    #####:10789:            printf(" %d", n_data);
    #####:10790:            printf("\n");
        -:10791:        }
        -:10792:    }
        -:10793:    }
    #####:10794:    function_tests++;
        -:10795:
    #####:10796:    return(test_ret);
        -:10797:}
        -:10798:
        -:10799:
        -:10800:static int
    #####:10801:test_xmlListClear(void) {
    #####:10802:    int test_ret = 0;
        -:10803:
        -:10804:    int mem_base;
        -:10805:    xmlListPtr l; /* a list */
        -:10806:    int n_l;
        -:10807:
    #####:10808:    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    #####:10809:        mem_base = xmlMemBlocks();
    #####:10810:        l = gen_xmlListPtr(n_l, 0);
        -:10811:
    #####:10812:        xmlListClear(l);
    #####:10813:        call_tests++;
    #####:10814:        des_xmlListPtr(n_l, l, 0);
    #####:10815:        xmlResetLastError();
    #####:10816:        if (mem_base != xmlMemBlocks()) {
    #####:10817:            printf("Leak of %d blocks found in xmlListClear",
    #####:10818:	           xmlMemBlocks() - mem_base);
    #####:10819:	    test_ret++;
    #####:10820:            printf(" %d", n_l);
    #####:10821:            printf("\n");
        -:10822:        }
        -:10823:    }
    #####:10824:    function_tests++;
        -:10825:
    #####:10826:    return(test_ret);
        -:10827:}
        -:10828:
        -:10829:
        -:10830:#define gen_nb_const_xmlListPtr 1
    #####:10831:static xmlListPtr gen_const_xmlListPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:10832:    return(NULL);
        -:10833:}
    #####:10834:static void des_const_xmlListPtr(int no ATTRIBUTE_UNUSED, const xmlListPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:10835:}
        -:10836:
        -:10837:static int
    #####:10838:test_xmlListCopy(void) {
    #####:10839:    int test_ret = 0;
        -:10840:
        -:10841:    int mem_base;
        -:10842:    int ret_val;
        -:10843:    xmlListPtr cur; /* the new list */
        -:10844:    int n_cur;
        -:10845:    xmlListPtr old; /* the old list */
        -:10846:    int n_old;
        -:10847:
    #####:10848:    for (n_cur = 0;n_cur < gen_nb_xmlListPtr;n_cur++) {
    #####:10849:    for (n_old = 0;n_old < gen_nb_const_xmlListPtr;n_old++) {
    #####:10850:        mem_base = xmlMemBlocks();
    #####:10851:        cur = gen_xmlListPtr(n_cur, 0);
    #####:10852:        old = gen_const_xmlListPtr(n_old, 1);
        -:10853:
    #####:10854:        ret_val = xmlListCopy(cur, (const xmlListPtr)old);
    #####:10855:        desret_int(ret_val);
    #####:10856:        call_tests++;
    #####:10857:        des_xmlListPtr(n_cur, cur, 0);
    #####:10858:        des_const_xmlListPtr(n_old, (const xmlListPtr)old, 1);
    #####:10859:        xmlResetLastError();
    #####:10860:        if (mem_base != xmlMemBlocks()) {
    #####:10861:            printf("Leak of %d blocks found in xmlListCopy",
    #####:10862:	           xmlMemBlocks() - mem_base);
    #####:10863:	    test_ret++;
    #####:10864:            printf(" %d", n_cur);
    #####:10865:            printf(" %d", n_old);
    #####:10866:            printf("\n");
        -:10867:        }
        -:10868:    }
        -:10869:    }
    #####:10870:    function_tests++;
        -:10871:
    #####:10872:    return(test_ret);
        -:10873:}
        -:10874:
        -:10875:
        -:10876:static int
    #####:10877:test_xmlListCreate(void) {
    #####:10878:    int test_ret = 0;
        -:10879:
        -:10880:
        -:10881:    /* missing type support */
    #####:10882:    return(test_ret);
        -:10883:}
        -:10884:
        -:10885:
        -:10886:static int
    #####:10887:test_xmlListDup(void) {
    #####:10888:    int test_ret = 0;
        -:10889:
        -:10890:
        -:10891:    /* missing type support */
    #####:10892:    return(test_ret);
        -:10893:}
        -:10894:
        -:10895:
        -:10896:static int
    #####:10897:test_xmlListEmpty(void) {
    #####:10898:    int test_ret = 0;
        -:10899:
        -:10900:    int mem_base;
        -:10901:    int ret_val;
        -:10902:    xmlListPtr l; /* a list */
        -:10903:    int n_l;
        -:10904:
    #####:10905:    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    #####:10906:        mem_base = xmlMemBlocks();
    #####:10907:        l = gen_xmlListPtr(n_l, 0);
        -:10908:
    #####:10909:        ret_val = xmlListEmpty(l);
    #####:10910:        desret_int(ret_val);
    #####:10911:        call_tests++;
    #####:10912:        des_xmlListPtr(n_l, l, 0);
    #####:10913:        xmlResetLastError();
    #####:10914:        if (mem_base != xmlMemBlocks()) {
    #####:10915:            printf("Leak of %d blocks found in xmlListEmpty",
    #####:10916:	           xmlMemBlocks() - mem_base);
    #####:10917:	    test_ret++;
    #####:10918:            printf(" %d", n_l);
    #####:10919:            printf("\n");
        -:10920:        }
        -:10921:    }
    #####:10922:    function_tests++;
        -:10923:
    #####:10924:    return(test_ret);
        -:10925:}
        -:10926:
        -:10927:
        -:10928:static int
    #####:10929:test_xmlListEnd(void) {
    #####:10930:    int test_ret = 0;
        -:10931:
        -:10932:
        -:10933:    /* missing type support */
    #####:10934:    return(test_ret);
        -:10935:}
        -:10936:
        -:10937:
        -:10938:static int
    #####:10939:test_xmlListFront(void) {
    #####:10940:    int test_ret = 0;
        -:10941:
        -:10942:
        -:10943:    /* missing type support */
    #####:10944:    return(test_ret);
        -:10945:}
        -:10946:
        -:10947:
        -:10948:static int
    #####:10949:test_xmlListInsert(void) {
    #####:10950:    int test_ret = 0;
        -:10951:
        -:10952:    int mem_base;
        -:10953:    int ret_val;
        -:10954:    xmlListPtr l; /* a list */
        -:10955:    int n_l;
        -:10956:    void * data; /* the data */
        -:10957:    int n_data;
        -:10958:
    #####:10959:    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    #####:10960:    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
    #####:10961:        mem_base = xmlMemBlocks();
    #####:10962:        l = gen_xmlListPtr(n_l, 0);
    #####:10963:        data = gen_userdata(n_data, 1);
        -:10964:
    #####:10965:        ret_val = xmlListInsert(l, data);
    #####:10966:        desret_int(ret_val);
    #####:10967:        call_tests++;
    #####:10968:        des_xmlListPtr(n_l, l, 0);
    #####:10969:        des_userdata(n_data, data, 1);
    #####:10970:        xmlResetLastError();
    #####:10971:        if (mem_base != xmlMemBlocks()) {
    #####:10972:            printf("Leak of %d blocks found in xmlListInsert",
    #####:10973:	           xmlMemBlocks() - mem_base);
    #####:10974:	    test_ret++;
    #####:10975:            printf(" %d", n_l);
    #####:10976:            printf(" %d", n_data);
    #####:10977:            printf("\n");
        -:10978:        }
        -:10979:    }
        -:10980:    }
    #####:10981:    function_tests++;
        -:10982:
    #####:10983:    return(test_ret);
        -:10984:}
        -:10985:
        -:10986:
        -:10987:static int
    #####:10988:test_xmlListMerge(void) {
    #####:10989:    int test_ret = 0;
        -:10990:
        -:10991:    int mem_base;
        -:10992:    xmlListPtr l1; /* the original list */
        -:10993:    int n_l1;
        -:10994:    xmlListPtr l2; /* the new list */
        -:10995:    int n_l2;
        -:10996:
    #####:10997:    for (n_l1 = 0;n_l1 < gen_nb_xmlListPtr;n_l1++) {
    #####:10998:    for (n_l2 = 0;n_l2 < gen_nb_xmlListPtr;n_l2++) {
    #####:10999:        mem_base = xmlMemBlocks();
    #####:11000:        l1 = gen_xmlListPtr(n_l1, 0);
    #####:11001:        l2 = gen_xmlListPtr(n_l2, 1);
        -:11002:
    #####:11003:        xmlListMerge(l1, l2);
    #####:11004:        call_tests++;
    #####:11005:        des_xmlListPtr(n_l1, l1, 0);
    #####:11006:        des_xmlListPtr(n_l2, l2, 1);
    #####:11007:        xmlResetLastError();
    #####:11008:        if (mem_base != xmlMemBlocks()) {
    #####:11009:            printf("Leak of %d blocks found in xmlListMerge",
    #####:11010:	           xmlMemBlocks() - mem_base);
    #####:11011:	    test_ret++;
    #####:11012:            printf(" %d", n_l1);
    #####:11013:            printf(" %d", n_l2);
    #####:11014:            printf("\n");
        -:11015:        }
        -:11016:    }
        -:11017:    }
    #####:11018:    function_tests++;
        -:11019:
    #####:11020:    return(test_ret);
        -:11021:}
        -:11022:
        -:11023:
        -:11024:static int
    #####:11025:test_xmlListPopBack(void) {
    #####:11026:    int test_ret = 0;
        -:11027:
        -:11028:    int mem_base;
        -:11029:    xmlListPtr l; /* a list */
        -:11030:    int n_l;
        -:11031:
    #####:11032:    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    #####:11033:        mem_base = xmlMemBlocks();
    #####:11034:        l = gen_xmlListPtr(n_l, 0);
        -:11035:
    #####:11036:        xmlListPopBack(l);
    #####:11037:        call_tests++;
    #####:11038:        des_xmlListPtr(n_l, l, 0);
    #####:11039:        xmlResetLastError();
    #####:11040:        if (mem_base != xmlMemBlocks()) {
    #####:11041:            printf("Leak of %d blocks found in xmlListPopBack",
    #####:11042:	           xmlMemBlocks() - mem_base);
    #####:11043:	    test_ret++;
    #####:11044:            printf(" %d", n_l);
    #####:11045:            printf("\n");
        -:11046:        }
        -:11047:    }
    #####:11048:    function_tests++;
        -:11049:
    #####:11050:    return(test_ret);
        -:11051:}
        -:11052:
        -:11053:
        -:11054:static int
    #####:11055:test_xmlListPopFront(void) {
    #####:11056:    int test_ret = 0;
        -:11057:
        -:11058:    int mem_base;
        -:11059:    xmlListPtr l; /* a list */
        -:11060:    int n_l;
        -:11061:
    #####:11062:    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    #####:11063:        mem_base = xmlMemBlocks();
    #####:11064:        l = gen_xmlListPtr(n_l, 0);
        -:11065:
    #####:11066:        xmlListPopFront(l);
    #####:11067:        call_tests++;
    #####:11068:        des_xmlListPtr(n_l, l, 0);
    #####:11069:        xmlResetLastError();
    #####:11070:        if (mem_base != xmlMemBlocks()) {
    #####:11071:            printf("Leak of %d blocks found in xmlListPopFront",
    #####:11072:	           xmlMemBlocks() - mem_base);
    #####:11073:	    test_ret++;
    #####:11074:            printf(" %d", n_l);
    #####:11075:            printf("\n");
        -:11076:        }
        -:11077:    }
    #####:11078:    function_tests++;
        -:11079:
    #####:11080:    return(test_ret);
        -:11081:}
        -:11082:
        -:11083:
        -:11084:static int
    #####:11085:test_xmlListPushBack(void) {
    #####:11086:    int test_ret = 0;
        -:11087:
        -:11088:    int mem_base;
        -:11089:    int ret_val;
        -:11090:    xmlListPtr l; /* a list */
        -:11091:    int n_l;
        -:11092:    void * data; /* new data */
        -:11093:    int n_data;
        -:11094:
    #####:11095:    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    #####:11096:    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
    #####:11097:        mem_base = xmlMemBlocks();
    #####:11098:        l = gen_xmlListPtr(n_l, 0);
    #####:11099:        data = gen_userdata(n_data, 1);
        -:11100:
    #####:11101:        ret_val = xmlListPushBack(l, data);
    #####:11102:        desret_int(ret_val);
    #####:11103:        call_tests++;
    #####:11104:        des_xmlListPtr(n_l, l, 0);
    #####:11105:        des_userdata(n_data, data, 1);
    #####:11106:        xmlResetLastError();
    #####:11107:        if (mem_base != xmlMemBlocks()) {
    #####:11108:            printf("Leak of %d blocks found in xmlListPushBack",
    #####:11109:	           xmlMemBlocks() - mem_base);
    #####:11110:	    test_ret++;
    #####:11111:            printf(" %d", n_l);
    #####:11112:            printf(" %d", n_data);
    #####:11113:            printf("\n");
        -:11114:        }
        -:11115:    }
        -:11116:    }
    #####:11117:    function_tests++;
        -:11118:
    #####:11119:    return(test_ret);
        -:11120:}
        -:11121:
        -:11122:
        -:11123:static int
    #####:11124:test_xmlListPushFront(void) {
    #####:11125:    int test_ret = 0;
        -:11126:
        -:11127:    int mem_base;
        -:11128:    int ret_val;
        -:11129:    xmlListPtr l; /* a list */
        -:11130:    int n_l;
        -:11131:    void * data; /* new data */
        -:11132:    int n_data;
        -:11133:
    #####:11134:    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    #####:11135:    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
    #####:11136:        mem_base = xmlMemBlocks();
    #####:11137:        l = gen_xmlListPtr(n_l, 0);
    #####:11138:        data = gen_userdata(n_data, 1);
        -:11139:
    #####:11140:        ret_val = xmlListPushFront(l, data);
    #####:11141:        desret_int(ret_val);
    #####:11142:        call_tests++;
    #####:11143:        des_xmlListPtr(n_l, l, 0);
    #####:11144:        des_userdata(n_data, data, 1);
    #####:11145:        xmlResetLastError();
    #####:11146:        if (mem_base != xmlMemBlocks()) {
    #####:11147:            printf("Leak of %d blocks found in xmlListPushFront",
    #####:11148:	           xmlMemBlocks() - mem_base);
    #####:11149:	    test_ret++;
    #####:11150:            printf(" %d", n_l);
    #####:11151:            printf(" %d", n_data);
    #####:11152:            printf("\n");
        -:11153:        }
        -:11154:    }
        -:11155:    }
    #####:11156:    function_tests++;
        -:11157:
    #####:11158:    return(test_ret);
        -:11159:}
        -:11160:
        -:11161:
        -:11162:static int
    #####:11163:test_xmlListRemoveAll(void) {
    #####:11164:    int test_ret = 0;
        -:11165:
        -:11166:    int mem_base;
        -:11167:    int ret_val;
        -:11168:    xmlListPtr l; /* a list */
        -:11169:    int n_l;
        -:11170:    void * data; /* list data */
        -:11171:    int n_data;
        -:11172:
    #####:11173:    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    #####:11174:    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
    #####:11175:        mem_base = xmlMemBlocks();
    #####:11176:        l = gen_xmlListPtr(n_l, 0);
    #####:11177:        data = gen_userdata(n_data, 1);
        -:11178:
    #####:11179:        ret_val = xmlListRemoveAll(l, data);
    #####:11180:        desret_int(ret_val);
    #####:11181:        call_tests++;
    #####:11182:        des_xmlListPtr(n_l, l, 0);
    #####:11183:        des_userdata(n_data, data, 1);
    #####:11184:        xmlResetLastError();
    #####:11185:        if (mem_base != xmlMemBlocks()) {
    #####:11186:            printf("Leak of %d blocks found in xmlListRemoveAll",
    #####:11187:	           xmlMemBlocks() - mem_base);
    #####:11188:	    test_ret++;
    #####:11189:            printf(" %d", n_l);
    #####:11190:            printf(" %d", n_data);
    #####:11191:            printf("\n");
        -:11192:        }
        -:11193:    }
        -:11194:    }
    #####:11195:    function_tests++;
        -:11196:
    #####:11197:    return(test_ret);
        -:11198:}
        -:11199:
        -:11200:
        -:11201:static int
    #####:11202:test_xmlListRemoveFirst(void) {
    #####:11203:    int test_ret = 0;
        -:11204:
        -:11205:    int mem_base;
        -:11206:    int ret_val;
        -:11207:    xmlListPtr l; /* a list */
        -:11208:    int n_l;
        -:11209:    void * data; /* list data */
        -:11210:    int n_data;
        -:11211:
    #####:11212:    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    #####:11213:    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
    #####:11214:        mem_base = xmlMemBlocks();
    #####:11215:        l = gen_xmlListPtr(n_l, 0);
    #####:11216:        data = gen_userdata(n_data, 1);
        -:11217:
    #####:11218:        ret_val = xmlListRemoveFirst(l, data);
    #####:11219:        desret_int(ret_val);
    #####:11220:        call_tests++;
    #####:11221:        des_xmlListPtr(n_l, l, 0);
    #####:11222:        des_userdata(n_data, data, 1);
    #####:11223:        xmlResetLastError();
    #####:11224:        if (mem_base != xmlMemBlocks()) {
    #####:11225:            printf("Leak of %d blocks found in xmlListRemoveFirst",
    #####:11226:	           xmlMemBlocks() - mem_base);
    #####:11227:	    test_ret++;
    #####:11228:            printf(" %d", n_l);
    #####:11229:            printf(" %d", n_data);
    #####:11230:            printf("\n");
        -:11231:        }
        -:11232:    }
        -:11233:    }
    #####:11234:    function_tests++;
        -:11235:
    #####:11236:    return(test_ret);
        -:11237:}
        -:11238:
        -:11239:
        -:11240:static int
    #####:11241:test_xmlListRemoveLast(void) {
    #####:11242:    int test_ret = 0;
        -:11243:
        -:11244:    int mem_base;
        -:11245:    int ret_val;
        -:11246:    xmlListPtr l; /* a list */
        -:11247:    int n_l;
        -:11248:    void * data; /* list data */
        -:11249:    int n_data;
        -:11250:
    #####:11251:    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    #####:11252:    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
    #####:11253:        mem_base = xmlMemBlocks();
    #####:11254:        l = gen_xmlListPtr(n_l, 0);
    #####:11255:        data = gen_userdata(n_data, 1);
        -:11256:
    #####:11257:        ret_val = xmlListRemoveLast(l, data);
    #####:11258:        desret_int(ret_val);
    #####:11259:        call_tests++;
    #####:11260:        des_xmlListPtr(n_l, l, 0);
    #####:11261:        des_userdata(n_data, data, 1);
    #####:11262:        xmlResetLastError();
    #####:11263:        if (mem_base != xmlMemBlocks()) {
    #####:11264:            printf("Leak of %d blocks found in xmlListRemoveLast",
    #####:11265:	           xmlMemBlocks() - mem_base);
    #####:11266:	    test_ret++;
    #####:11267:            printf(" %d", n_l);
    #####:11268:            printf(" %d", n_data);
    #####:11269:            printf("\n");
        -:11270:        }
        -:11271:    }
        -:11272:    }
    #####:11273:    function_tests++;
        -:11274:
    #####:11275:    return(test_ret);
        -:11276:}
        -:11277:
        -:11278:
        -:11279:static int
    #####:11280:test_xmlListReverse(void) {
    #####:11281:    int test_ret = 0;
        -:11282:
        -:11283:    int mem_base;
        -:11284:    xmlListPtr l; /* a list */
        -:11285:    int n_l;
        -:11286:
    #####:11287:    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    #####:11288:        mem_base = xmlMemBlocks();
    #####:11289:        l = gen_xmlListPtr(n_l, 0);
        -:11290:
    #####:11291:        xmlListReverse(l);
    #####:11292:        call_tests++;
    #####:11293:        des_xmlListPtr(n_l, l, 0);
    #####:11294:        xmlResetLastError();
    #####:11295:        if (mem_base != xmlMemBlocks()) {
    #####:11296:            printf("Leak of %d blocks found in xmlListReverse",
    #####:11297:	           xmlMemBlocks() - mem_base);
    #####:11298:	    test_ret++;
    #####:11299:            printf(" %d", n_l);
    #####:11300:            printf("\n");
        -:11301:        }
        -:11302:    }
    #####:11303:    function_tests++;
        -:11304:
    #####:11305:    return(test_ret);
        -:11306:}
        -:11307:
        -:11308:
        -:11309:static int
    #####:11310:test_xmlListReverseSearch(void) {
    #####:11311:    int test_ret = 0;
        -:11312:
        -:11313:    int mem_base;
        -:11314:    void * ret_val;
        -:11315:    xmlListPtr l; /* a list */
        -:11316:    int n_l;
        -:11317:    void * data; /* a search value */
        -:11318:    int n_data;
        -:11319:
    #####:11320:    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    #####:11321:    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
    #####:11322:        mem_base = xmlMemBlocks();
    #####:11323:        l = gen_xmlListPtr(n_l, 0);
    #####:11324:        data = gen_userdata(n_data, 1);
        -:11325:
    #####:11326:        ret_val = xmlListReverseSearch(l, data);
    #####:11327:        desret_void_ptr(ret_val);
    #####:11328:        call_tests++;
    #####:11329:        des_xmlListPtr(n_l, l, 0);
    #####:11330:        des_userdata(n_data, data, 1);
    #####:11331:        xmlResetLastError();
    #####:11332:        if (mem_base != xmlMemBlocks()) {
    #####:11333:            printf("Leak of %d blocks found in xmlListReverseSearch",
    #####:11334:	           xmlMemBlocks() - mem_base);
    #####:11335:	    test_ret++;
    #####:11336:            printf(" %d", n_l);
    #####:11337:            printf(" %d", n_data);
    #####:11338:            printf("\n");
        -:11339:        }
        -:11340:    }
        -:11341:    }
    #####:11342:    function_tests++;
        -:11343:
    #####:11344:    return(test_ret);
        -:11345:}
        -:11346:
        -:11347:
        -:11348:static int
    #####:11349:test_xmlListReverseWalk(void) {
    #####:11350:    int test_ret = 0;
        -:11351:
        -:11352:
        -:11353:    /* missing type support */
    #####:11354:    return(test_ret);
        -:11355:}
        -:11356:
        -:11357:
        -:11358:static int
    #####:11359:test_xmlListSearch(void) {
    #####:11360:    int test_ret = 0;
        -:11361:
        -:11362:    int mem_base;
        -:11363:    void * ret_val;
        -:11364:    xmlListPtr l; /* a list */
        -:11365:    int n_l;
        -:11366:    void * data; /* a search value */
        -:11367:    int n_data;
        -:11368:
    #####:11369:    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    #####:11370:    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
    #####:11371:        mem_base = xmlMemBlocks();
    #####:11372:        l = gen_xmlListPtr(n_l, 0);
    #####:11373:        data = gen_userdata(n_data, 1);
        -:11374:
    #####:11375:        ret_val = xmlListSearch(l, data);
    #####:11376:        desret_void_ptr(ret_val);
    #####:11377:        call_tests++;
    #####:11378:        des_xmlListPtr(n_l, l, 0);
    #####:11379:        des_userdata(n_data, data, 1);
    #####:11380:        xmlResetLastError();
    #####:11381:        if (mem_base != xmlMemBlocks()) {
    #####:11382:            printf("Leak of %d blocks found in xmlListSearch",
    #####:11383:	           xmlMemBlocks() - mem_base);
    #####:11384:	    test_ret++;
    #####:11385:            printf(" %d", n_l);
    #####:11386:            printf(" %d", n_data);
    #####:11387:            printf("\n");
        -:11388:        }
        -:11389:    }
        -:11390:    }
    #####:11391:    function_tests++;
        -:11392:
    #####:11393:    return(test_ret);
        -:11394:}
        -:11395:
        -:11396:
        -:11397:static int
    #####:11398:test_xmlListSize(void) {
    #####:11399:    int test_ret = 0;
        -:11400:
        -:11401:    int mem_base;
        -:11402:    int ret_val;
        -:11403:    xmlListPtr l; /* a list */
        -:11404:    int n_l;
        -:11405:
    #####:11406:    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    #####:11407:        mem_base = xmlMemBlocks();
    #####:11408:        l = gen_xmlListPtr(n_l, 0);
        -:11409:
    #####:11410:        ret_val = xmlListSize(l);
    #####:11411:        desret_int(ret_val);
    #####:11412:        call_tests++;
    #####:11413:        des_xmlListPtr(n_l, l, 0);
    #####:11414:        xmlResetLastError();
    #####:11415:        if (mem_base != xmlMemBlocks()) {
    #####:11416:            printf("Leak of %d blocks found in xmlListSize",
    #####:11417:	           xmlMemBlocks() - mem_base);
    #####:11418:	    test_ret++;
    #####:11419:            printf(" %d", n_l);
    #####:11420:            printf("\n");
        -:11421:        }
        -:11422:    }
    #####:11423:    function_tests++;
        -:11424:
    #####:11425:    return(test_ret);
        -:11426:}
        -:11427:
        -:11428:
        -:11429:static int
    #####:11430:test_xmlListSort(void) {
    #####:11431:    int test_ret = 0;
        -:11432:
        -:11433:    int mem_base;
        -:11434:    xmlListPtr l; /* a list */
        -:11435:    int n_l;
        -:11436:
    #####:11437:    for (n_l = 0;n_l < gen_nb_xmlListPtr;n_l++) {
    #####:11438:        mem_base = xmlMemBlocks();
    #####:11439:        l = gen_xmlListPtr(n_l, 0);
        -:11440:
    #####:11441:        xmlListSort(l);
    #####:11442:        call_tests++;
    #####:11443:        des_xmlListPtr(n_l, l, 0);
    #####:11444:        xmlResetLastError();
    #####:11445:        if (mem_base != xmlMemBlocks()) {
    #####:11446:            printf("Leak of %d blocks found in xmlListSort",
    #####:11447:	           xmlMemBlocks() - mem_base);
    #####:11448:	    test_ret++;
    #####:11449:            printf(" %d", n_l);
    #####:11450:            printf("\n");
        -:11451:        }
        -:11452:    }
    #####:11453:    function_tests++;
        -:11454:
    #####:11455:    return(test_ret);
        -:11456:}
        -:11457:
        -:11458:
        -:11459:static int
    #####:11460:test_xmlListWalk(void) {
    #####:11461:    int test_ret = 0;
        -:11462:
        -:11463:
        -:11464:    /* missing type support */
    #####:11465:    return(test_ret);
        -:11466:}
        -:11467:
        -:11468:static int
    #####:11469:test_list(void) {
    #####:11470:    int test_ret = 0;
        -:11471:
    #####:11472:    if (quiet == 0) printf("Testing list : 19 of 26 functions ...\n");
    #####:11473:    test_ret += test_xmlLinkGetData();
    #####:11474:    test_ret += test_xmlListAppend();
    #####:11475:    test_ret += test_xmlListClear();
    #####:11476:    test_ret += test_xmlListCopy();
    #####:11477:    test_ret += test_xmlListCreate();
    #####:11478:    test_ret += test_xmlListDup();
    #####:11479:    test_ret += test_xmlListEmpty();
    #####:11480:    test_ret += test_xmlListEnd();
    #####:11481:    test_ret += test_xmlListFront();
    #####:11482:    test_ret += test_xmlListInsert();
    #####:11483:    test_ret += test_xmlListMerge();
    #####:11484:    test_ret += test_xmlListPopBack();
    #####:11485:    test_ret += test_xmlListPopFront();
    #####:11486:    test_ret += test_xmlListPushBack();
    #####:11487:    test_ret += test_xmlListPushFront();
    #####:11488:    test_ret += test_xmlListRemoveAll();
    #####:11489:    test_ret += test_xmlListRemoveFirst();
    #####:11490:    test_ret += test_xmlListRemoveLast();
    #####:11491:    test_ret += test_xmlListReverse();
    #####:11492:    test_ret += test_xmlListReverseSearch();
    #####:11493:    test_ret += test_xmlListReverseWalk();
    #####:11494:    test_ret += test_xmlListSearch();
    #####:11495:    test_ret += test_xmlListSize();
    #####:11496:    test_ret += test_xmlListSort();
    #####:11497:    test_ret += test_xmlListWalk();
        -:11498:
    #####:11499:    if (test_ret != 0)
    #####:11500:	printf("Module list: %d errors\n", test_ret);
    #####:11501:    return(test_ret);
        -:11502:}
        -:11503:
        -:11504:static int
    #####:11505:test_xmlNanoFTPCheckResponse(void) {
    #####:11506:    int test_ret = 0;
        -:11507:
        -:11508:#if defined(LIBXML_FTP_ENABLED)
        -:11509:    int mem_base;
        -:11510:    int ret_val;
        -:11511:    void * ctx; /* an FTP context */
        -:11512:    int n_ctx;
        -:11513:
    #####:11514:    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoFTPCtxtPtr;n_ctx++) {
    #####:11515:        mem_base = xmlMemBlocks();
    #####:11516:        ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0);
        -:11517:
    #####:11518:        ret_val = xmlNanoFTPCheckResponse(ctx);
    #####:11519:        desret_int(ret_val);
    #####:11520:        call_tests++;
    #####:11521:        des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0);
    #####:11522:        xmlResetLastError();
    #####:11523:        if (mem_base != xmlMemBlocks()) {
    #####:11524:            printf("Leak of %d blocks found in xmlNanoFTPCheckResponse",
    #####:11525:	           xmlMemBlocks() - mem_base);
    #####:11526:	    test_ret++;
    #####:11527:            printf(" %d", n_ctx);
    #####:11528:            printf("\n");
        -:11529:        }
        -:11530:    }
    #####:11531:    function_tests++;
        -:11532:#endif
        -:11533:
    #####:11534:    return(test_ret);
        -:11535:}
        -:11536:
        -:11537:
        -:11538:static int
    #####:11539:test_xmlNanoFTPCleanup(void) {
    #####:11540:    int test_ret = 0;
        -:11541:
        -:11542:#if defined(LIBXML_FTP_ENABLED)
        -:11543:    int mem_base;
        -:11544:
    #####:11545:        mem_base = xmlMemBlocks();
        -:11546:
    #####:11547:        xmlNanoFTPCleanup();
    #####:11548:        call_tests++;
    #####:11549:        xmlResetLastError();
    #####:11550:        if (mem_base != xmlMemBlocks()) {
    #####:11551:            printf("Leak of %d blocks found in xmlNanoFTPCleanup",
    #####:11552:	           xmlMemBlocks() - mem_base);
    #####:11553:	    test_ret++;
    #####:11554:            printf("\n");
        -:11555:        }
    #####:11556:    function_tests++;
        -:11557:#endif
        -:11558:
    #####:11559:    return(test_ret);
        -:11560:}
        -:11561:
        -:11562:
        -:11563:static int
    #####:11564:test_xmlNanoFTPCloseConnection(void) {
    #####:11565:    int test_ret = 0;
        -:11566:
        -:11567:#if defined(LIBXML_FTP_ENABLED)
        -:11568:    int mem_base;
        -:11569:    int ret_val;
        -:11570:    void * ctx; /* an FTP context */
        -:11571:    int n_ctx;
        -:11572:
    #####:11573:    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoFTPCtxtPtr;n_ctx++) {
    #####:11574:        mem_base = xmlMemBlocks();
    #####:11575:        ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0);
        -:11576:
    #####:11577:        ret_val = xmlNanoFTPCloseConnection(ctx);
    #####:11578:        desret_int(ret_val);
    #####:11579:        call_tests++;
    #####:11580:        des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0);
    #####:11581:        xmlResetLastError();
    #####:11582:        if (mem_base != xmlMemBlocks()) {
    #####:11583:            printf("Leak of %d blocks found in xmlNanoFTPCloseConnection",
    #####:11584:	           xmlMemBlocks() - mem_base);
    #####:11585:	    test_ret++;
    #####:11586:            printf(" %d", n_ctx);
    #####:11587:            printf("\n");
        -:11588:        }
        -:11589:    }
    #####:11590:    function_tests++;
        -:11591:#endif
        -:11592:
    #####:11593:    return(test_ret);
        -:11594:}
        -:11595:
        -:11596:
        -:11597:static int
    #####:11598:test_xmlNanoFTPCwd(void) {
    #####:11599:    int test_ret = 0;
        -:11600:
        -:11601:#if defined(LIBXML_FTP_ENABLED)
        -:11602:    int mem_base;
        -:11603:    int ret_val;
        -:11604:    void * ctx; /* an FTP context */
        -:11605:    int n_ctx;
        -:11606:    char * directory; /* a directory on the server */
        -:11607:    int n_directory;
        -:11608:
    #####:11609:    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoFTPCtxtPtr;n_ctx++) {
    #####:11610:    for (n_directory = 0;n_directory < gen_nb_const_char_ptr;n_directory++) {
    #####:11611:        mem_base = xmlMemBlocks();
    #####:11612:        ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0);
    #####:11613:        directory = gen_const_char_ptr(n_directory, 1);
        -:11614:
    #####:11615:        ret_val = xmlNanoFTPCwd(ctx, (const char *)directory);
    #####:11616:        desret_int(ret_val);
    #####:11617:        call_tests++;
    #####:11618:        des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0);
    #####:11619:        des_const_char_ptr(n_directory, (const char *)directory, 1);
    #####:11620:        xmlResetLastError();
    #####:11621:        if (mem_base != xmlMemBlocks()) {
    #####:11622:            printf("Leak of %d blocks found in xmlNanoFTPCwd",
    #####:11623:	           xmlMemBlocks() - mem_base);
    #####:11624:	    test_ret++;
    #####:11625:            printf(" %d", n_ctx);
    #####:11626:            printf(" %d", n_directory);
    #####:11627:            printf("\n");
        -:11628:        }
        -:11629:    }
        -:11630:    }
    #####:11631:    function_tests++;
        -:11632:#endif
        -:11633:
    #####:11634:    return(test_ret);
        -:11635:}
        -:11636:
        -:11637:
        -:11638:static int
    #####:11639:test_xmlNanoFTPDele(void) {
    #####:11640:    int test_ret = 0;
        -:11641:
        -:11642:#if defined(LIBXML_FTP_ENABLED)
        -:11643:    int mem_base;
        -:11644:    int ret_val;
        -:11645:    void * ctx; /* an FTP context */
        -:11646:    int n_ctx;
        -:11647:    const char * file; /* a file or directory on the server */
        -:11648:    int n_file;
        -:11649:
    #####:11650:    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoFTPCtxtPtr;n_ctx++) {
    #####:11651:    for (n_file = 0;n_file < gen_nb_filepath;n_file++) {
    #####:11652:        mem_base = xmlMemBlocks();
    #####:11653:        ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0);
    #####:11654:        file = gen_filepath(n_file, 1);
        -:11655:
    #####:11656:        ret_val = xmlNanoFTPDele(ctx, file);
    #####:11657:        desret_int(ret_val);
    #####:11658:        call_tests++;
    #####:11659:        des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0);
    #####:11660:        des_filepath(n_file, file, 1);
    #####:11661:        xmlResetLastError();
    #####:11662:        if (mem_base != xmlMemBlocks()) {
    #####:11663:            printf("Leak of %d blocks found in xmlNanoFTPDele",
    #####:11664:	           xmlMemBlocks() - mem_base);
    #####:11665:	    test_ret++;
    #####:11666:            printf(" %d", n_ctx);
    #####:11667:            printf(" %d", n_file);
    #####:11668:            printf("\n");
        -:11669:        }
        -:11670:    }
        -:11671:    }
    #####:11672:    function_tests++;
        -:11673:#endif
        -:11674:
    #####:11675:    return(test_ret);
        -:11676:}
        -:11677:
        -:11678:
        -:11679:static int
    #####:11680:test_xmlNanoFTPGet(void) {
    #####:11681:    int test_ret = 0;
        -:11682:
        -:11683:
        -:11684:    /* missing type support */
    #####:11685:    return(test_ret);
        -:11686:}
        -:11687:
        -:11688:
        -:11689:static int
    #####:11690:test_xmlNanoFTPGetConnection(void) {
    #####:11691:    int test_ret = 0;
        -:11692:
        -:11693:
        -:11694:    /* missing type support */
    #####:11695:    return(test_ret);
        -:11696:}
        -:11697:
        -:11698:
        -:11699:static int
    #####:11700:test_xmlNanoFTPGetResponse(void) {
    #####:11701:    int test_ret = 0;
        -:11702:
        -:11703:#if defined(LIBXML_FTP_ENABLED)
        -:11704:    int mem_base;
        -:11705:    int ret_val;
        -:11706:    void * ctx; /* an FTP context */
        -:11707:    int n_ctx;
        -:11708:
    #####:11709:    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoFTPCtxtPtr;n_ctx++) {
    #####:11710:        mem_base = xmlMemBlocks();
    #####:11711:        ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0);
        -:11712:
    #####:11713:        ret_val = xmlNanoFTPGetResponse(ctx);
    #####:11714:        desret_int(ret_val);
    #####:11715:        call_tests++;
    #####:11716:        des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0);
    #####:11717:        xmlResetLastError();
    #####:11718:        if (mem_base != xmlMemBlocks()) {
    #####:11719:            printf("Leak of %d blocks found in xmlNanoFTPGetResponse",
    #####:11720:	           xmlMemBlocks() - mem_base);
    #####:11721:	    test_ret++;
    #####:11722:            printf(" %d", n_ctx);
    #####:11723:            printf("\n");
        -:11724:        }
        -:11725:    }
    #####:11726:    function_tests++;
        -:11727:#endif
        -:11728:
    #####:11729:    return(test_ret);
        -:11730:}
        -:11731:
        -:11732:
        -:11733:static int
    #####:11734:test_xmlNanoFTPGetSocket(void) {
    #####:11735:    int test_ret = 0;
        -:11736:
        -:11737:
        -:11738:    /* missing type support */
    #####:11739:    return(test_ret);
        -:11740:}
        -:11741:
        -:11742:
        -:11743:static int
    #####:11744:test_xmlNanoFTPInit(void) {
    #####:11745:    int test_ret = 0;
        -:11746:
        -:11747:#if defined(LIBXML_FTP_ENABLED)
        -:11748:    int mem_base;
        -:11749:
    #####:11750:        mem_base = xmlMemBlocks();
        -:11751:
    #####:11752:        xmlNanoFTPInit();
    #####:11753:        call_tests++;
    #####:11754:        xmlResetLastError();
    #####:11755:        if (mem_base != xmlMemBlocks()) {
    #####:11756:            printf("Leak of %d blocks found in xmlNanoFTPInit",
    #####:11757:	           xmlMemBlocks() - mem_base);
    #####:11758:	    test_ret++;
    #####:11759:            printf("\n");
        -:11760:        }
    #####:11761:    function_tests++;
        -:11762:#endif
        -:11763:
    #####:11764:    return(test_ret);
        -:11765:}
        -:11766:
        -:11767:
        -:11768:static int
    #####:11769:test_xmlNanoFTPList(void) {
    #####:11770:    int test_ret = 0;
        -:11771:
        -:11772:
        -:11773:    /* missing type support */
    #####:11774:    return(test_ret);
        -:11775:}
        -:11776:
        -:11777:
        -:11778:static int
    #####:11779:test_xmlNanoFTPNewCtxt(void) {
    #####:11780:    int test_ret = 0;
        -:11781:
        -:11782:#if defined(LIBXML_FTP_ENABLED)
        -:11783:    int mem_base;
        -:11784:    void * ret_val;
        -:11785:    const char * URL; /* The URL used to initialize the context */
        -:11786:    int n_URL;
        -:11787:
    #####:11788:    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    #####:11789:        mem_base = xmlMemBlocks();
    #####:11790:        URL = gen_filepath(n_URL, 0);
        -:11791:
    #####:11792:        ret_val = xmlNanoFTPNewCtxt(URL);
    #####:11793:        desret_xmlNanoFTPCtxtPtr(ret_val);
    #####:11794:        call_tests++;
    #####:11795:        des_filepath(n_URL, URL, 0);
    #####:11796:        xmlResetLastError();
    #####:11797:        if (mem_base != xmlMemBlocks()) {
    #####:11798:            printf("Leak of %d blocks found in xmlNanoFTPNewCtxt",
    #####:11799:	           xmlMemBlocks() - mem_base);
    #####:11800:	    test_ret++;
    #####:11801:            printf(" %d", n_URL);
    #####:11802:            printf("\n");
        -:11803:        }
        -:11804:    }
    #####:11805:    function_tests++;
        -:11806:#endif
        -:11807:
    #####:11808:    return(test_ret);
        -:11809:}
        -:11810:
        -:11811:
        -:11812:static int
    #####:11813:test_xmlNanoFTPOpen(void) {
    #####:11814:    int test_ret = 0;
        -:11815:
        -:11816:#if defined(LIBXML_FTP_ENABLED)
        -:11817:    int mem_base;
        -:11818:    void * ret_val;
        -:11819:    const char * URL; /* the URL to the resource */
        -:11820:    int n_URL;
        -:11821:
    #####:11822:    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    #####:11823:        mem_base = xmlMemBlocks();
    #####:11824:        URL = gen_filepath(n_URL, 0);
        -:11825:
    #####:11826:        ret_val = xmlNanoFTPOpen(URL);
    #####:11827:        desret_xmlNanoFTPCtxtPtr(ret_val);
    #####:11828:        call_tests++;
    #####:11829:        des_filepath(n_URL, URL, 0);
    #####:11830:        xmlResetLastError();
    #####:11831:        if (mem_base != xmlMemBlocks()) {
    #####:11832:            printf("Leak of %d blocks found in xmlNanoFTPOpen",
    #####:11833:	           xmlMemBlocks() - mem_base);
    #####:11834:	    test_ret++;
    #####:11835:            printf(" %d", n_URL);
    #####:11836:            printf("\n");
        -:11837:        }
        -:11838:    }
    #####:11839:    function_tests++;
        -:11840:#endif
        -:11841:
    #####:11842:    return(test_ret);
        -:11843:}
        -:11844:
        -:11845:
        -:11846:static int
    #####:11847:test_xmlNanoFTPProxy(void) {
    #####:11848:    int test_ret = 0;
        -:11849:
        -:11850:#if defined(LIBXML_FTP_ENABLED)
        -:11851:    char * host; /* the proxy host name */
        -:11852:    int n_host;
        -:11853:    int port; /* the proxy port */
        -:11854:    int n_port;
        -:11855:    char * user; /* the proxy user name */
        -:11856:    int n_user;
        -:11857:    char * passwd; /* the proxy password */
        -:11858:    int n_passwd;
        -:11859:    int type; /* the type of proxy 1 for using SITE, 2 for USER a@b */
        -:11860:    int n_type;
        -:11861:
    #####:11862:    for (n_host = 0;n_host < gen_nb_const_char_ptr;n_host++) {
    #####:11863:    for (n_port = 0;n_port < gen_nb_int;n_port++) {
    #####:11864:    for (n_user = 0;n_user < gen_nb_const_char_ptr;n_user++) {
    #####:11865:    for (n_passwd = 0;n_passwd < gen_nb_const_char_ptr;n_passwd++) {
    #####:11866:    for (n_type = 0;n_type < gen_nb_int;n_type++) {
    #####:11867:        host = gen_const_char_ptr(n_host, 0);
    #####:11868:        port = gen_int(n_port, 1);
    #####:11869:        user = gen_const_char_ptr(n_user, 2);
    #####:11870:        passwd = gen_const_char_ptr(n_passwd, 3);
    #####:11871:        type = gen_int(n_type, 4);
        -:11872:
    #####:11873:        xmlNanoFTPProxy((const char *)host, port, (const char *)user, (const char *)passwd, type);
    #####:11874:        call_tests++;
    #####:11875:        des_const_char_ptr(n_host, (const char *)host, 0);
    #####:11876:        des_int(n_port, port, 1);
    #####:11877:        des_const_char_ptr(n_user, (const char *)user, 2);
    #####:11878:        des_const_char_ptr(n_passwd, (const char *)passwd, 3);
    #####:11879:        des_int(n_type, type, 4);
    #####:11880:        xmlResetLastError();
        -:11881:    }
        -:11882:    }
        -:11883:    }
        -:11884:    }
        -:11885:    }
    #####:11886:    function_tests++;
        -:11887:#endif
        -:11888:
    #####:11889:    return(test_ret);
        -:11890:}
        -:11891:
        -:11892:
        -:11893:static int
    #####:11894:test_xmlNanoFTPQuit(void) {
    #####:11895:    int test_ret = 0;
        -:11896:
        -:11897:#if defined(LIBXML_FTP_ENABLED)
        -:11898:    int mem_base;
        -:11899:    int ret_val;
        -:11900:    void * ctx; /* an FTP context */
        -:11901:    int n_ctx;
        -:11902:
    #####:11903:    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoFTPCtxtPtr;n_ctx++) {
    #####:11904:        mem_base = xmlMemBlocks();
    #####:11905:        ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0);
        -:11906:
    #####:11907:        ret_val = xmlNanoFTPQuit(ctx);
    #####:11908:        desret_int(ret_val);
    #####:11909:        call_tests++;
    #####:11910:        des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0);
    #####:11911:        xmlResetLastError();
    #####:11912:        if (mem_base != xmlMemBlocks()) {
    #####:11913:            printf("Leak of %d blocks found in xmlNanoFTPQuit",
    #####:11914:	           xmlMemBlocks() - mem_base);
    #####:11915:	    test_ret++;
    #####:11916:            printf(" %d", n_ctx);
    #####:11917:            printf("\n");
        -:11918:        }
        -:11919:    }
    #####:11920:    function_tests++;
        -:11921:#endif
        -:11922:
    #####:11923:    return(test_ret);
        -:11924:}
        -:11925:
        -:11926:
        -:11927:static int
    #####:11928:test_xmlNanoFTPRead(void) {
    #####:11929:    int test_ret = 0;
        -:11930:
        -:11931:#if defined(LIBXML_FTP_ENABLED)
        -:11932:    int mem_base;
        -:11933:    int ret_val;
        -:11934:    void * ctx; /* the FTP context */
        -:11935:    int n_ctx;
        -:11936:    void * dest; /* a buffer */
        -:11937:    int n_dest;
        -:11938:    int len; /* the buffer length */
        -:11939:    int n_len;
        -:11940:
    #####:11941:    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoFTPCtxtPtr;n_ctx++) {
    #####:11942:    for (n_dest = 0;n_dest < gen_nb_void_ptr;n_dest++) {
    #####:11943:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:11944:        mem_base = xmlMemBlocks();
    #####:11945:        ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0);
    #####:11946:        dest = gen_void_ptr(n_dest, 1);
    #####:11947:        len = gen_int(n_len, 2);
        -:11948:
    #####:11949:        ret_val = xmlNanoFTPRead(ctx, dest, len);
    #####:11950:        desret_int(ret_val);
    #####:11951:        call_tests++;
    #####:11952:        des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0);
    #####:11953:        des_void_ptr(n_dest, dest, 1);
    #####:11954:        des_int(n_len, len, 2);
    #####:11955:        xmlResetLastError();
    #####:11956:        if (mem_base != xmlMemBlocks()) {
    #####:11957:            printf("Leak of %d blocks found in xmlNanoFTPRead",
    #####:11958:	           xmlMemBlocks() - mem_base);
    #####:11959:	    test_ret++;
    #####:11960:            printf(" %d", n_ctx);
    #####:11961:            printf(" %d", n_dest);
    #####:11962:            printf(" %d", n_len);
    #####:11963:            printf("\n");
        -:11964:        }
        -:11965:    }
        -:11966:    }
        -:11967:    }
    #####:11968:    function_tests++;
        -:11969:#endif
        -:11970:
    #####:11971:    return(test_ret);
        -:11972:}
        -:11973:
        -:11974:
        -:11975:static int
    #####:11976:test_xmlNanoFTPScanProxy(void) {
    #####:11977:    int test_ret = 0;
        -:11978:
        -:11979:#if defined(LIBXML_FTP_ENABLED)
        -:11980:    const char * URL; /* The proxy URL used to initialize the proxy context */
        -:11981:    int n_URL;
        -:11982:
    #####:11983:    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    #####:11984:        URL = gen_filepath(n_URL, 0);
        -:11985:
    #####:11986:        xmlNanoFTPScanProxy(URL);
    #####:11987:        call_tests++;
    #####:11988:        des_filepath(n_URL, URL, 0);
    #####:11989:        xmlResetLastError();
        -:11990:    }
    #####:11991:    function_tests++;
        -:11992:#endif
        -:11993:
    #####:11994:    return(test_ret);
        -:11995:}
        -:11996:
        -:11997:
        -:11998:static int
    #####:11999:test_xmlNanoFTPUpdateURL(void) {
    #####:12000:    int test_ret = 0;
        -:12001:
        -:12002:#if defined(LIBXML_FTP_ENABLED)
        -:12003:    int mem_base;
        -:12004:    int ret_val;
        -:12005:    void * ctx; /* an FTP context */
        -:12006:    int n_ctx;
        -:12007:    const char * URL; /* The URL used to update the context */
        -:12008:    int n_URL;
        -:12009:
    #####:12010:    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoFTPCtxtPtr;n_ctx++) {
    #####:12011:    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    #####:12012:        mem_base = xmlMemBlocks();
    #####:12013:        ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0);
    #####:12014:        URL = gen_filepath(n_URL, 1);
        -:12015:
    #####:12016:        ret_val = xmlNanoFTPUpdateURL(ctx, URL);
    #####:12017:        desret_int(ret_val);
    #####:12018:        call_tests++;
    #####:12019:        des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0);
    #####:12020:        des_filepath(n_URL, URL, 1);
    #####:12021:        xmlResetLastError();
    #####:12022:        if (mem_base != xmlMemBlocks()) {
    #####:12023:            printf("Leak of %d blocks found in xmlNanoFTPUpdateURL",
    #####:12024:	           xmlMemBlocks() - mem_base);
    #####:12025:	    test_ret++;
    #####:12026:            printf(" %d", n_ctx);
    #####:12027:            printf(" %d", n_URL);
    #####:12028:            printf("\n");
        -:12029:        }
        -:12030:    }
        -:12031:    }
    #####:12032:    function_tests++;
        -:12033:#endif
        -:12034:
    #####:12035:    return(test_ret);
        -:12036:}
        -:12037:
        -:12038:static int
    #####:12039:test_nanoftp(void) {
    #####:12040:    int test_ret = 0;
        -:12041:
    #####:12042:    if (quiet == 0) printf("Testing nanoftp : 14 of 22 functions ...\n");
    #####:12043:    test_ret += test_xmlNanoFTPCheckResponse();
    #####:12044:    test_ret += test_xmlNanoFTPCleanup();
    #####:12045:    test_ret += test_xmlNanoFTPCloseConnection();
    #####:12046:    test_ret += test_xmlNanoFTPCwd();
    #####:12047:    test_ret += test_xmlNanoFTPDele();
    #####:12048:    test_ret += test_xmlNanoFTPGet();
    #####:12049:    test_ret += test_xmlNanoFTPGetConnection();
    #####:12050:    test_ret += test_xmlNanoFTPGetResponse();
    #####:12051:    test_ret += test_xmlNanoFTPGetSocket();
    #####:12052:    test_ret += test_xmlNanoFTPInit();
    #####:12053:    test_ret += test_xmlNanoFTPList();
    #####:12054:    test_ret += test_xmlNanoFTPNewCtxt();
    #####:12055:    test_ret += test_xmlNanoFTPOpen();
    #####:12056:    test_ret += test_xmlNanoFTPProxy();
    #####:12057:    test_ret += test_xmlNanoFTPQuit();
    #####:12058:    test_ret += test_xmlNanoFTPRead();
    #####:12059:    test_ret += test_xmlNanoFTPScanProxy();
    #####:12060:    test_ret += test_xmlNanoFTPUpdateURL();
        -:12061:
    #####:12062:    if (test_ret != 0)
    #####:12063:	printf("Module nanoftp: %d errors\n", test_ret);
    #####:12064:    return(test_ret);
        -:12065:}
        -:12066:
        -:12067:static int
    #####:12068:test_xmlNanoHTTPAuthHeader(void) {
    #####:12069:    int test_ret = 0;
        -:12070:
        -:12071:#if defined(LIBXML_HTTP_ENABLED)
        -:12072:    int mem_base;
        -:12073:    const char * ret_val;
        -:12074:    void * ctx; /* the HTTP context */
        -:12075:    int n_ctx;
        -:12076:
    #####:12077:    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoHTTPCtxtPtr;n_ctx++) {
    #####:12078:        mem_base = xmlMemBlocks();
    #####:12079:        ctx = gen_xmlNanoHTTPCtxtPtr(n_ctx, 0);
        -:12080:
    #####:12081:        ret_val = xmlNanoHTTPAuthHeader(ctx);
    #####:12082:        desret_const_char_ptr(ret_val);
    #####:12083:        call_tests++;
    #####:12084:        des_xmlNanoHTTPCtxtPtr(n_ctx, ctx, 0);
    #####:12085:        xmlResetLastError();
    #####:12086:        if (mem_base != xmlMemBlocks()) {
    #####:12087:            printf("Leak of %d blocks found in xmlNanoHTTPAuthHeader",
    #####:12088:	           xmlMemBlocks() - mem_base);
    #####:12089:	    test_ret++;
    #####:12090:            printf(" %d", n_ctx);
    #####:12091:            printf("\n");
        -:12092:        }
        -:12093:    }
    #####:12094:    function_tests++;
        -:12095:#endif
        -:12096:
    #####:12097:    return(test_ret);
        -:12098:}
        -:12099:
        -:12100:
        -:12101:static int
    #####:12102:test_xmlNanoHTTPCleanup(void) {
    #####:12103:    int test_ret = 0;
        -:12104:
        -:12105:#if defined(LIBXML_HTTP_ENABLED)
        -:12106:    int mem_base;
        -:12107:
    #####:12108:        mem_base = xmlMemBlocks();
        -:12109:
    #####:12110:        xmlNanoHTTPCleanup();
    #####:12111:        call_tests++;
    #####:12112:        xmlResetLastError();
    #####:12113:        if (mem_base != xmlMemBlocks()) {
    #####:12114:            printf("Leak of %d blocks found in xmlNanoHTTPCleanup",
    #####:12115:	           xmlMemBlocks() - mem_base);
    #####:12116:	    test_ret++;
    #####:12117:            printf("\n");
        -:12118:        }
    #####:12119:    function_tests++;
        -:12120:#endif
        -:12121:
    #####:12122:    return(test_ret);
        -:12123:}
        -:12124:
        -:12125:
        -:12126:static int
    #####:12127:test_xmlNanoHTTPContentLength(void) {
    #####:12128:    int test_ret = 0;
        -:12129:
        -:12130:#if defined(LIBXML_HTTP_ENABLED)
        -:12131:    int mem_base;
        -:12132:    int ret_val;
        -:12133:    void * ctx; /* the HTTP context */
        -:12134:    int n_ctx;
        -:12135:
    #####:12136:    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoHTTPCtxtPtr;n_ctx++) {
    #####:12137:        mem_base = xmlMemBlocks();
    #####:12138:        ctx = gen_xmlNanoHTTPCtxtPtr(n_ctx, 0);
        -:12139:
    #####:12140:        ret_val = xmlNanoHTTPContentLength(ctx);
    #####:12141:        desret_int(ret_val);
    #####:12142:        call_tests++;
    #####:12143:        des_xmlNanoHTTPCtxtPtr(n_ctx, ctx, 0);
    #####:12144:        xmlResetLastError();
    #####:12145:        if (mem_base != xmlMemBlocks()) {
    #####:12146:            printf("Leak of %d blocks found in xmlNanoHTTPContentLength",
    #####:12147:	           xmlMemBlocks() - mem_base);
    #####:12148:	    test_ret++;
    #####:12149:            printf(" %d", n_ctx);
    #####:12150:            printf("\n");
        -:12151:        }
        -:12152:    }
    #####:12153:    function_tests++;
        -:12154:#endif
        -:12155:
    #####:12156:    return(test_ret);
        -:12157:}
        -:12158:
        -:12159:
        -:12160:static int
    #####:12161:test_xmlNanoHTTPEncoding(void) {
    #####:12162:    int test_ret = 0;
        -:12163:
        -:12164:#if defined(LIBXML_HTTP_ENABLED)
        -:12165:    int mem_base;
        -:12166:    const char * ret_val;
        -:12167:    void * ctx; /* the HTTP context */
        -:12168:    int n_ctx;
        -:12169:
    #####:12170:    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoHTTPCtxtPtr;n_ctx++) {
    #####:12171:        mem_base = xmlMemBlocks();
    #####:12172:        ctx = gen_xmlNanoHTTPCtxtPtr(n_ctx, 0);
        -:12173:
    #####:12174:        ret_val = xmlNanoHTTPEncoding(ctx);
    #####:12175:        desret_const_char_ptr(ret_val);
    #####:12176:        call_tests++;
    #####:12177:        des_xmlNanoHTTPCtxtPtr(n_ctx, ctx, 0);
    #####:12178:        xmlResetLastError();
    #####:12179:        if (mem_base != xmlMemBlocks()) {
    #####:12180:            printf("Leak of %d blocks found in xmlNanoHTTPEncoding",
    #####:12181:	           xmlMemBlocks() - mem_base);
    #####:12182:	    test_ret++;
    #####:12183:            printf(" %d", n_ctx);
    #####:12184:            printf("\n");
        -:12185:        }
        -:12186:    }
    #####:12187:    function_tests++;
        -:12188:#endif
        -:12189:
    #####:12190:    return(test_ret);
        -:12191:}
        -:12192:
        -:12193:
        -:12194:#define gen_nb_char_ptr_ptr 1
    #####:12195:static char ** gen_char_ptr_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:12196:    return(NULL);
        -:12197:}
    #####:12198:static void des_char_ptr_ptr(int no ATTRIBUTE_UNUSED, char ** val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:12199:}
        -:12200:
        -:12201:static int
    #####:12202:test_xmlNanoHTTPFetch(void) {
    #####:12203:    int test_ret = 0;
        -:12204:
        -:12205:#if defined(LIBXML_HTTP_ENABLED)
        -:12206:    int mem_base;
        -:12207:    int ret_val;
        -:12208:    const char * URL; /* The URL to load */
        -:12209:    int n_URL;
        -:12210:    const char * filename; /* the filename where the content should be saved */
        -:12211:    int n_filename;
        -:12212:    char ** contentType; /* if available the Content-Type information will be returned at that location */
        -:12213:    int n_contentType;
        -:12214:
    #####:12215:    for (n_URL = 0;n_URL < gen_nb_fileoutput;n_URL++) {
    #####:12216:    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    #####:12217:    for (n_contentType = 0;n_contentType < gen_nb_char_ptr_ptr;n_contentType++) {
    #####:12218:        mem_base = xmlMemBlocks();
    #####:12219:        URL = gen_fileoutput(n_URL, 0);
    #####:12220:        filename = gen_fileoutput(n_filename, 1);
    #####:12221:        contentType = gen_char_ptr_ptr(n_contentType, 2);
        -:12222:
    #####:12223:        ret_val = xmlNanoHTTPFetch(URL, filename, contentType);
    #####:12224:        desret_int(ret_val);
    #####:12225:        call_tests++;
    #####:12226:        des_fileoutput(n_URL, URL, 0);
    #####:12227:        des_fileoutput(n_filename, filename, 1);
    #####:12228:        des_char_ptr_ptr(n_contentType, contentType, 2);
    #####:12229:        xmlResetLastError();
    #####:12230:        if (mem_base != xmlMemBlocks()) {
    #####:12231:            printf("Leak of %d blocks found in xmlNanoHTTPFetch",
    #####:12232:	           xmlMemBlocks() - mem_base);
    #####:12233:	    test_ret++;
    #####:12234:            printf(" %d", n_URL);
    #####:12235:            printf(" %d", n_filename);
    #####:12236:            printf(" %d", n_contentType);
    #####:12237:            printf("\n");
        -:12238:        }
        -:12239:    }
        -:12240:    }
        -:12241:    }
    #####:12242:    function_tests++;
        -:12243:#endif
        -:12244:
    #####:12245:    return(test_ret);
        -:12246:}
        -:12247:
        -:12248:
        -:12249:static int
    #####:12250:test_xmlNanoHTTPInit(void) {
    #####:12251:    int test_ret = 0;
        -:12252:
        -:12253:#if defined(LIBXML_HTTP_ENABLED)
        -:12254:    int mem_base;
        -:12255:
    #####:12256:        mem_base = xmlMemBlocks();
        -:12257:
    #####:12258:        xmlNanoHTTPInit();
    #####:12259:        call_tests++;
    #####:12260:        xmlResetLastError();
    #####:12261:        if (mem_base != xmlMemBlocks()) {
    #####:12262:            printf("Leak of %d blocks found in xmlNanoHTTPInit",
    #####:12263:	           xmlMemBlocks() - mem_base);
    #####:12264:	    test_ret++;
    #####:12265:            printf("\n");
        -:12266:        }
    #####:12267:    function_tests++;
        -:12268:#endif
        -:12269:
    #####:12270:    return(test_ret);
        -:12271:}
        -:12272:
        -:12273:
        -:12274:static int
    #####:12275:test_xmlNanoHTTPMimeType(void) {
    #####:12276:    int test_ret = 0;
        -:12277:
        -:12278:#if defined(LIBXML_HTTP_ENABLED)
        -:12279:    int mem_base;
        -:12280:    const char * ret_val;
        -:12281:    void * ctx; /* the HTTP context */
        -:12282:    int n_ctx;
        -:12283:
    #####:12284:    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoHTTPCtxtPtr;n_ctx++) {
    #####:12285:        mem_base = xmlMemBlocks();
    #####:12286:        ctx = gen_xmlNanoHTTPCtxtPtr(n_ctx, 0);
        -:12287:
    #####:12288:        ret_val = xmlNanoHTTPMimeType(ctx);
    #####:12289:        desret_const_char_ptr(ret_val);
    #####:12290:        call_tests++;
    #####:12291:        des_xmlNanoHTTPCtxtPtr(n_ctx, ctx, 0);
    #####:12292:        xmlResetLastError();
    #####:12293:        if (mem_base != xmlMemBlocks()) {
    #####:12294:            printf("Leak of %d blocks found in xmlNanoHTTPMimeType",
    #####:12295:	           xmlMemBlocks() - mem_base);
    #####:12296:	    test_ret++;
    #####:12297:            printf(" %d", n_ctx);
    #####:12298:            printf("\n");
        -:12299:        }
        -:12300:    }
    #####:12301:    function_tests++;
        -:12302:#endif
        -:12303:
    #####:12304:    return(test_ret);
        -:12305:}
        -:12306:
        -:12307:
        -:12308:static int
    #####:12309:test_xmlNanoHTTPOpen(void) {
    #####:12310:    int test_ret = 0;
        -:12311:
        -:12312:#if defined(LIBXML_HTTP_ENABLED)
        -:12313:    int mem_base;
        -:12314:    void * ret_val;
        -:12315:    const char * URL; /* The URL to load */
        -:12316:    int n_URL;
        -:12317:    char ** contentType; /* if available the Content-Type information will be returned at that location */
        -:12318:    int n_contentType;
        -:12319:
    #####:12320:    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    #####:12321:    for (n_contentType = 0;n_contentType < gen_nb_char_ptr_ptr;n_contentType++) {
    #####:12322:        mem_base = xmlMemBlocks();
    #####:12323:        URL = gen_filepath(n_URL, 0);
    #####:12324:        contentType = gen_char_ptr_ptr(n_contentType, 1);
        -:12325:
    #####:12326:        ret_val = xmlNanoHTTPOpen(URL, contentType);
    #####:12327:        desret_xmlNanoHTTPCtxtPtr(ret_val);
    #####:12328:        call_tests++;
    #####:12329:        des_filepath(n_URL, URL, 0);
    #####:12330:        des_char_ptr_ptr(n_contentType, contentType, 1);
    #####:12331:        xmlResetLastError();
    #####:12332:        if (mem_base != xmlMemBlocks()) {
    #####:12333:            printf("Leak of %d blocks found in xmlNanoHTTPOpen",
    #####:12334:	           xmlMemBlocks() - mem_base);
    #####:12335:	    test_ret++;
    #####:12336:            printf(" %d", n_URL);
    #####:12337:            printf(" %d", n_contentType);
    #####:12338:            printf("\n");
        -:12339:        }
        -:12340:    }
        -:12341:    }
    #####:12342:    function_tests++;
        -:12343:#endif
        -:12344:
    #####:12345:    return(test_ret);
        -:12346:}
        -:12347:
        -:12348:
        -:12349:static int
    #####:12350:test_xmlNanoHTTPOpenRedir(void) {
    #####:12351:    int test_ret = 0;
        -:12352:
        -:12353:#if defined(LIBXML_HTTP_ENABLED)
        -:12354:    int mem_base;
        -:12355:    void * ret_val;
        -:12356:    const char * URL; /* The URL to load */
        -:12357:    int n_URL;
        -:12358:    char ** contentType; /* if available the Content-Type information will be returned at that location */
        -:12359:    int n_contentType;
        -:12360:    char ** redir; /* if available the redirected URL will be returned */
        -:12361:    int n_redir;
        -:12362:
    #####:12363:    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    #####:12364:    for (n_contentType = 0;n_contentType < gen_nb_char_ptr_ptr;n_contentType++) {
    #####:12365:    for (n_redir = 0;n_redir < gen_nb_char_ptr_ptr;n_redir++) {
    #####:12366:        mem_base = xmlMemBlocks();
    #####:12367:        URL = gen_filepath(n_URL, 0);
    #####:12368:        contentType = gen_char_ptr_ptr(n_contentType, 1);
    #####:12369:        redir = gen_char_ptr_ptr(n_redir, 2);
        -:12370:
    #####:12371:        ret_val = xmlNanoHTTPOpenRedir(URL, contentType, redir);
    #####:12372:        desret_xmlNanoHTTPCtxtPtr(ret_val);
    #####:12373:        call_tests++;
    #####:12374:        des_filepath(n_URL, URL, 0);
    #####:12375:        des_char_ptr_ptr(n_contentType, contentType, 1);
    #####:12376:        des_char_ptr_ptr(n_redir, redir, 2);
    #####:12377:        xmlResetLastError();
    #####:12378:        if (mem_base != xmlMemBlocks()) {
    #####:12379:            printf("Leak of %d blocks found in xmlNanoHTTPOpenRedir",
    #####:12380:	           xmlMemBlocks() - mem_base);
    #####:12381:	    test_ret++;
    #####:12382:            printf(" %d", n_URL);
    #####:12383:            printf(" %d", n_contentType);
    #####:12384:            printf(" %d", n_redir);
    #####:12385:            printf("\n");
        -:12386:        }
        -:12387:    }
        -:12388:    }
        -:12389:    }
    #####:12390:    function_tests++;
        -:12391:#endif
        -:12392:
    #####:12393:    return(test_ret);
        -:12394:}
        -:12395:
        -:12396:
        -:12397:static int
    #####:12398:test_xmlNanoHTTPRead(void) {
    #####:12399:    int test_ret = 0;
        -:12400:
        -:12401:#if defined(LIBXML_HTTP_ENABLED)
        -:12402:    int mem_base;
        -:12403:    int ret_val;
        -:12404:    void * ctx; /* the HTTP context */
        -:12405:    int n_ctx;
        -:12406:    void * dest; /* a buffer */
        -:12407:    int n_dest;
        -:12408:    int len; /* the buffer length */
        -:12409:    int n_len;
        -:12410:
    #####:12411:    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoHTTPCtxtPtr;n_ctx++) {
    #####:12412:    for (n_dest = 0;n_dest < gen_nb_void_ptr;n_dest++) {
    #####:12413:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:12414:        mem_base = xmlMemBlocks();
    #####:12415:        ctx = gen_xmlNanoHTTPCtxtPtr(n_ctx, 0);
    #####:12416:        dest = gen_void_ptr(n_dest, 1);
    #####:12417:        len = gen_int(n_len, 2);
        -:12418:
    #####:12419:        ret_val = xmlNanoHTTPRead(ctx, dest, len);
    #####:12420:        desret_int(ret_val);
    #####:12421:        call_tests++;
    #####:12422:        des_xmlNanoHTTPCtxtPtr(n_ctx, ctx, 0);
    #####:12423:        des_void_ptr(n_dest, dest, 1);
    #####:12424:        des_int(n_len, len, 2);
    #####:12425:        xmlResetLastError();
    #####:12426:        if (mem_base != xmlMemBlocks()) {
    #####:12427:            printf("Leak of %d blocks found in xmlNanoHTTPRead",
    #####:12428:	           xmlMemBlocks() - mem_base);
    #####:12429:	    test_ret++;
    #####:12430:            printf(" %d", n_ctx);
    #####:12431:            printf(" %d", n_dest);
    #####:12432:            printf(" %d", n_len);
    #####:12433:            printf("\n");
        -:12434:        }
        -:12435:    }
        -:12436:    }
        -:12437:    }
    #####:12438:    function_tests++;
        -:12439:#endif
        -:12440:
    #####:12441:    return(test_ret);
        -:12442:}
        -:12443:
        -:12444:
        -:12445:static int
    #####:12446:test_xmlNanoHTTPRedir(void) {
    #####:12447:    int test_ret = 0;
        -:12448:
        -:12449:
        -:12450:    /* missing type support */
    #####:12451:    return(test_ret);
        -:12452:}
        -:12453:
        -:12454:
        -:12455:static int
    #####:12456:test_xmlNanoHTTPReturnCode(void) {
    #####:12457:    int test_ret = 0;
        -:12458:
        -:12459:#if defined(LIBXML_HTTP_ENABLED)
        -:12460:    int mem_base;
        -:12461:    int ret_val;
        -:12462:    void * ctx; /* the HTTP context */
        -:12463:    int n_ctx;
        -:12464:
    #####:12465:    for (n_ctx = 0;n_ctx < gen_nb_xmlNanoHTTPCtxtPtr;n_ctx++) {
    #####:12466:        mem_base = xmlMemBlocks();
    #####:12467:        ctx = gen_xmlNanoHTTPCtxtPtr(n_ctx, 0);
        -:12468:
    #####:12469:        ret_val = xmlNanoHTTPReturnCode(ctx);
    #####:12470:        desret_int(ret_val);
    #####:12471:        call_tests++;
    #####:12472:        des_xmlNanoHTTPCtxtPtr(n_ctx, ctx, 0);
    #####:12473:        xmlResetLastError();
    #####:12474:        if (mem_base != xmlMemBlocks()) {
    #####:12475:            printf("Leak of %d blocks found in xmlNanoHTTPReturnCode",
    #####:12476:	           xmlMemBlocks() - mem_base);
    #####:12477:	    test_ret++;
    #####:12478:            printf(" %d", n_ctx);
    #####:12479:            printf("\n");
        -:12480:        }
        -:12481:    }
    #####:12482:    function_tests++;
        -:12483:#endif
        -:12484:
    #####:12485:    return(test_ret);
        -:12486:}
        -:12487:
        -:12488:
        -:12489:static int
    #####:12490:test_xmlNanoHTTPSave(void) {
    #####:12491:    int test_ret = 0;
        -:12492:
        -:12493:#if defined(LIBXML_HTTP_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
        -:12494:    int mem_base;
        -:12495:    int ret_val;
        -:12496:    void * ctxt; /* the HTTP context */
        -:12497:    int n_ctxt;
        -:12498:    const char * filename; /* the filename where the content should be saved */
        -:12499:    int n_filename;
        -:12500:
    #####:12501:    for (n_ctxt = 0;n_ctxt < gen_nb_void_ptr;n_ctxt++) {
    #####:12502:    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    #####:12503:        mem_base = xmlMemBlocks();
    #####:12504:        ctxt = gen_void_ptr(n_ctxt, 0);
    #####:12505:        filename = gen_fileoutput(n_filename, 1);
        -:12506:
    #####:12507:        ret_val = xmlNanoHTTPSave(ctxt, filename);
    #####:12508:        desret_int(ret_val);
    #####:12509:        call_tests++;
    #####:12510:        des_void_ptr(n_ctxt, ctxt, 0);
    #####:12511:        des_fileoutput(n_filename, filename, 1);
    #####:12512:        xmlResetLastError();
    #####:12513:        if (mem_base != xmlMemBlocks()) {
    #####:12514:            printf("Leak of %d blocks found in xmlNanoHTTPSave",
    #####:12515:	           xmlMemBlocks() - mem_base);
    #####:12516:	    test_ret++;
    #####:12517:            printf(" %d", n_ctxt);
    #####:12518:            printf(" %d", n_filename);
    #####:12519:            printf("\n");
        -:12520:        }
        -:12521:    }
        -:12522:    }
    #####:12523:    function_tests++;
        -:12524:#endif
        -:12525:
    #####:12526:    return(test_ret);
        -:12527:}
        -:12528:
        -:12529:
        -:12530:static int
    #####:12531:test_xmlNanoHTTPScanProxy(void) {
    #####:12532:    int test_ret = 0;
        -:12533:
        -:12534:#if defined(LIBXML_HTTP_ENABLED)
        -:12535:    const char * URL; /* The proxy URL used to initialize the proxy context */
        -:12536:    int n_URL;
        -:12537:
    #####:12538:    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    #####:12539:        URL = gen_filepath(n_URL, 0);
        -:12540:
    #####:12541:        xmlNanoHTTPScanProxy(URL);
    #####:12542:        call_tests++;
    #####:12543:        des_filepath(n_URL, URL, 0);
    #####:12544:        xmlResetLastError();
        -:12545:    }
    #####:12546:    function_tests++;
        -:12547:#endif
        -:12548:
    #####:12549:    return(test_ret);
        -:12550:}
        -:12551:
        -:12552:static int
    #####:12553:test_nanohttp(void) {
    #####:12554:    int test_ret = 0;
        -:12555:
    #####:12556:    if (quiet == 0) printf("Testing nanohttp : 13 of 17 functions ...\n");
    #####:12557:    test_ret += test_xmlNanoHTTPAuthHeader();
    #####:12558:    test_ret += test_xmlNanoHTTPCleanup();
    #####:12559:    test_ret += test_xmlNanoHTTPContentLength();
    #####:12560:    test_ret += test_xmlNanoHTTPEncoding();
    #####:12561:    test_ret += test_xmlNanoHTTPFetch();
    #####:12562:    test_ret += test_xmlNanoHTTPInit();
    #####:12563:    test_ret += test_xmlNanoHTTPMimeType();
    #####:12564:    test_ret += test_xmlNanoHTTPOpen();
    #####:12565:    test_ret += test_xmlNanoHTTPOpenRedir();
    #####:12566:    test_ret += test_xmlNanoHTTPRead();
    #####:12567:    test_ret += test_xmlNanoHTTPRedir();
    #####:12568:    test_ret += test_xmlNanoHTTPReturnCode();
    #####:12569:    test_ret += test_xmlNanoHTTPSave();
    #####:12570:    test_ret += test_xmlNanoHTTPScanProxy();
        -:12571:
    #####:12572:    if (test_ret != 0)
    #####:12573:	printf("Module nanohttp: %d errors\n", test_ret);
    #####:12574:    return(test_ret);
        -:12575:}
        -:12576:
        -:12577:static int
    #####:12578:test_xmlByteConsumed(void) {
    #####:12579:    int test_ret = 0;
        -:12580:
        -:12581:    int mem_base;
        -:12582:    long ret_val;
        -:12583:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:12584:    int n_ctxt;
        -:12585:
    #####:12586:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:12587:        mem_base = xmlMemBlocks();
    #####:12588:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        -:12589:
    #####:12590:        ret_val = xmlByteConsumed(ctxt);
    #####:12591:        desret_long(ret_val);
    #####:12592:        call_tests++;
    #####:12593:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:12594:        xmlResetLastError();
    #####:12595:        if (mem_base != xmlMemBlocks()) {
    #####:12596:            printf("Leak of %d blocks found in xmlByteConsumed",
    #####:12597:	           xmlMemBlocks() - mem_base);
    #####:12598:	    test_ret++;
    #####:12599:            printf(" %d", n_ctxt);
    #####:12600:            printf("\n");
        -:12601:        }
        -:12602:    }
    #####:12603:    function_tests++;
        -:12604:
    #####:12605:    return(test_ret);
        -:12606:}
        -:12607:
        -:12608:
        -:12609:static int
    #####:12610:test_xmlClearNodeInfoSeq(void) {
    #####:12611:    int test_ret = 0;
        -:12612:
        -:12613:    int mem_base;
        -:12614:    xmlParserNodeInfoSeqPtr seq; /* a node info sequence pointer */
        -:12615:    int n_seq;
        -:12616:
    #####:12617:    for (n_seq = 0;n_seq < gen_nb_xmlParserNodeInfoSeqPtr;n_seq++) {
    #####:12618:        mem_base = xmlMemBlocks();
    #####:12619:        seq = gen_xmlParserNodeInfoSeqPtr(n_seq, 0);
        -:12620:
    #####:12621:        xmlClearNodeInfoSeq(seq);
    #####:12622:        call_tests++;
    #####:12623:        des_xmlParserNodeInfoSeqPtr(n_seq, seq, 0);
    #####:12624:        xmlResetLastError();
    #####:12625:        if (mem_base != xmlMemBlocks()) {
    #####:12626:            printf("Leak of %d blocks found in xmlClearNodeInfoSeq",
    #####:12627:	           xmlMemBlocks() - mem_base);
    #####:12628:	    test_ret++;
    #####:12629:            printf(" %d", n_seq);
    #####:12630:            printf("\n");
        -:12631:        }
        -:12632:    }
    #####:12633:    function_tests++;
        -:12634:
    #####:12635:    return(test_ret);
        -:12636:}
        -:12637:
        -:12638:
        -:12639:static int
    #####:12640:test_xmlClearParserCtxt(void) {
    #####:12641:    int test_ret = 0;
        -:12642:
        -:12643:    int mem_base;
        -:12644:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:12645:    int n_ctxt;
        -:12646:
    #####:12647:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:12648:        mem_base = xmlMemBlocks();
    #####:12649:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        -:12650:
    #####:12651:        xmlClearParserCtxt(ctxt);
    #####:12652:        call_tests++;
    #####:12653:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:12654:        xmlResetLastError();
    #####:12655:        if (mem_base != xmlMemBlocks()) {
    #####:12656:            printf("Leak of %d blocks found in xmlClearParserCtxt",
    #####:12657:	           xmlMemBlocks() - mem_base);
    #####:12658:	    test_ret++;
    #####:12659:            printf(" %d", n_ctxt);
    #####:12660:            printf("\n");
        -:12661:        }
        -:12662:    }
    #####:12663:    function_tests++;
        -:12664:
    #####:12665:    return(test_ret);
        -:12666:}
        -:12667:
        -:12668:
        -:12669:static int
    #####:12670:test_xmlCreateDocParserCtxt(void) {
    #####:12671:    int test_ret = 0;
        -:12672:
        -:12673:    int mem_base;
        -:12674:    xmlParserCtxtPtr ret_val;
        -:12675:    xmlChar * cur; /* a pointer to an array of xmlChar */
        -:12676:    int n_cur;
        -:12677:
    #####:12678:    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    #####:12679:        mem_base = xmlMemBlocks();
    #####:12680:        cur = gen_const_xmlChar_ptr(n_cur, 0);
        -:12681:
    #####:12682:        ret_val = xmlCreateDocParserCtxt((const xmlChar *)cur);
    #####:12683:        desret_xmlParserCtxtPtr(ret_val);
    #####:12684:        call_tests++;
    #####:12685:        des_const_xmlChar_ptr(n_cur, (const xmlChar *)cur, 0);
    #####:12686:        xmlResetLastError();
    #####:12687:        if (mem_base != xmlMemBlocks()) {
    #####:12688:            printf("Leak of %d blocks found in xmlCreateDocParserCtxt",
    #####:12689:	           xmlMemBlocks() - mem_base);
    #####:12690:	    test_ret++;
    #####:12691:            printf(" %d", n_cur);
    #####:12692:            printf("\n");
        -:12693:        }
        -:12694:    }
    #####:12695:    function_tests++;
        -:12696:
    #####:12697:    return(test_ret);
        -:12698:}
        -:12699:
        -:12700:
        -:12701:static int
    #####:12702:test_xmlCreatePushParserCtxt(void) {
    #####:12703:    int test_ret = 0;
        -:12704:
        -:12705:#if defined(LIBXML_PUSH_ENABLED)
        -:12706:    int mem_base;
        -:12707:    xmlParserCtxtPtr ret_val;
        -:12708:    xmlSAXHandlerPtr sax; /* a SAX handler */
        -:12709:    int n_sax;
        -:12710:    void * user_data; /* The user data returned on SAX callbacks */
        -:12711:    int n_user_data;
        -:12712:    char * chunk; /* a pointer to an array of chars */
        -:12713:    int n_chunk;
        -:12714:    int size; /* number of chars in the array */
        -:12715:    int n_size;
        -:12716:    const char * filename; /* an optional file name or URI */
        -:12717:    int n_filename;
        -:12718:
    #####:12719:    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    #####:12720:    for (n_user_data = 0;n_user_data < gen_nb_userdata;n_user_data++) {
    #####:12721:    for (n_chunk = 0;n_chunk < gen_nb_const_char_ptr;n_chunk++) {
    #####:12722:    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    #####:12723:    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    #####:12724:        mem_base = xmlMemBlocks();
    #####:12725:        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
    #####:12726:        user_data = gen_userdata(n_user_data, 1);
    #####:12727:        chunk = gen_const_char_ptr(n_chunk, 2);
    #####:12728:        size = gen_int(n_size, 3);
    #####:12729:        filename = gen_fileoutput(n_filename, 4);
        -:12730:
    #####:12731:        ret_val = xmlCreatePushParserCtxt(sax, user_data, (const char *)chunk, size, filename);
    #####:12732:        desret_xmlParserCtxtPtr(ret_val);
    #####:12733:        call_tests++;
    #####:12734:        des_xmlSAXHandlerPtr(n_sax, sax, 0);
    #####:12735:        des_userdata(n_user_data, user_data, 1);
    #####:12736:        des_const_char_ptr(n_chunk, (const char *)chunk, 2);
    #####:12737:        des_int(n_size, size, 3);
    #####:12738:        des_fileoutput(n_filename, filename, 4);
    #####:12739:        xmlResetLastError();
    #####:12740:        if (mem_base != xmlMemBlocks()) {
    #####:12741:            printf("Leak of %d blocks found in xmlCreatePushParserCtxt",
    #####:12742:	           xmlMemBlocks() - mem_base);
    #####:12743:	    test_ret++;
    #####:12744:            printf(" %d", n_sax);
    #####:12745:            printf(" %d", n_user_data);
    #####:12746:            printf(" %d", n_chunk);
    #####:12747:            printf(" %d", n_size);
    #####:12748:            printf(" %d", n_filename);
    #####:12749:            printf("\n");
        -:12750:        }
        -:12751:    }
        -:12752:    }
        -:12753:    }
        -:12754:    }
        -:12755:    }
    #####:12756:    function_tests++;
        -:12757:#endif
        -:12758:
    #####:12759:    return(test_ret);
        -:12760:}
        -:12761:
        -:12762:
        -:12763:static int
    #####:12764:test_xmlCtxtReadDoc(void) {
    #####:12765:    int test_ret = 0;
        -:12766:
        -:12767:    int mem_base;
        -:12768:    xmlDocPtr ret_val;
        -:12769:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:12770:    int n_ctxt;
        -:12771:    xmlChar * cur; /* a pointer to a zero terminated string */
        -:12772:    int n_cur;
        -:12773:    const char * URL; /* the base URL to use for the document */
        -:12774:    int n_URL;
        -:12775:    char * encoding; /* the document encoding, or NULL */
        -:12776:    int n_encoding;
        -:12777:    int options; /* a combination of xmlParserOption */
        -:12778:    int n_options;
        -:12779:
    #####:12780:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:12781:    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    #####:12782:    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    #####:12783:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####:12784:    for (n_options = 0;n_options < gen_nb_parseroptions;n_options++) {
    #####:12785:        mem_base = xmlMemBlocks();
    #####:12786:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
    #####:12787:        cur = gen_const_xmlChar_ptr(n_cur, 1);
    #####:12788:        URL = gen_filepath(n_URL, 2);
    #####:12789:        encoding = gen_const_char_ptr(n_encoding, 3);
    #####:12790:        options = gen_parseroptions(n_options, 4);
        -:12791:
    #####:12792:        ret_val = xmlCtxtReadDoc(ctxt, (const xmlChar *)cur, URL, (const char *)encoding, options);
    #####:12793:        desret_xmlDocPtr(ret_val);
    #####:12794:        call_tests++;
    #####:12795:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:12796:        des_const_xmlChar_ptr(n_cur, (const xmlChar *)cur, 1);
    #####:12797:        des_filepath(n_URL, URL, 2);
    #####:12798:        des_const_char_ptr(n_encoding, (const char *)encoding, 3);
    #####:12799:        des_parseroptions(n_options, options, 4);
    #####:12800:        xmlResetLastError();
    #####:12801:        if (mem_base != xmlMemBlocks()) {
    #####:12802:            printf("Leak of %d blocks found in xmlCtxtReadDoc",
    #####:12803:	           xmlMemBlocks() - mem_base);
    #####:12804:	    test_ret++;
    #####:12805:            printf(" %d", n_ctxt);
    #####:12806:            printf(" %d", n_cur);
    #####:12807:            printf(" %d", n_URL);
    #####:12808:            printf(" %d", n_encoding);
    #####:12809:            printf(" %d", n_options);
    #####:12810:            printf("\n");
        -:12811:        }
        -:12812:    }
        -:12813:    }
        -:12814:    }
        -:12815:    }
        -:12816:    }
    #####:12817:    function_tests++;
        -:12818:
    #####:12819:    return(test_ret);
        -:12820:}
        -:12821:
        -:12822:
        -:12823:static int
    #####:12824:test_xmlCtxtReadFile(void) {
    #####:12825:    int test_ret = 0;
        -:12826:
        -:12827:    int mem_base;
        -:12828:    xmlDocPtr ret_val;
        -:12829:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:12830:    int n_ctxt;
        -:12831:    const char * filename; /* a file or URL */
        -:12832:    int n_filename;
        -:12833:    char * encoding; /* the document encoding, or NULL */
        -:12834:    int n_encoding;
        -:12835:    int options; /* a combination of xmlParserOption */
        -:12836:    int n_options;
        -:12837:
    #####:12838:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:12839:    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    #####:12840:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####:12841:    for (n_options = 0;n_options < gen_nb_parseroptions;n_options++) {
    #####:12842:        mem_base = xmlMemBlocks();
    #####:12843:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
    #####:12844:        filename = gen_filepath(n_filename, 1);
    #####:12845:        encoding = gen_const_char_ptr(n_encoding, 2);
    #####:12846:        options = gen_parseroptions(n_options, 3);
        -:12847:
    #####:12848:        ret_val = xmlCtxtReadFile(ctxt, filename, (const char *)encoding, options);
    #####:12849:        desret_xmlDocPtr(ret_val);
    #####:12850:        call_tests++;
    #####:12851:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:12852:        des_filepath(n_filename, filename, 1);
    #####:12853:        des_const_char_ptr(n_encoding, (const char *)encoding, 2);
    #####:12854:        des_parseroptions(n_options, options, 3);
    #####:12855:        xmlResetLastError();
    #####:12856:        if (mem_base != xmlMemBlocks()) {
    #####:12857:            printf("Leak of %d blocks found in xmlCtxtReadFile",
    #####:12858:	           xmlMemBlocks() - mem_base);
    #####:12859:	    test_ret++;
    #####:12860:            printf(" %d", n_ctxt);
    #####:12861:            printf(" %d", n_filename);
    #####:12862:            printf(" %d", n_encoding);
    #####:12863:            printf(" %d", n_options);
    #####:12864:            printf("\n");
        -:12865:        }
        -:12866:    }
        -:12867:    }
        -:12868:    }
        -:12869:    }
    #####:12870:    function_tests++;
        -:12871:
    #####:12872:    return(test_ret);
        -:12873:}
        -:12874:
        -:12875:
        -:12876:static int
    #####:12877:test_xmlCtxtReadMemory(void) {
    #####:12878:    int test_ret = 0;
        -:12879:
        -:12880:    int mem_base;
        -:12881:    xmlDocPtr ret_val;
        -:12882:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:12883:    int n_ctxt;
        -:12884:    char * buffer; /* a pointer to a char array */
        -:12885:    int n_buffer;
        -:12886:    int size; /* the size of the array */
        -:12887:    int n_size;
        -:12888:    const char * URL; /* the base URL to use for the document */
        -:12889:    int n_URL;
        -:12890:    char * encoding; /* the document encoding, or NULL */
        -:12891:    int n_encoding;
        -:12892:    int options; /* a combination of xmlParserOption */
        -:12893:    int n_options;
        -:12894:
    #####:12895:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:12896:    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    #####:12897:    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    #####:12898:    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    #####:12899:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####:12900:    for (n_options = 0;n_options < gen_nb_parseroptions;n_options++) {
    #####:12901:        mem_base = xmlMemBlocks();
    #####:12902:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
    #####:12903:        buffer = gen_const_char_ptr(n_buffer, 1);
    #####:12904:        size = gen_int(n_size, 2);
    #####:12905:        URL = gen_filepath(n_URL, 3);
    #####:12906:        encoding = gen_const_char_ptr(n_encoding, 4);
    #####:12907:        options = gen_parseroptions(n_options, 5);
        -:12908:
    #####:12909:        ret_val = xmlCtxtReadMemory(ctxt, (const char *)buffer, size, URL, (const char *)encoding, options);
    #####:12910:        desret_xmlDocPtr(ret_val);
    #####:12911:        call_tests++;
    #####:12912:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:12913:        des_const_char_ptr(n_buffer, (const char *)buffer, 1);
    #####:12914:        des_int(n_size, size, 2);
    #####:12915:        des_filepath(n_URL, URL, 3);
    #####:12916:        des_const_char_ptr(n_encoding, (const char *)encoding, 4);
    #####:12917:        des_parseroptions(n_options, options, 5);
    #####:12918:        xmlResetLastError();
    #####:12919:        if (mem_base != xmlMemBlocks()) {
    #####:12920:            printf("Leak of %d blocks found in xmlCtxtReadMemory",
    #####:12921:	           xmlMemBlocks() - mem_base);
    #####:12922:	    test_ret++;
    #####:12923:            printf(" %d", n_ctxt);
    #####:12924:            printf(" %d", n_buffer);
    #####:12925:            printf(" %d", n_size);
    #####:12926:            printf(" %d", n_URL);
    #####:12927:            printf(" %d", n_encoding);
    #####:12928:            printf(" %d", n_options);
    #####:12929:            printf("\n");
        -:12930:        }
        -:12931:    }
        -:12932:    }
        -:12933:    }
        -:12934:    }
        -:12935:    }
        -:12936:    }
    #####:12937:    function_tests++;
        -:12938:
    #####:12939:    return(test_ret);
        -:12940:}
        -:12941:
        -:12942:
        -:12943:static int
    #####:12944:test_xmlCtxtReset(void) {
    #####:12945:    int test_ret = 0;
        -:12946:
        -:12947:    int mem_base;
        -:12948:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:12949:    int n_ctxt;
        -:12950:
    #####:12951:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:12952:        mem_base = xmlMemBlocks();
    #####:12953:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        -:12954:
    #####:12955:        xmlCtxtReset(ctxt);
    #####:12956:        call_tests++;
    #####:12957:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:12958:        xmlResetLastError();
    #####:12959:        if (mem_base != xmlMemBlocks()) {
    #####:12960:            printf("Leak of %d blocks found in xmlCtxtReset",
    #####:12961:	           xmlMemBlocks() - mem_base);
    #####:12962:	    test_ret++;
    #####:12963:            printf(" %d", n_ctxt);
    #####:12964:            printf("\n");
        -:12965:        }
        -:12966:    }
    #####:12967:    function_tests++;
        -:12968:
    #####:12969:    return(test_ret);
        -:12970:}
        -:12971:
        -:12972:
        -:12973:static int
    #####:12974:test_xmlCtxtResetPush(void) {
    #####:12975:    int test_ret = 0;
        -:12976:
        -:12977:    int mem_base;
        -:12978:    int ret_val;
        -:12979:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:12980:    int n_ctxt;
        -:12981:    char * chunk; /* a pointer to an array of chars */
        -:12982:    int n_chunk;
        -:12983:    int size; /* number of chars in the array */
        -:12984:    int n_size;
        -:12985:    const char * filename; /* an optional file name or URI */
        -:12986:    int n_filename;
        -:12987:    char * encoding; /* the document encoding, or NULL */
        -:12988:    int n_encoding;
        -:12989:
    #####:12990:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:12991:    for (n_chunk = 0;n_chunk < gen_nb_const_char_ptr;n_chunk++) {
    #####:12992:    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    #####:12993:    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    #####:12994:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####:12995:        mem_base = xmlMemBlocks();
    #####:12996:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
    #####:12997:        chunk = gen_const_char_ptr(n_chunk, 1);
    #####:12998:        size = gen_int(n_size, 2);
    #####:12999:        filename = gen_filepath(n_filename, 3);
    #####:13000:        encoding = gen_const_char_ptr(n_encoding, 4);
        -:13001:
    #####:13002:        ret_val = xmlCtxtResetPush(ctxt, (const char *)chunk, size, filename, (const char *)encoding);
    #####:13003:        desret_int(ret_val);
    #####:13004:        call_tests++;
    #####:13005:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:13006:        des_const_char_ptr(n_chunk, (const char *)chunk, 1);
    #####:13007:        des_int(n_size, size, 2);
    #####:13008:        des_filepath(n_filename, filename, 3);
    #####:13009:        des_const_char_ptr(n_encoding, (const char *)encoding, 4);
    #####:13010:        xmlResetLastError();
    #####:13011:        if (mem_base != xmlMemBlocks()) {
    #####:13012:            printf("Leak of %d blocks found in xmlCtxtResetPush",
    #####:13013:	           xmlMemBlocks() - mem_base);
    #####:13014:	    test_ret++;
    #####:13015:            printf(" %d", n_ctxt);
    #####:13016:            printf(" %d", n_chunk);
    #####:13017:            printf(" %d", n_size);
    #####:13018:            printf(" %d", n_filename);
    #####:13019:            printf(" %d", n_encoding);
    #####:13020:            printf("\n");
        -:13021:        }
        -:13022:    }
        -:13023:    }
        -:13024:    }
        -:13025:    }
        -:13026:    }
    #####:13027:    function_tests++;
        -:13028:
    #####:13029:    return(test_ret);
        -:13030:}
        -:13031:
        -:13032:
        -:13033:static int
    #####:13034:test_xmlCtxtUseOptions(void) {
    #####:13035:    int test_ret = 0;
        -:13036:
        -:13037:    int mem_base;
        -:13038:    int ret_val;
        -:13039:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:13040:    int n_ctxt;
        -:13041:    int options; /* a combination of xmlParserOption */
        -:13042:    int n_options;
        -:13043:
    #####:13044:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:13045:    for (n_options = 0;n_options < gen_nb_parseroptions;n_options++) {
    #####:13046:        mem_base = xmlMemBlocks();
    #####:13047:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
    #####:13048:        options = gen_parseroptions(n_options, 1);
        -:13049:
    #####:13050:        ret_val = xmlCtxtUseOptions(ctxt, options);
    #####:13051:        desret_int(ret_val);
    #####:13052:        call_tests++;
    #####:13053:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:13054:        des_parseroptions(n_options, options, 1);
    #####:13055:        xmlResetLastError();
    #####:13056:        if (mem_base != xmlMemBlocks()) {
    #####:13057:            printf("Leak of %d blocks found in xmlCtxtUseOptions",
    #####:13058:	           xmlMemBlocks() - mem_base);
    #####:13059:	    test_ret++;
    #####:13060:            printf(" %d", n_ctxt);
    #####:13061:            printf(" %d", n_options);
    #####:13062:            printf("\n");
        -:13063:        }
        -:13064:    }
        -:13065:    }
    #####:13066:    function_tests++;
        -:13067:
    #####:13068:    return(test_ret);
        -:13069:}
        -:13070:
        -:13071:
        -:13072:static int
    #####:13073:test_xmlGetExternalEntityLoader(void) {
    #####:13074:    int test_ret = 0;
        -:13075:
        -:13076:
        -:13077:    /* missing type support */
    #####:13078:    return(test_ret);
        -:13079:}
        -:13080:
        -:13081:
        -:13082:static int
    #####:13083:test_xmlGetFeature(void) {
    #####:13084:    int test_ret = 0;
        -:13085:
        -:13086:#if defined(LIBXML_LEGACY_ENABLED)
        -:13087:#ifdef LIBXML_LEGACY_ENABLED
        -:13088:    int mem_base;
        -:13089:    int ret_val;
        -:13090:    xmlParserCtxtPtr ctxt; /* an XML/HTML parser context */
        -:13091:    int n_ctxt;
        -:13092:    char * name; /* the feature name */
        -:13093:    int n_name;
        -:13094:    void * result; /* location to store the result */
        -:13095:    int n_result;
        -:13096:
    #####:13097:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:13098:    for (n_name = 0;n_name < gen_nb_const_char_ptr;n_name++) {
    #####:13099:    for (n_result = 0;n_result < gen_nb_void_ptr;n_result++) {
    #####:13100:        mem_base = xmlMemBlocks();
    #####:13101:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
    #####:13102:        name = gen_const_char_ptr(n_name, 1);
    #####:13103:        result = gen_void_ptr(n_result, 2);
        -:13104:
    #####:13105:        ret_val = xmlGetFeature(ctxt, (const char *)name, result);
    #####:13106:        desret_int(ret_val);
    #####:13107:        call_tests++;
    #####:13108:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:13109:        des_const_char_ptr(n_name, (const char *)name, 1);
    #####:13110:        des_void_ptr(n_result, result, 2);
    #####:13111:        xmlResetLastError();
    #####:13112:        if (mem_base != xmlMemBlocks()) {
    #####:13113:            printf("Leak of %d blocks found in xmlGetFeature",
    #####:13114:	           xmlMemBlocks() - mem_base);
    #####:13115:	    test_ret++;
    #####:13116:            printf(" %d", n_ctxt);
    #####:13117:            printf(" %d", n_name);
    #####:13118:            printf(" %d", n_result);
    #####:13119:            printf("\n");
        -:13120:        }
        -:13121:    }
        -:13122:    }
        -:13123:    }
    #####:13124:    function_tests++;
        -:13125:#endif
        -:13126:#endif
        -:13127:
    #####:13128:    return(test_ret);
        -:13129:}
        -:13130:
        -:13131:
        -:13132:#define gen_nb_const_char_ptr_ptr 1
    #####:13133:static char ** gen_const_char_ptr_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:13134:    return(NULL);
        -:13135:}
    #####:13136:static void des_const_char_ptr_ptr(int no ATTRIBUTE_UNUSED, const char ** val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:13137:}
        -:13138:
        -:13139:static int
    #####:13140:test_xmlGetFeaturesList(void) {
    #####:13141:    int test_ret = 0;
        -:13142:
        -:13143:#if defined(LIBXML_LEGACY_ENABLED)
        -:13144:#ifdef LIBXML_LEGACY_ENABLED
        -:13145:    int mem_base;
        -:13146:    int ret_val;
        -:13147:    int * len; /* the length of the features name array (input/output) */
        -:13148:    int n_len;
        -:13149:    char ** result; /* an array of string to be filled with the features name. */
        -:13150:    int n_result;
        -:13151:
    #####:13152:    for (n_len = 0;n_len < gen_nb_int_ptr;n_len++) {
    #####:13153:    for (n_result = 0;n_result < gen_nb_const_char_ptr_ptr;n_result++) {
    #####:13154:        mem_base = xmlMemBlocks();
    #####:13155:        len = gen_int_ptr(n_len, 0);
    #####:13156:        result = gen_const_char_ptr_ptr(n_result, 1);
        -:13157:
    #####:13158:        ret_val = xmlGetFeaturesList(len, (const char **)result);
    #####:13159:        desret_int(ret_val);
    #####:13160:        call_tests++;
    #####:13161:        des_int_ptr(n_len, len, 0);
    #####:13162:        des_const_char_ptr_ptr(n_result, (const char **)result, 1);
    #####:13163:        xmlResetLastError();
    #####:13164:        if (mem_base != xmlMemBlocks()) {
    #####:13165:            printf("Leak of %d blocks found in xmlGetFeaturesList",
    #####:13166:	           xmlMemBlocks() - mem_base);
    #####:13167:	    test_ret++;
    #####:13168:            printf(" %d", n_len);
    #####:13169:            printf(" %d", n_result);
    #####:13170:            printf("\n");
        -:13171:        }
        -:13172:    }
        -:13173:    }
    #####:13174:    function_tests++;
        -:13175:#endif
        -:13176:#endif
        -:13177:
    #####:13178:    return(test_ret);
        -:13179:}
        -:13180:
        -:13181:
        -:13182:static int
    #####:13183:test_xmlHasFeature(void) {
    #####:13184:    int test_ret = 0;
        -:13185:
        -:13186:    int mem_base;
        -:13187:    int ret_val;
        -:13188:    xmlFeature feature; /* the feature to be examined */
        -:13189:    int n_feature;
        -:13190:
    #####:13191:    for (n_feature = 0;n_feature < gen_nb_xmlFeature;n_feature++) {
    #####:13192:        mem_base = xmlMemBlocks();
    #####:13193:        feature = gen_xmlFeature(n_feature, 0);
        -:13194:
    #####:13195:        ret_val = xmlHasFeature(feature);
    #####:13196:        desret_int(ret_val);
    #####:13197:        call_tests++;
    #####:13198:        des_xmlFeature(n_feature, feature, 0);
    #####:13199:        xmlResetLastError();
    #####:13200:        if (mem_base != xmlMemBlocks()) {
    #####:13201:            printf("Leak of %d blocks found in xmlHasFeature",
    #####:13202:	           xmlMemBlocks() - mem_base);
    #####:13203:	    test_ret++;
    #####:13204:            printf(" %d", n_feature);
    #####:13205:            printf("\n");
        -:13206:        }
        -:13207:    }
    #####:13208:    function_tests++;
        -:13209:
    #####:13210:    return(test_ret);
        -:13211:}
        -:13212:
        -:13213:
        -:13214:static int
    #####:13215:test_xmlIOParseDTD(void) {
    #####:13216:    int test_ret = 0;
        -:13217:
        -:13218:#if defined(LIBXML_VALID_ENABLED)
        -:13219:#ifdef LIBXML_VALID_ENABLED
        -:13220:    xmlDtdPtr ret_val;
        -:13221:    xmlSAXHandlerPtr sax; /* the SAX handler block or NULL */
        -:13222:    int n_sax;
        -:13223:    xmlParserInputBufferPtr input; /* an Input Buffer */
        -:13224:    int n_input;
        -:13225:    xmlCharEncoding enc; /* the charset encoding if known */
        -:13226:    int n_enc;
        -:13227:
    #####:13228:    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    #####:13229:    for (n_input = 0;n_input < gen_nb_xmlParserInputBufferPtr;n_input++) {
    #####:13230:    for (n_enc = 0;n_enc < gen_nb_xmlCharEncoding;n_enc++) {
    #####:13231:        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
    #####:13232:        input = gen_xmlParserInputBufferPtr(n_input, 1);
    #####:13233:        enc = gen_xmlCharEncoding(n_enc, 2);
        -:13234:
    #####:13235:        ret_val = xmlIOParseDTD(sax, input, enc);
    #####:13236:        input = NULL;
    #####:13237:        desret_xmlDtdPtr(ret_val);
    #####:13238:        call_tests++;
    #####:13239:        des_xmlSAXHandlerPtr(n_sax, sax, 0);
    #####:13240:        des_xmlParserInputBufferPtr(n_input, input, 1);
    #####:13241:        des_xmlCharEncoding(n_enc, enc, 2);
    #####:13242:        xmlResetLastError();
        -:13243:    }
        -:13244:    }
        -:13245:    }
    #####:13246:    function_tests++;
        -:13247:#endif
        -:13248:#endif
        -:13249:
    #####:13250:    return(test_ret);
        -:13251:}
        -:13252:
        -:13253:
        -:13254:static int
    #####:13255:test_xmlInitNodeInfoSeq(void) {
    #####:13256:    int test_ret = 0;
        -:13257:
        -:13258:    int mem_base;
        -:13259:    xmlParserNodeInfoSeqPtr seq; /* a node info sequence pointer */
        -:13260:    int n_seq;
        -:13261:
    #####:13262:    for (n_seq = 0;n_seq < gen_nb_xmlParserNodeInfoSeqPtr;n_seq++) {
    #####:13263:        mem_base = xmlMemBlocks();
    #####:13264:        seq = gen_xmlParserNodeInfoSeqPtr(n_seq, 0);
        -:13265:
    #####:13266:        xmlInitNodeInfoSeq(seq);
    #####:13267:        call_tests++;
    #####:13268:        des_xmlParserNodeInfoSeqPtr(n_seq, seq, 0);
    #####:13269:        xmlResetLastError();
    #####:13270:        if (mem_base != xmlMemBlocks()) {
    #####:13271:            printf("Leak of %d blocks found in xmlInitNodeInfoSeq",
    #####:13272:	           xmlMemBlocks() - mem_base);
    #####:13273:	    test_ret++;
    #####:13274:            printf(" %d", n_seq);
    #####:13275:            printf("\n");
        -:13276:        }
        -:13277:    }
    #####:13278:    function_tests++;
        -:13279:
    #####:13280:    return(test_ret);
        -:13281:}
        -:13282:
        -:13283:
        -:13284:static int
    #####:13285:test_xmlInitParser(void) {
    #####:13286:    int test_ret = 0;
        -:13287:
        -:13288:    int mem_base;
        -:13289:
    #####:13290:        mem_base = xmlMemBlocks();
        -:13291:
    #####:13292:        xmlInitParser();
    #####:13293:        call_tests++;
    #####:13294:        xmlResetLastError();
    #####:13295:        if (mem_base != xmlMemBlocks()) {
    #####:13296:            printf("Leak of %d blocks found in xmlInitParser",
    #####:13297:	           xmlMemBlocks() - mem_base);
    #####:13298:	    test_ret++;
    #####:13299:            printf("\n");
        -:13300:        }
    #####:13301:    function_tests++;
        -:13302:
    #####:13303:    return(test_ret);
        -:13304:}
        -:13305:
        -:13306:
        -:13307:static int
    #####:13308:test_xmlInitParserCtxt(void) {
    #####:13309:    int test_ret = 0;
        -:13310:
        -:13311:    int mem_base;
        -:13312:    int ret_val;
        -:13313:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:13314:    int n_ctxt;
        -:13315:
    #####:13316:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:13317:        mem_base = xmlMemBlocks();
    #####:13318:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        -:13319:
    #####:13320:        ret_val = xmlInitParserCtxt(ctxt);
    #####:13321:        desret_int(ret_val);
    #####:13322:        call_tests++;
    #####:13323:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:13324:        xmlResetLastError();
    #####:13325:        if (mem_base != xmlMemBlocks()) {
    #####:13326:            printf("Leak of %d blocks found in xmlInitParserCtxt",
    #####:13327:	           xmlMemBlocks() - mem_base);
    #####:13328:	    test_ret++;
    #####:13329:            printf(" %d", n_ctxt);
    #####:13330:            printf("\n");
        -:13331:        }
        -:13332:    }
    #####:13333:    function_tests++;
        -:13334:
    #####:13335:    return(test_ret);
        -:13336:}
        -:13337:
        -:13338:
        -:13339:static int
    #####:13340:test_xmlKeepBlanksDefault(void) {
    #####:13341:    int test_ret = 0;
        -:13342:
        -:13343:    int mem_base;
        -:13344:    int ret_val;
        -:13345:    int val; /* int 0 or 1 */
        -:13346:    int n_val;
        -:13347:
    #####:13348:    for (n_val = 0;n_val < gen_nb_int;n_val++) {
    #####:13349:        mem_base = xmlMemBlocks();
    #####:13350:        val = gen_int(n_val, 0);
        -:13351:
    #####:13352:        ret_val = xmlKeepBlanksDefault(val);
    #####:13353:        desret_int(ret_val);
    #####:13354:        call_tests++;
    #####:13355:        des_int(n_val, val, 0);
    #####:13356:        xmlResetLastError();
    #####:13357:        if (mem_base != xmlMemBlocks()) {
    #####:13358:            printf("Leak of %d blocks found in xmlKeepBlanksDefault",
    #####:13359:	           xmlMemBlocks() - mem_base);
    #####:13360:	    test_ret++;
    #####:13361:            printf(" %d", n_val);
    #####:13362:            printf("\n");
        -:13363:        }
        -:13364:    }
    #####:13365:    function_tests++;
        -:13366:
    #####:13367:    return(test_ret);
        -:13368:}
        -:13369:
        -:13370:
        -:13371:static int
    #####:13372:test_xmlLineNumbersDefault(void) {
    #####:13373:    int test_ret = 0;
        -:13374:
        -:13375:    int mem_base;
        -:13376:    int ret_val;
        -:13377:    int val; /* int 0 or 1 */
        -:13378:    int n_val;
        -:13379:
    #####:13380:    for (n_val = 0;n_val < gen_nb_int;n_val++) {
    #####:13381:        mem_base = xmlMemBlocks();
    #####:13382:        val = gen_int(n_val, 0);
        -:13383:
    #####:13384:        ret_val = xmlLineNumbersDefault(val);
    #####:13385:        desret_int(ret_val);
    #####:13386:        call_tests++;
    #####:13387:        des_int(n_val, val, 0);
    #####:13388:        xmlResetLastError();
    #####:13389:        if (mem_base != xmlMemBlocks()) {
    #####:13390:            printf("Leak of %d blocks found in xmlLineNumbersDefault",
    #####:13391:	           xmlMemBlocks() - mem_base);
    #####:13392:	    test_ret++;
    #####:13393:            printf(" %d", n_val);
    #####:13394:            printf("\n");
        -:13395:        }
        -:13396:    }
    #####:13397:    function_tests++;
        -:13398:
    #####:13399:    return(test_ret);
        -:13400:}
        -:13401:
        -:13402:
        -:13403:static int
    #####:13404:test_xmlLoadExternalEntity(void) {
    #####:13405:    int test_ret = 0;
        -:13406:
        -:13407:    int mem_base;
        -:13408:    xmlParserInputPtr ret_val;
        -:13409:    const char * URL; /* the URL for the entity to load */
        -:13410:    int n_URL;
        -:13411:    char * ID; /* the Public ID for the entity to load */
        -:13412:    int n_ID;
        -:13413:    xmlParserCtxtPtr ctxt; /* the context in which the entity is called or NULL */
        -:13414:    int n_ctxt;
        -:13415:
    #####:13416:    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    #####:13417:    for (n_ID = 0;n_ID < gen_nb_const_char_ptr;n_ID++) {
    #####:13418:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:13419:        mem_base = xmlMemBlocks();
    #####:13420:        URL = gen_filepath(n_URL, 0);
    #####:13421:        ID = gen_const_char_ptr(n_ID, 1);
    #####:13422:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 2);
        -:13423:
    #####:13424:        ret_val = xmlLoadExternalEntity(URL, (const char *)ID, ctxt);
    #####:13425:        desret_xmlParserInputPtr(ret_val);
    #####:13426:        call_tests++;
    #####:13427:        des_filepath(n_URL, URL, 0);
    #####:13428:        des_const_char_ptr(n_ID, (const char *)ID, 1);
    #####:13429:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 2);
    #####:13430:        xmlResetLastError();
    #####:13431:        if (mem_base != xmlMemBlocks()) {
    #####:13432:            printf("Leak of %d blocks found in xmlLoadExternalEntity",
    #####:13433:	           xmlMemBlocks() - mem_base);
    #####:13434:	    test_ret++;
    #####:13435:            printf(" %d", n_URL);
    #####:13436:            printf(" %d", n_ID);
    #####:13437:            printf(" %d", n_ctxt);
    #####:13438:            printf("\n");
        -:13439:        }
        -:13440:    }
        -:13441:    }
        -:13442:    }
    #####:13443:    function_tests++;
        -:13444:
    #####:13445:    return(test_ret);
        -:13446:}
        -:13447:
        -:13448:
        -:13449:static int
    #####:13450:test_xmlNewIOInputStream(void) {
    #####:13451:    int test_ret = 0;
        -:13452:
        -:13453:    int mem_base;
        -:13454:    xmlParserInputPtr ret_val;
        -:13455:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:13456:    int n_ctxt;
        -:13457:    xmlParserInputBufferPtr input; /* an I/O Input */
        -:13458:    int n_input;
        -:13459:    xmlCharEncoding enc; /* the charset encoding if known */
        -:13460:    int n_enc;
        -:13461:
    #####:13462:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:13463:    for (n_input = 0;n_input < gen_nb_xmlParserInputBufferPtr;n_input++) {
    #####:13464:    for (n_enc = 0;n_enc < gen_nb_xmlCharEncoding;n_enc++) {
    #####:13465:        mem_base = xmlMemBlocks();
    #####:13466:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
    #####:13467:        input = gen_xmlParserInputBufferPtr(n_input, 1);
    #####:13468:        enc = gen_xmlCharEncoding(n_enc, 2);
        -:13469:
    #####:13470:        ret_val = xmlNewIOInputStream(ctxt, input, enc);
    #####:13471:        if (ret_val != NULL) input = NULL;
    #####:13472:        desret_xmlParserInputPtr(ret_val);
    #####:13473:        call_tests++;
    #####:13474:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:13475:        des_xmlParserInputBufferPtr(n_input, input, 1);
    #####:13476:        des_xmlCharEncoding(n_enc, enc, 2);
    #####:13477:        xmlResetLastError();
    #####:13478:        if (mem_base != xmlMemBlocks()) {
    #####:13479:            printf("Leak of %d blocks found in xmlNewIOInputStream",
    #####:13480:	           xmlMemBlocks() - mem_base);
    #####:13481:	    test_ret++;
    #####:13482:            printf(" %d", n_ctxt);
    #####:13483:            printf(" %d", n_input);
    #####:13484:            printf(" %d", n_enc);
    #####:13485:            printf("\n");
        -:13486:        }
        -:13487:    }
        -:13488:    }
        -:13489:    }
    #####:13490:    function_tests++;
        -:13491:
    #####:13492:    return(test_ret);
        -:13493:}
        -:13494:
        -:13495:
        -:13496:static int
    #####:13497:test_xmlNewParserCtxt(void) {
    #####:13498:    int test_ret = 0;
        -:13499:
        -:13500:    int mem_base;
        -:13501:    xmlParserCtxtPtr ret_val;
        -:13502:
    #####:13503:        mem_base = xmlMemBlocks();
        -:13504:
    #####:13505:        ret_val = xmlNewParserCtxt();
    #####:13506:        desret_xmlParserCtxtPtr(ret_val);
    #####:13507:        call_tests++;
    #####:13508:        xmlResetLastError();
    #####:13509:        if (mem_base != xmlMemBlocks()) {
    #####:13510:            printf("Leak of %d blocks found in xmlNewParserCtxt",
    #####:13511:	           xmlMemBlocks() - mem_base);
    #####:13512:	    test_ret++;
    #####:13513:            printf("\n");
        -:13514:        }
    #####:13515:    function_tests++;
        -:13516:
    #####:13517:    return(test_ret);
        -:13518:}
        -:13519:
        -:13520:
        -:13521:#define gen_nb_xmlNodePtr_ptr 1
    #####:13522:static xmlNodePtr * gen_xmlNodePtr_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:13523:    return(NULL);
        -:13524:}
    #####:13525:static void des_xmlNodePtr_ptr(int no ATTRIBUTE_UNUSED, xmlNodePtr * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:13526:}
        -:13527:
        -:13528:static int
    #####:13529:test_xmlParseBalancedChunkMemory(void) {
    #####:13530:    int test_ret = 0;
        -:13531:
        -:13532:#if defined(LIBXML_SAX1_ENABLED)
        -:13533:#ifdef LIBXML_SAX1_ENABLED
        -:13534:    int mem_base;
        -:13535:    int ret_val;
        -:13536:    xmlDocPtr doc; /* the document the chunk pertains to */
        -:13537:    int n_doc;
        -:13538:    xmlSAXHandlerPtr sax; /* the SAX handler bloc (possibly NULL) */
        -:13539:    int n_sax;
        -:13540:    void * user_data; /* The user data returned on SAX callbacks (possibly NULL) */
        -:13541:    int n_user_data;
        -:13542:    int depth; /* Used for loop detection, use 0 */
        -:13543:    int n_depth;
        -:13544:    xmlChar * string; /* the input string in UTF8 or ISO-Latin (zero terminated) */
        -:13545:    int n_string;
        -:13546:    xmlNodePtr * lst; /* the return value for the set of parsed nodes */
        -:13547:    int n_lst;
        -:13548:
    #####:13549:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:13550:    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    #####:13551:    for (n_user_data = 0;n_user_data < gen_nb_userdata;n_user_data++) {
    #####:13552:    for (n_depth = 0;n_depth < gen_nb_int;n_depth++) {
    #####:13553:    for (n_string = 0;n_string < gen_nb_const_xmlChar_ptr;n_string++) {
    #####:13554:    for (n_lst = 0;n_lst < gen_nb_xmlNodePtr_ptr;n_lst++) {
    #####:13555:        mem_base = xmlMemBlocks();
    #####:13556:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:13557:        sax = gen_xmlSAXHandlerPtr(n_sax, 1);
    #####:13558:        user_data = gen_userdata(n_user_data, 2);
    #####:13559:        depth = gen_int(n_depth, 3);
    #####:13560:        string = gen_const_xmlChar_ptr(n_string, 4);
    #####:13561:        lst = gen_xmlNodePtr_ptr(n_lst, 5);
        -:13562:        
        -:13563:#ifdef LIBXML_SAX1_ENABLED
    #####:13564:        if (sax == (xmlSAXHandlerPtr)&xmlDefaultSAXHandler) user_data = NULL;
        -:13565:#endif
        -:13566:
        -:13567:
    #####:13568:        ret_val = xmlParseBalancedChunkMemory(doc, sax, user_data, depth, (const xmlChar *)string, lst);
    #####:13569:        desret_int(ret_val);
    #####:13570:        call_tests++;
    #####:13571:        des_xmlDocPtr(n_doc, doc, 0);
    #####:13572:        des_xmlSAXHandlerPtr(n_sax, sax, 1);
    #####:13573:        des_userdata(n_user_data, user_data, 2);
    #####:13574:        des_int(n_depth, depth, 3);
    #####:13575:        des_const_xmlChar_ptr(n_string, (const xmlChar *)string, 4);
    #####:13576:        des_xmlNodePtr_ptr(n_lst, lst, 5);
    #####:13577:        xmlResetLastError();
    #####:13578:        if (mem_base != xmlMemBlocks()) {
    #####:13579:            printf("Leak of %d blocks found in xmlParseBalancedChunkMemory",
    #####:13580:	           xmlMemBlocks() - mem_base);
    #####:13581:	    test_ret++;
    #####:13582:            printf(" %d", n_doc);
    #####:13583:            printf(" %d", n_sax);
    #####:13584:            printf(" %d", n_user_data);
    #####:13585:            printf(" %d", n_depth);
    #####:13586:            printf(" %d", n_string);
    #####:13587:            printf(" %d", n_lst);
    #####:13588:            printf("\n");
        -:13589:        }
        -:13590:    }
        -:13591:    }
        -:13592:    }
        -:13593:    }
        -:13594:    }
        -:13595:    }
    #####:13596:    function_tests++;
        -:13597:#endif
        -:13598:#endif
        -:13599:
    #####:13600:    return(test_ret);
        -:13601:}
        -:13602:
        -:13603:
        -:13604:static int
    #####:13605:test_xmlParseBalancedChunkMemoryRecover(void) {
    #####:13606:    int test_ret = 0;
        -:13607:
        -:13608:#if defined(LIBXML_SAX1_ENABLED)
        -:13609:#ifdef LIBXML_SAX1_ENABLED
        -:13610:    int mem_base;
        -:13611:    int ret_val;
        -:13612:    xmlDocPtr doc; /* the document the chunk pertains to */
        -:13613:    int n_doc;
        -:13614:    xmlSAXHandlerPtr sax; /* the SAX handler bloc (possibly NULL) */
        -:13615:    int n_sax;
        -:13616:    void * user_data; /* The user data returned on SAX callbacks (possibly NULL) */
        -:13617:    int n_user_data;
        -:13618:    int depth; /* Used for loop detection, use 0 */
        -:13619:    int n_depth;
        -:13620:    xmlChar * string; /* the input string in UTF8 or ISO-Latin (zero terminated) */
        -:13621:    int n_string;
        -:13622:    xmlNodePtr * lst; /* the return value for the set of parsed nodes */
        -:13623:    int n_lst;
        -:13624:    int recover; /* return nodes even if the data is broken (use 0) */
        -:13625:    int n_recover;
        -:13626:
    #####:13627:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:13628:    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    #####:13629:    for (n_user_data = 0;n_user_data < gen_nb_userdata;n_user_data++) {
    #####:13630:    for (n_depth = 0;n_depth < gen_nb_int;n_depth++) {
    #####:13631:    for (n_string = 0;n_string < gen_nb_const_xmlChar_ptr;n_string++) {
    #####:13632:    for (n_lst = 0;n_lst < gen_nb_xmlNodePtr_ptr;n_lst++) {
    #####:13633:    for (n_recover = 0;n_recover < gen_nb_int;n_recover++) {
    #####:13634:        mem_base = xmlMemBlocks();
    #####:13635:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:13636:        sax = gen_xmlSAXHandlerPtr(n_sax, 1);
    #####:13637:        user_data = gen_userdata(n_user_data, 2);
    #####:13638:        depth = gen_int(n_depth, 3);
    #####:13639:        string = gen_const_xmlChar_ptr(n_string, 4);
    #####:13640:        lst = gen_xmlNodePtr_ptr(n_lst, 5);
    #####:13641:        recover = gen_int(n_recover, 6);
        -:13642:        
        -:13643:#ifdef LIBXML_SAX1_ENABLED
    #####:13644:        if (sax == (xmlSAXHandlerPtr)&xmlDefaultSAXHandler) user_data = NULL;
        -:13645:#endif
        -:13646:
        -:13647:
    #####:13648:        ret_val = xmlParseBalancedChunkMemoryRecover(doc, sax, user_data, depth, (const xmlChar *)string, lst, recover);
    #####:13649:        desret_int(ret_val);
    #####:13650:        call_tests++;
    #####:13651:        des_xmlDocPtr(n_doc, doc, 0);
    #####:13652:        des_xmlSAXHandlerPtr(n_sax, sax, 1);
    #####:13653:        des_userdata(n_user_data, user_data, 2);
    #####:13654:        des_int(n_depth, depth, 3);
    #####:13655:        des_const_xmlChar_ptr(n_string, (const xmlChar *)string, 4);
    #####:13656:        des_xmlNodePtr_ptr(n_lst, lst, 5);
    #####:13657:        des_int(n_recover, recover, 6);
    #####:13658:        xmlResetLastError();
    #####:13659:        if (mem_base != xmlMemBlocks()) {
    #####:13660:            printf("Leak of %d blocks found in xmlParseBalancedChunkMemoryRecover",
    #####:13661:	           xmlMemBlocks() - mem_base);
    #####:13662:	    test_ret++;
    #####:13663:            printf(" %d", n_doc);
    #####:13664:            printf(" %d", n_sax);
    #####:13665:            printf(" %d", n_user_data);
    #####:13666:            printf(" %d", n_depth);
    #####:13667:            printf(" %d", n_string);
    #####:13668:            printf(" %d", n_lst);
    #####:13669:            printf(" %d", n_recover);
    #####:13670:            printf("\n");
        -:13671:        }
        -:13672:    }
        -:13673:    }
        -:13674:    }
        -:13675:    }
        -:13676:    }
        -:13677:    }
        -:13678:    }
    #####:13679:    function_tests++;
        -:13680:#endif
        -:13681:#endif
        -:13682:
    #####:13683:    return(test_ret);
        -:13684:}
        -:13685:
        -:13686:
        -:13687:static int
    #####:13688:test_xmlParseChunk(void) {
    #####:13689:    int test_ret = 0;
        -:13690:
        -:13691:#if defined(LIBXML_PUSH_ENABLED)
        -:13692:    int mem_base;
        -:13693:    int ret_val;
        -:13694:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:13695:    int n_ctxt;
        -:13696:    char * chunk; /* an char array */
        -:13697:    int n_chunk;
        -:13698:    int size; /* the size in byte of the chunk */
        -:13699:    int n_size;
        -:13700:    int terminate; /* last chunk indicator */
        -:13701:    int n_terminate;
        -:13702:
    #####:13703:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:13704:    for (n_chunk = 0;n_chunk < gen_nb_const_char_ptr;n_chunk++) {
    #####:13705:    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    #####:13706:    for (n_terminate = 0;n_terminate < gen_nb_int;n_terminate++) {
    #####:13707:        mem_base = xmlMemBlocks();
    #####:13708:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
    #####:13709:        chunk = gen_const_char_ptr(n_chunk, 1);
    #####:13710:        size = gen_int(n_size, 2);
    #####:13711:        terminate = gen_int(n_terminate, 3);
        -:13712:
    #####:13713:        ret_val = xmlParseChunk(ctxt, (const char *)chunk, size, terminate);
    #####:13714:        if (ctxt != NULL) {xmlFreeDoc(ctxt->myDoc); ctxt->myDoc = NULL;}
    #####:13715:        desret_int(ret_val);
    #####:13716:        call_tests++;
    #####:13717:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:13718:        des_const_char_ptr(n_chunk, (const char *)chunk, 1);
    #####:13719:        des_int(n_size, size, 2);
    #####:13720:        des_int(n_terminate, terminate, 3);
    #####:13721:        xmlResetLastError();
    #####:13722:        if (mem_base != xmlMemBlocks()) {
    #####:13723:            printf("Leak of %d blocks found in xmlParseChunk",
    #####:13724:	           xmlMemBlocks() - mem_base);
    #####:13725:	    test_ret++;
    #####:13726:            printf(" %d", n_ctxt);
    #####:13727:            printf(" %d", n_chunk);
    #####:13728:            printf(" %d", n_size);
    #####:13729:            printf(" %d", n_terminate);
    #####:13730:            printf("\n");
        -:13731:        }
        -:13732:    }
        -:13733:    }
        -:13734:    }
        -:13735:    }
    #####:13736:    function_tests++;
        -:13737:#endif
        -:13738:
    #####:13739:    return(test_ret);
        -:13740:}
        -:13741:
        -:13742:
        -:13743:static int
    #####:13744:test_xmlParseCtxtExternalEntity(void) {
    #####:13745:    int test_ret = 0;
        -:13746:
        -:13747:    int mem_base;
        -:13748:    int ret_val;
        -:13749:    xmlParserCtxtPtr ctx; /* the existing parsing context */
        -:13750:    int n_ctx;
        -:13751:    xmlChar * URL; /* the URL for the entity to load */
        -:13752:    int n_URL;
        -:13753:    xmlChar * ID; /* the System ID for the entity to load */
        -:13754:    int n_ID;
        -:13755:    xmlNodePtr * lst; /* the return value for the set of parsed nodes */
        -:13756:    int n_lst;
        -:13757:
    #####:13758:    for (n_ctx = 0;n_ctx < gen_nb_xmlParserCtxtPtr;n_ctx++) {
    #####:13759:    for (n_URL = 0;n_URL < gen_nb_const_xmlChar_ptr;n_URL++) {
    #####:13760:    for (n_ID = 0;n_ID < gen_nb_const_xmlChar_ptr;n_ID++) {
    #####:13761:    for (n_lst = 0;n_lst < gen_nb_xmlNodePtr_ptr;n_lst++) {
    #####:13762:        mem_base = xmlMemBlocks();
    #####:13763:        ctx = gen_xmlParserCtxtPtr(n_ctx, 0);
    #####:13764:        URL = gen_const_xmlChar_ptr(n_URL, 1);
    #####:13765:        ID = gen_const_xmlChar_ptr(n_ID, 2);
    #####:13766:        lst = gen_xmlNodePtr_ptr(n_lst, 3);
        -:13767:
    #####:13768:        ret_val = xmlParseCtxtExternalEntity(ctx, (const xmlChar *)URL, (const xmlChar *)ID, lst);
    #####:13769:        desret_int(ret_val);
    #####:13770:        call_tests++;
    #####:13771:        des_xmlParserCtxtPtr(n_ctx, ctx, 0);
    #####:13772:        des_const_xmlChar_ptr(n_URL, (const xmlChar *)URL, 1);
    #####:13773:        des_const_xmlChar_ptr(n_ID, (const xmlChar *)ID, 2);
    #####:13774:        des_xmlNodePtr_ptr(n_lst, lst, 3);
    #####:13775:        xmlResetLastError();
    #####:13776:        if (mem_base != xmlMemBlocks()) {
    #####:13777:            printf("Leak of %d blocks found in xmlParseCtxtExternalEntity",
    #####:13778:	           xmlMemBlocks() - mem_base);
    #####:13779:	    test_ret++;
    #####:13780:            printf(" %d", n_ctx);
    #####:13781:            printf(" %d", n_URL);
    #####:13782:            printf(" %d", n_ID);
    #####:13783:            printf(" %d", n_lst);
    #####:13784:            printf("\n");
        -:13785:        }
        -:13786:    }
        -:13787:    }
        -:13788:    }
        -:13789:    }
    #####:13790:    function_tests++;
        -:13791:
    #####:13792:    return(test_ret);
        -:13793:}
        -:13794:
        -:13795:
        -:13796:static int
    #####:13797:test_xmlParseDTD(void) {
    #####:13798:    int test_ret = 0;
        -:13799:
        -:13800:#if defined(LIBXML_VALID_ENABLED)
        -:13801:#ifdef LIBXML_VALID_ENABLED
        -:13802:    int mem_base;
        -:13803:    xmlDtdPtr ret_val;
        -:13804:    xmlChar * ExternalID; /* a NAME* containing the External ID of the DTD */
        -:13805:    int n_ExternalID;
        -:13806:    xmlChar * SystemID; /* a NAME* containing the URL to the DTD */
        -:13807:    int n_SystemID;
        -:13808:
    #####:13809:    for (n_ExternalID = 0;n_ExternalID < gen_nb_const_xmlChar_ptr;n_ExternalID++) {
    #####:13810:    for (n_SystemID = 0;n_SystemID < gen_nb_const_xmlChar_ptr;n_SystemID++) {
    #####:13811:        mem_base = xmlMemBlocks();
    #####:13812:        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 0);
    #####:13813:        SystemID = gen_const_xmlChar_ptr(n_SystemID, 1);
        -:13814:
    #####:13815:        ret_val = xmlParseDTD((const xmlChar *)ExternalID, (const xmlChar *)SystemID);
    #####:13816:        desret_xmlDtdPtr(ret_val);
    #####:13817:        call_tests++;
    #####:13818:        des_const_xmlChar_ptr(n_ExternalID, (const xmlChar *)ExternalID, 0);
    #####:13819:        des_const_xmlChar_ptr(n_SystemID, (const xmlChar *)SystemID, 1);
    #####:13820:        xmlResetLastError();
    #####:13821:        if (mem_base != xmlMemBlocks()) {
    #####:13822:            printf("Leak of %d blocks found in xmlParseDTD",
    #####:13823:	           xmlMemBlocks() - mem_base);
    #####:13824:	    test_ret++;
    #####:13825:            printf(" %d", n_ExternalID);
    #####:13826:            printf(" %d", n_SystemID);
    #####:13827:            printf("\n");
        -:13828:        }
        -:13829:    }
        -:13830:    }
    #####:13831:    function_tests++;
        -:13832:#endif
        -:13833:#endif
        -:13834:
    #####:13835:    return(test_ret);
        -:13836:}
        -:13837:
        -:13838:
        -:13839:static int
    #####:13840:test_xmlParseDoc(void) {
    #####:13841:    int test_ret = 0;
        -:13842:
        -:13843:#if defined(LIBXML_SAX1_ENABLED)
        -:13844:#ifdef LIBXML_SAX1_ENABLED
        -:13845:    int mem_base;
        -:13846:    xmlDocPtr ret_val;
        -:13847:    xmlChar * cur; /* a pointer to an array of xmlChar */
        -:13848:    int n_cur;
        -:13849:
    #####:13850:    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    #####:13851:        mem_base = xmlMemBlocks();
    #####:13852:        cur = gen_const_xmlChar_ptr(n_cur, 0);
        -:13853:
    #####:13854:        ret_val = xmlParseDoc((const xmlChar *)cur);
    #####:13855:        desret_xmlDocPtr(ret_val);
    #####:13856:        call_tests++;
    #####:13857:        des_const_xmlChar_ptr(n_cur, (const xmlChar *)cur, 0);
    #####:13858:        xmlResetLastError();
    #####:13859:        if (mem_base != xmlMemBlocks()) {
    #####:13860:            printf("Leak of %d blocks found in xmlParseDoc",
    #####:13861:	           xmlMemBlocks() - mem_base);
    #####:13862:	    test_ret++;
    #####:13863:            printf(" %d", n_cur);
    #####:13864:            printf("\n");
        -:13865:        }
        -:13866:    }
    #####:13867:    function_tests++;
        -:13868:#endif
        -:13869:#endif
        -:13870:
    #####:13871:    return(test_ret);
        -:13872:}
        -:13873:
        -:13874:
        -:13875:static int
    #####:13876:test_xmlParseDocument(void) {
    #####:13877:    int test_ret = 0;
        -:13878:
        -:13879:    int mem_base;
        -:13880:    int ret_val;
        -:13881:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:13882:    int n_ctxt;
        -:13883:
    #####:13884:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:13885:        mem_base = xmlMemBlocks();
    #####:13886:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        -:13887:
    #####:13888:        ret_val = xmlParseDocument(ctxt);
    #####:13889:        if (ctxt != NULL) {xmlFreeDoc(ctxt->myDoc); ctxt->myDoc = NULL;}
    #####:13890:        desret_int(ret_val);
    #####:13891:        call_tests++;
    #####:13892:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:13893:        xmlResetLastError();
    #####:13894:        if (mem_base != xmlMemBlocks()) {
    #####:13895:            printf("Leak of %d blocks found in xmlParseDocument",
    #####:13896:	           xmlMemBlocks() - mem_base);
    #####:13897:	    test_ret++;
    #####:13898:            printf(" %d", n_ctxt);
    #####:13899:            printf("\n");
        -:13900:        }
        -:13901:    }
    #####:13902:    function_tests++;
        -:13903:
    #####:13904:    return(test_ret);
        -:13905:}
        -:13906:
        -:13907:
        -:13908:static int
    #####:13909:test_xmlParseEntity(void) {
    #####:13910:    int test_ret = 0;
        -:13911:
        -:13912:#if defined(LIBXML_SAX1_ENABLED)
        -:13913:#ifdef LIBXML_SAX1_ENABLED
        -:13914:    int mem_base;
        -:13915:    xmlDocPtr ret_val;
        -:13916:    const char * filename; /* the filename */
        -:13917:    int n_filename;
        -:13918:
    #####:13919:    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    #####:13920:        mem_base = xmlMemBlocks();
    #####:13921:        filename = gen_filepath(n_filename, 0);
        -:13922:
    #####:13923:        ret_val = xmlParseEntity(filename);
    #####:13924:        desret_xmlDocPtr(ret_val);
    #####:13925:        call_tests++;
    #####:13926:        des_filepath(n_filename, filename, 0);
    #####:13927:        xmlResetLastError();
    #####:13928:        if (mem_base != xmlMemBlocks()) {
    #####:13929:            printf("Leak of %d blocks found in xmlParseEntity",
    #####:13930:	           xmlMemBlocks() - mem_base);
    #####:13931:	    test_ret++;
    #####:13932:            printf(" %d", n_filename);
    #####:13933:            printf("\n");
        -:13934:        }
        -:13935:    }
    #####:13936:    function_tests++;
        -:13937:#endif
        -:13938:#endif
        -:13939:
    #####:13940:    return(test_ret);
        -:13941:}
        -:13942:
        -:13943:
        -:13944:static int
    #####:13945:test_xmlParseExtParsedEnt(void) {
    #####:13946:    int test_ret = 0;
        -:13947:
        -:13948:    int mem_base;
        -:13949:    int ret_val;
        -:13950:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:13951:    int n_ctxt;
        -:13952:
    #####:13953:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:13954:        mem_base = xmlMemBlocks();
    #####:13955:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        -:13956:
    #####:13957:        ret_val = xmlParseExtParsedEnt(ctxt);
    #####:13958:        if (ctxt != NULL) {xmlFreeDoc(ctxt->myDoc); ctxt->myDoc = NULL;}
    #####:13959:        desret_int(ret_val);
    #####:13960:        call_tests++;
    #####:13961:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:13962:        xmlResetLastError();
    #####:13963:        if (mem_base != xmlMemBlocks()) {
    #####:13964:            printf("Leak of %d blocks found in xmlParseExtParsedEnt",
    #####:13965:	           xmlMemBlocks() - mem_base);
    #####:13966:	    test_ret++;
    #####:13967:            printf(" %d", n_ctxt);
    #####:13968:            printf("\n");
        -:13969:        }
        -:13970:    }
    #####:13971:    function_tests++;
        -:13972:
    #####:13973:    return(test_ret);
        -:13974:}
        -:13975:
        -:13976:
        -:13977:static int
    #####:13978:test_xmlParseExternalEntity(void) {
    #####:13979:    int test_ret = 0;
        -:13980:
        -:13981:#if defined(LIBXML_SAX1_ENABLED)
        -:13982:#ifdef LIBXML_SAX1_ENABLED
        -:13983:    int mem_base;
        -:13984:    int ret_val;
        -:13985:    xmlDocPtr doc; /* the document the chunk pertains to */
        -:13986:    int n_doc;
        -:13987:    xmlSAXHandlerPtr sax; /* the SAX handler bloc (possibly NULL) */
        -:13988:    int n_sax;
        -:13989:    void * user_data; /* The user data returned on SAX callbacks (possibly NULL) */
        -:13990:    int n_user_data;
        -:13991:    int depth; /* Used for loop detection, use 0 */
        -:13992:    int n_depth;
        -:13993:    xmlChar * URL; /* the URL for the entity to load */
        -:13994:    int n_URL;
        -:13995:    xmlChar * ID; /* the System ID for the entity to load */
        -:13996:    int n_ID;
        -:13997:    xmlNodePtr * lst; /* the return value for the set of parsed nodes */
        -:13998:    int n_lst;
        -:13999:
    #####:14000:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:14001:    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    #####:14002:    for (n_user_data = 0;n_user_data < gen_nb_userdata;n_user_data++) {
    #####:14003:    for (n_depth = 0;n_depth < gen_nb_int;n_depth++) {
    #####:14004:    for (n_URL = 0;n_URL < gen_nb_const_xmlChar_ptr;n_URL++) {
    #####:14005:    for (n_ID = 0;n_ID < gen_nb_const_xmlChar_ptr;n_ID++) {
    #####:14006:    for (n_lst = 0;n_lst < gen_nb_xmlNodePtr_ptr;n_lst++) {
    #####:14007:        mem_base = xmlMemBlocks();
    #####:14008:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:14009:        sax = gen_xmlSAXHandlerPtr(n_sax, 1);
    #####:14010:        user_data = gen_userdata(n_user_data, 2);
    #####:14011:        depth = gen_int(n_depth, 3);
    #####:14012:        URL = gen_const_xmlChar_ptr(n_URL, 4);
    #####:14013:        ID = gen_const_xmlChar_ptr(n_ID, 5);
    #####:14014:        lst = gen_xmlNodePtr_ptr(n_lst, 6);
        -:14015:
    #####:14016:        ret_val = xmlParseExternalEntity(doc, sax, user_data, depth, (const xmlChar *)URL, (const xmlChar *)ID, lst);
    #####:14017:        desret_int(ret_val);
    #####:14018:        call_tests++;
    #####:14019:        des_xmlDocPtr(n_doc, doc, 0);
    #####:14020:        des_xmlSAXHandlerPtr(n_sax, sax, 1);
    #####:14021:        des_userdata(n_user_data, user_data, 2);
    #####:14022:        des_int(n_depth, depth, 3);
    #####:14023:        des_const_xmlChar_ptr(n_URL, (const xmlChar *)URL, 4);
    #####:14024:        des_const_xmlChar_ptr(n_ID, (const xmlChar *)ID, 5);
    #####:14025:        des_xmlNodePtr_ptr(n_lst, lst, 6);
    #####:14026:        xmlResetLastError();
    #####:14027:        if (mem_base != xmlMemBlocks()) {
    #####:14028:            printf("Leak of %d blocks found in xmlParseExternalEntity",
    #####:14029:	           xmlMemBlocks() - mem_base);
    #####:14030:	    test_ret++;
    #####:14031:            printf(" %d", n_doc);
    #####:14032:            printf(" %d", n_sax);
    #####:14033:            printf(" %d", n_user_data);
    #####:14034:            printf(" %d", n_depth);
    #####:14035:            printf(" %d", n_URL);
    #####:14036:            printf(" %d", n_ID);
    #####:14037:            printf(" %d", n_lst);
    #####:14038:            printf("\n");
        -:14039:        }
        -:14040:    }
        -:14041:    }
        -:14042:    }
        -:14043:    }
        -:14044:    }
        -:14045:    }
        -:14046:    }
    #####:14047:    function_tests++;
        -:14048:#endif
        -:14049:#endif
        -:14050:
    #####:14051:    return(test_ret);
        -:14052:}
        -:14053:
        -:14054:
        -:14055:static int
    #####:14056:test_xmlParseFile(void) {
    #####:14057:    int test_ret = 0;
        -:14058:
        -:14059:#if defined(LIBXML_SAX1_ENABLED)
        -:14060:#ifdef LIBXML_SAX1_ENABLED
        -:14061:    int mem_base;
        -:14062:    xmlDocPtr ret_val;
        -:14063:    const char * filename; /* the filename */
        -:14064:    int n_filename;
        -:14065:
    #####:14066:    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    #####:14067:        mem_base = xmlMemBlocks();
    #####:14068:        filename = gen_filepath(n_filename, 0);
        -:14069:
    #####:14070:        ret_val = xmlParseFile(filename);
    #####:14071:        desret_xmlDocPtr(ret_val);
    #####:14072:        call_tests++;
    #####:14073:        des_filepath(n_filename, filename, 0);
    #####:14074:        xmlResetLastError();
    #####:14075:        if (mem_base != xmlMemBlocks()) {
    #####:14076:            printf("Leak of %d blocks found in xmlParseFile",
    #####:14077:	           xmlMemBlocks() - mem_base);
    #####:14078:	    test_ret++;
    #####:14079:            printf(" %d", n_filename);
    #####:14080:            printf("\n");
        -:14081:        }
        -:14082:    }
    #####:14083:    function_tests++;
        -:14084:#endif
        -:14085:#endif
        -:14086:
    #####:14087:    return(test_ret);
        -:14088:}
        -:14089:
        -:14090:
        -:14091:static int
    #####:14092:test_xmlParseInNodeContext(void) {
    #####:14093:    int test_ret = 0;
        -:14094:
        -:14095:    int mem_base;
        -:14096:    xmlParserErrors ret_val;
        -:14097:    xmlNodePtr node; /* the context node */
        -:14098:    int n_node;
        -:14099:    char * data; /* the input string */
        -:14100:    int n_data;
        -:14101:    int datalen; /* the input string length in bytes */
        -:14102:    int n_datalen;
        -:14103:    int options; /* a combination of xmlParserOption */
        -:14104:    int n_options;
        -:14105:    xmlNodePtr * lst; /* the return value for the set of parsed nodes */
        -:14106:    int n_lst;
        -:14107:
    #####:14108:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:14109:    for (n_data = 0;n_data < gen_nb_const_char_ptr;n_data++) {
    #####:14110:    for (n_datalen = 0;n_datalen < gen_nb_int;n_datalen++) {
    #####:14111:    for (n_options = 0;n_options < gen_nb_parseroptions;n_options++) {
    #####:14112:    for (n_lst = 0;n_lst < gen_nb_xmlNodePtr_ptr;n_lst++) {
    #####:14113:        mem_base = xmlMemBlocks();
    #####:14114:        node = gen_xmlNodePtr(n_node, 0);
    #####:14115:        data = gen_const_char_ptr(n_data, 1);
    #####:14116:        datalen = gen_int(n_datalen, 2);
    #####:14117:        options = gen_parseroptions(n_options, 3);
    #####:14118:        lst = gen_xmlNodePtr_ptr(n_lst, 4);
        -:14119:
    #####:14120:        ret_val = xmlParseInNodeContext(node, (const char *)data, datalen, options, lst);
    #####:14121:        desret_xmlParserErrors(ret_val);
    #####:14122:        call_tests++;
    #####:14123:        des_xmlNodePtr(n_node, node, 0);
    #####:14124:        des_const_char_ptr(n_data, (const char *)data, 1);
    #####:14125:        des_int(n_datalen, datalen, 2);
    #####:14126:        des_parseroptions(n_options, options, 3);
    #####:14127:        des_xmlNodePtr_ptr(n_lst, lst, 4);
    #####:14128:        xmlResetLastError();
    #####:14129:        if (mem_base != xmlMemBlocks()) {
    #####:14130:            printf("Leak of %d blocks found in xmlParseInNodeContext",
    #####:14131:	           xmlMemBlocks() - mem_base);
    #####:14132:	    test_ret++;
    #####:14133:            printf(" %d", n_node);
    #####:14134:            printf(" %d", n_data);
    #####:14135:            printf(" %d", n_datalen);
    #####:14136:            printf(" %d", n_options);
    #####:14137:            printf(" %d", n_lst);
    #####:14138:            printf("\n");
        -:14139:        }
        -:14140:    }
        -:14141:    }
        -:14142:    }
        -:14143:    }
        -:14144:    }
    #####:14145:    function_tests++;
        -:14146:
    #####:14147:    return(test_ret);
        -:14148:}
        -:14149:
        -:14150:
        -:14151:static int
    #####:14152:test_xmlParseMemory(void) {
    #####:14153:    int test_ret = 0;
        -:14154:
        -:14155:#if defined(LIBXML_SAX1_ENABLED)
        -:14156:#ifdef LIBXML_SAX1_ENABLED
        -:14157:    int mem_base;
        -:14158:    xmlDocPtr ret_val;
        -:14159:    char * buffer; /* an pointer to a char array */
        -:14160:    int n_buffer;
        -:14161:    int size; /* the size of the array */
        -:14162:    int n_size;
        -:14163:
    #####:14164:    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    #####:14165:    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    #####:14166:        mem_base = xmlMemBlocks();
    #####:14167:        buffer = gen_const_char_ptr(n_buffer, 0);
    #####:14168:        size = gen_int(n_size, 1);
        -:14169:
    #####:14170:        ret_val = xmlParseMemory((const char *)buffer, size);
    #####:14171:        desret_xmlDocPtr(ret_val);
    #####:14172:        call_tests++;
    #####:14173:        des_const_char_ptr(n_buffer, (const char *)buffer, 0);
    #####:14174:        des_int(n_size, size, 1);
    #####:14175:        xmlResetLastError();
    #####:14176:        if (mem_base != xmlMemBlocks()) {
    #####:14177:            printf("Leak of %d blocks found in xmlParseMemory",
    #####:14178:	           xmlMemBlocks() - mem_base);
    #####:14179:	    test_ret++;
    #####:14180:            printf(" %d", n_buffer);
    #####:14181:            printf(" %d", n_size);
    #####:14182:            printf("\n");
        -:14183:        }
        -:14184:    }
        -:14185:    }
    #####:14186:    function_tests++;
        -:14187:#endif
        -:14188:#endif
        -:14189:
    #####:14190:    return(test_ret);
        -:14191:}
        -:14192:
        -:14193:
        -:14194:#define gen_nb_const_xmlParserNodeInfoPtr 1
    #####:14195:static xmlParserNodeInfoPtr gen_const_xmlParserNodeInfoPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:14196:    return(NULL);
        -:14197:}
    #####:14198:static void des_const_xmlParserNodeInfoPtr(int no ATTRIBUTE_UNUSED, const xmlParserNodeInfoPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:14199:}
        -:14200:
        -:14201:static int
    #####:14202:test_xmlParserAddNodeInfo(void) {
    #####:14203:    int test_ret = 0;
        -:14204:
        -:14205:    int mem_base;
        -:14206:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:14207:    int n_ctxt;
        -:14208:    xmlParserNodeInfoPtr info; /* a node info sequence pointer */
        -:14209:    int n_info;
        -:14210:
    #####:14211:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:14212:    for (n_info = 0;n_info < gen_nb_const_xmlParserNodeInfoPtr;n_info++) {
    #####:14213:        mem_base = xmlMemBlocks();
    #####:14214:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
    #####:14215:        info = gen_const_xmlParserNodeInfoPtr(n_info, 1);
        -:14216:
    #####:14217:        xmlParserAddNodeInfo(ctxt, (const xmlParserNodeInfoPtr)info);
    #####:14218:        call_tests++;
    #####:14219:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:14220:        des_const_xmlParserNodeInfoPtr(n_info, (const xmlParserNodeInfoPtr)info, 1);
    #####:14221:        xmlResetLastError();
    #####:14222:        if (mem_base != xmlMemBlocks()) {
    #####:14223:            printf("Leak of %d blocks found in xmlParserAddNodeInfo",
    #####:14224:	           xmlMemBlocks() - mem_base);
    #####:14225:	    test_ret++;
    #####:14226:            printf(" %d", n_ctxt);
    #####:14227:            printf(" %d", n_info);
    #####:14228:            printf("\n");
        -:14229:        }
        -:14230:    }
        -:14231:    }
    #####:14232:    function_tests++;
        -:14233:
    #####:14234:    return(test_ret);
        -:14235:}
        -:14236:
        -:14237:
        -:14238:#define gen_nb_const_xmlParserCtxtPtr 1
    #####:14239:static xmlParserCtxtPtr gen_const_xmlParserCtxtPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:14240:    return(NULL);
        -:14241:}
    #####:14242:static void des_const_xmlParserCtxtPtr(int no ATTRIBUTE_UNUSED, const xmlParserCtxtPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:14243:}
        -:14244:
        -:14245:#define gen_nb_const_xmlNodePtr 1
    #####:14246:static xmlNodePtr gen_const_xmlNodePtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:14247:    return(NULL);
        -:14248:}
    #####:14249:static void des_const_xmlNodePtr(int no ATTRIBUTE_UNUSED, const xmlNodePtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:14250:}
        -:14251:
        -:14252:static int
    #####:14253:test_xmlParserFindNodeInfo(void) {
    #####:14254:    int test_ret = 0;
        -:14255:
        -:14256:    int mem_base;
        -:14257:    const xmlParserNodeInfo * ret_val;
        -:14258:    xmlParserCtxtPtr ctx; /* an XML parser context */
        -:14259:    int n_ctx;
        -:14260:    xmlNodePtr node; /* an XML node within the tree */
        -:14261:    int n_node;
        -:14262:
    #####:14263:    for (n_ctx = 0;n_ctx < gen_nb_const_xmlParserCtxtPtr;n_ctx++) {
    #####:14264:    for (n_node = 0;n_node < gen_nb_const_xmlNodePtr;n_node++) {
    #####:14265:        mem_base = xmlMemBlocks();
    #####:14266:        ctx = gen_const_xmlParserCtxtPtr(n_ctx, 0);
    #####:14267:        node = gen_const_xmlNodePtr(n_node, 1);
        -:14268:
    #####:14269:        ret_val = xmlParserFindNodeInfo((const xmlParserCtxtPtr)ctx, (const xmlNodePtr)node);
    #####:14270:        desret_const_xmlParserNodeInfo_ptr(ret_val);
    #####:14271:        call_tests++;
    #####:14272:        des_const_xmlParserCtxtPtr(n_ctx, (const xmlParserCtxtPtr)ctx, 0);
    #####:14273:        des_const_xmlNodePtr(n_node, (const xmlNodePtr)node, 1);
    #####:14274:        xmlResetLastError();
    #####:14275:        if (mem_base != xmlMemBlocks()) {
    #####:14276:            printf("Leak of %d blocks found in xmlParserFindNodeInfo",
    #####:14277:	           xmlMemBlocks() - mem_base);
    #####:14278:	    test_ret++;
    #####:14279:            printf(" %d", n_ctx);
    #####:14280:            printf(" %d", n_node);
    #####:14281:            printf("\n");
        -:14282:        }
        -:14283:    }
        -:14284:    }
    #####:14285:    function_tests++;
        -:14286:
    #####:14287:    return(test_ret);
        -:14288:}
        -:14289:
        -:14290:
        -:14291:#define gen_nb_const_xmlParserNodeInfoSeqPtr 1
    #####:14292:static xmlParserNodeInfoSeqPtr gen_const_xmlParserNodeInfoSeqPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:14293:    return(NULL);
        -:14294:}
    #####:14295:static void des_const_xmlParserNodeInfoSeqPtr(int no ATTRIBUTE_UNUSED, const xmlParserNodeInfoSeqPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:14296:}
        -:14297:
        -:14298:static int
    #####:14299:test_xmlParserFindNodeInfoIndex(void) {
    #####:14300:    int test_ret = 0;
        -:14301:
        -:14302:    int mem_base;
        -:14303:    unsigned long ret_val;
        -:14304:    xmlParserNodeInfoSeqPtr seq; /* a node info sequence pointer */
        -:14305:    int n_seq;
        -:14306:    xmlNodePtr node; /* an XML node pointer */
        -:14307:    int n_node;
        -:14308:
    #####:14309:    for (n_seq = 0;n_seq < gen_nb_const_xmlParserNodeInfoSeqPtr;n_seq++) {
    #####:14310:    for (n_node = 0;n_node < gen_nb_const_xmlNodePtr;n_node++) {
    #####:14311:        mem_base = xmlMemBlocks();
    #####:14312:        seq = gen_const_xmlParserNodeInfoSeqPtr(n_seq, 0);
    #####:14313:        node = gen_const_xmlNodePtr(n_node, 1);
        -:14314:
    #####:14315:        ret_val = xmlParserFindNodeInfoIndex((const xmlParserNodeInfoSeqPtr)seq, (const xmlNodePtr)node);
    #####:14316:        desret_unsigned_long(ret_val);
    #####:14317:        call_tests++;
    #####:14318:        des_const_xmlParserNodeInfoSeqPtr(n_seq, (const xmlParserNodeInfoSeqPtr)seq, 0);
    #####:14319:        des_const_xmlNodePtr(n_node, (const xmlNodePtr)node, 1);
    #####:14320:        xmlResetLastError();
    #####:14321:        if (mem_base != xmlMemBlocks()) {
    #####:14322:            printf("Leak of %d blocks found in xmlParserFindNodeInfoIndex",
    #####:14323:	           xmlMemBlocks() - mem_base);
    #####:14324:	    test_ret++;
    #####:14325:            printf(" %d", n_seq);
    #####:14326:            printf(" %d", n_node);
    #####:14327:            printf("\n");
        -:14328:        }
        -:14329:    }
        -:14330:    }
    #####:14331:    function_tests++;
        -:14332:
    #####:14333:    return(test_ret);
        -:14334:}
        -:14335:
        -:14336:
        -:14337:#define gen_nb_xmlParserInputPtr 1
    #####:14338:static xmlParserInputPtr gen_xmlParserInputPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:14339:    return(NULL);
        -:14340:}
    #####:14341:static void des_xmlParserInputPtr(int no ATTRIBUTE_UNUSED, xmlParserInputPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:14342:}
        -:14343:
        -:14344:static int
    #####:14345:test_xmlParserInputGrow(void) {
    #####:14346:    int test_ret = 0;
        -:14347:
        -:14348:    int mem_base;
        -:14349:    int ret_val;
        -:14350:    xmlParserInputPtr in; /* an XML parser input */
        -:14351:    int n_in;
        -:14352:    int len; /* an indicative size for the lookahead */
        -:14353:    int n_len;
        -:14354:
    #####:14355:    for (n_in = 0;n_in < gen_nb_xmlParserInputPtr;n_in++) {
    #####:14356:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:14357:        mem_base = xmlMemBlocks();
    #####:14358:        in = gen_xmlParserInputPtr(n_in, 0);
    #####:14359:        len = gen_int(n_len, 1);
        -:14360:
    #####:14361:        ret_val = xmlParserInputGrow(in, len);
    #####:14362:        desret_int(ret_val);
    #####:14363:        call_tests++;
    #####:14364:        des_xmlParserInputPtr(n_in, in, 0);
    #####:14365:        des_int(n_len, len, 1);
    #####:14366:        xmlResetLastError();
    #####:14367:        if (mem_base != xmlMemBlocks()) {
    #####:14368:            printf("Leak of %d blocks found in xmlParserInputGrow",
    #####:14369:	           xmlMemBlocks() - mem_base);
    #####:14370:	    test_ret++;
    #####:14371:            printf(" %d", n_in);
    #####:14372:            printf(" %d", n_len);
    #####:14373:            printf("\n");
        -:14374:        }
        -:14375:    }
        -:14376:    }
    #####:14377:    function_tests++;
        -:14378:
    #####:14379:    return(test_ret);
        -:14380:}
        -:14381:
        -:14382:
        -:14383:static int
    #####:14384:test_xmlParserInputRead(void) {
    #####:14385:    int test_ret = 0;
        -:14386:
        -:14387:    int mem_base;
        -:14388:    int ret_val;
        -:14389:    xmlParserInputPtr in; /* an XML parser input */
        -:14390:    int n_in;
        -:14391:    int len; /* an indicative size for the lookahead */
        -:14392:    int n_len;
        -:14393:
    #####:14394:    for (n_in = 0;n_in < gen_nb_xmlParserInputPtr;n_in++) {
    #####:14395:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:14396:        mem_base = xmlMemBlocks();
    #####:14397:        in = gen_xmlParserInputPtr(n_in, 0);
    #####:14398:        len = gen_int(n_len, 1);
        -:14399:
    #####:14400:        ret_val = xmlParserInputRead(in, len);
    #####:14401:        desret_int(ret_val);
    #####:14402:        call_tests++;
    #####:14403:        des_xmlParserInputPtr(n_in, in, 0);
    #####:14404:        des_int(n_len, len, 1);
    #####:14405:        xmlResetLastError();
    #####:14406:        if (mem_base != xmlMemBlocks()) {
    #####:14407:            printf("Leak of %d blocks found in xmlParserInputRead",
    #####:14408:	           xmlMemBlocks() - mem_base);
    #####:14409:	    test_ret++;
    #####:14410:            printf(" %d", n_in);
    #####:14411:            printf(" %d", n_len);
    #####:14412:            printf("\n");
        -:14413:        }
        -:14414:    }
        -:14415:    }
    #####:14416:    function_tests++;
        -:14417:
    #####:14418:    return(test_ret);
        -:14419:}
        -:14420:
        -:14421:
        -:14422:static int
    #####:14423:test_xmlPedanticParserDefault(void) {
    #####:14424:    int test_ret = 0;
        -:14425:
        -:14426:    int mem_base;
        -:14427:    int ret_val;
        -:14428:    int val; /* int 0 or 1 */
        -:14429:    int n_val;
        -:14430:
    #####:14431:    for (n_val = 0;n_val < gen_nb_int;n_val++) {
    #####:14432:        mem_base = xmlMemBlocks();
    #####:14433:        val = gen_int(n_val, 0);
        -:14434:
    #####:14435:        ret_val = xmlPedanticParserDefault(val);
    #####:14436:        desret_int(ret_val);
    #####:14437:        call_tests++;
    #####:14438:        des_int(n_val, val, 0);
    #####:14439:        xmlResetLastError();
    #####:14440:        if (mem_base != xmlMemBlocks()) {
    #####:14441:            printf("Leak of %d blocks found in xmlPedanticParserDefault",
    #####:14442:	           xmlMemBlocks() - mem_base);
    #####:14443:	    test_ret++;
    #####:14444:            printf(" %d", n_val);
    #####:14445:            printf("\n");
        -:14446:        }
        -:14447:    }
    #####:14448:    function_tests++;
        -:14449:
    #####:14450:    return(test_ret);
        -:14451:}
        -:14452:
        -:14453:
        -:14454:static int
    #####:14455:test_xmlReadDoc(void) {
    #####:14456:    int test_ret = 0;
        -:14457:
        -:14458:    int mem_base;
        -:14459:    xmlDocPtr ret_val;
        -:14460:    xmlChar * cur; /* a pointer to a zero terminated string */
        -:14461:    int n_cur;
        -:14462:    const char * URL; /* the base URL to use for the document */
        -:14463:    int n_URL;
        -:14464:    char * encoding; /* the document encoding, or NULL */
        -:14465:    int n_encoding;
        -:14466:    int options; /* a combination of xmlParserOption */
        -:14467:    int n_options;
        -:14468:
    #####:14469:    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    #####:14470:    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    #####:14471:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####:14472:    for (n_options = 0;n_options < gen_nb_parseroptions;n_options++) {
    #####:14473:        mem_base = xmlMemBlocks();
    #####:14474:        cur = gen_const_xmlChar_ptr(n_cur, 0);
    #####:14475:        URL = gen_filepath(n_URL, 1);
    #####:14476:        encoding = gen_const_char_ptr(n_encoding, 2);
    #####:14477:        options = gen_parseroptions(n_options, 3);
        -:14478:
    #####:14479:        ret_val = xmlReadDoc((const xmlChar *)cur, URL, (const char *)encoding, options);
    #####:14480:        desret_xmlDocPtr(ret_val);
    #####:14481:        call_tests++;
    #####:14482:        des_const_xmlChar_ptr(n_cur, (const xmlChar *)cur, 0);
    #####:14483:        des_filepath(n_URL, URL, 1);
    #####:14484:        des_const_char_ptr(n_encoding, (const char *)encoding, 2);
    #####:14485:        des_parseroptions(n_options, options, 3);
    #####:14486:        xmlResetLastError();
    #####:14487:        if (mem_base != xmlMemBlocks()) {
    #####:14488:            printf("Leak of %d blocks found in xmlReadDoc",
    #####:14489:	           xmlMemBlocks() - mem_base);
    #####:14490:	    test_ret++;
    #####:14491:            printf(" %d", n_cur);
    #####:14492:            printf(" %d", n_URL);
    #####:14493:            printf(" %d", n_encoding);
    #####:14494:            printf(" %d", n_options);
    #####:14495:            printf("\n");
        -:14496:        }
        -:14497:    }
        -:14498:    }
        -:14499:    }
        -:14500:    }
    #####:14501:    function_tests++;
        -:14502:
    #####:14503:    return(test_ret);
        -:14504:}
        -:14505:
        -:14506:
        -:14507:static int
    #####:14508:test_xmlReadFile(void) {
    #####:14509:    int test_ret = 0;
        -:14510:
        -:14511:    int mem_base;
        -:14512:    xmlDocPtr ret_val;
        -:14513:    const char * filename; /* a file or URL */
        -:14514:    int n_filename;
        -:14515:    char * encoding; /* the document encoding, or NULL */
        -:14516:    int n_encoding;
        -:14517:    int options; /* a combination of xmlParserOption */
        -:14518:    int n_options;
        -:14519:
    #####:14520:    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    #####:14521:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####:14522:    for (n_options = 0;n_options < gen_nb_parseroptions;n_options++) {
    #####:14523:        mem_base = xmlMemBlocks();
    #####:14524:        filename = gen_filepath(n_filename, 0);
    #####:14525:        encoding = gen_const_char_ptr(n_encoding, 1);
    #####:14526:        options = gen_parseroptions(n_options, 2);
        -:14527:
    #####:14528:        ret_val = xmlReadFile(filename, (const char *)encoding, options);
    #####:14529:        desret_xmlDocPtr(ret_val);
    #####:14530:        call_tests++;
    #####:14531:        des_filepath(n_filename, filename, 0);
    #####:14532:        des_const_char_ptr(n_encoding, (const char *)encoding, 1);
    #####:14533:        des_parseroptions(n_options, options, 2);
    #####:14534:        xmlResetLastError();
    #####:14535:        if (mem_base != xmlMemBlocks()) {
    #####:14536:            printf("Leak of %d blocks found in xmlReadFile",
    #####:14537:	           xmlMemBlocks() - mem_base);
    #####:14538:	    test_ret++;
    #####:14539:            printf(" %d", n_filename);
    #####:14540:            printf(" %d", n_encoding);
    #####:14541:            printf(" %d", n_options);
    #####:14542:            printf("\n");
        -:14543:        }
        -:14544:    }
        -:14545:    }
        -:14546:    }
    #####:14547:    function_tests++;
        -:14548:
    #####:14549:    return(test_ret);
        -:14550:}
        -:14551:
        -:14552:
        -:14553:static int
    #####:14554:test_xmlReadMemory(void) {
    #####:14555:    int test_ret = 0;
        -:14556:
        -:14557:    int mem_base;
        -:14558:    xmlDocPtr ret_val;
        -:14559:    char * buffer; /* a pointer to a char array */
        -:14560:    int n_buffer;
        -:14561:    int size; /* the size of the array */
        -:14562:    int n_size;
        -:14563:    const char * URL; /* the base URL to use for the document */
        -:14564:    int n_URL;
        -:14565:    char * encoding; /* the document encoding, or NULL */
        -:14566:    int n_encoding;
        -:14567:    int options; /* a combination of xmlParserOption */
        -:14568:    int n_options;
        -:14569:
    #####:14570:    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    #####:14571:    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    #####:14572:    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    #####:14573:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####:14574:    for (n_options = 0;n_options < gen_nb_parseroptions;n_options++) {
    #####:14575:        mem_base = xmlMemBlocks();
    #####:14576:        buffer = gen_const_char_ptr(n_buffer, 0);
    #####:14577:        size = gen_int(n_size, 1);
    #####:14578:        URL = gen_filepath(n_URL, 2);
    #####:14579:        encoding = gen_const_char_ptr(n_encoding, 3);
    #####:14580:        options = gen_parseroptions(n_options, 4);
        -:14581:
    #####:14582:        ret_val = xmlReadMemory((const char *)buffer, size, URL, (const char *)encoding, options);
    #####:14583:        desret_xmlDocPtr(ret_val);
    #####:14584:        call_tests++;
    #####:14585:        des_const_char_ptr(n_buffer, (const char *)buffer, 0);
    #####:14586:        des_int(n_size, size, 1);
    #####:14587:        des_filepath(n_URL, URL, 2);
    #####:14588:        des_const_char_ptr(n_encoding, (const char *)encoding, 3);
    #####:14589:        des_parseroptions(n_options, options, 4);
    #####:14590:        xmlResetLastError();
    #####:14591:        if (mem_base != xmlMemBlocks()) {
    #####:14592:            printf("Leak of %d blocks found in xmlReadMemory",
    #####:14593:	           xmlMemBlocks() - mem_base);
    #####:14594:	    test_ret++;
    #####:14595:            printf(" %d", n_buffer);
    #####:14596:            printf(" %d", n_size);
    #####:14597:            printf(" %d", n_URL);
    #####:14598:            printf(" %d", n_encoding);
    #####:14599:            printf(" %d", n_options);
    #####:14600:            printf("\n");
        -:14601:        }
        -:14602:    }
        -:14603:    }
        -:14604:    }
        -:14605:    }
        -:14606:    }
    #####:14607:    function_tests++;
        -:14608:
    #####:14609:    return(test_ret);
        -:14610:}
        -:14611:
        -:14612:
        -:14613:static int
    #####:14614:test_xmlRecoverDoc(void) {
    #####:14615:    int test_ret = 0;
        -:14616:
        -:14617:#if defined(LIBXML_SAX1_ENABLED)
        -:14618:#ifdef LIBXML_SAX1_ENABLED
        -:14619:    int mem_base;
        -:14620:    xmlDocPtr ret_val;
        -:14621:    xmlChar * cur; /* a pointer to an array of xmlChar */
        -:14622:    int n_cur;
        -:14623:
    #####:14624:    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    #####:14625:        mem_base = xmlMemBlocks();
    #####:14626:        cur = gen_const_xmlChar_ptr(n_cur, 0);
        -:14627:
    #####:14628:        ret_val = xmlRecoverDoc((const xmlChar *)cur);
    #####:14629:        desret_xmlDocPtr(ret_val);
    #####:14630:        call_tests++;
    #####:14631:        des_const_xmlChar_ptr(n_cur, (const xmlChar *)cur, 0);
    #####:14632:        xmlResetLastError();
    #####:14633:        if (mem_base != xmlMemBlocks()) {
    #####:14634:            printf("Leak of %d blocks found in xmlRecoverDoc",
    #####:14635:	           xmlMemBlocks() - mem_base);
    #####:14636:	    test_ret++;
    #####:14637:            printf(" %d", n_cur);
    #####:14638:            printf("\n");
        -:14639:        }
        -:14640:    }
    #####:14641:    function_tests++;
        -:14642:#endif
        -:14643:#endif
        -:14644:
    #####:14645:    return(test_ret);
        -:14646:}
        -:14647:
        -:14648:
        -:14649:static int
    #####:14650:test_xmlRecoverFile(void) {
    #####:14651:    int test_ret = 0;
        -:14652:
        -:14653:#if defined(LIBXML_SAX1_ENABLED)
        -:14654:#ifdef LIBXML_SAX1_ENABLED
        -:14655:    int mem_base;
        -:14656:    xmlDocPtr ret_val;
        -:14657:    const char * filename; /* the filename */
        -:14658:    int n_filename;
        -:14659:
    #####:14660:    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    #####:14661:        mem_base = xmlMemBlocks();
    #####:14662:        filename = gen_filepath(n_filename, 0);
        -:14663:
    #####:14664:        ret_val = xmlRecoverFile(filename);
    #####:14665:        desret_xmlDocPtr(ret_val);
    #####:14666:        call_tests++;
    #####:14667:        des_filepath(n_filename, filename, 0);
    #####:14668:        xmlResetLastError();
    #####:14669:        if (mem_base != xmlMemBlocks()) {
    #####:14670:            printf("Leak of %d blocks found in xmlRecoverFile",
    #####:14671:	           xmlMemBlocks() - mem_base);
    #####:14672:	    test_ret++;
    #####:14673:            printf(" %d", n_filename);
    #####:14674:            printf("\n");
        -:14675:        }
        -:14676:    }
    #####:14677:    function_tests++;
        -:14678:#endif
        -:14679:#endif
        -:14680:
    #####:14681:    return(test_ret);
        -:14682:}
        -:14683:
        -:14684:
        -:14685:static int
    #####:14686:test_xmlRecoverMemory(void) {
    #####:14687:    int test_ret = 0;
        -:14688:
        -:14689:#if defined(LIBXML_SAX1_ENABLED)
        -:14690:#ifdef LIBXML_SAX1_ENABLED
        -:14691:    int mem_base;
        -:14692:    xmlDocPtr ret_val;
        -:14693:    char * buffer; /* an pointer to a char array */
        -:14694:    int n_buffer;
        -:14695:    int size; /* the size of the array */
        -:14696:    int n_size;
        -:14697:
    #####:14698:    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    #####:14699:    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    #####:14700:        mem_base = xmlMemBlocks();
    #####:14701:        buffer = gen_const_char_ptr(n_buffer, 0);
    #####:14702:        size = gen_int(n_size, 1);
        -:14703:
    #####:14704:        ret_val = xmlRecoverMemory((const char *)buffer, size);
    #####:14705:        desret_xmlDocPtr(ret_val);
    #####:14706:        call_tests++;
    #####:14707:        des_const_char_ptr(n_buffer, (const char *)buffer, 0);
    #####:14708:        des_int(n_size, size, 1);
    #####:14709:        xmlResetLastError();
    #####:14710:        if (mem_base != xmlMemBlocks()) {
    #####:14711:            printf("Leak of %d blocks found in xmlRecoverMemory",
    #####:14712:	           xmlMemBlocks() - mem_base);
    #####:14713:	    test_ret++;
    #####:14714:            printf(" %d", n_buffer);
    #####:14715:            printf(" %d", n_size);
    #####:14716:            printf("\n");
        -:14717:        }
        -:14718:    }
        -:14719:    }
    #####:14720:    function_tests++;
        -:14721:#endif
        -:14722:#endif
        -:14723:
    #####:14724:    return(test_ret);
        -:14725:}
        -:14726:
        -:14727:
        -:14728:static int
    #####:14729:test_xmlSAXParseDTD(void) {
    #####:14730:    int test_ret = 0;
        -:14731:
        -:14732:#if defined(LIBXML_VALID_ENABLED)
        -:14733:#ifdef LIBXML_SAX1_ENABLED
        -:14734:    int mem_base;
        -:14735:    xmlDtdPtr ret_val;
        -:14736:    xmlSAXHandlerPtr sax; /* the SAX handler block */
        -:14737:    int n_sax;
        -:14738:    xmlChar * ExternalID; /* a NAME* containing the External ID of the DTD */
        -:14739:    int n_ExternalID;
        -:14740:    xmlChar * SystemID; /* a NAME* containing the URL to the DTD */
        -:14741:    int n_SystemID;
        -:14742:
    #####:14743:    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    #####:14744:    for (n_ExternalID = 0;n_ExternalID < gen_nb_const_xmlChar_ptr;n_ExternalID++) {
    #####:14745:    for (n_SystemID = 0;n_SystemID < gen_nb_const_xmlChar_ptr;n_SystemID++) {
    #####:14746:        mem_base = xmlMemBlocks();
    #####:14747:        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
    #####:14748:        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 1);
    #####:14749:        SystemID = gen_const_xmlChar_ptr(n_SystemID, 2);
        -:14750:
    #####:14751:        ret_val = xmlSAXParseDTD(sax, (const xmlChar *)ExternalID, (const xmlChar *)SystemID);
    #####:14752:        desret_xmlDtdPtr(ret_val);
    #####:14753:        call_tests++;
    #####:14754:        des_xmlSAXHandlerPtr(n_sax, sax, 0);
    #####:14755:        des_const_xmlChar_ptr(n_ExternalID, (const xmlChar *)ExternalID, 1);
    #####:14756:        des_const_xmlChar_ptr(n_SystemID, (const xmlChar *)SystemID, 2);
    #####:14757:        xmlResetLastError();
    #####:14758:        if (mem_base != xmlMemBlocks()) {
    #####:14759:            printf("Leak of %d blocks found in xmlSAXParseDTD",
    #####:14760:	           xmlMemBlocks() - mem_base);
    #####:14761:	    test_ret++;
    #####:14762:            printf(" %d", n_sax);
    #####:14763:            printf(" %d", n_ExternalID);
    #####:14764:            printf(" %d", n_SystemID);
    #####:14765:            printf("\n");
        -:14766:        }
        -:14767:    }
        -:14768:    }
        -:14769:    }
    #####:14770:    function_tests++;
        -:14771:#endif
        -:14772:#endif
        -:14773:
    #####:14774:    return(test_ret);
        -:14775:}
        -:14776:
        -:14777:
        -:14778:static int
    #####:14779:test_xmlSAXParseDoc(void) {
    #####:14780:    int test_ret = 0;
        -:14781:
        -:14782:#if defined(LIBXML_SAX1_ENABLED)
        -:14783:#ifdef LIBXML_SAX1_ENABLED
        -:14784:    int mem_base;
        -:14785:    xmlDocPtr ret_val;
        -:14786:    xmlSAXHandlerPtr sax; /* the SAX handler block */
        -:14787:    int n_sax;
        -:14788:    xmlChar * cur; /* a pointer to an array of xmlChar */
        -:14789:    int n_cur;
        -:14790:    int recovery; /* work in recovery mode, i.e. tries to read no Well Formed documents */
        -:14791:    int n_recovery;
        -:14792:
    #####:14793:    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    #####:14794:    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    #####:14795:    for (n_recovery = 0;n_recovery < gen_nb_int;n_recovery++) {
    #####:14796:        mem_base = xmlMemBlocks();
    #####:14797:        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
    #####:14798:        cur = gen_const_xmlChar_ptr(n_cur, 1);
    #####:14799:        recovery = gen_int(n_recovery, 2);
        -:14800:
    #####:14801:        ret_val = xmlSAXParseDoc(sax, (const xmlChar *)cur, recovery);
    #####:14802:        desret_xmlDocPtr(ret_val);
    #####:14803:        call_tests++;
    #####:14804:        des_xmlSAXHandlerPtr(n_sax, sax, 0);
    #####:14805:        des_const_xmlChar_ptr(n_cur, (const xmlChar *)cur, 1);
    #####:14806:        des_int(n_recovery, recovery, 2);
    #####:14807:        xmlResetLastError();
    #####:14808:        if (mem_base != xmlMemBlocks()) {
    #####:14809:            printf("Leak of %d blocks found in xmlSAXParseDoc",
    #####:14810:	           xmlMemBlocks() - mem_base);
    #####:14811:	    test_ret++;
    #####:14812:            printf(" %d", n_sax);
    #####:14813:            printf(" %d", n_cur);
    #####:14814:            printf(" %d", n_recovery);
    #####:14815:            printf("\n");
        -:14816:        }
        -:14817:    }
        -:14818:    }
        -:14819:    }
    #####:14820:    function_tests++;
        -:14821:#endif
        -:14822:#endif
        -:14823:
    #####:14824:    return(test_ret);
        -:14825:}
        -:14826:
        -:14827:
        -:14828:static int
    #####:14829:test_xmlSAXParseEntity(void) {
    #####:14830:    int test_ret = 0;
        -:14831:
        -:14832:#if defined(LIBXML_SAX1_ENABLED)
        -:14833:#ifdef LIBXML_SAX1_ENABLED
        -:14834:    int mem_base;
        -:14835:    xmlDocPtr ret_val;
        -:14836:    xmlSAXHandlerPtr sax; /* the SAX handler block */
        -:14837:    int n_sax;
        -:14838:    const char * filename; /* the filename */
        -:14839:    int n_filename;
        -:14840:
    #####:14841:    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    #####:14842:    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    #####:14843:        mem_base = xmlMemBlocks();
    #####:14844:        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
    #####:14845:        filename = gen_filepath(n_filename, 1);
        -:14846:
    #####:14847:        ret_val = xmlSAXParseEntity(sax, filename);
    #####:14848:        desret_xmlDocPtr(ret_val);
    #####:14849:        call_tests++;
    #####:14850:        des_xmlSAXHandlerPtr(n_sax, sax, 0);
    #####:14851:        des_filepath(n_filename, filename, 1);
    #####:14852:        xmlResetLastError();
    #####:14853:        if (mem_base != xmlMemBlocks()) {
    #####:14854:            printf("Leak of %d blocks found in xmlSAXParseEntity",
    #####:14855:	           xmlMemBlocks() - mem_base);
    #####:14856:	    test_ret++;
    #####:14857:            printf(" %d", n_sax);
    #####:14858:            printf(" %d", n_filename);
    #####:14859:            printf("\n");
        -:14860:        }
        -:14861:    }
        -:14862:    }
    #####:14863:    function_tests++;
        -:14864:#endif
        -:14865:#endif
        -:14866:
    #####:14867:    return(test_ret);
        -:14868:}
        -:14869:
        -:14870:
        -:14871:static int
    #####:14872:test_xmlSAXParseFile(void) {
    #####:14873:    int test_ret = 0;
        -:14874:
        -:14875:#if defined(LIBXML_SAX1_ENABLED)
        -:14876:#ifdef LIBXML_SAX1_ENABLED
        -:14877:    int mem_base;
        -:14878:    xmlDocPtr ret_val;
        -:14879:    xmlSAXHandlerPtr sax; /* the SAX handler block */
        -:14880:    int n_sax;
        -:14881:    const char * filename; /* the filename */
        -:14882:    int n_filename;
        -:14883:    int recovery; /* work in recovery mode, i.e. tries to read no Well Formed documents */
        -:14884:    int n_recovery;
        -:14885:
    #####:14886:    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    #####:14887:    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    #####:14888:    for (n_recovery = 0;n_recovery < gen_nb_int;n_recovery++) {
    #####:14889:        mem_base = xmlMemBlocks();
    #####:14890:        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
    #####:14891:        filename = gen_filepath(n_filename, 1);
    #####:14892:        recovery = gen_int(n_recovery, 2);
        -:14893:
    #####:14894:        ret_val = xmlSAXParseFile(sax, filename, recovery);
    #####:14895:        desret_xmlDocPtr(ret_val);
    #####:14896:        call_tests++;
    #####:14897:        des_xmlSAXHandlerPtr(n_sax, sax, 0);
    #####:14898:        des_filepath(n_filename, filename, 1);
    #####:14899:        des_int(n_recovery, recovery, 2);
    #####:14900:        xmlResetLastError();
    #####:14901:        if (mem_base != xmlMemBlocks()) {
    #####:14902:            printf("Leak of %d blocks found in xmlSAXParseFile",
    #####:14903:	           xmlMemBlocks() - mem_base);
    #####:14904:	    test_ret++;
    #####:14905:            printf(" %d", n_sax);
    #####:14906:            printf(" %d", n_filename);
    #####:14907:            printf(" %d", n_recovery);
    #####:14908:            printf("\n");
        -:14909:        }
        -:14910:    }
        -:14911:    }
        -:14912:    }
    #####:14913:    function_tests++;
        -:14914:#endif
        -:14915:#endif
        -:14916:
    #####:14917:    return(test_ret);
        -:14918:}
        -:14919:
        -:14920:
        -:14921:static int
    #####:14922:test_xmlSAXParseFileWithData(void) {
    #####:14923:    int test_ret = 0;
        -:14924:
        -:14925:#if defined(LIBXML_SAX1_ENABLED)
        -:14926:#ifdef LIBXML_SAX1_ENABLED
        -:14927:    int mem_base;
        -:14928:    xmlDocPtr ret_val;
        -:14929:    xmlSAXHandlerPtr sax; /* the SAX handler block */
        -:14930:    int n_sax;
        -:14931:    const char * filename; /* the filename */
        -:14932:    int n_filename;
        -:14933:    int recovery; /* work in recovery mode, i.e. tries to read no Well Formed documents */
        -:14934:    int n_recovery;
        -:14935:    void * data; /* the userdata */
        -:14936:    int n_data;
        -:14937:
    #####:14938:    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    #####:14939:    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    #####:14940:    for (n_recovery = 0;n_recovery < gen_nb_int;n_recovery++) {
    #####:14941:    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
    #####:14942:        mem_base = xmlMemBlocks();
    #####:14943:        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
    #####:14944:        filename = gen_filepath(n_filename, 1);
    #####:14945:        recovery = gen_int(n_recovery, 2);
    #####:14946:        data = gen_userdata(n_data, 3);
        -:14947:
    #####:14948:        ret_val = xmlSAXParseFileWithData(sax, filename, recovery, data);
    #####:14949:        desret_xmlDocPtr(ret_val);
    #####:14950:        call_tests++;
    #####:14951:        des_xmlSAXHandlerPtr(n_sax, sax, 0);
    #####:14952:        des_filepath(n_filename, filename, 1);
    #####:14953:        des_int(n_recovery, recovery, 2);
    #####:14954:        des_userdata(n_data, data, 3);
    #####:14955:        xmlResetLastError();
    #####:14956:        if (mem_base != xmlMemBlocks()) {
    #####:14957:            printf("Leak of %d blocks found in xmlSAXParseFileWithData",
    #####:14958:	           xmlMemBlocks() - mem_base);
    #####:14959:	    test_ret++;
    #####:14960:            printf(" %d", n_sax);
    #####:14961:            printf(" %d", n_filename);
    #####:14962:            printf(" %d", n_recovery);
    #####:14963:            printf(" %d", n_data);
    #####:14964:            printf("\n");
        -:14965:        }
        -:14966:    }
        -:14967:    }
        -:14968:    }
        -:14969:    }
    #####:14970:    function_tests++;
        -:14971:#endif
        -:14972:#endif
        -:14973:
    #####:14974:    return(test_ret);
        -:14975:}
        -:14976:
        -:14977:
        -:14978:static int
    #####:14979:test_xmlSAXParseMemory(void) {
    #####:14980:    int test_ret = 0;
        -:14981:
        -:14982:#if defined(LIBXML_SAX1_ENABLED)
        -:14983:#ifdef LIBXML_SAX1_ENABLED
        -:14984:    int mem_base;
        -:14985:    xmlDocPtr ret_val;
        -:14986:    xmlSAXHandlerPtr sax; /* the SAX handler block */
        -:14987:    int n_sax;
        -:14988:    char * buffer; /* an pointer to a char array */
        -:14989:    int n_buffer;
        -:14990:    int size; /* the size of the array */
        -:14991:    int n_size;
        -:14992:    int recovery; /* work in recovery mode, i.e. tries to read not Well Formed documents */
        -:14993:    int n_recovery;
        -:14994:
    #####:14995:    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    #####:14996:    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    #####:14997:    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    #####:14998:    for (n_recovery = 0;n_recovery < gen_nb_int;n_recovery++) {
    #####:14999:        mem_base = xmlMemBlocks();
    #####:15000:        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
    #####:15001:        buffer = gen_const_char_ptr(n_buffer, 1);
    #####:15002:        size = gen_int(n_size, 2);
    #####:15003:        recovery = gen_int(n_recovery, 3);
        -:15004:
    #####:15005:        ret_val = xmlSAXParseMemory(sax, (const char *)buffer, size, recovery);
    #####:15006:        desret_xmlDocPtr(ret_val);
    #####:15007:        call_tests++;
    #####:15008:        des_xmlSAXHandlerPtr(n_sax, sax, 0);
    #####:15009:        des_const_char_ptr(n_buffer, (const char *)buffer, 1);
    #####:15010:        des_int(n_size, size, 2);
    #####:15011:        des_int(n_recovery, recovery, 3);
    #####:15012:        xmlResetLastError();
    #####:15013:        if (mem_base != xmlMemBlocks()) {
    #####:15014:            printf("Leak of %d blocks found in xmlSAXParseMemory",
    #####:15015:	           xmlMemBlocks() - mem_base);
    #####:15016:	    test_ret++;
    #####:15017:            printf(" %d", n_sax);
    #####:15018:            printf(" %d", n_buffer);
    #####:15019:            printf(" %d", n_size);
    #####:15020:            printf(" %d", n_recovery);
    #####:15021:            printf("\n");
        -:15022:        }
        -:15023:    }
        -:15024:    }
        -:15025:    }
        -:15026:    }
    #####:15027:    function_tests++;
        -:15028:#endif
        -:15029:#endif
        -:15030:
    #####:15031:    return(test_ret);
        -:15032:}
        -:15033:
        -:15034:
        -:15035:static int
    #####:15036:test_xmlSAXParseMemoryWithData(void) {
    #####:15037:    int test_ret = 0;
        -:15038:
        -:15039:#if defined(LIBXML_SAX1_ENABLED)
        -:15040:#ifdef LIBXML_SAX1_ENABLED
        -:15041:    int mem_base;
        -:15042:    xmlDocPtr ret_val;
        -:15043:    xmlSAXHandlerPtr sax; /* the SAX handler block */
        -:15044:    int n_sax;
        -:15045:    char * buffer; /* an pointer to a char array */
        -:15046:    int n_buffer;
        -:15047:    int size; /* the size of the array */
        -:15048:    int n_size;
        -:15049:    int recovery; /* work in recovery mode, i.e. tries to read no Well Formed documents */
        -:15050:    int n_recovery;
        -:15051:    void * data; /* the userdata */
        -:15052:    int n_data;
        -:15053:
    #####:15054:    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    #####:15055:    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    #####:15056:    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    #####:15057:    for (n_recovery = 0;n_recovery < gen_nb_int;n_recovery++) {
    #####:15058:    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
    #####:15059:        mem_base = xmlMemBlocks();
    #####:15060:        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
    #####:15061:        buffer = gen_const_char_ptr(n_buffer, 1);
    #####:15062:        size = gen_int(n_size, 2);
    #####:15063:        recovery = gen_int(n_recovery, 3);
    #####:15064:        data = gen_userdata(n_data, 4);
        -:15065:
    #####:15066:        ret_val = xmlSAXParseMemoryWithData(sax, (const char *)buffer, size, recovery, data);
    #####:15067:        desret_xmlDocPtr(ret_val);
    #####:15068:        call_tests++;
    #####:15069:        des_xmlSAXHandlerPtr(n_sax, sax, 0);
    #####:15070:        des_const_char_ptr(n_buffer, (const char *)buffer, 1);
    #####:15071:        des_int(n_size, size, 2);
    #####:15072:        des_int(n_recovery, recovery, 3);
    #####:15073:        des_userdata(n_data, data, 4);
    #####:15074:        xmlResetLastError();
    #####:15075:        if (mem_base != xmlMemBlocks()) {
    #####:15076:            printf("Leak of %d blocks found in xmlSAXParseMemoryWithData",
    #####:15077:	           xmlMemBlocks() - mem_base);
    #####:15078:	    test_ret++;
    #####:15079:            printf(" %d", n_sax);
    #####:15080:            printf(" %d", n_buffer);
    #####:15081:            printf(" %d", n_size);
    #####:15082:            printf(" %d", n_recovery);
    #####:15083:            printf(" %d", n_data);
    #####:15084:            printf("\n");
        -:15085:        }
        -:15086:    }
        -:15087:    }
        -:15088:    }
        -:15089:    }
        -:15090:    }
    #####:15091:    function_tests++;
        -:15092:#endif
        -:15093:#endif
        -:15094:
    #####:15095:    return(test_ret);
        -:15096:}
        -:15097:
        -:15098:
        -:15099:static int
    #####:15100:test_xmlSAXUserParseFile(void) {
    #####:15101:    int test_ret = 0;
        -:15102:
        -:15103:#if defined(LIBXML_SAX1_ENABLED)
        -:15104:#ifdef LIBXML_SAX1_ENABLED
        -:15105:    int mem_base;
        -:15106:    int ret_val;
        -:15107:    xmlSAXHandlerPtr sax; /* a SAX handler */
        -:15108:    int n_sax;
        -:15109:    void * user_data; /* The user data returned on SAX callbacks */
        -:15110:    int n_user_data;
        -:15111:    const char * filename; /* a file name */
        -:15112:    int n_filename;
        -:15113:
    #####:15114:    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    #####:15115:    for (n_user_data = 0;n_user_data < gen_nb_userdata;n_user_data++) {
    #####:15116:    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    #####:15117:        mem_base = xmlMemBlocks();
    #####:15118:        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
    #####:15119:        user_data = gen_userdata(n_user_data, 1);
    #####:15120:        filename = gen_filepath(n_filename, 2);
        -:15121:        
        -:15122:#ifdef LIBXML_SAX1_ENABLED
    #####:15123:        if (sax == (xmlSAXHandlerPtr)&xmlDefaultSAXHandler) user_data = NULL;
        -:15124:#endif
        -:15125:
        -:15126:
    #####:15127:        ret_val = xmlSAXUserParseFile(sax, user_data, filename);
    #####:15128:        desret_int(ret_val);
    #####:15129:        call_tests++;
    #####:15130:        des_xmlSAXHandlerPtr(n_sax, sax, 0);
    #####:15131:        des_userdata(n_user_data, user_data, 1);
    #####:15132:        des_filepath(n_filename, filename, 2);
    #####:15133:        xmlResetLastError();
    #####:15134:        if (mem_base != xmlMemBlocks()) {
    #####:15135:            printf("Leak of %d blocks found in xmlSAXUserParseFile",
    #####:15136:	           xmlMemBlocks() - mem_base);
    #####:15137:	    test_ret++;
    #####:15138:            printf(" %d", n_sax);
    #####:15139:            printf(" %d", n_user_data);
    #####:15140:            printf(" %d", n_filename);
    #####:15141:            printf("\n");
        -:15142:        }
        -:15143:    }
        -:15144:    }
        -:15145:    }
    #####:15146:    function_tests++;
        -:15147:#endif
        -:15148:#endif
        -:15149:
    #####:15150:    return(test_ret);
        -:15151:}
        -:15152:
        -:15153:
        -:15154:static int
    #####:15155:test_xmlSAXUserParseMemory(void) {
    #####:15156:    int test_ret = 0;
        -:15157:
        -:15158:#if defined(LIBXML_SAX1_ENABLED)
        -:15159:#ifdef LIBXML_SAX1_ENABLED
        -:15160:    int mem_base;
        -:15161:    int ret_val;
        -:15162:    xmlSAXHandlerPtr sax; /* a SAX handler */
        -:15163:    int n_sax;
        -:15164:    void * user_data; /* The user data returned on SAX callbacks */
        -:15165:    int n_user_data;
        -:15166:    char * buffer; /* an in-memory XML document input */
        -:15167:    int n_buffer;
        -:15168:    int size; /* the length of the XML document in bytes */
        -:15169:    int n_size;
        -:15170:
    #####:15171:    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    #####:15172:    for (n_user_data = 0;n_user_data < gen_nb_userdata;n_user_data++) {
    #####:15173:    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    #####:15174:    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    #####:15175:        mem_base = xmlMemBlocks();
    #####:15176:        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
    #####:15177:        user_data = gen_userdata(n_user_data, 1);
    #####:15178:        buffer = gen_const_char_ptr(n_buffer, 2);
    #####:15179:        size = gen_int(n_size, 3);
        -:15180:        
        -:15181:#ifdef LIBXML_SAX1_ENABLED
    #####:15182:        if (sax == (xmlSAXHandlerPtr)&xmlDefaultSAXHandler) user_data = NULL;
        -:15183:#endif
        -:15184:
        -:15185:
    #####:15186:        ret_val = xmlSAXUserParseMemory(sax, user_data, (const char *)buffer, size);
    #####:15187:        desret_int(ret_val);
    #####:15188:        call_tests++;
    #####:15189:        des_xmlSAXHandlerPtr(n_sax, sax, 0);
    #####:15190:        des_userdata(n_user_data, user_data, 1);
    #####:15191:        des_const_char_ptr(n_buffer, (const char *)buffer, 2);
    #####:15192:        des_int(n_size, size, 3);
    #####:15193:        xmlResetLastError();
    #####:15194:        if (mem_base != xmlMemBlocks()) {
    #####:15195:            printf("Leak of %d blocks found in xmlSAXUserParseMemory",
    #####:15196:	           xmlMemBlocks() - mem_base);
    #####:15197:	    test_ret++;
    #####:15198:            printf(" %d", n_sax);
    #####:15199:            printf(" %d", n_user_data);
    #####:15200:            printf(" %d", n_buffer);
    #####:15201:            printf(" %d", n_size);
    #####:15202:            printf("\n");
        -:15203:        }
        -:15204:    }
        -:15205:    }
        -:15206:    }
        -:15207:    }
    #####:15208:    function_tests++;
        -:15209:#endif
        -:15210:#endif
        -:15211:
    #####:15212:    return(test_ret);
        -:15213:}
        -:15214:
        -:15215:
        -:15216:static int
    #####:15217:test_xmlSetExternalEntityLoader(void) {
    #####:15218:    int test_ret = 0;
        -:15219:
        -:15220:
        -:15221:    /* missing type support */
    #####:15222:    return(test_ret);
        -:15223:}
        -:15224:
        -:15225:
        -:15226:static int
    #####:15227:test_xmlSetFeature(void) {
    #####:15228:    int test_ret = 0;
        -:15229:
        -:15230:#if defined(LIBXML_LEGACY_ENABLED)
        -:15231:#ifdef LIBXML_LEGACY_ENABLED
        -:15232:    int mem_base;
        -:15233:    int ret_val;
        -:15234:    xmlParserCtxtPtr ctxt; /* an XML/HTML parser context */
        -:15235:    int n_ctxt;
        -:15236:    char * name; /* the feature name */
        -:15237:    int n_name;
        -:15238:    void * value; /* pointer to the location of the new value */
        -:15239:    int n_value;
        -:15240:
    #####:15241:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:15242:    for (n_name = 0;n_name < gen_nb_const_char_ptr;n_name++) {
    #####:15243:    for (n_value = 0;n_value < gen_nb_void_ptr;n_value++) {
    #####:15244:        mem_base = xmlMemBlocks();
    #####:15245:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
    #####:15246:        name = gen_const_char_ptr(n_name, 1);
    #####:15247:        value = gen_void_ptr(n_value, 2);
        -:15248:
    #####:15249:        ret_val = xmlSetFeature(ctxt, (const char *)name, value);
    #####:15250:        desret_int(ret_val);
    #####:15251:        call_tests++;
    #####:15252:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:15253:        des_const_char_ptr(n_name, (const char *)name, 1);
    #####:15254:        des_void_ptr(n_value, value, 2);
    #####:15255:        xmlResetLastError();
    #####:15256:        if (mem_base != xmlMemBlocks()) {
    #####:15257:            printf("Leak of %d blocks found in xmlSetFeature",
    #####:15258:	           xmlMemBlocks() - mem_base);
    #####:15259:	    test_ret++;
    #####:15260:            printf(" %d", n_ctxt);
    #####:15261:            printf(" %d", n_name);
    #####:15262:            printf(" %d", n_value);
    #####:15263:            printf("\n");
        -:15264:        }
        -:15265:    }
        -:15266:    }
        -:15267:    }
    #####:15268:    function_tests++;
        -:15269:#endif
        -:15270:#endif
        -:15271:
    #####:15272:    return(test_ret);
        -:15273:}
        -:15274:
        -:15275:
        -:15276:static int
    #####:15277:test_xmlSetupParserForBuffer(void) {
    #####:15278:    int test_ret = 0;
        -:15279:
        -:15280:#if defined(LIBXML_SAX1_ENABLED)
        -:15281:#ifdef LIBXML_SAX1_ENABLED
        -:15282:    int mem_base;
        -:15283:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:15284:    int n_ctxt;
        -:15285:    xmlChar * buffer; /* a xmlChar * buffer */
        -:15286:    int n_buffer;
        -:15287:    const char * filename; /* a file name */
        -:15288:    int n_filename;
        -:15289:
    #####:15290:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:15291:    for (n_buffer = 0;n_buffer < gen_nb_const_xmlChar_ptr;n_buffer++) {
    #####:15292:    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    #####:15293:        mem_base = xmlMemBlocks();
    #####:15294:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
    #####:15295:        buffer = gen_const_xmlChar_ptr(n_buffer, 1);
    #####:15296:        filename = gen_filepath(n_filename, 2);
        -:15297:
    #####:15298:        xmlSetupParserForBuffer(ctxt, (const xmlChar *)buffer, filename);
    #####:15299:        call_tests++;
    #####:15300:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:15301:        des_const_xmlChar_ptr(n_buffer, (const xmlChar *)buffer, 1);
    #####:15302:        des_filepath(n_filename, filename, 2);
    #####:15303:        xmlResetLastError();
    #####:15304:        if (mem_base != xmlMemBlocks()) {
    #####:15305:            printf("Leak of %d blocks found in xmlSetupParserForBuffer",
    #####:15306:	           xmlMemBlocks() - mem_base);
    #####:15307:	    test_ret++;
    #####:15308:            printf(" %d", n_ctxt);
    #####:15309:            printf(" %d", n_buffer);
    #####:15310:            printf(" %d", n_filename);
    #####:15311:            printf("\n");
        -:15312:        }
        -:15313:    }
        -:15314:    }
        -:15315:    }
    #####:15316:    function_tests++;
        -:15317:#endif
        -:15318:#endif
        -:15319:
    #####:15320:    return(test_ret);
        -:15321:}
        -:15322:
        -:15323:
        -:15324:static int
    #####:15325:test_xmlStopParser(void) {
    #####:15326:    int test_ret = 0;
        -:15327:
        -:15328:#ifdef LIBXML_PUSH_ENABLED
        -:15329:    int mem_base;
        -:15330:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:15331:    int n_ctxt;
        -:15332:
    #####:15333:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:15334:        mem_base = xmlMemBlocks();
    #####:15335:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        -:15336:
    #####:15337:        xmlStopParser(ctxt);
    #####:15338:        call_tests++;
    #####:15339:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:15340:        xmlResetLastError();
    #####:15341:        if (mem_base != xmlMemBlocks()) {
    #####:15342:            printf("Leak of %d blocks found in xmlStopParser",
    #####:15343:	           xmlMemBlocks() - mem_base);
    #####:15344:	    test_ret++;
    #####:15345:            printf(" %d", n_ctxt);
    #####:15346:            printf("\n");
        -:15347:        }
        -:15348:    }
    #####:15349:    function_tests++;
        -:15350:#endif
        -:15351:
    #####:15352:    return(test_ret);
        -:15353:}
        -:15354:
        -:15355:
        -:15356:static int
    #####:15357:test_xmlSubstituteEntitiesDefault(void) {
    #####:15358:    int test_ret = 0;
        -:15359:
        -:15360:    int mem_base;
        -:15361:    int ret_val;
        -:15362:    int val; /* int 0 or 1 */
        -:15363:    int n_val;
        -:15364:
    #####:15365:    for (n_val = 0;n_val < gen_nb_int;n_val++) {
    #####:15366:        mem_base = xmlMemBlocks();
    #####:15367:        val = gen_int(n_val, 0);
        -:15368:
    #####:15369:        ret_val = xmlSubstituteEntitiesDefault(val);
    #####:15370:        desret_int(ret_val);
    #####:15371:        call_tests++;
    #####:15372:        des_int(n_val, val, 0);
    #####:15373:        xmlResetLastError();
    #####:15374:        if (mem_base != xmlMemBlocks()) {
    #####:15375:            printf("Leak of %d blocks found in xmlSubstituteEntitiesDefault",
    #####:15376:	           xmlMemBlocks() - mem_base);
    #####:15377:	    test_ret++;
    #####:15378:            printf(" %d", n_val);
    #####:15379:            printf("\n");
        -:15380:        }
        -:15381:    }
    #####:15382:    function_tests++;
        -:15383:
    #####:15384:    return(test_ret);
        -:15385:}
        -:15386:
        -:15387:static int
    #####:15388:test_parser(void) {
    #####:15389:    int test_ret = 0;
        -:15390:
    #####:15391:    if (quiet == 0) printf("Testing parser : 61 of 70 functions ...\n");
    #####:15392:    test_ret += test_xmlByteConsumed();
    #####:15393:    test_ret += test_xmlClearNodeInfoSeq();
    #####:15394:    test_ret += test_xmlClearParserCtxt();
    #####:15395:    test_ret += test_xmlCreateDocParserCtxt();
    #####:15396:    test_ret += test_xmlCreatePushParserCtxt();
    #####:15397:    test_ret += test_xmlCtxtReadDoc();
    #####:15398:    test_ret += test_xmlCtxtReadFile();
    #####:15399:    test_ret += test_xmlCtxtReadMemory();
    #####:15400:    test_ret += test_xmlCtxtReset();
    #####:15401:    test_ret += test_xmlCtxtResetPush();
    #####:15402:    test_ret += test_xmlCtxtUseOptions();
    #####:15403:    test_ret += test_xmlGetExternalEntityLoader();
    #####:15404:    test_ret += test_xmlGetFeature();
    #####:15405:    test_ret += test_xmlGetFeaturesList();
    #####:15406:    test_ret += test_xmlHasFeature();
    #####:15407:    test_ret += test_xmlIOParseDTD();
    #####:15408:    test_ret += test_xmlInitNodeInfoSeq();
    #####:15409:    test_ret += test_xmlInitParser();
    #####:15410:    test_ret += test_xmlInitParserCtxt();
    #####:15411:    test_ret += test_xmlKeepBlanksDefault();
    #####:15412:    test_ret += test_xmlLineNumbersDefault();
    #####:15413:    test_ret += test_xmlLoadExternalEntity();
    #####:15414:    test_ret += test_xmlNewIOInputStream();
    #####:15415:    test_ret += test_xmlNewParserCtxt();
    #####:15416:    test_ret += test_xmlParseBalancedChunkMemory();
    #####:15417:    test_ret += test_xmlParseBalancedChunkMemoryRecover();
    #####:15418:    test_ret += test_xmlParseChunk();
    #####:15419:    test_ret += test_xmlParseCtxtExternalEntity();
    #####:15420:    test_ret += test_xmlParseDTD();
    #####:15421:    test_ret += test_xmlParseDoc();
    #####:15422:    test_ret += test_xmlParseDocument();
    #####:15423:    test_ret += test_xmlParseEntity();
    #####:15424:    test_ret += test_xmlParseExtParsedEnt();
    #####:15425:    test_ret += test_xmlParseExternalEntity();
    #####:15426:    test_ret += test_xmlParseFile();
    #####:15427:    test_ret += test_xmlParseInNodeContext();
    #####:15428:    test_ret += test_xmlParseMemory();
    #####:15429:    test_ret += test_xmlParserAddNodeInfo();
    #####:15430:    test_ret += test_xmlParserFindNodeInfo();
    #####:15431:    test_ret += test_xmlParserFindNodeInfoIndex();
    #####:15432:    test_ret += test_xmlParserInputGrow();
    #####:15433:    test_ret += test_xmlParserInputRead();
    #####:15434:    test_ret += test_xmlPedanticParserDefault();
    #####:15435:    test_ret += test_xmlReadDoc();
    #####:15436:    test_ret += test_xmlReadFile();
    #####:15437:    test_ret += test_xmlReadMemory();
    #####:15438:    test_ret += test_xmlRecoverDoc();
    #####:15439:    test_ret += test_xmlRecoverFile();
    #####:15440:    test_ret += test_xmlRecoverMemory();
    #####:15441:    test_ret += test_xmlSAXParseDTD();
    #####:15442:    test_ret += test_xmlSAXParseDoc();
    #####:15443:    test_ret += test_xmlSAXParseEntity();
    #####:15444:    test_ret += test_xmlSAXParseFile();
    #####:15445:    test_ret += test_xmlSAXParseFileWithData();
    #####:15446:    test_ret += test_xmlSAXParseMemory();
    #####:15447:    test_ret += test_xmlSAXParseMemoryWithData();
    #####:15448:    test_ret += test_xmlSAXUserParseFile();
    #####:15449:    test_ret += test_xmlSAXUserParseMemory();
    #####:15450:    test_ret += test_xmlSetExternalEntityLoader();
    #####:15451:    test_ret += test_xmlSetFeature();
    #####:15452:    test_ret += test_xmlSetupParserForBuffer();
    #####:15453:    test_ret += test_xmlStopParser();
    #####:15454:    test_ret += test_xmlSubstituteEntitiesDefault();
        -:15455:
    #####:15456:    if (test_ret != 0)
    #####:15457:	printf("Module parser: %d errors\n", test_ret);
    #####:15458:    return(test_ret);
        -:15459:}
        -:15460:
        -:15461:static int
    #####:15462:test_htmlCreateFileParserCtxt(void) {
    #####:15463:    int test_ret = 0;
        -:15464:
        -:15465:#if defined(LIBXML_HTML_ENABLED)
        -:15466:    int mem_base;
        -:15467:    htmlParserCtxtPtr ret_val;
        -:15468:    const char * filename; /* the filename */
        -:15469:    int n_filename;
        -:15470:    char * encoding; /* a free form C string describing the HTML document encoding, or NULL */
        -:15471:    int n_encoding;
        -:15472:
    #####:15473:    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    #####:15474:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####:15475:        mem_base = xmlMemBlocks();
    #####:15476:        filename = gen_fileoutput(n_filename, 0);
    #####:15477:        encoding = gen_const_char_ptr(n_encoding, 1);
        -:15478:
    #####:15479:        ret_val = htmlCreateFileParserCtxt(filename, (const char *)encoding);
    #####:15480:        desret_htmlParserCtxtPtr(ret_val);
    #####:15481:        call_tests++;
    #####:15482:        des_fileoutput(n_filename, filename, 0);
    #####:15483:        des_const_char_ptr(n_encoding, (const char *)encoding, 1);
    #####:15484:        xmlResetLastError();
    #####:15485:        if (mem_base != xmlMemBlocks()) {
    #####:15486:            printf("Leak of %d blocks found in htmlCreateFileParserCtxt",
    #####:15487:	           xmlMemBlocks() - mem_base);
    #####:15488:	    test_ret++;
    #####:15489:            printf(" %d", n_filename);
    #####:15490:            printf(" %d", n_encoding);
    #####:15491:            printf("\n");
        -:15492:        }
        -:15493:    }
        -:15494:    }
    #####:15495:    function_tests++;
        -:15496:#endif
        -:15497:
    #####:15498:    return(test_ret);
        -:15499:}
        -:15500:
        -:15501:
        -:15502:static int
    #####:15503:test_htmlInitAutoClose(void) {
    #####:15504:    int test_ret = 0;
        -:15505:
        -:15506:#if defined(LIBXML_HTML_ENABLED)
        -:15507:    int mem_base;
        -:15508:
    #####:15509:        mem_base = xmlMemBlocks();
        -:15510:
    #####:15511:        htmlInitAutoClose();
    #####:15512:        call_tests++;
    #####:15513:        xmlResetLastError();
    #####:15514:        if (mem_base != xmlMemBlocks()) {
    #####:15515:            printf("Leak of %d blocks found in htmlInitAutoClose",
    #####:15516:	           xmlMemBlocks() - mem_base);
    #####:15517:	    test_ret++;
    #####:15518:            printf("\n");
        -:15519:        }
    #####:15520:    function_tests++;
        -:15521:#endif
        -:15522:
    #####:15523:    return(test_ret);
        -:15524:}
        -:15525:
        -:15526:
        -:15527:static int
    #####:15528:test_inputPop(void) {
    #####:15529:    int test_ret = 0;
        -:15530:
        -:15531:    int mem_base;
        -:15532:    xmlParserInputPtr ret_val;
        -:15533:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:15534:    int n_ctxt;
        -:15535:
    #####:15536:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:15537:        mem_base = xmlMemBlocks();
    #####:15538:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        -:15539:
    #####:15540:        ret_val = inputPop(ctxt);
    #####:15541:        desret_xmlParserInputPtr(ret_val);
    #####:15542:        call_tests++;
    #####:15543:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:15544:        xmlResetLastError();
    #####:15545:        if (mem_base != xmlMemBlocks()) {
    #####:15546:            printf("Leak of %d blocks found in inputPop",
    #####:15547:	           xmlMemBlocks() - mem_base);
    #####:15548:	    test_ret++;
    #####:15549:            printf(" %d", n_ctxt);
    #####:15550:            printf("\n");
        -:15551:        }
        -:15552:    }
    #####:15553:    function_tests++;
        -:15554:
    #####:15555:    return(test_ret);
        -:15556:}
        -:15557:
        -:15558:
        -:15559:static int
    #####:15560:test_inputPush(void) {
    #####:15561:    int test_ret = 0;
        -:15562:
        -:15563:    int mem_base;
        -:15564:    int ret_val;
        -:15565:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:15566:    int n_ctxt;
        -:15567:    xmlParserInputPtr value; /* the parser input */
        -:15568:    int n_value;
        -:15569:
    #####:15570:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:15571:    for (n_value = 0;n_value < gen_nb_xmlParserInputPtr;n_value++) {
    #####:15572:        mem_base = xmlMemBlocks();
    #####:15573:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
    #####:15574:        value = gen_xmlParserInputPtr(n_value, 1);
        -:15575:
    #####:15576:        ret_val = inputPush(ctxt, value);
    #####:15577:        desret_int(ret_val);
    #####:15578:        call_tests++;
    #####:15579:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:15580:        des_xmlParserInputPtr(n_value, value, 1);
    #####:15581:        xmlResetLastError();
    #####:15582:        if (mem_base != xmlMemBlocks()) {
    #####:15583:            printf("Leak of %d blocks found in inputPush",
    #####:15584:	           xmlMemBlocks() - mem_base);
    #####:15585:	    test_ret++;
    #####:15586:            printf(" %d", n_ctxt);
    #####:15587:            printf(" %d", n_value);
    #####:15588:            printf("\n");
        -:15589:        }
        -:15590:    }
        -:15591:    }
    #####:15592:    function_tests++;
        -:15593:
    #####:15594:    return(test_ret);
        -:15595:}
        -:15596:
        -:15597:
        -:15598:static int
    #####:15599:test_namePop(void) {
    #####:15600:    int test_ret = 0;
        -:15601:
        -:15602:    int mem_base;
        -:15603:    const xmlChar * ret_val;
        -:15604:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:15605:    int n_ctxt;
        -:15606:
    #####:15607:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:15608:        mem_base = xmlMemBlocks();
    #####:15609:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        -:15610:
    #####:15611:        ret_val = namePop(ctxt);
    #####:15612:        desret_const_xmlChar_ptr(ret_val);
    #####:15613:        call_tests++;
    #####:15614:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:15615:        xmlResetLastError();
    #####:15616:        if (mem_base != xmlMemBlocks()) {
    #####:15617:            printf("Leak of %d blocks found in namePop",
    #####:15618:	           xmlMemBlocks() - mem_base);
    #####:15619:	    test_ret++;
    #####:15620:            printf(" %d", n_ctxt);
    #####:15621:            printf("\n");
        -:15622:        }
        -:15623:    }
    #####:15624:    function_tests++;
        -:15625:
    #####:15626:    return(test_ret);
        -:15627:}
        -:15628:
        -:15629:
        -:15630:static int
    #####:15631:test_namePush(void) {
    #####:15632:    int test_ret = 0;
        -:15633:
        -:15634:    int mem_base;
        -:15635:    int ret_val;
        -:15636:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:15637:    int n_ctxt;
        -:15638:    xmlChar * value; /* the element name */
        -:15639:    int n_value;
        -:15640:
    #####:15641:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:15642:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:15643:        mem_base = xmlMemBlocks();
    #####:15644:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
    #####:15645:        value = gen_const_xmlChar_ptr(n_value, 1);
        -:15646:
    #####:15647:        ret_val = namePush(ctxt, (const xmlChar *)value);
    #####:15648:        desret_int(ret_val);
    #####:15649:        call_tests++;
    #####:15650:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:15651:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 1);
    #####:15652:        xmlResetLastError();
    #####:15653:        if (mem_base != xmlMemBlocks()) {
    #####:15654:            printf("Leak of %d blocks found in namePush",
    #####:15655:	           xmlMemBlocks() - mem_base);
    #####:15656:	    test_ret++;
    #####:15657:            printf(" %d", n_ctxt);
    #####:15658:            printf(" %d", n_value);
    #####:15659:            printf("\n");
        -:15660:        }
        -:15661:    }
        -:15662:    }
    #####:15663:    function_tests++;
        -:15664:
    #####:15665:    return(test_ret);
        -:15666:}
        -:15667:
        -:15668:
        -:15669:static int
    #####:15670:test_nodePop(void) {
    #####:15671:    int test_ret = 0;
        -:15672:
        -:15673:    int mem_base;
        -:15674:    xmlNodePtr ret_val;
        -:15675:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:15676:    int n_ctxt;
        -:15677:
    #####:15678:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:15679:        mem_base = xmlMemBlocks();
    #####:15680:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        -:15681:
    #####:15682:        ret_val = nodePop(ctxt);
    #####:15683:        desret_xmlNodePtr(ret_val);
    #####:15684:        call_tests++;
    #####:15685:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:15686:        xmlResetLastError();
    #####:15687:        if (mem_base != xmlMemBlocks()) {
    #####:15688:            printf("Leak of %d blocks found in nodePop",
    #####:15689:	           xmlMemBlocks() - mem_base);
    #####:15690:	    test_ret++;
    #####:15691:            printf(" %d", n_ctxt);
    #####:15692:            printf("\n");
        -:15693:        }
        -:15694:    }
    #####:15695:    function_tests++;
        -:15696:
    #####:15697:    return(test_ret);
        -:15698:}
        -:15699:
        -:15700:
        -:15701:static int
    #####:15702:test_nodePush(void) {
    #####:15703:    int test_ret = 0;
        -:15704:
        -:15705:    int mem_base;
        -:15706:    int ret_val;
        -:15707:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:15708:    int n_ctxt;
        -:15709:    xmlNodePtr value; /* the element node */
        -:15710:    int n_value;
        -:15711:
    #####:15712:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:15713:    for (n_value = 0;n_value < gen_nb_xmlNodePtr;n_value++) {
    #####:15714:        mem_base = xmlMemBlocks();
    #####:15715:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
    #####:15716:        value = gen_xmlNodePtr(n_value, 1);
        -:15717:
    #####:15718:        ret_val = nodePush(ctxt, value);
    #####:15719:        desret_int(ret_val);
    #####:15720:        call_tests++;
    #####:15721:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:15722:        des_xmlNodePtr(n_value, value, 1);
    #####:15723:        xmlResetLastError();
    #####:15724:        if (mem_base != xmlMemBlocks()) {
    #####:15725:            printf("Leak of %d blocks found in nodePush",
    #####:15726:	           xmlMemBlocks() - mem_base);
    #####:15727:	    test_ret++;
    #####:15728:            printf(" %d", n_ctxt);
    #####:15729:            printf(" %d", n_value);
    #####:15730:            printf("\n");
        -:15731:        }
        -:15732:    }
        -:15733:    }
    #####:15734:    function_tests++;
        -:15735:
    #####:15736:    return(test_ret);
        -:15737:}
        -:15738:
        -:15739:
        -:15740:static int
    #####:15741:test_xmlCheckLanguageID(void) {
    #####:15742:    int test_ret = 0;
        -:15743:
        -:15744:    int mem_base;
        -:15745:    int ret_val;
        -:15746:    xmlChar * lang; /* pointer to the string value */
        -:15747:    int n_lang;
        -:15748:
    #####:15749:    for (n_lang = 0;n_lang < gen_nb_const_xmlChar_ptr;n_lang++) {
    #####:15750:        mem_base = xmlMemBlocks();
    #####:15751:        lang = gen_const_xmlChar_ptr(n_lang, 0);
        -:15752:
    #####:15753:        ret_val = xmlCheckLanguageID((const xmlChar *)lang);
    #####:15754:        desret_int(ret_val);
    #####:15755:        call_tests++;
    #####:15756:        des_const_xmlChar_ptr(n_lang, (const xmlChar *)lang, 0);
    #####:15757:        xmlResetLastError();
    #####:15758:        if (mem_base != xmlMemBlocks()) {
    #####:15759:            printf("Leak of %d blocks found in xmlCheckLanguageID",
    #####:15760:	           xmlMemBlocks() - mem_base);
    #####:15761:	    test_ret++;
    #####:15762:            printf(" %d", n_lang);
    #####:15763:            printf("\n");
        -:15764:        }
        -:15765:    }
    #####:15766:    function_tests++;
        -:15767:
    #####:15768:    return(test_ret);
        -:15769:}
        -:15770:
        -:15771:
        -:15772:static int
    #####:15773:test_xmlCopyChar(void) {
    #####:15774:    int test_ret = 0;
        -:15775:
        -:15776:    int mem_base;
        -:15777:    int ret_val;
        -:15778:    int len; /* Ignored, compatibility */
        -:15779:    int n_len;
        -:15780:    xmlChar * out; /* pointer to an array of xmlChar */
        -:15781:    int n_out;
        -:15782:    int val; /* the char value */
        -:15783:    int n_val;
        -:15784:
    #####:15785:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:15786:    for (n_out = 0;n_out < gen_nb_xmlChar_ptr;n_out++) {
    #####:15787:    for (n_val = 0;n_val < gen_nb_int;n_val++) {
    #####:15788:        mem_base = xmlMemBlocks();
    #####:15789:        len = gen_int(n_len, 0);
    #####:15790:        out = gen_xmlChar_ptr(n_out, 1);
    #####:15791:        val = gen_int(n_val, 2);
        -:15792:
    #####:15793:        ret_val = xmlCopyChar(len, out, val);
    #####:15794:        desret_int(ret_val);
    #####:15795:        call_tests++;
    #####:15796:        des_int(n_len, len, 0);
    #####:15797:        des_xmlChar_ptr(n_out, out, 1);
    #####:15798:        des_int(n_val, val, 2);
    #####:15799:        xmlResetLastError();
    #####:15800:        if (mem_base != xmlMemBlocks()) {
    #####:15801:            printf("Leak of %d blocks found in xmlCopyChar",
    #####:15802:	           xmlMemBlocks() - mem_base);
    #####:15803:	    test_ret++;
    #####:15804:            printf(" %d", n_len);
    #####:15805:            printf(" %d", n_out);
    #####:15806:            printf(" %d", n_val);
    #####:15807:            printf("\n");
        -:15808:        }
        -:15809:    }
        -:15810:    }
        -:15811:    }
    #####:15812:    function_tests++;
        -:15813:
    #####:15814:    return(test_ret);
        -:15815:}
        -:15816:
        -:15817:
        -:15818:static int
    #####:15819:test_xmlCopyCharMultiByte(void) {
    #####:15820:    int test_ret = 0;
        -:15821:
        -:15822:    int mem_base;
        -:15823:    int ret_val;
        -:15824:    xmlChar * out; /* pointer to an array of xmlChar */
        -:15825:    int n_out;
        -:15826:    int val; /* the char value */
        -:15827:    int n_val;
        -:15828:
    #####:15829:    for (n_out = 0;n_out < gen_nb_xmlChar_ptr;n_out++) {
    #####:15830:    for (n_val = 0;n_val < gen_nb_int;n_val++) {
    #####:15831:        mem_base = xmlMemBlocks();
    #####:15832:        out = gen_xmlChar_ptr(n_out, 0);
    #####:15833:        val = gen_int(n_val, 1);
        -:15834:
    #####:15835:        ret_val = xmlCopyCharMultiByte(out, val);
    #####:15836:        desret_int(ret_val);
    #####:15837:        call_tests++;
    #####:15838:        des_xmlChar_ptr(n_out, out, 0);
    #####:15839:        des_int(n_val, val, 1);
    #####:15840:        xmlResetLastError();
    #####:15841:        if (mem_base != xmlMemBlocks()) {
    #####:15842:            printf("Leak of %d blocks found in xmlCopyCharMultiByte",
    #####:15843:	           xmlMemBlocks() - mem_base);
    #####:15844:	    test_ret++;
    #####:15845:            printf(" %d", n_out);
    #####:15846:            printf(" %d", n_val);
    #####:15847:            printf("\n");
        -:15848:        }
        -:15849:    }
        -:15850:    }
    #####:15851:    function_tests++;
        -:15852:
    #####:15853:    return(test_ret);
        -:15854:}
        -:15855:
        -:15856:
        -:15857:static int
    #####:15858:test_xmlCreateEntityParserCtxt(void) {
    #####:15859:    int test_ret = 0;
        -:15860:
        -:15861:    int mem_base;
        -:15862:    xmlParserCtxtPtr ret_val;
        -:15863:    xmlChar * URL; /* the entity URL */
        -:15864:    int n_URL;
        -:15865:    xmlChar * ID; /* the entity PUBLIC ID */
        -:15866:    int n_ID;
        -:15867:    xmlChar * base; /* a possible base for the target URI */
        -:15868:    int n_base;
        -:15869:
    #####:15870:    for (n_URL = 0;n_URL < gen_nb_const_xmlChar_ptr;n_URL++) {
    #####:15871:    for (n_ID = 0;n_ID < gen_nb_const_xmlChar_ptr;n_ID++) {
    #####:15872:    for (n_base = 0;n_base < gen_nb_const_xmlChar_ptr;n_base++) {
    #####:15873:        mem_base = xmlMemBlocks();
    #####:15874:        URL = gen_const_xmlChar_ptr(n_URL, 0);
    #####:15875:        ID = gen_const_xmlChar_ptr(n_ID, 1);
    #####:15876:        base = gen_const_xmlChar_ptr(n_base, 2);
        -:15877:
    #####:15878:        ret_val = xmlCreateEntityParserCtxt((const xmlChar *)URL, (const xmlChar *)ID, (const xmlChar *)base);
    #####:15879:        desret_xmlParserCtxtPtr(ret_val);
    #####:15880:        call_tests++;
    #####:15881:        des_const_xmlChar_ptr(n_URL, (const xmlChar *)URL, 0);
    #####:15882:        des_const_xmlChar_ptr(n_ID, (const xmlChar *)ID, 1);
    #####:15883:        des_const_xmlChar_ptr(n_base, (const xmlChar *)base, 2);
    #####:15884:        xmlResetLastError();
    #####:15885:        if (mem_base != xmlMemBlocks()) {
    #####:15886:            printf("Leak of %d blocks found in xmlCreateEntityParserCtxt",
    #####:15887:	           xmlMemBlocks() - mem_base);
    #####:15888:	    test_ret++;
    #####:15889:            printf(" %d", n_URL);
    #####:15890:            printf(" %d", n_ID);
    #####:15891:            printf(" %d", n_base);
    #####:15892:            printf("\n");
        -:15893:        }
        -:15894:    }
        -:15895:    }
        -:15896:    }
    #####:15897:    function_tests++;
        -:15898:
    #####:15899:    return(test_ret);
        -:15900:}
        -:15901:
        -:15902:
        -:15903:static int
    #####:15904:test_xmlCreateFileParserCtxt(void) {
    #####:15905:    int test_ret = 0;
        -:15906:
        -:15907:    int mem_base;
        -:15908:    xmlParserCtxtPtr ret_val;
        -:15909:    const char * filename; /* the filename */
        -:15910:    int n_filename;
        -:15911:
    #####:15912:    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    #####:15913:        mem_base = xmlMemBlocks();
    #####:15914:        filename = gen_fileoutput(n_filename, 0);
        -:15915:
    #####:15916:        ret_val = xmlCreateFileParserCtxt(filename);
    #####:15917:        desret_xmlParserCtxtPtr(ret_val);
    #####:15918:        call_tests++;
    #####:15919:        des_fileoutput(n_filename, filename, 0);
    #####:15920:        xmlResetLastError();
    #####:15921:        if (mem_base != xmlMemBlocks()) {
    #####:15922:            printf("Leak of %d blocks found in xmlCreateFileParserCtxt",
    #####:15923:	           xmlMemBlocks() - mem_base);
    #####:15924:	    test_ret++;
    #####:15925:            printf(" %d", n_filename);
    #####:15926:            printf("\n");
        -:15927:        }
        -:15928:    }
    #####:15929:    function_tests++;
        -:15930:
    #####:15931:    return(test_ret);
        -:15932:}
        -:15933:
        -:15934:
        -:15935:static int
    #####:15936:test_xmlCreateMemoryParserCtxt(void) {
    #####:15937:    int test_ret = 0;
        -:15938:
        -:15939:    int mem_base;
        -:15940:    xmlParserCtxtPtr ret_val;
        -:15941:    char * buffer; /* a pointer to a char array */
        -:15942:    int n_buffer;
        -:15943:    int size; /* the size of the array */
        -:15944:    int n_size;
        -:15945:
    #####:15946:    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    #####:15947:    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    #####:15948:        mem_base = xmlMemBlocks();
    #####:15949:        buffer = gen_const_char_ptr(n_buffer, 0);
    #####:15950:        size = gen_int(n_size, 1);
        -:15951:
    #####:15952:        ret_val = xmlCreateMemoryParserCtxt((const char *)buffer, size);
    #####:15953:        desret_xmlParserCtxtPtr(ret_val);
    #####:15954:        call_tests++;
    #####:15955:        des_const_char_ptr(n_buffer, (const char *)buffer, 0);
    #####:15956:        des_int(n_size, size, 1);
    #####:15957:        xmlResetLastError();
    #####:15958:        if (mem_base != xmlMemBlocks()) {
    #####:15959:            printf("Leak of %d blocks found in xmlCreateMemoryParserCtxt",
    #####:15960:	           xmlMemBlocks() - mem_base);
    #####:15961:	    test_ret++;
    #####:15962:            printf(" %d", n_buffer);
    #####:15963:            printf(" %d", n_size);
    #####:15964:            printf("\n");
        -:15965:        }
        -:15966:    }
        -:15967:    }
    #####:15968:    function_tests++;
        -:15969:
    #####:15970:    return(test_ret);
        -:15971:}
        -:15972:
        -:15973:
        -:15974:static int
    #####:15975:test_xmlCreateURLParserCtxt(void) {
    #####:15976:    int test_ret = 0;
        -:15977:
        -:15978:    int mem_base;
        -:15979:    xmlParserCtxtPtr ret_val;
        -:15980:    const char * filename; /* the filename or URL */
        -:15981:    int n_filename;
        -:15982:    int options; /* a combination of xmlParserOption */
        -:15983:    int n_options;
        -:15984:
    #####:15985:    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    #####:15986:    for (n_options = 0;n_options < gen_nb_int;n_options++) {
    #####:15987:        mem_base = xmlMemBlocks();
    #####:15988:        filename = gen_fileoutput(n_filename, 0);
    #####:15989:        options = gen_int(n_options, 1);
        -:15990:
    #####:15991:        ret_val = xmlCreateURLParserCtxt(filename, options);
    #####:15992:        desret_xmlParserCtxtPtr(ret_val);
    #####:15993:        call_tests++;
    #####:15994:        des_fileoutput(n_filename, filename, 0);
    #####:15995:        des_int(n_options, options, 1);
    #####:15996:        xmlResetLastError();
    #####:15997:        if (mem_base != xmlMemBlocks()) {
    #####:15998:            printf("Leak of %d blocks found in xmlCreateURLParserCtxt",
    #####:15999:	           xmlMemBlocks() - mem_base);
    #####:16000:	    test_ret++;
    #####:16001:            printf(" %d", n_filename);
    #####:16002:            printf(" %d", n_options);
    #####:16003:            printf("\n");
        -:16004:        }
        -:16005:    }
        -:16006:    }
    #####:16007:    function_tests++;
        -:16008:
    #####:16009:    return(test_ret);
        -:16010:}
        -:16011:
        -:16012:
        -:16013:static int
    #####:16014:test_xmlCurrentChar(void) {
    #####:16015:    int test_ret = 0;
        -:16016:
        -:16017:    int mem_base;
        -:16018:    int ret_val;
        -:16019:    xmlParserCtxtPtr ctxt; /* the XML parser context */
        -:16020:    int n_ctxt;
        -:16021:    int * len; /* pointer to the length of the char read */
        -:16022:    int n_len;
        -:16023:
    #####:16024:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:16025:    for (n_len = 0;n_len < gen_nb_int_ptr;n_len++) {
    #####:16026:        mem_base = xmlMemBlocks();
    #####:16027:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
    #####:16028:        len = gen_int_ptr(n_len, 1);
        -:16029:
    #####:16030:        ret_val = xmlCurrentChar(ctxt, len);
    #####:16031:        desret_int(ret_val);
    #####:16032:        call_tests++;
    #####:16033:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:16034:        des_int_ptr(n_len, len, 1);
    #####:16035:        xmlResetLastError();
    #####:16036:        if (mem_base != xmlMemBlocks()) {
    #####:16037:            printf("Leak of %d blocks found in xmlCurrentChar",
    #####:16038:	           xmlMemBlocks() - mem_base);
    #####:16039:	    test_ret++;
    #####:16040:            printf(" %d", n_ctxt);
    #####:16041:            printf(" %d", n_len);
    #####:16042:            printf("\n");
        -:16043:        }
        -:16044:    }
        -:16045:    }
    #####:16046:    function_tests++;
        -:16047:
    #####:16048:    return(test_ret);
        -:16049:}
        -:16050:
        -:16051:
        -:16052:static int
    #####:16053:test_xmlErrMemory(void) {
    #####:16054:    int test_ret = 0;
        -:16055:
        -:16056:    int mem_base;
        -:16057:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:16058:    int n_ctxt;
        -:16059:    char * extra; /* extra informations */
        -:16060:    int n_extra;
        -:16061:
    #####:16062:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:16063:    for (n_extra = 0;n_extra < gen_nb_const_char_ptr;n_extra++) {
    #####:16064:        mem_base = xmlMemBlocks();
    #####:16065:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
    #####:16066:        extra = gen_const_char_ptr(n_extra, 1);
        -:16067:
    #####:16068:        xmlErrMemory(ctxt, (const char *)extra);
    #####:16069:        call_tests++;
    #####:16070:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:16071:        des_const_char_ptr(n_extra, (const char *)extra, 1);
    #####:16072:        xmlResetLastError();
    #####:16073:        if (mem_base != xmlMemBlocks()) {
    #####:16074:            printf("Leak of %d blocks found in xmlErrMemory",
    #####:16075:	           xmlMemBlocks() - mem_base);
    #####:16076:	    test_ret++;
    #####:16077:            printf(" %d", n_ctxt);
    #####:16078:            printf(" %d", n_extra);
    #####:16079:            printf("\n");
        -:16080:        }
        -:16081:    }
        -:16082:    }
    #####:16083:    function_tests++;
        -:16084:
    #####:16085:    return(test_ret);
        -:16086:}
        -:16087:
        -:16088:
        -:16089:static int
    #####:16090:test_xmlIsLetter(void) {
    #####:16091:    int test_ret = 0;
        -:16092:
        -:16093:    int mem_base;
        -:16094:    int ret_val;
        -:16095:    int c; /* an unicode character (int) */
        -:16096:    int n_c;
        -:16097:
    #####:16098:    for (n_c = 0;n_c < gen_nb_int;n_c++) {
    #####:16099:        mem_base = xmlMemBlocks();
    #####:16100:        c = gen_int(n_c, 0);
        -:16101:
    #####:16102:        ret_val = xmlIsLetter(c);
    #####:16103:        desret_int(ret_val);
    #####:16104:        call_tests++;
    #####:16105:        des_int(n_c, c, 0);
    #####:16106:        xmlResetLastError();
    #####:16107:        if (mem_base != xmlMemBlocks()) {
    #####:16108:            printf("Leak of %d blocks found in xmlIsLetter",
    #####:16109:	           xmlMemBlocks() - mem_base);
    #####:16110:	    test_ret++;
    #####:16111:            printf(" %d", n_c);
    #####:16112:            printf("\n");
        -:16113:        }
        -:16114:    }
    #####:16115:    function_tests++;
        -:16116:
    #####:16117:    return(test_ret);
        -:16118:}
        -:16119:
        -:16120:
        -:16121:static int
    #####:16122:test_xmlNewEntityInputStream(void) {
    #####:16123:    int test_ret = 0;
        -:16124:
        -:16125:    int mem_base;
        -:16126:    xmlParserInputPtr ret_val;
        -:16127:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:16128:    int n_ctxt;
        -:16129:    xmlEntityPtr entity; /* an Entity pointer */
        -:16130:    int n_entity;
        -:16131:
    #####:16132:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:16133:    for (n_entity = 0;n_entity < gen_nb_xmlEntityPtr;n_entity++) {
    #####:16134:        mem_base = xmlMemBlocks();
    #####:16135:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
    #####:16136:        entity = gen_xmlEntityPtr(n_entity, 1);
        -:16137:
    #####:16138:        ret_val = xmlNewEntityInputStream(ctxt, entity);
    #####:16139:        desret_xmlParserInputPtr(ret_val);
    #####:16140:        call_tests++;
    #####:16141:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:16142:        des_xmlEntityPtr(n_entity, entity, 1);
    #####:16143:        xmlResetLastError();
    #####:16144:        if (mem_base != xmlMemBlocks()) {
    #####:16145:            printf("Leak of %d blocks found in xmlNewEntityInputStream",
    #####:16146:	           xmlMemBlocks() - mem_base);
    #####:16147:	    test_ret++;
    #####:16148:            printf(" %d", n_ctxt);
    #####:16149:            printf(" %d", n_entity);
    #####:16150:            printf("\n");
        -:16151:        }
        -:16152:    }
        -:16153:    }
    #####:16154:    function_tests++;
        -:16155:
    #####:16156:    return(test_ret);
        -:16157:}
        -:16158:
        -:16159:
        -:16160:static int
    #####:16161:test_xmlNewInputFromFile(void) {
    #####:16162:    int test_ret = 0;
        -:16163:
        -:16164:    int mem_base;
        -:16165:    xmlParserInputPtr ret_val;
        -:16166:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:16167:    int n_ctxt;
        -:16168:    const char * filename; /* the filename to use as entity */
        -:16169:    int n_filename;
        -:16170:
    #####:16171:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:16172:    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    #####:16173:        mem_base = xmlMemBlocks();
    #####:16174:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
    #####:16175:        filename = gen_filepath(n_filename, 1);
        -:16176:
    #####:16177:        ret_val = xmlNewInputFromFile(ctxt, filename);
    #####:16178:        desret_xmlParserInputPtr(ret_val);
    #####:16179:        call_tests++;
    #####:16180:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:16181:        des_filepath(n_filename, filename, 1);
    #####:16182:        xmlResetLastError();
    #####:16183:        if (mem_base != xmlMemBlocks()) {
    #####:16184:            printf("Leak of %d blocks found in xmlNewInputFromFile",
    #####:16185:	           xmlMemBlocks() - mem_base);
    #####:16186:	    test_ret++;
    #####:16187:            printf(" %d", n_ctxt);
    #####:16188:            printf(" %d", n_filename);
    #####:16189:            printf("\n");
        -:16190:        }
        -:16191:    }
        -:16192:    }
    #####:16193:    function_tests++;
        -:16194:
    #####:16195:    return(test_ret);
        -:16196:}
        -:16197:
        -:16198:
        -:16199:static int
    #####:16200:test_xmlNewInputStream(void) {
    #####:16201:    int test_ret = 0;
        -:16202:
        -:16203:    int mem_base;
        -:16204:    xmlParserInputPtr ret_val;
        -:16205:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:16206:    int n_ctxt;
        -:16207:
    #####:16208:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:16209:        mem_base = xmlMemBlocks();
    #####:16210:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        -:16211:
    #####:16212:        ret_val = xmlNewInputStream(ctxt);
    #####:16213:        desret_xmlParserInputPtr(ret_val);
    #####:16214:        call_tests++;
    #####:16215:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:16216:        xmlResetLastError();
    #####:16217:        if (mem_base != xmlMemBlocks()) {
    #####:16218:            printf("Leak of %d blocks found in xmlNewInputStream",
    #####:16219:	           xmlMemBlocks() - mem_base);
    #####:16220:	    test_ret++;
    #####:16221:            printf(" %d", n_ctxt);
    #####:16222:            printf("\n");
        -:16223:        }
        -:16224:    }
    #####:16225:    function_tests++;
        -:16226:
    #####:16227:    return(test_ret);
        -:16228:}
        -:16229:
        -:16230:
        -:16231:static int
    #####:16232:test_xmlNewStringInputStream(void) {
    #####:16233:    int test_ret = 0;
        -:16234:
        -:16235:    int mem_base;
        -:16236:    xmlParserInputPtr ret_val;
        -:16237:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:16238:    int n_ctxt;
        -:16239:    xmlChar * buffer; /* an memory buffer */
        -:16240:    int n_buffer;
        -:16241:
    #####:16242:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:16243:    for (n_buffer = 0;n_buffer < gen_nb_const_xmlChar_ptr;n_buffer++) {
    #####:16244:        mem_base = xmlMemBlocks();
    #####:16245:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
    #####:16246:        buffer = gen_const_xmlChar_ptr(n_buffer, 1);
        -:16247:
    #####:16248:        ret_val = xmlNewStringInputStream(ctxt, (const xmlChar *)buffer);
    #####:16249:        desret_xmlParserInputPtr(ret_val);
    #####:16250:        call_tests++;
    #####:16251:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:16252:        des_const_xmlChar_ptr(n_buffer, (const xmlChar *)buffer, 1);
    #####:16253:        xmlResetLastError();
    #####:16254:        if (mem_base != xmlMemBlocks()) {
    #####:16255:            printf("Leak of %d blocks found in xmlNewStringInputStream",
    #####:16256:	           xmlMemBlocks() - mem_base);
    #####:16257:	    test_ret++;
    #####:16258:            printf(" %d", n_ctxt);
    #####:16259:            printf(" %d", n_buffer);
    #####:16260:            printf("\n");
        -:16261:        }
        -:16262:    }
        -:16263:    }
    #####:16264:    function_tests++;
        -:16265:
    #####:16266:    return(test_ret);
        -:16267:}
        -:16268:
        -:16269:
        -:16270:static int
    #####:16271:test_xmlNextChar(void) {
    #####:16272:    int test_ret = 0;
        -:16273:
        -:16274:    int mem_base;
        -:16275:    xmlParserCtxtPtr ctxt; /* the XML parser context */
        -:16276:    int n_ctxt;
        -:16277:
    #####:16278:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:16279:        mem_base = xmlMemBlocks();
    #####:16280:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        -:16281:
    #####:16282:        xmlNextChar(ctxt);
    #####:16283:        call_tests++;
    #####:16284:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:16285:        xmlResetLastError();
    #####:16286:        if (mem_base != xmlMemBlocks()) {
    #####:16287:            printf("Leak of %d blocks found in xmlNextChar",
    #####:16288:	           xmlMemBlocks() - mem_base);
    #####:16289:	    test_ret++;
    #####:16290:            printf(" %d", n_ctxt);
    #####:16291:            printf("\n");
        -:16292:        }
        -:16293:    }
    #####:16294:    function_tests++;
        -:16295:
    #####:16296:    return(test_ret);
        -:16297:}
        -:16298:
        -:16299:
        -:16300:static int
    #####:16301:test_xmlParserInputShrink(void) {
    #####:16302:    int test_ret = 0;
        -:16303:
        -:16304:    int mem_base;
        -:16305:    xmlParserInputPtr in; /* an XML parser input */
        -:16306:    int n_in;
        -:16307:
    #####:16308:    for (n_in = 0;n_in < gen_nb_xmlParserInputPtr;n_in++) {
    #####:16309:        mem_base = xmlMemBlocks();
    #####:16310:        in = gen_xmlParserInputPtr(n_in, 0);
        -:16311:
    #####:16312:        xmlParserInputShrink(in);
    #####:16313:        call_tests++;
    #####:16314:        des_xmlParserInputPtr(n_in, in, 0);
    #####:16315:        xmlResetLastError();
    #####:16316:        if (mem_base != xmlMemBlocks()) {
    #####:16317:            printf("Leak of %d blocks found in xmlParserInputShrink",
    #####:16318:	           xmlMemBlocks() - mem_base);
    #####:16319:	    test_ret++;
    #####:16320:            printf(" %d", n_in);
    #####:16321:            printf("\n");
        -:16322:        }
        -:16323:    }
    #####:16324:    function_tests++;
        -:16325:
    #####:16326:    return(test_ret);
        -:16327:}
        -:16328:
        -:16329:
        -:16330:static int
    #####:16331:test_xmlPopInput(void) {
    #####:16332:    int test_ret = 0;
        -:16333:
        -:16334:    int mem_base;
        -:16335:    xmlChar ret_val;
        -:16336:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:16337:    int n_ctxt;
        -:16338:
    #####:16339:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:16340:        mem_base = xmlMemBlocks();
    #####:16341:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        -:16342:
    #####:16343:        ret_val = xmlPopInput(ctxt);
    #####:16344:        desret_xmlChar(ret_val);
    #####:16345:        call_tests++;
    #####:16346:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:16347:        xmlResetLastError();
    #####:16348:        if (mem_base != xmlMemBlocks()) {
    #####:16349:            printf("Leak of %d blocks found in xmlPopInput",
    #####:16350:	           xmlMemBlocks() - mem_base);
    #####:16351:	    test_ret++;
    #####:16352:            printf(" %d", n_ctxt);
    #####:16353:            printf("\n");
        -:16354:        }
        -:16355:    }
    #####:16356:    function_tests++;
        -:16357:
    #####:16358:    return(test_ret);
        -:16359:}
        -:16360:
        -:16361:
        -:16362:static int
    #####:16363:test_xmlPushInput(void) {
    #####:16364:    int test_ret = 0;
        -:16365:
        -:16366:    int mem_base;
        -:16367:    int ret_val;
        -:16368:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:16369:    int n_ctxt;
        -:16370:    xmlParserInputPtr input; /* an XML parser input fragment (entity, XML fragment ...). */
        -:16371:    int n_input;
        -:16372:
    #####:16373:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:16374:    for (n_input = 0;n_input < gen_nb_xmlParserInputPtr;n_input++) {
    #####:16375:        mem_base = xmlMemBlocks();
    #####:16376:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
    #####:16377:        input = gen_xmlParserInputPtr(n_input, 1);
        -:16378:
    #####:16379:        ret_val = xmlPushInput(ctxt, input);
    #####:16380:        desret_int(ret_val);
    #####:16381:        call_tests++;
    #####:16382:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:16383:        des_xmlParserInputPtr(n_input, input, 1);
    #####:16384:        xmlResetLastError();
    #####:16385:        if (mem_base != xmlMemBlocks()) {
    #####:16386:            printf("Leak of %d blocks found in xmlPushInput",
    #####:16387:	           xmlMemBlocks() - mem_base);
    #####:16388:	    test_ret++;
    #####:16389:            printf(" %d", n_ctxt);
    #####:16390:            printf(" %d", n_input);
    #####:16391:            printf("\n");
        -:16392:        }
        -:16393:    }
        -:16394:    }
    #####:16395:    function_tests++;
        -:16396:
    #####:16397:    return(test_ret);
        -:16398:}
        -:16399:
        -:16400:
        -:16401:static int
    #####:16402:test_xmlSetEntityReferenceFunc(void) {
    #####:16403:    int test_ret = 0;
        -:16404:
        -:16405:
        -:16406:    /* missing type support */
    #####:16407:    return(test_ret);
        -:16408:}
        -:16409:
        -:16410:
        -:16411:static int
    #####:16412:test_xmlSplitQName(void) {
    #####:16413:    int test_ret = 0;
        -:16414:
        -:16415:    int mem_base;
        -:16416:    xmlChar * ret_val;
        -:16417:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:16418:    int n_ctxt;
        -:16419:    xmlChar * name; /* an XML parser context */
        -:16420:    int n_name;
        -:16421:    xmlChar ** prefix; /* a xmlChar ** */
        -:16422:    int n_prefix;
        -:16423:
    #####:16424:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:16425:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:16426:    for (n_prefix = 0;n_prefix < gen_nb_xmlChar_ptr_ptr;n_prefix++) {
    #####:16427:        mem_base = xmlMemBlocks();
    #####:16428:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
    #####:16429:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:16430:        prefix = gen_xmlChar_ptr_ptr(n_prefix, 2);
        -:16431:
    #####:16432:        ret_val = xmlSplitQName(ctxt, (const xmlChar *)name, prefix);
    #####:16433:        desret_xmlChar_ptr(ret_val);
    #####:16434:        call_tests++;
    #####:16435:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:16436:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:16437:        des_xmlChar_ptr_ptr(n_prefix, prefix, 2);
    #####:16438:        xmlResetLastError();
    #####:16439:        if (mem_base != xmlMemBlocks()) {
    #####:16440:            printf("Leak of %d blocks found in xmlSplitQName",
    #####:16441:	           xmlMemBlocks() - mem_base);
    #####:16442:	    test_ret++;
    #####:16443:            printf(" %d", n_ctxt);
    #####:16444:            printf(" %d", n_name);
    #####:16445:            printf(" %d", n_prefix);
    #####:16446:            printf("\n");
        -:16447:        }
        -:16448:    }
        -:16449:    }
        -:16450:    }
    #####:16451:    function_tests++;
        -:16452:
    #####:16453:    return(test_ret);
        -:16454:}
        -:16455:
        -:16456:
        -:16457:static int
    #####:16458:test_xmlStringCurrentChar(void) {
    #####:16459:    int test_ret = 0;
        -:16460:
        -:16461:    int mem_base;
        -:16462:    int ret_val;
        -:16463:    xmlParserCtxtPtr ctxt; /* the XML parser context */
        -:16464:    int n_ctxt;
        -:16465:    xmlChar * cur; /* pointer to the beginning of the char */
        -:16466:    int n_cur;
        -:16467:    int * len; /* pointer to the length of the char read */
        -:16468:    int n_len;
        -:16469:
    #####:16470:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:16471:    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    #####:16472:    for (n_len = 0;n_len < gen_nb_int_ptr;n_len++) {
    #####:16473:        mem_base = xmlMemBlocks();
    #####:16474:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
    #####:16475:        cur = gen_const_xmlChar_ptr(n_cur, 1);
    #####:16476:        len = gen_int_ptr(n_len, 2);
        -:16477:
    #####:16478:        ret_val = xmlStringCurrentChar(ctxt, (const xmlChar *)cur, len);
    #####:16479:        desret_int(ret_val);
    #####:16480:        call_tests++;
    #####:16481:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:16482:        des_const_xmlChar_ptr(n_cur, (const xmlChar *)cur, 1);
    #####:16483:        des_int_ptr(n_len, len, 2);
    #####:16484:        xmlResetLastError();
    #####:16485:        if (mem_base != xmlMemBlocks()) {
    #####:16486:            printf("Leak of %d blocks found in xmlStringCurrentChar",
    #####:16487:	           xmlMemBlocks() - mem_base);
    #####:16488:	    test_ret++;
    #####:16489:            printf(" %d", n_ctxt);
    #####:16490:            printf(" %d", n_cur);
    #####:16491:            printf(" %d", n_len);
    #####:16492:            printf("\n");
        -:16493:        }
        -:16494:    }
        -:16495:    }
        -:16496:    }
    #####:16497:    function_tests++;
        -:16498:
    #####:16499:    return(test_ret);
        -:16500:}
        -:16501:
        -:16502:
        -:16503:static int
    #####:16504:test_xmlStringDecodeEntities(void) {
    #####:16505:    int test_ret = 0;
        -:16506:
        -:16507:    int mem_base;
        -:16508:    xmlChar * ret_val;
        -:16509:    xmlParserCtxtPtr ctxt; /* the parser context */
        -:16510:    int n_ctxt;
        -:16511:    xmlChar * str; /* the input string */
        -:16512:    int n_str;
        -:16513:    int what; /* combination of XML_SUBSTITUTE_REF and XML_SUBSTITUTE_PEREF */
        -:16514:    int n_what;
        -:16515:    xmlChar end; /* an end marker xmlChar, 0 if none */
        -:16516:    int n_end;
        -:16517:    xmlChar end2; /* an end marker xmlChar, 0 if none */
        -:16518:    int n_end2;
        -:16519:    xmlChar end3; /* an end marker xmlChar, 0 if none */
        -:16520:    int n_end3;
        -:16521:
    #####:16522:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:16523:    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    #####:16524:    for (n_what = 0;n_what < gen_nb_int;n_what++) {
    #####:16525:    for (n_end = 0;n_end < gen_nb_xmlChar;n_end++) {
    #####:16526:    for (n_end2 = 0;n_end2 < gen_nb_xmlChar;n_end2++) {
    #####:16527:    for (n_end3 = 0;n_end3 < gen_nb_xmlChar;n_end3++) {
    #####:16528:        mem_base = xmlMemBlocks();
    #####:16529:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
    #####:16530:        str = gen_const_xmlChar_ptr(n_str, 1);
    #####:16531:        what = gen_int(n_what, 2);
    #####:16532:        end = gen_xmlChar(n_end, 3);
    #####:16533:        end2 = gen_xmlChar(n_end2, 4);
    #####:16534:        end3 = gen_xmlChar(n_end3, 5);
        -:16535:
    #####:16536:        ret_val = xmlStringDecodeEntities(ctxt, (const xmlChar *)str, what, end, end2, end3);
    #####:16537:        desret_xmlChar_ptr(ret_val);
    #####:16538:        call_tests++;
    #####:16539:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:16540:        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 1);
    #####:16541:        des_int(n_what, what, 2);
    #####:16542:        des_xmlChar(n_end, end, 3);
    #####:16543:        des_xmlChar(n_end2, end2, 4);
    #####:16544:        des_xmlChar(n_end3, end3, 5);
    #####:16545:        xmlResetLastError();
    #####:16546:        if (mem_base != xmlMemBlocks()) {
    #####:16547:            printf("Leak of %d blocks found in xmlStringDecodeEntities",
    #####:16548:	           xmlMemBlocks() - mem_base);
    #####:16549:	    test_ret++;
    #####:16550:            printf(" %d", n_ctxt);
    #####:16551:            printf(" %d", n_str);
    #####:16552:            printf(" %d", n_what);
    #####:16553:            printf(" %d", n_end);
    #####:16554:            printf(" %d", n_end2);
    #####:16555:            printf(" %d", n_end3);
    #####:16556:            printf("\n");
        -:16557:        }
        -:16558:    }
        -:16559:    }
        -:16560:    }
        -:16561:    }
        -:16562:    }
        -:16563:    }
    #####:16564:    function_tests++;
        -:16565:
    #####:16566:    return(test_ret);
        -:16567:}
        -:16568:
        -:16569:
        -:16570:static int
    #####:16571:test_xmlStringLenDecodeEntities(void) {
    #####:16572:    int test_ret = 0;
        -:16573:
        -:16574:    int mem_base;
        -:16575:    xmlChar * ret_val;
        -:16576:    xmlParserCtxtPtr ctxt; /* the parser context */
        -:16577:    int n_ctxt;
        -:16578:    xmlChar * str; /* the input string */
        -:16579:    int n_str;
        -:16580:    int len; /* the string length */
        -:16581:    int n_len;
        -:16582:    int what; /* combination of XML_SUBSTITUTE_REF and XML_SUBSTITUTE_PEREF */
        -:16583:    int n_what;
        -:16584:    xmlChar end; /* an end marker xmlChar, 0 if none */
        -:16585:    int n_end;
        -:16586:    xmlChar end2; /* an end marker xmlChar, 0 if none */
        -:16587:    int n_end2;
        -:16588:    xmlChar end3; /* an end marker xmlChar, 0 if none */
        -:16589:    int n_end3;
        -:16590:
    #####:16591:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:16592:    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    #####:16593:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:16594:    for (n_what = 0;n_what < gen_nb_int;n_what++) {
    #####:16595:    for (n_end = 0;n_end < gen_nb_xmlChar;n_end++) {
    #####:16596:    for (n_end2 = 0;n_end2 < gen_nb_xmlChar;n_end2++) {
    #####:16597:    for (n_end3 = 0;n_end3 < gen_nb_xmlChar;n_end3++) {
    #####:16598:        mem_base = xmlMemBlocks();
    #####:16599:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
    #####:16600:        str = gen_const_xmlChar_ptr(n_str, 1);
    #####:16601:        len = gen_int(n_len, 2);
    #####:16602:        what = gen_int(n_what, 3);
    #####:16603:        end = gen_xmlChar(n_end, 4);
    #####:16604:        end2 = gen_xmlChar(n_end2, 5);
    #####:16605:        end3 = gen_xmlChar(n_end3, 6);
        -:16606:
    #####:16607:        ret_val = xmlStringLenDecodeEntities(ctxt, (const xmlChar *)str, len, what, end, end2, end3);
    #####:16608:        desret_xmlChar_ptr(ret_val);
    #####:16609:        call_tests++;
    #####:16610:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:16611:        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 1);
    #####:16612:        des_int(n_len, len, 2);
    #####:16613:        des_int(n_what, what, 3);
    #####:16614:        des_xmlChar(n_end, end, 4);
    #####:16615:        des_xmlChar(n_end2, end2, 5);
    #####:16616:        des_xmlChar(n_end3, end3, 6);
    #####:16617:        xmlResetLastError();
    #####:16618:        if (mem_base != xmlMemBlocks()) {
    #####:16619:            printf("Leak of %d blocks found in xmlStringLenDecodeEntities",
    #####:16620:	           xmlMemBlocks() - mem_base);
    #####:16621:	    test_ret++;
    #####:16622:            printf(" %d", n_ctxt);
    #####:16623:            printf(" %d", n_str);
    #####:16624:            printf(" %d", n_len);
    #####:16625:            printf(" %d", n_what);
    #####:16626:            printf(" %d", n_end);
    #####:16627:            printf(" %d", n_end2);
    #####:16628:            printf(" %d", n_end3);
    #####:16629:            printf("\n");
        -:16630:        }
        -:16631:    }
        -:16632:    }
        -:16633:    }
        -:16634:    }
        -:16635:    }
        -:16636:    }
        -:16637:    }
    #####:16638:    function_tests++;
        -:16639:
    #####:16640:    return(test_ret);
        -:16641:}
        -:16642:
        -:16643:
        -:16644:static int
    #####:16645:test_xmlSwitchEncoding(void) {
    #####:16646:    int test_ret = 0;
        -:16647:
        -:16648:    int mem_base;
        -:16649:    int ret_val;
        -:16650:    xmlParserCtxtPtr ctxt; /* the parser context */
        -:16651:    int n_ctxt;
        -:16652:    xmlCharEncoding enc; /* the encoding value (number) */
        -:16653:    int n_enc;
        -:16654:
    #####:16655:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:16656:    for (n_enc = 0;n_enc < gen_nb_xmlCharEncoding;n_enc++) {
    #####:16657:        mem_base = xmlMemBlocks();
    #####:16658:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
    #####:16659:        enc = gen_xmlCharEncoding(n_enc, 1);
        -:16660:
    #####:16661:        ret_val = xmlSwitchEncoding(ctxt, enc);
    #####:16662:        desret_int(ret_val);
    #####:16663:        call_tests++;
    #####:16664:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:16665:        des_xmlCharEncoding(n_enc, enc, 1);
    #####:16666:        xmlResetLastError();
    #####:16667:        if (mem_base != xmlMemBlocks()) {
    #####:16668:            printf("Leak of %d blocks found in xmlSwitchEncoding",
    #####:16669:	           xmlMemBlocks() - mem_base);
    #####:16670:	    test_ret++;
    #####:16671:            printf(" %d", n_ctxt);
    #####:16672:            printf(" %d", n_enc);
    #####:16673:            printf("\n");
        -:16674:        }
        -:16675:    }
        -:16676:    }
    #####:16677:    function_tests++;
        -:16678:
    #####:16679:    return(test_ret);
        -:16680:}
        -:16681:
        -:16682:
        -:16683:static int
    #####:16684:test_xmlSwitchInputEncoding(void) {
    #####:16685:    int test_ret = 0;
        -:16686:
        -:16687:    int mem_base;
        -:16688:    int ret_val;
        -:16689:    xmlParserCtxtPtr ctxt; /* the parser context */
        -:16690:    int n_ctxt;
        -:16691:    xmlParserInputPtr input; /* the input stream */
        -:16692:    int n_input;
        -:16693:    xmlCharEncodingHandlerPtr handler; /* the encoding handler */
        -:16694:    int n_handler;
        -:16695:
    #####:16696:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:16697:    for (n_input = 0;n_input < gen_nb_xmlParserInputPtr;n_input++) {
    #####:16698:    for (n_handler = 0;n_handler < gen_nb_xmlCharEncodingHandlerPtr;n_handler++) {
    #####:16699:        mem_base = xmlMemBlocks();
    #####:16700:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
    #####:16701:        input = gen_xmlParserInputPtr(n_input, 1);
    #####:16702:        handler = gen_xmlCharEncodingHandlerPtr(n_handler, 2);
        -:16703:
    #####:16704:        ret_val = xmlSwitchInputEncoding(ctxt, input, handler);
    #####:16705:        desret_int(ret_val);
    #####:16706:        call_tests++;
    #####:16707:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:16708:        des_xmlParserInputPtr(n_input, input, 1);
    #####:16709:        des_xmlCharEncodingHandlerPtr(n_handler, handler, 2);
    #####:16710:        xmlResetLastError();
    #####:16711:        if (mem_base != xmlMemBlocks()) {
    #####:16712:            printf("Leak of %d blocks found in xmlSwitchInputEncoding",
    #####:16713:	           xmlMemBlocks() - mem_base);
    #####:16714:	    test_ret++;
    #####:16715:            printf(" %d", n_ctxt);
    #####:16716:            printf(" %d", n_input);
    #####:16717:            printf(" %d", n_handler);
    #####:16718:            printf("\n");
        -:16719:        }
        -:16720:    }
        -:16721:    }
        -:16722:    }
    #####:16723:    function_tests++;
        -:16724:
    #####:16725:    return(test_ret);
        -:16726:}
        -:16727:
        -:16728:
        -:16729:static int
    #####:16730:test_xmlSwitchToEncoding(void) {
    #####:16731:    int test_ret = 0;
        -:16732:
        -:16733:    int mem_base;
        -:16734:    int ret_val;
        -:16735:    xmlParserCtxtPtr ctxt; /* the parser context */
        -:16736:    int n_ctxt;
        -:16737:    xmlCharEncodingHandlerPtr handler; /* the encoding handler */
        -:16738:    int n_handler;
        -:16739:
    #####:16740:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:16741:    for (n_handler = 0;n_handler < gen_nb_xmlCharEncodingHandlerPtr;n_handler++) {
    #####:16742:        mem_base = xmlMemBlocks();
    #####:16743:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
    #####:16744:        handler = gen_xmlCharEncodingHandlerPtr(n_handler, 1);
        -:16745:
    #####:16746:        ret_val = xmlSwitchToEncoding(ctxt, handler);
    #####:16747:        desret_int(ret_val);
    #####:16748:        call_tests++;
    #####:16749:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:16750:        des_xmlCharEncodingHandlerPtr(n_handler, handler, 1);
    #####:16751:        xmlResetLastError();
    #####:16752:        if (mem_base != xmlMemBlocks()) {
    #####:16753:            printf("Leak of %d blocks found in xmlSwitchToEncoding",
    #####:16754:	           xmlMemBlocks() - mem_base);
    #####:16755:	    test_ret++;
    #####:16756:            printf(" %d", n_ctxt);
    #####:16757:            printf(" %d", n_handler);
    #####:16758:            printf("\n");
        -:16759:        }
        -:16760:    }
        -:16761:    }
    #####:16762:    function_tests++;
        -:16763:
    #####:16764:    return(test_ret);
        -:16765:}
        -:16766:
        -:16767:static int
    #####:16768:test_parserInternals(void) {
    #####:16769:    int test_ret = 0;
        -:16770:
    #####:16771:    if (quiet == 0) printf("Testing parserInternals : 33 of 90 functions ...\n");
    #####:16772:    test_ret += test_htmlCreateFileParserCtxt();
    #####:16773:    test_ret += test_htmlInitAutoClose();
    #####:16774:    test_ret += test_inputPop();
    #####:16775:    test_ret += test_inputPush();
    #####:16776:    test_ret += test_namePop();
    #####:16777:    test_ret += test_namePush();
    #####:16778:    test_ret += test_nodePop();
    #####:16779:    test_ret += test_nodePush();
    #####:16780:    test_ret += test_xmlCheckLanguageID();
    #####:16781:    test_ret += test_xmlCopyChar();
    #####:16782:    test_ret += test_xmlCopyCharMultiByte();
    #####:16783:    test_ret += test_xmlCreateEntityParserCtxt();
    #####:16784:    test_ret += test_xmlCreateFileParserCtxt();
    #####:16785:    test_ret += test_xmlCreateMemoryParserCtxt();
    #####:16786:    test_ret += test_xmlCreateURLParserCtxt();
    #####:16787:    test_ret += test_xmlCurrentChar();
    #####:16788:    test_ret += test_xmlErrMemory();
    #####:16789:    test_ret += test_xmlIsLetter();
    #####:16790:    test_ret += test_xmlNewEntityInputStream();
    #####:16791:    test_ret += test_xmlNewInputFromFile();
    #####:16792:    test_ret += test_xmlNewInputStream();
    #####:16793:    test_ret += test_xmlNewStringInputStream();
    #####:16794:    test_ret += test_xmlNextChar();
    #####:16795:    test_ret += test_xmlParserInputShrink();
    #####:16796:    test_ret += test_xmlPopInput();
    #####:16797:    test_ret += test_xmlPushInput();
    #####:16798:    test_ret += test_xmlSetEntityReferenceFunc();
    #####:16799:    test_ret += test_xmlSplitQName();
    #####:16800:    test_ret += test_xmlStringCurrentChar();
    #####:16801:    test_ret += test_xmlStringDecodeEntities();
    #####:16802:    test_ret += test_xmlStringLenDecodeEntities();
    #####:16803:    test_ret += test_xmlSwitchEncoding();
    #####:16804:    test_ret += test_xmlSwitchInputEncoding();
    #####:16805:    test_ret += test_xmlSwitchToEncoding();
        -:16806:
    #####:16807:    if (test_ret != 0)
    #####:16808:	printf("Module parserInternals: %d errors\n", test_ret);
    #####:16809:    return(test_ret);
        -:16810:}
        -:16811:
        -:16812:static int
    #####:16813:test_xmlPatternFromRoot(void) {
    #####:16814:    int test_ret = 0;
        -:16815:
        -:16816:#if defined(LIBXML_PATTERN_ENABLED)
        -:16817:    int mem_base;
        -:16818:    int ret_val;
        -:16819:    xmlPatternPtr comp; /* the precompiled pattern */
        -:16820:    int n_comp;
        -:16821:
    #####:16822:    for (n_comp = 0;n_comp < gen_nb_xmlPatternPtr;n_comp++) {
    #####:16823:        mem_base = xmlMemBlocks();
    #####:16824:        comp = gen_xmlPatternPtr(n_comp, 0);
        -:16825:
    #####:16826:        ret_val = xmlPatternFromRoot(comp);
    #####:16827:        desret_int(ret_val);
    #####:16828:        call_tests++;
    #####:16829:        des_xmlPatternPtr(n_comp, comp, 0);
    #####:16830:        xmlResetLastError();
    #####:16831:        if (mem_base != xmlMemBlocks()) {
    #####:16832:            printf("Leak of %d blocks found in xmlPatternFromRoot",
    #####:16833:	           xmlMemBlocks() - mem_base);
    #####:16834:	    test_ret++;
    #####:16835:            printf(" %d", n_comp);
    #####:16836:            printf("\n");
        -:16837:        }
        -:16838:    }
    #####:16839:    function_tests++;
        -:16840:#endif
        -:16841:
    #####:16842:    return(test_ret);
        -:16843:}
        -:16844:
        -:16845:
        -:16846:static int
    #####:16847:test_xmlPatternGetStreamCtxt(void) {
    #####:16848:    int test_ret = 0;
        -:16849:
        -:16850:
        -:16851:    /* missing type support */
    #####:16852:    return(test_ret);
        -:16853:}
        -:16854:
        -:16855:
        -:16856:static int
    #####:16857:test_xmlPatternMatch(void) {
    #####:16858:    int test_ret = 0;
        -:16859:
        -:16860:#if defined(LIBXML_PATTERN_ENABLED)
        -:16861:    int mem_base;
        -:16862:    int ret_val;
        -:16863:    xmlPatternPtr comp; /* the precompiled pattern */
        -:16864:    int n_comp;
        -:16865:    xmlNodePtr node; /* a node */
        -:16866:    int n_node;
        -:16867:
    #####:16868:    for (n_comp = 0;n_comp < gen_nb_xmlPatternPtr;n_comp++) {
    #####:16869:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:16870:        mem_base = xmlMemBlocks();
    #####:16871:        comp = gen_xmlPatternPtr(n_comp, 0);
    #####:16872:        node = gen_xmlNodePtr(n_node, 1);
        -:16873:
    #####:16874:        ret_val = xmlPatternMatch(comp, node);
    #####:16875:        desret_int(ret_val);
    #####:16876:        call_tests++;
    #####:16877:        des_xmlPatternPtr(n_comp, comp, 0);
    #####:16878:        des_xmlNodePtr(n_node, node, 1);
    #####:16879:        xmlResetLastError();
    #####:16880:        if (mem_base != xmlMemBlocks()) {
    #####:16881:            printf("Leak of %d blocks found in xmlPatternMatch",
    #####:16882:	           xmlMemBlocks() - mem_base);
    #####:16883:	    test_ret++;
    #####:16884:            printf(" %d", n_comp);
    #####:16885:            printf(" %d", n_node);
    #####:16886:            printf("\n");
        -:16887:        }
        -:16888:    }
        -:16889:    }
    #####:16890:    function_tests++;
        -:16891:#endif
        -:16892:
    #####:16893:    return(test_ret);
        -:16894:}
        -:16895:
        -:16896:
        -:16897:static int
    #####:16898:test_xmlPatternMaxDepth(void) {
    #####:16899:    int test_ret = 0;
        -:16900:
        -:16901:#if defined(LIBXML_PATTERN_ENABLED)
        -:16902:    int mem_base;
        -:16903:    int ret_val;
        -:16904:    xmlPatternPtr comp; /* the precompiled pattern */
        -:16905:    int n_comp;
        -:16906:
    #####:16907:    for (n_comp = 0;n_comp < gen_nb_xmlPatternPtr;n_comp++) {
    #####:16908:        mem_base = xmlMemBlocks();
    #####:16909:        comp = gen_xmlPatternPtr(n_comp, 0);
        -:16910:
    #####:16911:        ret_val = xmlPatternMaxDepth(comp);
    #####:16912:        desret_int(ret_val);
    #####:16913:        call_tests++;
    #####:16914:        des_xmlPatternPtr(n_comp, comp, 0);
    #####:16915:        xmlResetLastError();
    #####:16916:        if (mem_base != xmlMemBlocks()) {
    #####:16917:            printf("Leak of %d blocks found in xmlPatternMaxDepth",
    #####:16918:	           xmlMemBlocks() - mem_base);
    #####:16919:	    test_ret++;
    #####:16920:            printf(" %d", n_comp);
    #####:16921:            printf("\n");
        -:16922:        }
        -:16923:    }
    #####:16924:    function_tests++;
        -:16925:#endif
        -:16926:
    #####:16927:    return(test_ret);
        -:16928:}
        -:16929:
        -:16930:
        -:16931:static int
    #####:16932:test_xmlPatternMinDepth(void) {
    #####:16933:    int test_ret = 0;
        -:16934:
        -:16935:#if defined(LIBXML_PATTERN_ENABLED)
        -:16936:    int mem_base;
        -:16937:    int ret_val;
        -:16938:    xmlPatternPtr comp; /* the precompiled pattern */
        -:16939:    int n_comp;
        -:16940:
    #####:16941:    for (n_comp = 0;n_comp < gen_nb_xmlPatternPtr;n_comp++) {
    #####:16942:        mem_base = xmlMemBlocks();
    #####:16943:        comp = gen_xmlPatternPtr(n_comp, 0);
        -:16944:
    #####:16945:        ret_val = xmlPatternMinDepth(comp);
    #####:16946:        desret_int(ret_val);
    #####:16947:        call_tests++;
    #####:16948:        des_xmlPatternPtr(n_comp, comp, 0);
    #####:16949:        xmlResetLastError();
    #####:16950:        if (mem_base != xmlMemBlocks()) {
    #####:16951:            printf("Leak of %d blocks found in xmlPatternMinDepth",
    #####:16952:	           xmlMemBlocks() - mem_base);
    #####:16953:	    test_ret++;
    #####:16954:            printf(" %d", n_comp);
    #####:16955:            printf("\n");
        -:16956:        }
        -:16957:    }
    #####:16958:    function_tests++;
        -:16959:#endif
        -:16960:
    #####:16961:    return(test_ret);
        -:16962:}
        -:16963:
        -:16964:
        -:16965:static int
    #####:16966:test_xmlPatternStreamable(void) {
    #####:16967:    int test_ret = 0;
        -:16968:
        -:16969:#if defined(LIBXML_PATTERN_ENABLED)
        -:16970:    int mem_base;
        -:16971:    int ret_val;
        -:16972:    xmlPatternPtr comp; /* the precompiled pattern */
        -:16973:    int n_comp;
        -:16974:
    #####:16975:    for (n_comp = 0;n_comp < gen_nb_xmlPatternPtr;n_comp++) {
    #####:16976:        mem_base = xmlMemBlocks();
    #####:16977:        comp = gen_xmlPatternPtr(n_comp, 0);
        -:16978:
    #####:16979:        ret_val = xmlPatternStreamable(comp);
    #####:16980:        desret_int(ret_val);
    #####:16981:        call_tests++;
    #####:16982:        des_xmlPatternPtr(n_comp, comp, 0);
    #####:16983:        xmlResetLastError();
    #####:16984:        if (mem_base != xmlMemBlocks()) {
    #####:16985:            printf("Leak of %d blocks found in xmlPatternStreamable",
    #####:16986:	           xmlMemBlocks() - mem_base);
    #####:16987:	    test_ret++;
    #####:16988:            printf(" %d", n_comp);
    #####:16989:            printf("\n");
        -:16990:        }
        -:16991:    }
    #####:16992:    function_tests++;
        -:16993:#endif
        -:16994:
    #####:16995:    return(test_ret);
        -:16996:}
        -:16997:
        -:16998:
        -:16999:static int
    #####:17000:test_xmlPatterncompile(void) {
    #####:17001:    int test_ret = 0;
        -:17002:
        -:17003:
        -:17004:    /* missing type support */
    #####:17005:    return(test_ret);
        -:17006:}
        -:17007:
        -:17008:#ifdef LIBXML_PATTERN_ENABLED
        -:17009:
        -:17010:#define gen_nb_xmlStreamCtxtPtr 1
    #####:17011:static xmlStreamCtxtPtr gen_xmlStreamCtxtPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:17012:    return(NULL);
        -:17013:}
    #####:17014:static void des_xmlStreamCtxtPtr(int no ATTRIBUTE_UNUSED, xmlStreamCtxtPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:17015:}
        -:17016:#endif
        -:17017:
        -:17018:
        -:17019:static int
    #####:17020:test_xmlStreamPop(void) {
    #####:17021:    int test_ret = 0;
        -:17022:
        -:17023:#if defined(LIBXML_PATTERN_ENABLED)
        -:17024:    int mem_base;
        -:17025:    int ret_val;
        -:17026:    xmlStreamCtxtPtr stream; /* the stream context */
        -:17027:    int n_stream;
        -:17028:
    #####:17029:    for (n_stream = 0;n_stream < gen_nb_xmlStreamCtxtPtr;n_stream++) {
    #####:17030:        mem_base = xmlMemBlocks();
    #####:17031:        stream = gen_xmlStreamCtxtPtr(n_stream, 0);
        -:17032:
    #####:17033:        ret_val = xmlStreamPop(stream);
    #####:17034:        desret_int(ret_val);
    #####:17035:        call_tests++;
    #####:17036:        des_xmlStreamCtxtPtr(n_stream, stream, 0);
    #####:17037:        xmlResetLastError();
    #####:17038:        if (mem_base != xmlMemBlocks()) {
    #####:17039:            printf("Leak of %d blocks found in xmlStreamPop",
    #####:17040:	           xmlMemBlocks() - mem_base);
    #####:17041:	    test_ret++;
    #####:17042:            printf(" %d", n_stream);
    #####:17043:            printf("\n");
        -:17044:        }
        -:17045:    }
    #####:17046:    function_tests++;
        -:17047:#endif
        -:17048:
    #####:17049:    return(test_ret);
        -:17050:}
        -:17051:
        -:17052:
        -:17053:static int
    #####:17054:test_xmlStreamPush(void) {
    #####:17055:    int test_ret = 0;
        -:17056:
        -:17057:#if defined(LIBXML_PATTERN_ENABLED)
        -:17058:    int mem_base;
        -:17059:    int ret_val;
        -:17060:    xmlStreamCtxtPtr stream; /* the stream context */
        -:17061:    int n_stream;
        -:17062:    xmlChar * name; /* the current name */
        -:17063:    int n_name;
        -:17064:    xmlChar * ns; /* the namespace name */
        -:17065:    int n_ns;
        -:17066:
    #####:17067:    for (n_stream = 0;n_stream < gen_nb_xmlStreamCtxtPtr;n_stream++) {
    #####:17068:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:17069:    for (n_ns = 0;n_ns < gen_nb_const_xmlChar_ptr;n_ns++) {
    #####:17070:        mem_base = xmlMemBlocks();
    #####:17071:        stream = gen_xmlStreamCtxtPtr(n_stream, 0);
    #####:17072:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:17073:        ns = gen_const_xmlChar_ptr(n_ns, 2);
        -:17074:
    #####:17075:        ret_val = xmlStreamPush(stream, (const xmlChar *)name, (const xmlChar *)ns);
    #####:17076:        desret_int(ret_val);
    #####:17077:        call_tests++;
    #####:17078:        des_xmlStreamCtxtPtr(n_stream, stream, 0);
    #####:17079:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:17080:        des_const_xmlChar_ptr(n_ns, (const xmlChar *)ns, 2);
    #####:17081:        xmlResetLastError();
    #####:17082:        if (mem_base != xmlMemBlocks()) {
    #####:17083:            printf("Leak of %d blocks found in xmlStreamPush",
    #####:17084:	           xmlMemBlocks() - mem_base);
    #####:17085:	    test_ret++;
    #####:17086:            printf(" %d", n_stream);
    #####:17087:            printf(" %d", n_name);
    #####:17088:            printf(" %d", n_ns);
    #####:17089:            printf("\n");
        -:17090:        }
        -:17091:    }
        -:17092:    }
        -:17093:    }
    #####:17094:    function_tests++;
        -:17095:#endif
        -:17096:
    #####:17097:    return(test_ret);
        -:17098:}
        -:17099:
        -:17100:
        -:17101:static int
    #####:17102:test_xmlStreamPushAttr(void) {
    #####:17103:    int test_ret = 0;
        -:17104:
        -:17105:#if defined(LIBXML_PATTERN_ENABLED)
        -:17106:    int mem_base;
        -:17107:    int ret_val;
        -:17108:    xmlStreamCtxtPtr stream; /* the stream context */
        -:17109:    int n_stream;
        -:17110:    xmlChar * name; /* the current name */
        -:17111:    int n_name;
        -:17112:    xmlChar * ns; /* the namespace name */
        -:17113:    int n_ns;
        -:17114:
    #####:17115:    for (n_stream = 0;n_stream < gen_nb_xmlStreamCtxtPtr;n_stream++) {
    #####:17116:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:17117:    for (n_ns = 0;n_ns < gen_nb_const_xmlChar_ptr;n_ns++) {
    #####:17118:        mem_base = xmlMemBlocks();
    #####:17119:        stream = gen_xmlStreamCtxtPtr(n_stream, 0);
    #####:17120:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:17121:        ns = gen_const_xmlChar_ptr(n_ns, 2);
        -:17122:
    #####:17123:        ret_val = xmlStreamPushAttr(stream, (const xmlChar *)name, (const xmlChar *)ns);
    #####:17124:        desret_int(ret_val);
    #####:17125:        call_tests++;
    #####:17126:        des_xmlStreamCtxtPtr(n_stream, stream, 0);
    #####:17127:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:17128:        des_const_xmlChar_ptr(n_ns, (const xmlChar *)ns, 2);
    #####:17129:        xmlResetLastError();
    #####:17130:        if (mem_base != xmlMemBlocks()) {
    #####:17131:            printf("Leak of %d blocks found in xmlStreamPushAttr",
    #####:17132:	           xmlMemBlocks() - mem_base);
    #####:17133:	    test_ret++;
    #####:17134:            printf(" %d", n_stream);
    #####:17135:            printf(" %d", n_name);
    #####:17136:            printf(" %d", n_ns);
    #####:17137:            printf("\n");
        -:17138:        }
        -:17139:    }
        -:17140:    }
        -:17141:    }
    #####:17142:    function_tests++;
        -:17143:#endif
        -:17144:
    #####:17145:    return(test_ret);
        -:17146:}
        -:17147:
        -:17148:
        -:17149:static int
    #####:17150:test_xmlStreamPushNode(void) {
    #####:17151:    int test_ret = 0;
        -:17152:
        -:17153:#if defined(LIBXML_PATTERN_ENABLED)
        -:17154:    int mem_base;
        -:17155:    int ret_val;
        -:17156:    xmlStreamCtxtPtr stream; /* the stream context */
        -:17157:    int n_stream;
        -:17158:    xmlChar * name; /* the current name */
        -:17159:    int n_name;
        -:17160:    xmlChar * ns; /* the namespace name */
        -:17161:    int n_ns;
        -:17162:    int nodeType; /* the type of the node being pushed */
        -:17163:    int n_nodeType;
        -:17164:
    #####:17165:    for (n_stream = 0;n_stream < gen_nb_xmlStreamCtxtPtr;n_stream++) {
    #####:17166:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:17167:    for (n_ns = 0;n_ns < gen_nb_const_xmlChar_ptr;n_ns++) {
    #####:17168:    for (n_nodeType = 0;n_nodeType < gen_nb_int;n_nodeType++) {
    #####:17169:        mem_base = xmlMemBlocks();
    #####:17170:        stream = gen_xmlStreamCtxtPtr(n_stream, 0);
    #####:17171:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:17172:        ns = gen_const_xmlChar_ptr(n_ns, 2);
    #####:17173:        nodeType = gen_int(n_nodeType, 3);
        -:17174:
    #####:17175:        ret_val = xmlStreamPushNode(stream, (const xmlChar *)name, (const xmlChar *)ns, nodeType);
    #####:17176:        desret_int(ret_val);
    #####:17177:        call_tests++;
    #####:17178:        des_xmlStreamCtxtPtr(n_stream, stream, 0);
    #####:17179:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:17180:        des_const_xmlChar_ptr(n_ns, (const xmlChar *)ns, 2);
    #####:17181:        des_int(n_nodeType, nodeType, 3);
    #####:17182:        xmlResetLastError();
    #####:17183:        if (mem_base != xmlMemBlocks()) {
    #####:17184:            printf("Leak of %d blocks found in xmlStreamPushNode",
    #####:17185:	           xmlMemBlocks() - mem_base);
    #####:17186:	    test_ret++;
    #####:17187:            printf(" %d", n_stream);
    #####:17188:            printf(" %d", n_name);
    #####:17189:            printf(" %d", n_ns);
    #####:17190:            printf(" %d", n_nodeType);
    #####:17191:            printf("\n");
        -:17192:        }
        -:17193:    }
        -:17194:    }
        -:17195:    }
        -:17196:    }
    #####:17197:    function_tests++;
        -:17198:#endif
        -:17199:
    #####:17200:    return(test_ret);
        -:17201:}
        -:17202:
        -:17203:
        -:17204:static int
    #####:17205:test_xmlStreamWantsAnyNode(void) {
    #####:17206:    int test_ret = 0;
        -:17207:
        -:17208:#if defined(LIBXML_PATTERN_ENABLED)
        -:17209:    int mem_base;
        -:17210:    int ret_val;
        -:17211:    xmlStreamCtxtPtr streamCtxt; /* the stream context */
        -:17212:    int n_streamCtxt;
        -:17213:
    #####:17214:    for (n_streamCtxt = 0;n_streamCtxt < gen_nb_xmlStreamCtxtPtr;n_streamCtxt++) {
    #####:17215:        mem_base = xmlMemBlocks();
    #####:17216:        streamCtxt = gen_xmlStreamCtxtPtr(n_streamCtxt, 0);
        -:17217:
    #####:17218:        ret_val = xmlStreamWantsAnyNode(streamCtxt);
    #####:17219:        desret_int(ret_val);
    #####:17220:        call_tests++;
    #####:17221:        des_xmlStreamCtxtPtr(n_streamCtxt, streamCtxt, 0);
    #####:17222:        xmlResetLastError();
    #####:17223:        if (mem_base != xmlMemBlocks()) {
    #####:17224:            printf("Leak of %d blocks found in xmlStreamWantsAnyNode",
    #####:17225:	           xmlMemBlocks() - mem_base);
    #####:17226:	    test_ret++;
    #####:17227:            printf(" %d", n_streamCtxt);
    #####:17228:            printf("\n");
        -:17229:        }
        -:17230:    }
    #####:17231:    function_tests++;
        -:17232:#endif
        -:17233:
    #####:17234:    return(test_ret);
        -:17235:}
        -:17236:
        -:17237:static int
    #####:17238:test_pattern(void) {
    #####:17239:    int test_ret = 0;
        -:17240:
    #####:17241:    if (quiet == 0) printf("Testing pattern : 10 of 15 functions ...\n");
    #####:17242:    test_ret += test_xmlPatternFromRoot();
    #####:17243:    test_ret += test_xmlPatternGetStreamCtxt();
    #####:17244:    test_ret += test_xmlPatternMatch();
    #####:17245:    test_ret += test_xmlPatternMaxDepth();
    #####:17246:    test_ret += test_xmlPatternMinDepth();
    #####:17247:    test_ret += test_xmlPatternStreamable();
    #####:17248:    test_ret += test_xmlPatterncompile();
    #####:17249:    test_ret += test_xmlStreamPop();
    #####:17250:    test_ret += test_xmlStreamPush();
    #####:17251:    test_ret += test_xmlStreamPushAttr();
    #####:17252:    test_ret += test_xmlStreamPushNode();
    #####:17253:    test_ret += test_xmlStreamWantsAnyNode();
        -:17254:
    #####:17255:    if (test_ret != 0)
    #####:17256:	printf("Module pattern: %d errors\n", test_ret);
    #####:17257:    return(test_ret);
        -:17258:}
        -:17259:#ifdef LIBXML_SCHEMAS_ENABLED
        -:17260:
        -:17261:#define gen_nb_xmlRelaxNGPtr 1
    #####:17262:static xmlRelaxNGPtr gen_xmlRelaxNGPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:17263:    return(NULL);
        -:17264:}
    #####:17265:static void des_xmlRelaxNGPtr(int no ATTRIBUTE_UNUSED, xmlRelaxNGPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:17266:}
        -:17267:#endif
        -:17268:
        -:17269:
        -:17270:static int
    #####:17271:test_xmlRelaxNGDump(void) {
    #####:17272:    int test_ret = 0;
        -:17273:
        -:17274:#if defined(LIBXML_SCHEMAS_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
        -:17275:    int mem_base;
        -:17276:    FILE * output; /* the file output */
        -:17277:    int n_output;
        -:17278:    xmlRelaxNGPtr schema; /* a schema structure */
        -:17279:    int n_schema;
        -:17280:
    #####:17281:    for (n_output = 0;n_output < gen_nb_FILE_ptr;n_output++) {
    #####:17282:    for (n_schema = 0;n_schema < gen_nb_xmlRelaxNGPtr;n_schema++) {
    #####:17283:        mem_base = xmlMemBlocks();
    #####:17284:        output = gen_FILE_ptr(n_output, 0);
    #####:17285:        schema = gen_xmlRelaxNGPtr(n_schema, 1);
        -:17286:
    #####:17287:        xmlRelaxNGDump(output, schema);
    #####:17288:        call_tests++;
    #####:17289:        des_FILE_ptr(n_output, output, 0);
    #####:17290:        des_xmlRelaxNGPtr(n_schema, schema, 1);
    #####:17291:        xmlResetLastError();
    #####:17292:        if (mem_base != xmlMemBlocks()) {
    #####:17293:            printf("Leak of %d blocks found in xmlRelaxNGDump",
    #####:17294:	           xmlMemBlocks() - mem_base);
    #####:17295:	    test_ret++;
    #####:17296:            printf(" %d", n_output);
    #####:17297:            printf(" %d", n_schema);
    #####:17298:            printf("\n");
        -:17299:        }
        -:17300:    }
        -:17301:    }
    #####:17302:    function_tests++;
        -:17303:#endif
        -:17304:
    #####:17305:    return(test_ret);
        -:17306:}
        -:17307:
        -:17308:
        -:17309:static int
    #####:17310:test_xmlRelaxNGDumpTree(void) {
    #####:17311:    int test_ret = 0;
        -:17312:
        -:17313:#if defined(LIBXML_SCHEMAS_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
        -:17314:    int mem_base;
        -:17315:    FILE * output; /* the file output */
        -:17316:    int n_output;
        -:17317:    xmlRelaxNGPtr schema; /* a schema structure */
        -:17318:    int n_schema;
        -:17319:
    #####:17320:    for (n_output = 0;n_output < gen_nb_FILE_ptr;n_output++) {
    #####:17321:    for (n_schema = 0;n_schema < gen_nb_xmlRelaxNGPtr;n_schema++) {
    #####:17322:        mem_base = xmlMemBlocks();
    #####:17323:        output = gen_FILE_ptr(n_output, 0);
    #####:17324:        schema = gen_xmlRelaxNGPtr(n_schema, 1);
        -:17325:
    #####:17326:        xmlRelaxNGDumpTree(output, schema);
    #####:17327:        call_tests++;
    #####:17328:        des_FILE_ptr(n_output, output, 0);
    #####:17329:        des_xmlRelaxNGPtr(n_schema, schema, 1);
    #####:17330:        xmlResetLastError();
    #####:17331:        if (mem_base != xmlMemBlocks()) {
    #####:17332:            printf("Leak of %d blocks found in xmlRelaxNGDumpTree",
    #####:17333:	           xmlMemBlocks() - mem_base);
    #####:17334:	    test_ret++;
    #####:17335:            printf(" %d", n_output);
    #####:17336:            printf(" %d", n_schema);
    #####:17337:            printf("\n");
        -:17338:        }
        -:17339:    }
        -:17340:    }
    #####:17341:    function_tests++;
        -:17342:#endif
        -:17343:
    #####:17344:    return(test_ret);
        -:17345:}
        -:17346:
        -:17347:#ifdef LIBXML_SCHEMAS_ENABLED
        -:17348:
        -:17349:#define gen_nb_xmlRelaxNGParserCtxtPtr 1
    #####:17350:static xmlRelaxNGParserCtxtPtr gen_xmlRelaxNGParserCtxtPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:17351:    return(NULL);
        -:17352:}
    #####:17353:static void des_xmlRelaxNGParserCtxtPtr(int no ATTRIBUTE_UNUSED, xmlRelaxNGParserCtxtPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:17354:}
        -:17355:#endif
        -:17356:
        -:17357:#ifdef LIBXML_SCHEMAS_ENABLED
        -:17358:
        -:17359:#define gen_nb_xmlRelaxNGValidityErrorFunc_ptr 1
    #####:17360:static xmlRelaxNGValidityErrorFunc * gen_xmlRelaxNGValidityErrorFunc_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:17361:    return(NULL);
        -:17362:}
    #####:17363:static void des_xmlRelaxNGValidityErrorFunc_ptr(int no ATTRIBUTE_UNUSED, xmlRelaxNGValidityErrorFunc * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:17364:}
        -:17365:#endif
        -:17366:
        -:17367:#ifdef LIBXML_SCHEMAS_ENABLED
        -:17368:
        -:17369:#define gen_nb_xmlRelaxNGValidityWarningFunc_ptr 1
    #####:17370:static xmlRelaxNGValidityWarningFunc * gen_xmlRelaxNGValidityWarningFunc_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:17371:    return(NULL);
        -:17372:}
    #####:17373:static void des_xmlRelaxNGValidityWarningFunc_ptr(int no ATTRIBUTE_UNUSED, xmlRelaxNGValidityWarningFunc * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:17374:}
        -:17375:#endif
        -:17376:
        -:17377:
        -:17378:static int
    #####:17379:test_xmlRelaxNGGetParserErrors(void) {
    #####:17380:    int test_ret = 0;
        -:17381:
        -:17382:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:17383:    int mem_base;
        -:17384:    int ret_val;
        -:17385:    xmlRelaxNGParserCtxtPtr ctxt; /* a Relax-NG validation context */
        -:17386:    int n_ctxt;
        -:17387:    xmlRelaxNGValidityErrorFunc * err; /* the error callback result */
        -:17388:    int n_err;
        -:17389:    xmlRelaxNGValidityWarningFunc * warn; /* the warning callback result */
        -:17390:    int n_warn;
        -:17391:    void ** ctx; /* contextual data for the callbacks result */
        -:17392:    int n_ctx;
        -:17393:
    #####:17394:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlRelaxNGParserCtxtPtr;n_ctxt++) {
    #####:17395:    for (n_err = 0;n_err < gen_nb_xmlRelaxNGValidityErrorFunc_ptr;n_err++) {
    #####:17396:    for (n_warn = 0;n_warn < gen_nb_xmlRelaxNGValidityWarningFunc_ptr;n_warn++) {
    #####:17397:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr_ptr;n_ctx++) {
    #####:17398:        mem_base = xmlMemBlocks();
    #####:17399:        ctxt = gen_xmlRelaxNGParserCtxtPtr(n_ctxt, 0);
    #####:17400:        err = gen_xmlRelaxNGValidityErrorFunc_ptr(n_err, 1);
    #####:17401:        warn = gen_xmlRelaxNGValidityWarningFunc_ptr(n_warn, 2);
    #####:17402:        ctx = gen_void_ptr_ptr(n_ctx, 3);
        -:17403:
    #####:17404:        ret_val = xmlRelaxNGGetParserErrors(ctxt, err, warn, ctx);
    #####:17405:        desret_int(ret_val);
    #####:17406:        call_tests++;
    #####:17407:        des_xmlRelaxNGParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:17408:        des_xmlRelaxNGValidityErrorFunc_ptr(n_err, err, 1);
    #####:17409:        des_xmlRelaxNGValidityWarningFunc_ptr(n_warn, warn, 2);
    #####:17410:        des_void_ptr_ptr(n_ctx, ctx, 3);
    #####:17411:        xmlResetLastError();
    #####:17412:        if (mem_base != xmlMemBlocks()) {
    #####:17413:            printf("Leak of %d blocks found in xmlRelaxNGGetParserErrors",
    #####:17414:	           xmlMemBlocks() - mem_base);
    #####:17415:	    test_ret++;
    #####:17416:            printf(" %d", n_ctxt);
    #####:17417:            printf(" %d", n_err);
    #####:17418:            printf(" %d", n_warn);
    #####:17419:            printf(" %d", n_ctx);
    #####:17420:            printf("\n");
        -:17421:        }
        -:17422:    }
        -:17423:    }
        -:17424:    }
        -:17425:    }
    #####:17426:    function_tests++;
        -:17427:#endif
        -:17428:
    #####:17429:    return(test_ret);
        -:17430:}
        -:17431:
        -:17432:#ifdef LIBXML_SCHEMAS_ENABLED
        -:17433:
        -:17434:#define gen_nb_xmlRelaxNGValidCtxtPtr 1
    #####:17435:static xmlRelaxNGValidCtxtPtr gen_xmlRelaxNGValidCtxtPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:17436:    return(NULL);
        -:17437:}
    #####:17438:static void des_xmlRelaxNGValidCtxtPtr(int no ATTRIBUTE_UNUSED, xmlRelaxNGValidCtxtPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:17439:}
        -:17440:#endif
        -:17441:
        -:17442:
        -:17443:static int
    #####:17444:test_xmlRelaxNGGetValidErrors(void) {
    #####:17445:    int test_ret = 0;
        -:17446:
        -:17447:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:17448:    int mem_base;
        -:17449:    int ret_val;
        -:17450:    xmlRelaxNGValidCtxtPtr ctxt; /* a Relax-NG validation context */
        -:17451:    int n_ctxt;
        -:17452:    xmlRelaxNGValidityErrorFunc * err; /* the error function result */
        -:17453:    int n_err;
        -:17454:    xmlRelaxNGValidityWarningFunc * warn; /* the warning function result */
        -:17455:    int n_warn;
        -:17456:    void ** ctx; /* the functions context result */
        -:17457:    int n_ctx;
        -:17458:
    #####:17459:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlRelaxNGValidCtxtPtr;n_ctxt++) {
    #####:17460:    for (n_err = 0;n_err < gen_nb_xmlRelaxNGValidityErrorFunc_ptr;n_err++) {
    #####:17461:    for (n_warn = 0;n_warn < gen_nb_xmlRelaxNGValidityWarningFunc_ptr;n_warn++) {
    #####:17462:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr_ptr;n_ctx++) {
    #####:17463:        mem_base = xmlMemBlocks();
    #####:17464:        ctxt = gen_xmlRelaxNGValidCtxtPtr(n_ctxt, 0);
    #####:17465:        err = gen_xmlRelaxNGValidityErrorFunc_ptr(n_err, 1);
    #####:17466:        warn = gen_xmlRelaxNGValidityWarningFunc_ptr(n_warn, 2);
    #####:17467:        ctx = gen_void_ptr_ptr(n_ctx, 3);
        -:17468:
    #####:17469:        ret_val = xmlRelaxNGGetValidErrors(ctxt, err, warn, ctx);
    #####:17470:        desret_int(ret_val);
    #####:17471:        call_tests++;
    #####:17472:        des_xmlRelaxNGValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:17473:        des_xmlRelaxNGValidityErrorFunc_ptr(n_err, err, 1);
    #####:17474:        des_xmlRelaxNGValidityWarningFunc_ptr(n_warn, warn, 2);
    #####:17475:        des_void_ptr_ptr(n_ctx, ctx, 3);
    #####:17476:        xmlResetLastError();
    #####:17477:        if (mem_base != xmlMemBlocks()) {
    #####:17478:            printf("Leak of %d blocks found in xmlRelaxNGGetValidErrors",
    #####:17479:	           xmlMemBlocks() - mem_base);
    #####:17480:	    test_ret++;
    #####:17481:            printf(" %d", n_ctxt);
    #####:17482:            printf(" %d", n_err);
    #####:17483:            printf(" %d", n_warn);
    #####:17484:            printf(" %d", n_ctx);
    #####:17485:            printf("\n");
        -:17486:        }
        -:17487:    }
        -:17488:    }
        -:17489:    }
        -:17490:    }
    #####:17491:    function_tests++;
        -:17492:#endif
        -:17493:
    #####:17494:    return(test_ret);
        -:17495:}
        -:17496:
        -:17497:
        -:17498:static int
    #####:17499:test_xmlRelaxNGInitTypes(void) {
    #####:17500:    int test_ret = 0;
        -:17501:
        -:17502:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:17503:    int mem_base;
        -:17504:    int ret_val;
        -:17505:
    #####:17506:        mem_base = xmlMemBlocks();
        -:17507:
    #####:17508:        ret_val = xmlRelaxNGInitTypes();
    #####:17509:        desret_int(ret_val);
    #####:17510:        call_tests++;
    #####:17511:        xmlResetLastError();
    #####:17512:        if (mem_base != xmlMemBlocks()) {
    #####:17513:            printf("Leak of %d blocks found in xmlRelaxNGInitTypes",
    #####:17514:	           xmlMemBlocks() - mem_base);
    #####:17515:	    test_ret++;
    #####:17516:            printf("\n");
        -:17517:        }
    #####:17518:    function_tests++;
        -:17519:#endif
        -:17520:
    #####:17521:    return(test_ret);
        -:17522:}
        -:17523:
        -:17524:
        -:17525:static int
    #####:17526:test_xmlRelaxNGNewDocParserCtxt(void) {
    #####:17527:    int test_ret = 0;
        -:17528:
        -:17529:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:17530:    int mem_base;
        -:17531:    xmlRelaxNGParserCtxtPtr ret_val;
        -:17532:    xmlDocPtr doc; /* a preparsed document tree */
        -:17533:    int n_doc;
        -:17534:
    #####:17535:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:17536:        mem_base = xmlMemBlocks();
    #####:17537:        doc = gen_xmlDocPtr(n_doc, 0);
        -:17538:
    #####:17539:        ret_val = xmlRelaxNGNewDocParserCtxt(doc);
    #####:17540:        desret_xmlRelaxNGParserCtxtPtr(ret_val);
    #####:17541:        call_tests++;
    #####:17542:        des_xmlDocPtr(n_doc, doc, 0);
    #####:17543:        xmlResetLastError();
    #####:17544:        if (mem_base != xmlMemBlocks()) {
    #####:17545:            printf("Leak of %d blocks found in xmlRelaxNGNewDocParserCtxt",
    #####:17546:	           xmlMemBlocks() - mem_base);
    #####:17547:	    test_ret++;
    #####:17548:            printf(" %d", n_doc);
    #####:17549:            printf("\n");
        -:17550:        }
        -:17551:    }
    #####:17552:    function_tests++;
        -:17553:#endif
        -:17554:
    #####:17555:    return(test_ret);
        -:17556:}
        -:17557:
        -:17558:
        -:17559:static int
    #####:17560:test_xmlRelaxNGNewMemParserCtxt(void) {
    #####:17561:    int test_ret = 0;
        -:17562:
        -:17563:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:17564:    int mem_base;
        -:17565:    xmlRelaxNGParserCtxtPtr ret_val;
        -:17566:    char * buffer; /* a pointer to a char array containing the schemas */
        -:17567:    int n_buffer;
        -:17568:    int size; /* the size of the array */
        -:17569:    int n_size;
        -:17570:
    #####:17571:    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    #####:17572:    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    #####:17573:        mem_base = xmlMemBlocks();
    #####:17574:        buffer = gen_const_char_ptr(n_buffer, 0);
    #####:17575:        size = gen_int(n_size, 1);
        -:17576:
    #####:17577:        ret_val = xmlRelaxNGNewMemParserCtxt((const char *)buffer, size);
    #####:17578:        desret_xmlRelaxNGParserCtxtPtr(ret_val);
    #####:17579:        call_tests++;
    #####:17580:        des_const_char_ptr(n_buffer, (const char *)buffer, 0);
    #####:17581:        des_int(n_size, size, 1);
    #####:17582:        xmlResetLastError();
    #####:17583:        if (mem_base != xmlMemBlocks()) {
    #####:17584:            printf("Leak of %d blocks found in xmlRelaxNGNewMemParserCtxt",
    #####:17585:	           xmlMemBlocks() - mem_base);
    #####:17586:	    test_ret++;
    #####:17587:            printf(" %d", n_buffer);
    #####:17588:            printf(" %d", n_size);
    #####:17589:            printf("\n");
        -:17590:        }
        -:17591:    }
        -:17592:    }
    #####:17593:    function_tests++;
        -:17594:#endif
        -:17595:
    #####:17596:    return(test_ret);
        -:17597:}
        -:17598:
        -:17599:
        -:17600:static int
    #####:17601:test_xmlRelaxNGNewParserCtxt(void) {
    #####:17602:    int test_ret = 0;
        -:17603:
        -:17604:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:17605:    int mem_base;
        -:17606:    xmlRelaxNGParserCtxtPtr ret_val;
        -:17607:    char * URL; /* the location of the schema */
        -:17608:    int n_URL;
        -:17609:
    #####:17610:    for (n_URL = 0;n_URL < gen_nb_const_char_ptr;n_URL++) {
    #####:17611:        mem_base = xmlMemBlocks();
    #####:17612:        URL = gen_const_char_ptr(n_URL, 0);
        -:17613:
    #####:17614:        ret_val = xmlRelaxNGNewParserCtxt((const char *)URL);
    #####:17615:        desret_xmlRelaxNGParserCtxtPtr(ret_val);
    #####:17616:        call_tests++;
    #####:17617:        des_const_char_ptr(n_URL, (const char *)URL, 0);
    #####:17618:        xmlResetLastError();
    #####:17619:        if (mem_base != xmlMemBlocks()) {
    #####:17620:            printf("Leak of %d blocks found in xmlRelaxNGNewParserCtxt",
    #####:17621:	           xmlMemBlocks() - mem_base);
    #####:17622:	    test_ret++;
    #####:17623:            printf(" %d", n_URL);
    #####:17624:            printf("\n");
        -:17625:        }
        -:17626:    }
    #####:17627:    function_tests++;
        -:17628:#endif
        -:17629:
    #####:17630:    return(test_ret);
        -:17631:}
        -:17632:
        -:17633:
        -:17634:static int
    #####:17635:test_xmlRelaxNGNewValidCtxt(void) {
    #####:17636:    int test_ret = 0;
        -:17637:
        -:17638:
        -:17639:    /* missing type support */
    #####:17640:    return(test_ret);
        -:17641:}
        -:17642:
        -:17643:
        -:17644:static int
    #####:17645:test_xmlRelaxNGParse(void) {
    #####:17646:    int test_ret = 0;
        -:17647:
        -:17648:
        -:17649:    /* missing type support */
    #####:17650:    return(test_ret);
        -:17651:}
        -:17652:
        -:17653:
        -:17654:static int
    #####:17655:test_xmlRelaxNGSetParserErrors(void) {
    #####:17656:    int test_ret = 0;
        -:17657:
        -:17658:
        -:17659:    /* missing type support */
    #####:17660:    return(test_ret);
        -:17661:}
        -:17662:
        -:17663:
        -:17664:static int
    #####:17665:test_xmlRelaxNGSetParserStructuredErrors(void) {
    #####:17666:    int test_ret = 0;
        -:17667:
        -:17668:
        -:17669:    /* missing type support */
    #####:17670:    return(test_ret);
        -:17671:}
        -:17672:
        -:17673:
        -:17674:static int
    #####:17675:test_xmlRelaxNGSetValidErrors(void) {
    #####:17676:    int test_ret = 0;
        -:17677:
        -:17678:
        -:17679:    /* missing type support */
    #####:17680:    return(test_ret);
        -:17681:}
        -:17682:
        -:17683:
        -:17684:static int
    #####:17685:test_xmlRelaxNGSetValidStructuredErrors(void) {
    #####:17686:    int test_ret = 0;
        -:17687:
        -:17688:
        -:17689:    /* missing type support */
    #####:17690:    return(test_ret);
        -:17691:}
        -:17692:
        -:17693:
        -:17694:static int
    #####:17695:test_xmlRelaxNGValidateDoc(void) {
    #####:17696:    int test_ret = 0;
        -:17697:
        -:17698:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:17699:    int mem_base;
        -:17700:    int ret_val;
        -:17701:    xmlRelaxNGValidCtxtPtr ctxt; /* a Relax-NG validation context */
        -:17702:    int n_ctxt;
        -:17703:    xmlDocPtr doc; /* a parsed document tree */
        -:17704:    int n_doc;
        -:17705:
    #####:17706:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlRelaxNGValidCtxtPtr;n_ctxt++) {
    #####:17707:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:17708:        mem_base = xmlMemBlocks();
    #####:17709:        ctxt = gen_xmlRelaxNGValidCtxtPtr(n_ctxt, 0);
    #####:17710:        doc = gen_xmlDocPtr(n_doc, 1);
        -:17711:
    #####:17712:        ret_val = xmlRelaxNGValidateDoc(ctxt, doc);
    #####:17713:        desret_int(ret_val);
    #####:17714:        call_tests++;
    #####:17715:        des_xmlRelaxNGValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:17716:        des_xmlDocPtr(n_doc, doc, 1);
    #####:17717:        xmlResetLastError();
    #####:17718:        if (mem_base != xmlMemBlocks()) {
    #####:17719:            printf("Leak of %d blocks found in xmlRelaxNGValidateDoc",
    #####:17720:	           xmlMemBlocks() - mem_base);
    #####:17721:	    test_ret++;
    #####:17722:            printf(" %d", n_ctxt);
    #####:17723:            printf(" %d", n_doc);
    #####:17724:            printf("\n");
        -:17725:        }
        -:17726:    }
        -:17727:    }
    #####:17728:    function_tests++;
        -:17729:#endif
        -:17730:
    #####:17731:    return(test_ret);
        -:17732:}
        -:17733:
        -:17734:
        -:17735:static int
    #####:17736:test_xmlRelaxNGValidateFullElement(void) {
    #####:17737:    int test_ret = 0;
        -:17738:
        -:17739:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:17740:    int mem_base;
        -:17741:    int ret_val;
        -:17742:    xmlRelaxNGValidCtxtPtr ctxt; /* the validation context */
        -:17743:    int n_ctxt;
        -:17744:    xmlDocPtr doc; /* a document instance */
        -:17745:    int n_doc;
        -:17746:    xmlNodePtr elem; /* an element instance */
        -:17747:    int n_elem;
        -:17748:
    #####:17749:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlRelaxNGValidCtxtPtr;n_ctxt++) {
    #####:17750:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:17751:    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    #####:17752:        mem_base = xmlMemBlocks();
    #####:17753:        ctxt = gen_xmlRelaxNGValidCtxtPtr(n_ctxt, 0);
    #####:17754:        doc = gen_xmlDocPtr(n_doc, 1);
    #####:17755:        elem = gen_xmlNodePtr(n_elem, 2);
        -:17756:
    #####:17757:        ret_val = xmlRelaxNGValidateFullElement(ctxt, doc, elem);
    #####:17758:        desret_int(ret_val);
    #####:17759:        call_tests++;
    #####:17760:        des_xmlRelaxNGValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:17761:        des_xmlDocPtr(n_doc, doc, 1);
    #####:17762:        des_xmlNodePtr(n_elem, elem, 2);
    #####:17763:        xmlResetLastError();
    #####:17764:        if (mem_base != xmlMemBlocks()) {
    #####:17765:            printf("Leak of %d blocks found in xmlRelaxNGValidateFullElement",
    #####:17766:	           xmlMemBlocks() - mem_base);
    #####:17767:	    test_ret++;
    #####:17768:            printf(" %d", n_ctxt);
    #####:17769:            printf(" %d", n_doc);
    #####:17770:            printf(" %d", n_elem);
    #####:17771:            printf("\n");
        -:17772:        }
        -:17773:    }
        -:17774:    }
        -:17775:    }
    #####:17776:    function_tests++;
        -:17777:#endif
        -:17778:
    #####:17779:    return(test_ret);
        -:17780:}
        -:17781:
        -:17782:
        -:17783:static int
    #####:17784:test_xmlRelaxNGValidatePopElement(void) {
    #####:17785:    int test_ret = 0;
        -:17786:
        -:17787:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:17788:    int mem_base;
        -:17789:    int ret_val;
        -:17790:    xmlRelaxNGValidCtxtPtr ctxt; /* the RelaxNG validation context */
        -:17791:    int n_ctxt;
        -:17792:    xmlDocPtr doc; /* a document instance */
        -:17793:    int n_doc;
        -:17794:    xmlNodePtr elem; /* an element instance */
        -:17795:    int n_elem;
        -:17796:
    #####:17797:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlRelaxNGValidCtxtPtr;n_ctxt++) {
    #####:17798:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:17799:    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    #####:17800:        mem_base = xmlMemBlocks();
    #####:17801:        ctxt = gen_xmlRelaxNGValidCtxtPtr(n_ctxt, 0);
    #####:17802:        doc = gen_xmlDocPtr(n_doc, 1);
    #####:17803:        elem = gen_xmlNodePtr(n_elem, 2);
        -:17804:
    #####:17805:        ret_val = xmlRelaxNGValidatePopElement(ctxt, doc, elem);
    #####:17806:        desret_int(ret_val);
    #####:17807:        call_tests++;
    #####:17808:        des_xmlRelaxNGValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:17809:        des_xmlDocPtr(n_doc, doc, 1);
    #####:17810:        des_xmlNodePtr(n_elem, elem, 2);
    #####:17811:        xmlResetLastError();
    #####:17812:        if (mem_base != xmlMemBlocks()) {
    #####:17813:            printf("Leak of %d blocks found in xmlRelaxNGValidatePopElement",
    #####:17814:	           xmlMemBlocks() - mem_base);
    #####:17815:	    test_ret++;
    #####:17816:            printf(" %d", n_ctxt);
    #####:17817:            printf(" %d", n_doc);
    #####:17818:            printf(" %d", n_elem);
    #####:17819:            printf("\n");
        -:17820:        }
        -:17821:    }
        -:17822:    }
        -:17823:    }
    #####:17824:    function_tests++;
        -:17825:#endif
        -:17826:
    #####:17827:    return(test_ret);
        -:17828:}
        -:17829:
        -:17830:
        -:17831:static int
    #####:17832:test_xmlRelaxNGValidatePushCData(void) {
    #####:17833:    int test_ret = 0;
        -:17834:
        -:17835:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:17836:    int mem_base;
        -:17837:    int ret_val;
        -:17838:    xmlRelaxNGValidCtxtPtr ctxt; /* the RelaxNG validation context */
        -:17839:    int n_ctxt;
        -:17840:    xmlChar * data; /* some character data read */
        -:17841:    int n_data;
        -:17842:    int len; /* the length of the data */
        -:17843:    int n_len;
        -:17844:
    #####:17845:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlRelaxNGValidCtxtPtr;n_ctxt++) {
    #####:17846:    for (n_data = 0;n_data < gen_nb_const_xmlChar_ptr;n_data++) {
    #####:17847:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:17848:        mem_base = xmlMemBlocks();
    #####:17849:        ctxt = gen_xmlRelaxNGValidCtxtPtr(n_ctxt, 0);
    #####:17850:        data = gen_const_xmlChar_ptr(n_data, 1);
    #####:17851:        len = gen_int(n_len, 2);
        -:17852:
    #####:17853:        ret_val = xmlRelaxNGValidatePushCData(ctxt, (const xmlChar *)data, len);
    #####:17854:        desret_int(ret_val);
    #####:17855:        call_tests++;
    #####:17856:        des_xmlRelaxNGValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:17857:        des_const_xmlChar_ptr(n_data, (const xmlChar *)data, 1);
    #####:17858:        des_int(n_len, len, 2);
    #####:17859:        xmlResetLastError();
    #####:17860:        if (mem_base != xmlMemBlocks()) {
    #####:17861:            printf("Leak of %d blocks found in xmlRelaxNGValidatePushCData",
    #####:17862:	           xmlMemBlocks() - mem_base);
    #####:17863:	    test_ret++;
    #####:17864:            printf(" %d", n_ctxt);
    #####:17865:            printf(" %d", n_data);
    #####:17866:            printf(" %d", n_len);
    #####:17867:            printf("\n");
        -:17868:        }
        -:17869:    }
        -:17870:    }
        -:17871:    }
    #####:17872:    function_tests++;
        -:17873:#endif
        -:17874:
    #####:17875:    return(test_ret);
        -:17876:}
        -:17877:
        -:17878:
        -:17879:static int
    #####:17880:test_xmlRelaxNGValidatePushElement(void) {
    #####:17881:    int test_ret = 0;
        -:17882:
        -:17883:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:17884:    int mem_base;
        -:17885:    int ret_val;
        -:17886:    xmlRelaxNGValidCtxtPtr ctxt; /* the validation context */
        -:17887:    int n_ctxt;
        -:17888:    xmlDocPtr doc; /* a document instance */
        -:17889:    int n_doc;
        -:17890:    xmlNodePtr elem; /* an element instance */
        -:17891:    int n_elem;
        -:17892:
    #####:17893:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlRelaxNGValidCtxtPtr;n_ctxt++) {
    #####:17894:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:17895:    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    #####:17896:        mem_base = xmlMemBlocks();
    #####:17897:        ctxt = gen_xmlRelaxNGValidCtxtPtr(n_ctxt, 0);
    #####:17898:        doc = gen_xmlDocPtr(n_doc, 1);
    #####:17899:        elem = gen_xmlNodePtr(n_elem, 2);
        -:17900:
    #####:17901:        ret_val = xmlRelaxNGValidatePushElement(ctxt, doc, elem);
    #####:17902:        desret_int(ret_val);
    #####:17903:        call_tests++;
    #####:17904:        des_xmlRelaxNGValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:17905:        des_xmlDocPtr(n_doc, doc, 1);
    #####:17906:        des_xmlNodePtr(n_elem, elem, 2);
    #####:17907:        xmlResetLastError();
    #####:17908:        if (mem_base != xmlMemBlocks()) {
    #####:17909:            printf("Leak of %d blocks found in xmlRelaxNGValidatePushElement",
    #####:17910:	           xmlMemBlocks() - mem_base);
    #####:17911:	    test_ret++;
    #####:17912:            printf(" %d", n_ctxt);
    #####:17913:            printf(" %d", n_doc);
    #####:17914:            printf(" %d", n_elem);
    #####:17915:            printf("\n");
        -:17916:        }
        -:17917:    }
        -:17918:    }
        -:17919:    }
    #####:17920:    function_tests++;
        -:17921:#endif
        -:17922:
    #####:17923:    return(test_ret);
        -:17924:}
        -:17925:
        -:17926:
        -:17927:static int
    #####:17928:test_xmlRelaxParserSetFlag(void) {
    #####:17929:    int test_ret = 0;
        -:17930:
        -:17931:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:17932:    int mem_base;
        -:17933:    int ret_val;
        -:17934:    xmlRelaxNGParserCtxtPtr ctxt; /* a RelaxNG parser context */
        -:17935:    int n_ctxt;
        -:17936:    int flags; /* a set of flags values */
        -:17937:    int n_flags;
        -:17938:
    #####:17939:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlRelaxNGParserCtxtPtr;n_ctxt++) {
    #####:17940:    for (n_flags = 0;n_flags < gen_nb_int;n_flags++) {
    #####:17941:        mem_base = xmlMemBlocks();
    #####:17942:        ctxt = gen_xmlRelaxNGParserCtxtPtr(n_ctxt, 0);
    #####:17943:        flags = gen_int(n_flags, 1);
        -:17944:
    #####:17945:        ret_val = xmlRelaxParserSetFlag(ctxt, flags);
    #####:17946:        desret_int(ret_val);
    #####:17947:        call_tests++;
    #####:17948:        des_xmlRelaxNGParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:17949:        des_int(n_flags, flags, 1);
    #####:17950:        xmlResetLastError();
    #####:17951:        if (mem_base != xmlMemBlocks()) {
    #####:17952:            printf("Leak of %d blocks found in xmlRelaxParserSetFlag",
    #####:17953:	           xmlMemBlocks() - mem_base);
    #####:17954:	    test_ret++;
    #####:17955:            printf(" %d", n_ctxt);
    #####:17956:            printf(" %d", n_flags);
    #####:17957:            printf("\n");
        -:17958:        }
        -:17959:    }
        -:17960:    }
    #####:17961:    function_tests++;
        -:17962:#endif
        -:17963:
    #####:17964:    return(test_ret);
        -:17965:}
        -:17966:
        -:17967:static int
    #####:17968:test_relaxng(void) {
    #####:17969:    int test_ret = 0;
        -:17970:
    #####:17971:    if (quiet == 0) printf("Testing relaxng : 14 of 24 functions ...\n");
    #####:17972:    test_ret += test_xmlRelaxNGDump();
    #####:17973:    test_ret += test_xmlRelaxNGDumpTree();
    #####:17974:    test_ret += test_xmlRelaxNGGetParserErrors();
    #####:17975:    test_ret += test_xmlRelaxNGGetValidErrors();
    #####:17976:    test_ret += test_xmlRelaxNGInitTypes();
    #####:17977:    test_ret += test_xmlRelaxNGNewDocParserCtxt();
    #####:17978:    test_ret += test_xmlRelaxNGNewMemParserCtxt();
    #####:17979:    test_ret += test_xmlRelaxNGNewParserCtxt();
    #####:17980:    test_ret += test_xmlRelaxNGNewValidCtxt();
    #####:17981:    test_ret += test_xmlRelaxNGParse();
    #####:17982:    test_ret += test_xmlRelaxNGSetParserErrors();
    #####:17983:    test_ret += test_xmlRelaxNGSetParserStructuredErrors();
    #####:17984:    test_ret += test_xmlRelaxNGSetValidErrors();
    #####:17985:    test_ret += test_xmlRelaxNGSetValidStructuredErrors();
    #####:17986:    test_ret += test_xmlRelaxNGValidateDoc();
    #####:17987:    test_ret += test_xmlRelaxNGValidateFullElement();
    #####:17988:    test_ret += test_xmlRelaxNGValidatePopElement();
    #####:17989:    test_ret += test_xmlRelaxNGValidatePushCData();
    #####:17990:    test_ret += test_xmlRelaxNGValidatePushElement();
    #####:17991:    test_ret += test_xmlRelaxParserSetFlag();
        -:17992:
    #####:17993:    if (test_ret != 0)
    #####:17994:	printf("Module relaxng: %d errors\n", test_ret);
    #####:17995:    return(test_ret);
        -:17996:}
        -:17997:static int
    #####:17998:test_schemasInternals(void) {
    #####:17999:    int test_ret = 0;
        -:18000:
    #####:18001:    if (quiet == 0) printf("Testing schemasInternals : 0 of 2 functions ...\n");
        -:18002:
    #####:18003:    if (test_ret != 0)
    #####:18004:	printf("Module schemasInternals: %d errors\n", test_ret);
    #####:18005:    return(test_ret);
        -:18006:}
        -:18007:
        -:18008:static int
    #####:18009:test_xmlSchematronNewDocParserCtxt(void) {
    #####:18010:    int test_ret = 0;
        -:18011:
        -:18012:
        -:18013:    /* missing type support */
    #####:18014:    return(test_ret);
        -:18015:}
        -:18016:
        -:18017:
        -:18018:static int
    #####:18019:test_xmlSchematronNewMemParserCtxt(void) {
    #####:18020:    int test_ret = 0;
        -:18021:
        -:18022:
        -:18023:    /* missing type support */
    #####:18024:    return(test_ret);
        -:18025:}
        -:18026:
        -:18027:
        -:18028:static int
    #####:18029:test_xmlSchematronNewParserCtxt(void) {
    #####:18030:    int test_ret = 0;
        -:18031:
        -:18032:
        -:18033:    /* missing type support */
    #####:18034:    return(test_ret);
        -:18035:}
        -:18036:
        -:18037:#ifdef LIBXML_SCHEMATRON_ENABLED
        -:18038:
        -:18039:#define gen_nb_xmlSchematronPtr 1
    #####:18040:static xmlSchematronPtr gen_xmlSchematronPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:18041:    return(NULL);
        -:18042:}
    #####:18043:static void des_xmlSchematronPtr(int no ATTRIBUTE_UNUSED, xmlSchematronPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:18044:}
        -:18045:#endif
        -:18046:
        -:18047:
        -:18048:static int
    #####:18049:test_xmlSchematronNewValidCtxt(void) {
    #####:18050:    int test_ret = 0;
        -:18051:
        -:18052:
        -:18053:    /* missing type support */
    #####:18054:    return(test_ret);
        -:18055:}
        -:18056:
        -:18057:#ifdef LIBXML_SCHEMATRON_ENABLED
        -:18058:
        -:18059:#define gen_nb_xmlSchematronParserCtxtPtr 1
    #####:18060:static xmlSchematronParserCtxtPtr gen_xmlSchematronParserCtxtPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:18061:    return(NULL);
        -:18062:}
    #####:18063:static void des_xmlSchematronParserCtxtPtr(int no ATTRIBUTE_UNUSED, xmlSchematronParserCtxtPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:18064:}
        -:18065:#endif
        -:18066:
        -:18067:
        -:18068:static int
    #####:18069:test_xmlSchematronParse(void) {
    #####:18070:    int test_ret = 0;
        -:18071:
        -:18072:
        -:18073:    /* missing type support */
    #####:18074:    return(test_ret);
        -:18075:}
        -:18076:
        -:18077:#ifdef LIBXML_SCHEMATRON_ENABLED
        -:18078:
        -:18079:#define gen_nb_xmlSchematronValidCtxtPtr 1
    #####:18080:static xmlSchematronValidCtxtPtr gen_xmlSchematronValidCtxtPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:18081:    return(NULL);
        -:18082:}
    #####:18083:static void des_xmlSchematronValidCtxtPtr(int no ATTRIBUTE_UNUSED, xmlSchematronValidCtxtPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:18084:}
        -:18085:#endif
        -:18086:
        -:18087:
        -:18088:static int
    #####:18089:test_xmlSchematronSetValidStructuredErrors(void) {
    #####:18090:    int test_ret = 0;
        -:18091:
        -:18092:
        -:18093:    /* missing type support */
    #####:18094:    return(test_ret);
        -:18095:}
        -:18096:
        -:18097:
        -:18098:static int
    #####:18099:test_xmlSchematronValidateDoc(void) {
    #####:18100:    int test_ret = 0;
        -:18101:
        -:18102:#if defined(LIBXML_SCHEMATRON_ENABLED)
        -:18103:    int mem_base;
        -:18104:    int ret_val;
        -:18105:    xmlSchematronValidCtxtPtr ctxt; /* the schema validation context */
        -:18106:    int n_ctxt;
        -:18107:    xmlDocPtr instance; /* the document instace tree */
        -:18108:    int n_instance;
        -:18109:
    #####:18110:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchematronValidCtxtPtr;n_ctxt++) {
    #####:18111:    for (n_instance = 0;n_instance < gen_nb_xmlDocPtr;n_instance++) {
    #####:18112:        mem_base = xmlMemBlocks();
    #####:18113:        ctxt = gen_xmlSchematronValidCtxtPtr(n_ctxt, 0);
    #####:18114:        instance = gen_xmlDocPtr(n_instance, 1);
        -:18115:
    #####:18116:        ret_val = xmlSchematronValidateDoc(ctxt, instance);
    #####:18117:        desret_int(ret_val);
    #####:18118:        call_tests++;
    #####:18119:        des_xmlSchematronValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:18120:        des_xmlDocPtr(n_instance, instance, 1);
    #####:18121:        xmlResetLastError();
    #####:18122:        if (mem_base != xmlMemBlocks()) {
    #####:18123:            printf("Leak of %d blocks found in xmlSchematronValidateDoc",
    #####:18124:	           xmlMemBlocks() - mem_base);
    #####:18125:	    test_ret++;
    #####:18126:            printf(" %d", n_ctxt);
    #####:18127:            printf(" %d", n_instance);
    #####:18128:            printf("\n");
        -:18129:        }
        -:18130:    }
        -:18131:    }
    #####:18132:    function_tests++;
        -:18133:#endif
        -:18134:
    #####:18135:    return(test_ret);
        -:18136:}
        -:18137:
        -:18138:static int
    #####:18139:test_schematron(void) {
    #####:18140:    int test_ret = 0;
        -:18141:
    #####:18142:    if (quiet == 0) printf("Testing schematron : 1 of 10 functions ...\n");
    #####:18143:    test_ret += test_xmlSchematronNewDocParserCtxt();
    #####:18144:    test_ret += test_xmlSchematronNewMemParserCtxt();
    #####:18145:    test_ret += test_xmlSchematronNewParserCtxt();
    #####:18146:    test_ret += test_xmlSchematronNewValidCtxt();
    #####:18147:    test_ret += test_xmlSchematronParse();
    #####:18148:    test_ret += test_xmlSchematronSetValidStructuredErrors();
    #####:18149:    test_ret += test_xmlSchematronValidateDoc();
        -:18150:
    #####:18151:    if (test_ret != 0)
    #####:18152:	printf("Module schematron: %d errors\n", test_ret);
    #####:18153:    return(test_ret);
        -:18154:}
        -:18155:
        -:18156:static int
    #####:18157:test_xmlAddChild(void) {
    #####:18158:    int test_ret = 0;
        -:18159:
        -:18160:    int mem_base;
        -:18161:    xmlNodePtr ret_val;
        -:18162:    xmlNodePtr parent; /* the parent node */
        -:18163:    int n_parent;
        -:18164:    xmlNodePtr cur; /* the child node */
        -:18165:    int n_cur;
        -:18166:
    #####:18167:    for (n_parent = 0;n_parent < gen_nb_xmlNodePtr;n_parent++) {
    #####:18168:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr_in;n_cur++) {
    #####:18169:        mem_base = xmlMemBlocks();
    #####:18170:        parent = gen_xmlNodePtr(n_parent, 0);
    #####:18171:        cur = gen_xmlNodePtr_in(n_cur, 1);
        -:18172:
    #####:18173:        ret_val = xmlAddChild(parent, cur);
    #####:18174:        if (ret_val == NULL) { xmlFreeNode(cur) ; cur = NULL ; }
    #####:18175:        desret_xmlNodePtr(ret_val);
    #####:18176:        call_tests++;
    #####:18177:        des_xmlNodePtr(n_parent, parent, 0);
    #####:18178:        des_xmlNodePtr_in(n_cur, cur, 1);
    #####:18179:        xmlResetLastError();
    #####:18180:        if (mem_base != xmlMemBlocks()) {
    #####:18181:            printf("Leak of %d blocks found in xmlAddChild",
    #####:18182:	           xmlMemBlocks() - mem_base);
    #####:18183:	    test_ret++;
    #####:18184:            printf(" %d", n_parent);
    #####:18185:            printf(" %d", n_cur);
    #####:18186:            printf("\n");
        -:18187:        }
        -:18188:    }
        -:18189:    }
    #####:18190:    function_tests++;
        -:18191:
    #####:18192:    return(test_ret);
        -:18193:}
        -:18194:
        -:18195:
        -:18196:static int
    #####:18197:test_xmlAddChildList(void) {
    #####:18198:    int test_ret = 0;
        -:18199:
        -:18200:    int mem_base;
        -:18201:    xmlNodePtr ret_val;
        -:18202:    xmlNodePtr parent; /* the parent node */
        -:18203:    int n_parent;
        -:18204:    xmlNodePtr cur; /* the first node in the list */
        -:18205:    int n_cur;
        -:18206:
    #####:18207:    for (n_parent = 0;n_parent < gen_nb_xmlNodePtr;n_parent++) {
    #####:18208:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr_in;n_cur++) {
    #####:18209:        mem_base = xmlMemBlocks();
    #####:18210:        parent = gen_xmlNodePtr(n_parent, 0);
    #####:18211:        cur = gen_xmlNodePtr_in(n_cur, 1);
        -:18212:
    #####:18213:        ret_val = xmlAddChildList(parent, cur);
    #####:18214:        if (ret_val == NULL) { xmlFreeNodeList(cur) ; cur = NULL ; }
    #####:18215:        desret_xmlNodePtr(ret_val);
    #####:18216:        call_tests++;
    #####:18217:        des_xmlNodePtr(n_parent, parent, 0);
    #####:18218:        des_xmlNodePtr_in(n_cur, cur, 1);
    #####:18219:        xmlResetLastError();
    #####:18220:        if (mem_base != xmlMemBlocks()) {
    #####:18221:            printf("Leak of %d blocks found in xmlAddChildList",
    #####:18222:	           xmlMemBlocks() - mem_base);
    #####:18223:	    test_ret++;
    #####:18224:            printf(" %d", n_parent);
    #####:18225:            printf(" %d", n_cur);
    #####:18226:            printf("\n");
        -:18227:        }
        -:18228:    }
        -:18229:    }
    #####:18230:    function_tests++;
        -:18231:
    #####:18232:    return(test_ret);
        -:18233:}
        -:18234:
        -:18235:
        -:18236:static int
    #####:18237:test_xmlAddNextSibling(void) {
    #####:18238:    int test_ret = 0;
        -:18239:
        -:18240:    int mem_base;
        -:18241:    xmlNodePtr ret_val;
        -:18242:    xmlNodePtr cur; /* the child node */
        -:18243:    int n_cur;
        -:18244:    xmlNodePtr elem; /* the new node */
        -:18245:    int n_elem;
        -:18246:
    #####:18247:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####:18248:    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr_in;n_elem++) {
    #####:18249:        mem_base = xmlMemBlocks();
    #####:18250:        cur = gen_xmlNodePtr(n_cur, 0);
    #####:18251:        elem = gen_xmlNodePtr_in(n_elem, 1);
        -:18252:
    #####:18253:        ret_val = xmlAddNextSibling(cur, elem);
    #####:18254:        if (ret_val == NULL) { xmlFreeNode(elem) ; elem = NULL ; }
    #####:18255:        desret_xmlNodePtr(ret_val);
    #####:18256:        call_tests++;
    #####:18257:        des_xmlNodePtr(n_cur, cur, 0);
    #####:18258:        des_xmlNodePtr_in(n_elem, elem, 1);
    #####:18259:        xmlResetLastError();
    #####:18260:        if (mem_base != xmlMemBlocks()) {
    #####:18261:            printf("Leak of %d blocks found in xmlAddNextSibling",
    #####:18262:	           xmlMemBlocks() - mem_base);
    #####:18263:	    test_ret++;
    #####:18264:            printf(" %d", n_cur);
    #####:18265:            printf(" %d", n_elem);
    #####:18266:            printf("\n");
        -:18267:        }
        -:18268:    }
        -:18269:    }
    #####:18270:    function_tests++;
        -:18271:
    #####:18272:    return(test_ret);
        -:18273:}
        -:18274:
        -:18275:
        -:18276:static int
    #####:18277:test_xmlAddPrevSibling(void) {
    #####:18278:    int test_ret = 0;
        -:18279:
        -:18280:#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED)
        -:18281:    int mem_base;
        -:18282:    xmlNodePtr ret_val;
        -:18283:    xmlNodePtr cur; /* the child node */
        -:18284:    int n_cur;
        -:18285:    xmlNodePtr elem; /* the new node */
        -:18286:    int n_elem;
        -:18287:
    #####:18288:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####:18289:    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr_in;n_elem++) {
    #####:18290:        mem_base = xmlMemBlocks();
    #####:18291:        cur = gen_xmlNodePtr(n_cur, 0);
    #####:18292:        elem = gen_xmlNodePtr_in(n_elem, 1);
        -:18293:
    #####:18294:        ret_val = xmlAddPrevSibling(cur, elem);
    #####:18295:        if (ret_val == NULL) { xmlFreeNode(elem) ; elem = NULL ; }
    #####:18296:        desret_xmlNodePtr(ret_val);
    #####:18297:        call_tests++;
    #####:18298:        des_xmlNodePtr(n_cur, cur, 0);
    #####:18299:        des_xmlNodePtr_in(n_elem, elem, 1);
    #####:18300:        xmlResetLastError();
    #####:18301:        if (mem_base != xmlMemBlocks()) {
    #####:18302:            printf("Leak of %d blocks found in xmlAddPrevSibling",
    #####:18303:	           xmlMemBlocks() - mem_base);
    #####:18304:	    test_ret++;
    #####:18305:            printf(" %d", n_cur);
    #####:18306:            printf(" %d", n_elem);
    #####:18307:            printf("\n");
        -:18308:        }
        -:18309:    }
        -:18310:    }
    #####:18311:    function_tests++;
        -:18312:#endif
        -:18313:
    #####:18314:    return(test_ret);
        -:18315:}
        -:18316:
        -:18317:
        -:18318:static int
    #####:18319:test_xmlAddSibling(void) {
    #####:18320:    int test_ret = 0;
        -:18321:
        -:18322:    int mem_base;
        -:18323:    xmlNodePtr ret_val;
        -:18324:    xmlNodePtr cur; /* the child node */
        -:18325:    int n_cur;
        -:18326:    xmlNodePtr elem; /* the new node */
        -:18327:    int n_elem;
        -:18328:
    #####:18329:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####:18330:    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr_in;n_elem++) {
    #####:18331:        mem_base = xmlMemBlocks();
    #####:18332:        cur = gen_xmlNodePtr(n_cur, 0);
    #####:18333:        elem = gen_xmlNodePtr_in(n_elem, 1);
        -:18334:
    #####:18335:        ret_val = xmlAddSibling(cur, elem);
    #####:18336:        if (ret_val == NULL) { xmlFreeNode(elem) ; elem = NULL ; }
    #####:18337:        desret_xmlNodePtr(ret_val);
    #####:18338:        call_tests++;
    #####:18339:        des_xmlNodePtr(n_cur, cur, 0);
    #####:18340:        des_xmlNodePtr_in(n_elem, elem, 1);
    #####:18341:        xmlResetLastError();
    #####:18342:        if (mem_base != xmlMemBlocks()) {
    #####:18343:            printf("Leak of %d blocks found in xmlAddSibling",
    #####:18344:	           xmlMemBlocks() - mem_base);
    #####:18345:	    test_ret++;
    #####:18346:            printf(" %d", n_cur);
    #####:18347:            printf(" %d", n_elem);
    #####:18348:            printf("\n");
        -:18349:        }
        -:18350:    }
        -:18351:    }
    #####:18352:    function_tests++;
        -:18353:
    #####:18354:    return(test_ret);
        -:18355:}
        -:18356:
        -:18357:
        -:18358:static int
    #####:18359:test_xmlAttrSerializeTxtContent(void) {
    #####:18360:    int test_ret = 0;
        -:18361:
        -:18362:#if defined(LIBXML_OUTPUT_ENABLED)
        -:18363:#ifdef LIBXML_OUTPUT_ENABLED
        -:18364:    int mem_base;
        -:18365:    xmlBufferPtr buf; /* the XML buffer output */
        -:18366:    int n_buf;
        -:18367:    xmlDocPtr doc; /* the document */
        -:18368:    int n_doc;
        -:18369:    xmlAttrPtr attr; /* the attribute node */
        -:18370:    int n_attr;
        -:18371:    xmlChar * string; /* the text content */
        -:18372:    int n_string;
        -:18373:
    #####:18374:    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    #####:18375:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:18376:    for (n_attr = 0;n_attr < gen_nb_xmlAttrPtr;n_attr++) {
    #####:18377:    for (n_string = 0;n_string < gen_nb_const_xmlChar_ptr;n_string++) {
    #####:18378:        mem_base = xmlMemBlocks();
    #####:18379:        buf = gen_xmlBufferPtr(n_buf, 0);
    #####:18380:        doc = gen_xmlDocPtr(n_doc, 1);
    #####:18381:        attr = gen_xmlAttrPtr(n_attr, 2);
    #####:18382:        string = gen_const_xmlChar_ptr(n_string, 3);
        -:18383:
    #####:18384:        xmlAttrSerializeTxtContent(buf, doc, attr, (const xmlChar *)string);
    #####:18385:        call_tests++;
    #####:18386:        des_xmlBufferPtr(n_buf, buf, 0);
    #####:18387:        des_xmlDocPtr(n_doc, doc, 1);
    #####:18388:        des_xmlAttrPtr(n_attr, attr, 2);
    #####:18389:        des_const_xmlChar_ptr(n_string, (const xmlChar *)string, 3);
    #####:18390:        xmlResetLastError();
    #####:18391:        if (mem_base != xmlMemBlocks()) {
    #####:18392:            printf("Leak of %d blocks found in xmlAttrSerializeTxtContent",
    #####:18393:	           xmlMemBlocks() - mem_base);
    #####:18394:	    test_ret++;
    #####:18395:            printf(" %d", n_buf);
    #####:18396:            printf(" %d", n_doc);
    #####:18397:            printf(" %d", n_attr);
    #####:18398:            printf(" %d", n_string);
    #####:18399:            printf("\n");
        -:18400:        }
        -:18401:    }
        -:18402:    }
        -:18403:    }
        -:18404:    }
    #####:18405:    function_tests++;
        -:18406:#endif
        -:18407:#endif
        -:18408:
    #####:18409:    return(test_ret);
        -:18410:}
        -:18411:
        -:18412:
        -:18413:#define gen_nb_const_xmlBuf_ptr 1
    #####:18414:static xmlBuf * gen_const_xmlBuf_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:18415:    return(NULL);
        -:18416:}
    #####:18417:static void des_const_xmlBuf_ptr(int no ATTRIBUTE_UNUSED, const xmlBuf * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:18418:}
        -:18419:
        -:18420:static int
    #####:18421:test_xmlBufContent(void) {
    #####:18422:    int test_ret = 0;
        -:18423:
        -:18424:    int mem_base;
        -:18425:    xmlChar * ret_val;
        -:18426:    xmlBuf * buf; /* the buffer */
        -:18427:    int n_buf;
        -:18428:
    #####:18429:    for (n_buf = 0;n_buf < gen_nb_const_xmlBuf_ptr;n_buf++) {
    #####:18430:        mem_base = xmlMemBlocks();
    #####:18431:        buf = gen_const_xmlBuf_ptr(n_buf, 0);
        -:18432:
    #####:18433:        ret_val = xmlBufContent((const xmlBuf *)buf);
    #####:18434:        desret_xmlChar_ptr(ret_val);
    #####:18435:        call_tests++;
    #####:18436:        des_const_xmlBuf_ptr(n_buf, (const xmlBuf *)buf, 0);
    #####:18437:        xmlResetLastError();
    #####:18438:        if (mem_base != xmlMemBlocks()) {
    #####:18439:            printf("Leak of %d blocks found in xmlBufContent",
    #####:18440:	           xmlMemBlocks() - mem_base);
    #####:18441:	    test_ret++;
    #####:18442:            printf(" %d", n_buf);
    #####:18443:            printf("\n");
        -:18444:        }
        -:18445:    }
    #####:18446:    function_tests++;
        -:18447:
    #####:18448:    return(test_ret);
        -:18449:}
        -:18450:
        -:18451:
        -:18452:#define gen_nb_xmlBufPtr 1
    #####:18453:static xmlBufPtr gen_xmlBufPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:18454:    return(NULL);
        -:18455:}
    #####:18456:static void des_xmlBufPtr(int no ATTRIBUTE_UNUSED, xmlBufPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:18457:}
        -:18458:
        -:18459:static int
    #####:18460:test_xmlBufEnd(void) {
    #####:18461:    int test_ret = 0;
        -:18462:
        -:18463:    int mem_base;
        -:18464:    xmlChar * ret_val;
        -:18465:    xmlBufPtr buf; /* the buffer */
        -:18466:    int n_buf;
        -:18467:
    #####:18468:    for (n_buf = 0;n_buf < gen_nb_xmlBufPtr;n_buf++) {
    #####:18469:        mem_base = xmlMemBlocks();
    #####:18470:        buf = gen_xmlBufPtr(n_buf, 0);
        -:18471:
    #####:18472:        ret_val = xmlBufEnd(buf);
    #####:18473:        desret_xmlChar_ptr(ret_val);
    #####:18474:        call_tests++;
    #####:18475:        des_xmlBufPtr(n_buf, buf, 0);
    #####:18476:        xmlResetLastError();
    #####:18477:        if (mem_base != xmlMemBlocks()) {
    #####:18478:            printf("Leak of %d blocks found in xmlBufEnd",
    #####:18479:	           xmlMemBlocks() - mem_base);
    #####:18480:	    test_ret++;
    #####:18481:            printf(" %d", n_buf);
    #####:18482:            printf("\n");
        -:18483:        }
        -:18484:    }
    #####:18485:    function_tests++;
        -:18486:
    #####:18487:    return(test_ret);
        -:18488:}
        -:18489:
        -:18490:
        -:18491:#define gen_nb_const_xmlNode_ptr 1
    #####:18492:static xmlNode * gen_const_xmlNode_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:18493:    return(NULL);
        -:18494:}
    #####:18495:static void des_const_xmlNode_ptr(int no ATTRIBUTE_UNUSED, const xmlNode * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:18496:}
        -:18497:
        -:18498:static int
    #####:18499:test_xmlBufGetNodeContent(void) {
    #####:18500:    int test_ret = 0;
        -:18501:
        -:18502:    int mem_base;
        -:18503:    int ret_val;
        -:18504:    xmlBufPtr buf; /* a buffer xmlBufPtr */
        -:18505:    int n_buf;
        -:18506:    xmlNode * cur; /* the node being read */
        -:18507:    int n_cur;
        -:18508:
    #####:18509:    for (n_buf = 0;n_buf < gen_nb_xmlBufPtr;n_buf++) {
    #####:18510:    for (n_cur = 0;n_cur < gen_nb_const_xmlNode_ptr;n_cur++) {
    #####:18511:        mem_base = xmlMemBlocks();
    #####:18512:        buf = gen_xmlBufPtr(n_buf, 0);
    #####:18513:        cur = gen_const_xmlNode_ptr(n_cur, 1);
        -:18514:
    #####:18515:        ret_val = xmlBufGetNodeContent(buf, (const xmlNode *)cur);
    #####:18516:        desret_int(ret_val);
    #####:18517:        call_tests++;
    #####:18518:        des_xmlBufPtr(n_buf, buf, 0);
    #####:18519:        des_const_xmlNode_ptr(n_cur, (const xmlNode *)cur, 1);
    #####:18520:        xmlResetLastError();
    #####:18521:        if (mem_base != xmlMemBlocks()) {
    #####:18522:            printf("Leak of %d blocks found in xmlBufGetNodeContent",
    #####:18523:	           xmlMemBlocks() - mem_base);
    #####:18524:	    test_ret++;
    #####:18525:            printf(" %d", n_buf);
    #####:18526:            printf(" %d", n_cur);
    #####:18527:            printf("\n");
        -:18528:        }
        -:18529:    }
        -:18530:    }
    #####:18531:    function_tests++;
        -:18532:
    #####:18533:    return(test_ret);
        -:18534:}
        -:18535:
        -:18536:
        -:18537:static int
    #####:18538:test_xmlBufNodeDump(void) {
    #####:18539:    int test_ret = 0;
        -:18540:
        -:18541:
        -:18542:    /* missing type support */
    #####:18543:    return(test_ret);
        -:18544:}
        -:18545:
        -:18546:
        -:18547:static int
    #####:18548:test_xmlBufShrink(void) {
    #####:18549:    int test_ret = 0;
        -:18550:
        -:18551:
        -:18552:    /* missing type support */
    #####:18553:    return(test_ret);
        -:18554:}
        -:18555:
        -:18556:
        -:18557:#define gen_nb_const_xmlBufPtr 1
    #####:18558:static xmlBufPtr gen_const_xmlBufPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:18559:    return(NULL);
        -:18560:}
    #####:18561:static void des_const_xmlBufPtr(int no ATTRIBUTE_UNUSED, const xmlBufPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:18562:}
        -:18563:
        -:18564:static int
    #####:18565:test_xmlBufUse(void) {
    #####:18566:    int test_ret = 0;
        -:18567:
        -:18568:
        -:18569:    /* missing type support */
    #####:18570:    return(test_ret);
        -:18571:}
        -:18572:
        -:18573:
        -:18574:static int
    #####:18575:test_xmlBufferAdd(void) {
    #####:18576:    int test_ret = 0;
        -:18577:
        -:18578:    int mem_base;
        -:18579:    int ret_val;
        -:18580:    xmlBufferPtr buf; /* the buffer to dump */
        -:18581:    int n_buf;
        -:18582:    xmlChar * str; /* the #xmlChar string */
        -:18583:    int n_str;
        -:18584:    int len; /* the number of #xmlChar to add */
        -:18585:    int n_len;
        -:18586:
    #####:18587:    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    #####:18588:    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    #####:18589:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:18590:        mem_base = xmlMemBlocks();
    #####:18591:        buf = gen_xmlBufferPtr(n_buf, 0);
    #####:18592:        str = gen_const_xmlChar_ptr(n_str, 1);
    #####:18593:        len = gen_int(n_len, 2);
        -:18594:
    #####:18595:        ret_val = xmlBufferAdd(buf, (const xmlChar *)str, len);
    #####:18596:        desret_int(ret_val);
    #####:18597:        call_tests++;
    #####:18598:        des_xmlBufferPtr(n_buf, buf, 0);
    #####:18599:        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 1);
    #####:18600:        des_int(n_len, len, 2);
    #####:18601:        xmlResetLastError();
    #####:18602:        if (mem_base != xmlMemBlocks()) {
    #####:18603:            printf("Leak of %d blocks found in xmlBufferAdd",
    #####:18604:	           xmlMemBlocks() - mem_base);
    #####:18605:	    test_ret++;
    #####:18606:            printf(" %d", n_buf);
    #####:18607:            printf(" %d", n_str);
    #####:18608:            printf(" %d", n_len);
    #####:18609:            printf("\n");
        -:18610:        }
        -:18611:    }
        -:18612:    }
        -:18613:    }
    #####:18614:    function_tests++;
        -:18615:
    #####:18616:    return(test_ret);
        -:18617:}
        -:18618:
        -:18619:
        -:18620:static int
    #####:18621:test_xmlBufferAddHead(void) {
    #####:18622:    int test_ret = 0;
        -:18623:
        -:18624:    int mem_base;
        -:18625:    int ret_val;
        -:18626:    xmlBufferPtr buf; /* the buffer */
        -:18627:    int n_buf;
        -:18628:    xmlChar * str; /* the #xmlChar string */
        -:18629:    int n_str;
        -:18630:    int len; /* the number of #xmlChar to add */
        -:18631:    int n_len;
        -:18632:
    #####:18633:    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    #####:18634:    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    #####:18635:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:18636:        mem_base = xmlMemBlocks();
    #####:18637:        buf = gen_xmlBufferPtr(n_buf, 0);
    #####:18638:        str = gen_const_xmlChar_ptr(n_str, 1);
    #####:18639:        len = gen_int(n_len, 2);
        -:18640:
    #####:18641:        ret_val = xmlBufferAddHead(buf, (const xmlChar *)str, len);
    #####:18642:        desret_int(ret_val);
    #####:18643:        call_tests++;
    #####:18644:        des_xmlBufferPtr(n_buf, buf, 0);
    #####:18645:        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 1);
    #####:18646:        des_int(n_len, len, 2);
    #####:18647:        xmlResetLastError();
    #####:18648:        if (mem_base != xmlMemBlocks()) {
    #####:18649:            printf("Leak of %d blocks found in xmlBufferAddHead",
    #####:18650:	           xmlMemBlocks() - mem_base);
    #####:18651:	    test_ret++;
    #####:18652:            printf(" %d", n_buf);
    #####:18653:            printf(" %d", n_str);
    #####:18654:            printf(" %d", n_len);
    #####:18655:            printf("\n");
        -:18656:        }
        -:18657:    }
        -:18658:    }
        -:18659:    }
    #####:18660:    function_tests++;
        -:18661:
    #####:18662:    return(test_ret);
        -:18663:}
        -:18664:
        -:18665:
        -:18666:static int
    #####:18667:test_xmlBufferCCat(void) {
    #####:18668:    int test_ret = 0;
        -:18669:
        -:18670:    int mem_base;
        -:18671:    int ret_val;
        -:18672:    xmlBufferPtr buf; /* the buffer to dump */
        -:18673:    int n_buf;
        -:18674:    char * str; /* the C char string */
        -:18675:    int n_str;
        -:18676:
    #####:18677:    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    #####:18678:    for (n_str = 0;n_str < gen_nb_const_char_ptr;n_str++) {
    #####:18679:        mem_base = xmlMemBlocks();
    #####:18680:        buf = gen_xmlBufferPtr(n_buf, 0);
    #####:18681:        str = gen_const_char_ptr(n_str, 1);
        -:18682:
    #####:18683:        ret_val = xmlBufferCCat(buf, (const char *)str);
    #####:18684:        desret_int(ret_val);
    #####:18685:        call_tests++;
    #####:18686:        des_xmlBufferPtr(n_buf, buf, 0);
    #####:18687:        des_const_char_ptr(n_str, (const char *)str, 1);
    #####:18688:        xmlResetLastError();
    #####:18689:        if (mem_base != xmlMemBlocks()) {
    #####:18690:            printf("Leak of %d blocks found in xmlBufferCCat",
    #####:18691:	           xmlMemBlocks() - mem_base);
    #####:18692:	    test_ret++;
    #####:18693:            printf(" %d", n_buf);
    #####:18694:            printf(" %d", n_str);
    #####:18695:            printf("\n");
        -:18696:        }
        -:18697:    }
        -:18698:    }
    #####:18699:    function_tests++;
        -:18700:
    #####:18701:    return(test_ret);
        -:18702:}
        -:18703:
        -:18704:
        -:18705:static int
    #####:18706:test_xmlBufferCat(void) {
    #####:18707:    int test_ret = 0;
        -:18708:
        -:18709:    int mem_base;
        -:18710:    int ret_val;
        -:18711:    xmlBufferPtr buf; /* the buffer to add to */
        -:18712:    int n_buf;
        -:18713:    xmlChar * str; /* the #xmlChar string */
        -:18714:    int n_str;
        -:18715:
    #####:18716:    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    #####:18717:    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    #####:18718:        mem_base = xmlMemBlocks();
    #####:18719:        buf = gen_xmlBufferPtr(n_buf, 0);
    #####:18720:        str = gen_const_xmlChar_ptr(n_str, 1);
        -:18721:
    #####:18722:        ret_val = xmlBufferCat(buf, (const xmlChar *)str);
    #####:18723:        desret_int(ret_val);
    #####:18724:        call_tests++;
    #####:18725:        des_xmlBufferPtr(n_buf, buf, 0);
    #####:18726:        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 1);
    #####:18727:        xmlResetLastError();
    #####:18728:        if (mem_base != xmlMemBlocks()) {
    #####:18729:            printf("Leak of %d blocks found in xmlBufferCat",
    #####:18730:	           xmlMemBlocks() - mem_base);
    #####:18731:	    test_ret++;
    #####:18732:            printf(" %d", n_buf);
    #####:18733:            printf(" %d", n_str);
    #####:18734:            printf("\n");
        -:18735:        }
        -:18736:    }
        -:18737:    }
    #####:18738:    function_tests++;
        -:18739:
    #####:18740:    return(test_ret);
        -:18741:}
        -:18742:
        -:18743:
        -:18744:#define gen_nb_const_xmlBuffer_ptr 1
    #####:18745:static xmlBuffer * gen_const_xmlBuffer_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:18746:    return(NULL);
        -:18747:}
    #####:18748:static void des_const_xmlBuffer_ptr(int no ATTRIBUTE_UNUSED, const xmlBuffer * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:18749:}
        -:18750:
        -:18751:static int
    #####:18752:test_xmlBufferContent(void) {
    #####:18753:    int test_ret = 0;
        -:18754:
        -:18755:    int mem_base;
        -:18756:    const xmlChar * ret_val;
        -:18757:    xmlBuffer * buf; /* the buffer */
        -:18758:    int n_buf;
        -:18759:
    #####:18760:    for (n_buf = 0;n_buf < gen_nb_const_xmlBuffer_ptr;n_buf++) {
    #####:18761:        mem_base = xmlMemBlocks();
    #####:18762:        buf = gen_const_xmlBuffer_ptr(n_buf, 0);
        -:18763:
    #####:18764:        ret_val = xmlBufferContent((const xmlBuffer *)buf);
    #####:18765:        desret_const_xmlChar_ptr(ret_val);
    #####:18766:        call_tests++;
    #####:18767:        des_const_xmlBuffer_ptr(n_buf, (const xmlBuffer *)buf, 0);
    #####:18768:        xmlResetLastError();
    #####:18769:        if (mem_base != xmlMemBlocks()) {
    #####:18770:            printf("Leak of %d blocks found in xmlBufferContent",
    #####:18771:	           xmlMemBlocks() - mem_base);
    #####:18772:	    test_ret++;
    #####:18773:            printf(" %d", n_buf);
    #####:18774:            printf("\n");
        -:18775:        }
        -:18776:    }
    #####:18777:    function_tests++;
        -:18778:
    #####:18779:    return(test_ret);
        -:18780:}
        -:18781:
        -:18782:
        -:18783:static int
    #####:18784:test_xmlBufferCreate(void) {
    #####:18785:    int test_ret = 0;
        -:18786:
        -:18787:    int mem_base;
        -:18788:    xmlBufferPtr ret_val;
        -:18789:
    #####:18790:        mem_base = xmlMemBlocks();
        -:18791:
    #####:18792:        ret_val = xmlBufferCreate();
    #####:18793:        desret_xmlBufferPtr(ret_val);
    #####:18794:        call_tests++;
    #####:18795:        xmlResetLastError();
    #####:18796:        if (mem_base != xmlMemBlocks()) {
    #####:18797:            printf("Leak of %d blocks found in xmlBufferCreate",
    #####:18798:	           xmlMemBlocks() - mem_base);
    #####:18799:	    test_ret++;
    #####:18800:            printf("\n");
        -:18801:        }
    #####:18802:    function_tests++;
        -:18803:
    #####:18804:    return(test_ret);
        -:18805:}
        -:18806:
        -:18807:
        -:18808:static int
    #####:18809:test_xmlBufferCreateSize(void) {
    #####:18810:    int test_ret = 0;
        -:18811:
        -:18812:
        -:18813:    /* missing type support */
    #####:18814:    return(test_ret);
        -:18815:}
        -:18816:
        -:18817:
        -:18818:static int
    #####:18819:test_xmlBufferCreateStatic(void) {
    #####:18820:    int test_ret = 0;
        -:18821:
        -:18822:
        -:18823:    /* missing type support */
    #####:18824:    return(test_ret);
        -:18825:}
        -:18826:
        -:18827:
        -:18828:static int
    #####:18829:test_xmlBufferDetach(void) {
    #####:18830:    int test_ret = 0;
        -:18831:
        -:18832:    int mem_base;
        -:18833:    xmlChar * ret_val;
        -:18834:    xmlBufferPtr buf; /* the buffer */
        -:18835:    int n_buf;
        -:18836:
    #####:18837:    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    #####:18838:        mem_base = xmlMemBlocks();
    #####:18839:        buf = gen_xmlBufferPtr(n_buf, 0);
        -:18840:
    #####:18841:        ret_val = xmlBufferDetach(buf);
    #####:18842:        desret_xmlChar_ptr(ret_val);
    #####:18843:        call_tests++;
    #####:18844:        des_xmlBufferPtr(n_buf, buf, 0);
    #####:18845:        xmlResetLastError();
    #####:18846:        if (mem_base != xmlMemBlocks()) {
    #####:18847:            printf("Leak of %d blocks found in xmlBufferDetach",
    #####:18848:	           xmlMemBlocks() - mem_base);
    #####:18849:	    test_ret++;
    #####:18850:            printf(" %d", n_buf);
    #####:18851:            printf("\n");
        -:18852:        }
        -:18853:    }
    #####:18854:    function_tests++;
        -:18855:
    #####:18856:    return(test_ret);
        -:18857:}
        -:18858:
        -:18859:
        -:18860:static int
    #####:18861:test_xmlBufferEmpty(void) {
    #####:18862:    int test_ret = 0;
        -:18863:
        -:18864:    int mem_base;
        -:18865:    xmlBufferPtr buf; /* the buffer */
        -:18866:    int n_buf;
        -:18867:
    #####:18868:    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    #####:18869:        mem_base = xmlMemBlocks();
    #####:18870:        buf = gen_xmlBufferPtr(n_buf, 0);
        -:18871:
    #####:18872:        xmlBufferEmpty(buf);
    #####:18873:        call_tests++;
    #####:18874:        des_xmlBufferPtr(n_buf, buf, 0);
    #####:18875:        xmlResetLastError();
    #####:18876:        if (mem_base != xmlMemBlocks()) {
    #####:18877:            printf("Leak of %d blocks found in xmlBufferEmpty",
    #####:18878:	           xmlMemBlocks() - mem_base);
    #####:18879:	    test_ret++;
    #####:18880:            printf(" %d", n_buf);
    #####:18881:            printf("\n");
        -:18882:        }
        -:18883:    }
    #####:18884:    function_tests++;
        -:18885:
    #####:18886:    return(test_ret);
        -:18887:}
        -:18888:
        -:18889:
        -:18890:static int
    #####:18891:test_xmlBufferGrow(void) {
    #####:18892:    int test_ret = 0;
        -:18893:
        -:18894:    int mem_base;
        -:18895:    int ret_val;
        -:18896:    xmlBufferPtr buf; /* the buffer */
        -:18897:    int n_buf;
        -:18898:    unsigned int len; /* the minimum free size to allocate */
        -:18899:    int n_len;
        -:18900:
    #####:18901:    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    #####:18902:    for (n_len = 0;n_len < gen_nb_unsigned_int;n_len++) {
    #####:18903:        mem_base = xmlMemBlocks();
    #####:18904:        buf = gen_xmlBufferPtr(n_buf, 0);
    #####:18905:        len = gen_unsigned_int(n_len, 1);
        -:18906:
    #####:18907:        ret_val = xmlBufferGrow(buf, len);
    #####:18908:        desret_int(ret_val);
    #####:18909:        call_tests++;
    #####:18910:        des_xmlBufferPtr(n_buf, buf, 0);
    #####:18911:        des_unsigned_int(n_len, len, 1);
    #####:18912:        xmlResetLastError();
    #####:18913:        if (mem_base != xmlMemBlocks()) {
    #####:18914:            printf("Leak of %d blocks found in xmlBufferGrow",
    #####:18915:	           xmlMemBlocks() - mem_base);
    #####:18916:	    test_ret++;
    #####:18917:            printf(" %d", n_buf);
    #####:18918:            printf(" %d", n_len);
    #####:18919:            printf("\n");
        -:18920:        }
        -:18921:    }
        -:18922:    }
    #####:18923:    function_tests++;
        -:18924:
    #####:18925:    return(test_ret);
        -:18926:}
        -:18927:
        -:18928:
        -:18929:static int
    #####:18930:test_xmlBufferLength(void) {
    #####:18931:    int test_ret = 0;
        -:18932:
        -:18933:    int mem_base;
        -:18934:    int ret_val;
        -:18935:    xmlBuffer * buf; /* the buffer */
        -:18936:    int n_buf;
        -:18937:
    #####:18938:    for (n_buf = 0;n_buf < gen_nb_const_xmlBuffer_ptr;n_buf++) {
    #####:18939:        mem_base = xmlMemBlocks();
    #####:18940:        buf = gen_const_xmlBuffer_ptr(n_buf, 0);
        -:18941:
    #####:18942:        ret_val = xmlBufferLength((const xmlBuffer *)buf);
    #####:18943:        desret_int(ret_val);
    #####:18944:        call_tests++;
    #####:18945:        des_const_xmlBuffer_ptr(n_buf, (const xmlBuffer *)buf, 0);
    #####:18946:        xmlResetLastError();
    #####:18947:        if (mem_base != xmlMemBlocks()) {
    #####:18948:            printf("Leak of %d blocks found in xmlBufferLength",
    #####:18949:	           xmlMemBlocks() - mem_base);
    #####:18950:	    test_ret++;
    #####:18951:            printf(" %d", n_buf);
    #####:18952:            printf("\n");
        -:18953:        }
        -:18954:    }
    #####:18955:    function_tests++;
        -:18956:
    #####:18957:    return(test_ret);
        -:18958:}
        -:18959:
        -:18960:
        -:18961:static int
    #####:18962:test_xmlBufferResize(void) {
    #####:18963:    int test_ret = 0;
        -:18964:
        -:18965:    int mem_base;
        -:18966:    int ret_val;
        -:18967:    xmlBufferPtr buf; /* the buffer to resize */
        -:18968:    int n_buf;
        -:18969:    unsigned int size; /* the desired size */
        -:18970:    int n_size;
        -:18971:
    #####:18972:    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    #####:18973:    for (n_size = 0;n_size < gen_nb_unsigned_int;n_size++) {
    #####:18974:        mem_base = xmlMemBlocks();
    #####:18975:        buf = gen_xmlBufferPtr(n_buf, 0);
    #####:18976:        size = gen_unsigned_int(n_size, 1);
        -:18977:
    #####:18978:        ret_val = xmlBufferResize(buf, size);
    #####:18979:        desret_int(ret_val);
    #####:18980:        call_tests++;
    #####:18981:        des_xmlBufferPtr(n_buf, buf, 0);
    #####:18982:        des_unsigned_int(n_size, size, 1);
    #####:18983:        xmlResetLastError();
    #####:18984:        if (mem_base != xmlMemBlocks()) {
    #####:18985:            printf("Leak of %d blocks found in xmlBufferResize",
    #####:18986:	           xmlMemBlocks() - mem_base);
    #####:18987:	    test_ret++;
    #####:18988:            printf(" %d", n_buf);
    #####:18989:            printf(" %d", n_size);
    #####:18990:            printf("\n");
        -:18991:        }
        -:18992:    }
        -:18993:    }
    #####:18994:    function_tests++;
        -:18995:
    #####:18996:    return(test_ret);
        -:18997:}
        -:18998:
        -:18999:
        -:19000:static int
    #####:19001:test_xmlBufferSetAllocationScheme(void) {
    #####:19002:    int test_ret = 0;
        -:19003:
        -:19004:    int mem_base;
        -:19005:    xmlBufferPtr buf; /* the buffer to tune */
        -:19006:    int n_buf;
        -:19007:    xmlBufferAllocationScheme scheme; /* allocation scheme to use */
        -:19008:    int n_scheme;
        -:19009:
    #####:19010:    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    #####:19011:    for (n_scheme = 0;n_scheme < gen_nb_xmlBufferAllocationScheme;n_scheme++) {
    #####:19012:        mem_base = xmlMemBlocks();
    #####:19013:        buf = gen_xmlBufferPtr(n_buf, 0);
    #####:19014:        scheme = gen_xmlBufferAllocationScheme(n_scheme, 1);
        -:19015:
    #####:19016:        xmlBufferSetAllocationScheme(buf, scheme);
    #####:19017:        if ((buf != NULL) && (scheme == XML_BUFFER_ALLOC_IMMUTABLE) && (buf->content != NULL) && (buf->content != static_buf_content)) { xmlFree(buf->content); buf->content = NULL;}
    #####:19018:        call_tests++;
    #####:19019:        des_xmlBufferPtr(n_buf, buf, 0);
    #####:19020:        des_xmlBufferAllocationScheme(n_scheme, scheme, 1);
    #####:19021:        xmlResetLastError();
    #####:19022:        if (mem_base != xmlMemBlocks()) {
    #####:19023:            printf("Leak of %d blocks found in xmlBufferSetAllocationScheme",
    #####:19024:	           xmlMemBlocks() - mem_base);
    #####:19025:	    test_ret++;
    #####:19026:            printf(" %d", n_buf);
    #####:19027:            printf(" %d", n_scheme);
    #####:19028:            printf("\n");
        -:19029:        }
        -:19030:    }
        -:19031:    }
    #####:19032:    function_tests++;
        -:19033:
    #####:19034:    return(test_ret);
        -:19035:}
        -:19036:
        -:19037:
        -:19038:static int
    #####:19039:test_xmlBufferShrink(void) {
    #####:19040:    int test_ret = 0;
        -:19041:
        -:19042:    int mem_base;
        -:19043:    int ret_val;
        -:19044:    xmlBufferPtr buf; /* the buffer to dump */
        -:19045:    int n_buf;
        -:19046:    unsigned int len; /* the number of xmlChar to remove */
        -:19047:    int n_len;
        -:19048:
    #####:19049:    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    #####:19050:    for (n_len = 0;n_len < gen_nb_unsigned_int;n_len++) {
    #####:19051:        mem_base = xmlMemBlocks();
    #####:19052:        buf = gen_xmlBufferPtr(n_buf, 0);
    #####:19053:        len = gen_unsigned_int(n_len, 1);
        -:19054:
    #####:19055:        ret_val = xmlBufferShrink(buf, len);
    #####:19056:        desret_int(ret_val);
    #####:19057:        call_tests++;
    #####:19058:        des_xmlBufferPtr(n_buf, buf, 0);
    #####:19059:        des_unsigned_int(n_len, len, 1);
    #####:19060:        xmlResetLastError();
    #####:19061:        if (mem_base != xmlMemBlocks()) {
    #####:19062:            printf("Leak of %d blocks found in xmlBufferShrink",
    #####:19063:	           xmlMemBlocks() - mem_base);
    #####:19064:	    test_ret++;
    #####:19065:            printf(" %d", n_buf);
    #####:19066:            printf(" %d", n_len);
    #####:19067:            printf("\n");
        -:19068:        }
        -:19069:    }
        -:19070:    }
    #####:19071:    function_tests++;
        -:19072:
    #####:19073:    return(test_ret);
        -:19074:}
        -:19075:
        -:19076:
        -:19077:static int
    #####:19078:test_xmlBufferWriteCHAR(void) {
    #####:19079:    int test_ret = 0;
        -:19080:
        -:19081:    int mem_base;
        -:19082:    xmlBufferPtr buf; /* the XML buffer */
        -:19083:    int n_buf;
        -:19084:    xmlChar * string; /* the string to add */
        -:19085:    int n_string;
        -:19086:
    #####:19087:    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    #####:19088:    for (n_string = 0;n_string < gen_nb_const_xmlChar_ptr;n_string++) {
    #####:19089:        mem_base = xmlMemBlocks();
    #####:19090:        buf = gen_xmlBufferPtr(n_buf, 0);
    #####:19091:        string = gen_const_xmlChar_ptr(n_string, 1);
        -:19092:
    #####:19093:        xmlBufferWriteCHAR(buf, (const xmlChar *)string);
    #####:19094:        call_tests++;
    #####:19095:        des_xmlBufferPtr(n_buf, buf, 0);
    #####:19096:        des_const_xmlChar_ptr(n_string, (const xmlChar *)string, 1);
    #####:19097:        xmlResetLastError();
    #####:19098:        if (mem_base != xmlMemBlocks()) {
    #####:19099:            printf("Leak of %d blocks found in xmlBufferWriteCHAR",
    #####:19100:	           xmlMemBlocks() - mem_base);
    #####:19101:	    test_ret++;
    #####:19102:            printf(" %d", n_buf);
    #####:19103:            printf(" %d", n_string);
    #####:19104:            printf("\n");
        -:19105:        }
        -:19106:    }
        -:19107:    }
    #####:19108:    function_tests++;
        -:19109:
    #####:19110:    return(test_ret);
        -:19111:}
        -:19112:
        -:19113:
        -:19114:static int
    #####:19115:test_xmlBufferWriteChar(void) {
    #####:19116:    int test_ret = 0;
        -:19117:
        -:19118:    int mem_base;
        -:19119:    xmlBufferPtr buf; /* the XML buffer output */
        -:19120:    int n_buf;
        -:19121:    char * string; /* the string to add */
        -:19122:    int n_string;
        -:19123:
    #####:19124:    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    #####:19125:    for (n_string = 0;n_string < gen_nb_const_char_ptr;n_string++) {
    #####:19126:        mem_base = xmlMemBlocks();
    #####:19127:        buf = gen_xmlBufferPtr(n_buf, 0);
    #####:19128:        string = gen_const_char_ptr(n_string, 1);
        -:19129:
    #####:19130:        xmlBufferWriteChar(buf, (const char *)string);
    #####:19131:        call_tests++;
    #####:19132:        des_xmlBufferPtr(n_buf, buf, 0);
    #####:19133:        des_const_char_ptr(n_string, (const char *)string, 1);
    #####:19134:        xmlResetLastError();
    #####:19135:        if (mem_base != xmlMemBlocks()) {
    #####:19136:            printf("Leak of %d blocks found in xmlBufferWriteChar",
    #####:19137:	           xmlMemBlocks() - mem_base);
    #####:19138:	    test_ret++;
    #####:19139:            printf(" %d", n_buf);
    #####:19140:            printf(" %d", n_string);
    #####:19141:            printf("\n");
        -:19142:        }
        -:19143:    }
        -:19144:    }
    #####:19145:    function_tests++;
        -:19146:
    #####:19147:    return(test_ret);
        -:19148:}
        -:19149:
        -:19150:
        -:19151:static int
    #####:19152:test_xmlBufferWriteQuotedString(void) {
    #####:19153:    int test_ret = 0;
        -:19154:
        -:19155:    int mem_base;
        -:19156:    xmlBufferPtr buf; /* the XML buffer output */
        -:19157:    int n_buf;
        -:19158:    xmlChar * string; /* the string to add */
        -:19159:    int n_string;
        -:19160:
    #####:19161:    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    #####:19162:    for (n_string = 0;n_string < gen_nb_const_xmlChar_ptr;n_string++) {
    #####:19163:        mem_base = xmlMemBlocks();
    #####:19164:        buf = gen_xmlBufferPtr(n_buf, 0);
    #####:19165:        string = gen_const_xmlChar_ptr(n_string, 1);
        -:19166:
    #####:19167:        xmlBufferWriteQuotedString(buf, (const xmlChar *)string);
    #####:19168:        call_tests++;
    #####:19169:        des_xmlBufferPtr(n_buf, buf, 0);
    #####:19170:        des_const_xmlChar_ptr(n_string, (const xmlChar *)string, 1);
    #####:19171:        xmlResetLastError();
    #####:19172:        if (mem_base != xmlMemBlocks()) {
    #####:19173:            printf("Leak of %d blocks found in xmlBufferWriteQuotedString",
    #####:19174:	           xmlMemBlocks() - mem_base);
    #####:19175:	    test_ret++;
    #####:19176:            printf(" %d", n_buf);
    #####:19177:            printf(" %d", n_string);
    #####:19178:            printf("\n");
        -:19179:        }
        -:19180:    }
        -:19181:    }
    #####:19182:    function_tests++;
        -:19183:
    #####:19184:    return(test_ret);
        -:19185:}
        -:19186:
        -:19187:
        -:19188:static int
    #####:19189:test_xmlBuildQName(void) {
    #####:19190:    int test_ret = 0;
        -:19191:
        -:19192:    int mem_base;
        -:19193:    xmlChar * ret_val;
        -:19194:    xmlChar * ncname; /* the Name */
        -:19195:    int n_ncname;
        -:19196:    xmlChar * prefix; /* the prefix */
        -:19197:    int n_prefix;
        -:19198:    xmlChar * memory; /* preallocated memory */
        -:19199:    int n_memory;
        -:19200:    int len; /* preallocated memory length */
        -:19201:    int n_len;
        -:19202:
    #####:19203:    for (n_ncname = 0;n_ncname < gen_nb_const_xmlChar_ptr;n_ncname++) {
    #####:19204:    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    #####:19205:    for (n_memory = 0;n_memory < gen_nb_xmlChar_ptr;n_memory++) {
    #####:19206:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:19207:        mem_base = xmlMemBlocks();
    #####:19208:        ncname = gen_const_xmlChar_ptr(n_ncname, 0);
    #####:19209:        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
    #####:19210:        memory = gen_xmlChar_ptr(n_memory, 2);
    #####:19211:        len = gen_int(n_len, 3);
        -:19212:
    #####:19213:        ret_val = xmlBuildQName((const xmlChar *)ncname, (const xmlChar *)prefix, memory, len);
    #####:19214:        if ((ret_val != NULL) && (ret_val != ncname) &&
    #####:19215:              (ret_val != prefix) && (ret_val != memory))
    #####:19216:              xmlFree(ret_val);
    #####:19217:	  ret_val = NULL;
    #####:19218:        desret_xmlChar_ptr(ret_val);
    #####:19219:        call_tests++;
    #####:19220:        des_const_xmlChar_ptr(n_ncname, (const xmlChar *)ncname, 0);
    #####:19221:        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 1);
    #####:19222:        des_xmlChar_ptr(n_memory, memory, 2);
    #####:19223:        des_int(n_len, len, 3);
    #####:19224:        xmlResetLastError();
    #####:19225:        if (mem_base != xmlMemBlocks()) {
    #####:19226:            printf("Leak of %d blocks found in xmlBuildQName",
    #####:19227:	           xmlMemBlocks() - mem_base);
    #####:19228:	    test_ret++;
    #####:19229:            printf(" %d", n_ncname);
    #####:19230:            printf(" %d", n_prefix);
    #####:19231:            printf(" %d", n_memory);
    #####:19232:            printf(" %d", n_len);
    #####:19233:            printf("\n");
        -:19234:        }
        -:19235:    }
        -:19236:    }
        -:19237:    }
        -:19238:    }
    #####:19239:    function_tests++;
        -:19240:
    #####:19241:    return(test_ret);
        -:19242:}
        -:19243:
        -:19244:
        -:19245:static int
    #####:19246:test_xmlChildElementCount(void) {
    #####:19247:    int test_ret = 0;
        -:19248:
        -:19249:#if defined(LIBXML_TREE_ENABLED)
        -:19250:    int mem_base;
        -:19251:    unsigned long ret_val;
        -:19252:    xmlNodePtr parent; /* the parent node */
        -:19253:    int n_parent;
        -:19254:
    #####:19255:    for (n_parent = 0;n_parent < gen_nb_xmlNodePtr;n_parent++) {
    #####:19256:        mem_base = xmlMemBlocks();
    #####:19257:        parent = gen_xmlNodePtr(n_parent, 0);
        -:19258:
    #####:19259:        ret_val = xmlChildElementCount(parent);
    #####:19260:        desret_unsigned_long(ret_val);
    #####:19261:        call_tests++;
    #####:19262:        des_xmlNodePtr(n_parent, parent, 0);
    #####:19263:        xmlResetLastError();
    #####:19264:        if (mem_base != xmlMemBlocks()) {
    #####:19265:            printf("Leak of %d blocks found in xmlChildElementCount",
    #####:19266:	           xmlMemBlocks() - mem_base);
    #####:19267:	    test_ret++;
    #####:19268:            printf(" %d", n_parent);
    #####:19269:            printf("\n");
        -:19270:        }
        -:19271:    }
    #####:19272:    function_tests++;
        -:19273:#endif
        -:19274:
    #####:19275:    return(test_ret);
        -:19276:}
        -:19277:
        -:19278:
        -:19279:static int
    #####:19280:test_xmlCopyDoc(void) {
    #####:19281:    int test_ret = 0;
        -:19282:
        -:19283:#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
        -:19284:    int mem_base;
        -:19285:    xmlDocPtr ret_val;
        -:19286:    xmlDocPtr doc; /* the document */
        -:19287:    int n_doc;
        -:19288:    int recursive; /* if not zero do a recursive copy. */
        -:19289:    int n_recursive;
        -:19290:
    #####:19291:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:19292:    for (n_recursive = 0;n_recursive < gen_nb_int;n_recursive++) {
    #####:19293:        mem_base = xmlMemBlocks();
    #####:19294:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:19295:        recursive = gen_int(n_recursive, 1);
        -:19296:
    #####:19297:        ret_val = xmlCopyDoc(doc, recursive);
    #####:19298:        desret_xmlDocPtr(ret_val);
    #####:19299:        call_tests++;
    #####:19300:        des_xmlDocPtr(n_doc, doc, 0);
    #####:19301:        des_int(n_recursive, recursive, 1);
    #####:19302:        xmlResetLastError();
    #####:19303:        if (mem_base != xmlMemBlocks()) {
    #####:19304:            printf("Leak of %d blocks found in xmlCopyDoc",
    #####:19305:	           xmlMemBlocks() - mem_base);
    #####:19306:	    test_ret++;
    #####:19307:            printf(" %d", n_doc);
    #####:19308:            printf(" %d", n_recursive);
    #####:19309:            printf("\n");
        -:19310:        }
        -:19311:    }
        -:19312:    }
    #####:19313:    function_tests++;
        -:19314:#endif
        -:19315:
    #####:19316:    return(test_ret);
        -:19317:}
        -:19318:
        -:19319:
        -:19320:static int
    #####:19321:test_xmlCopyDtd(void) {
    #####:19322:    int test_ret = 0;
        -:19323:
        -:19324:#if defined(LIBXML_TREE_ENABLED)
        -:19325:    int mem_base;
        -:19326:    xmlDtdPtr ret_val;
        -:19327:    xmlDtdPtr dtd; /* the dtd */
        -:19328:    int n_dtd;
        -:19329:
    #####:19330:    for (n_dtd = 0;n_dtd < gen_nb_xmlDtdPtr;n_dtd++) {
    #####:19331:        mem_base = xmlMemBlocks();
    #####:19332:        dtd = gen_xmlDtdPtr(n_dtd, 0);
        -:19333:
    #####:19334:        ret_val = xmlCopyDtd(dtd);
    #####:19335:        desret_xmlDtdPtr(ret_val);
    #####:19336:        call_tests++;
    #####:19337:        des_xmlDtdPtr(n_dtd, dtd, 0);
    #####:19338:        xmlResetLastError();
    #####:19339:        if (mem_base != xmlMemBlocks()) {
    #####:19340:            printf("Leak of %d blocks found in xmlCopyDtd",
    #####:19341:	           xmlMemBlocks() - mem_base);
    #####:19342:	    test_ret++;
    #####:19343:            printf(" %d", n_dtd);
    #####:19344:            printf("\n");
        -:19345:        }
        -:19346:    }
    #####:19347:    function_tests++;
        -:19348:#endif
        -:19349:
    #####:19350:    return(test_ret);
        -:19351:}
        -:19352:
        -:19353:
        -:19354:static int
    #####:19355:test_xmlCopyNamespace(void) {
    #####:19356:    int test_ret = 0;
        -:19357:
        -:19358:    int mem_base;
        -:19359:    xmlNsPtr ret_val;
        -:19360:    xmlNsPtr cur; /* the namespace */
        -:19361:    int n_cur;
        -:19362:
    #####:19363:    for (n_cur = 0;n_cur < gen_nb_xmlNsPtr;n_cur++) {
    #####:19364:        mem_base = xmlMemBlocks();
    #####:19365:        cur = gen_xmlNsPtr(n_cur, 0);
        -:19366:
    #####:19367:        ret_val = xmlCopyNamespace(cur);
    #####:19368:        if (ret_val != NULL) xmlFreeNs(ret_val);
    #####:19369:        desret_xmlNsPtr(ret_val);
    #####:19370:        call_tests++;
    #####:19371:        des_xmlNsPtr(n_cur, cur, 0);
    #####:19372:        xmlResetLastError();
    #####:19373:        if (mem_base != xmlMemBlocks()) {
    #####:19374:            printf("Leak of %d blocks found in xmlCopyNamespace",
    #####:19375:	           xmlMemBlocks() - mem_base);
    #####:19376:	    test_ret++;
    #####:19377:            printf(" %d", n_cur);
    #####:19378:            printf("\n");
        -:19379:        }
        -:19380:    }
    #####:19381:    function_tests++;
        -:19382:
    #####:19383:    return(test_ret);
        -:19384:}
        -:19385:
        -:19386:
        -:19387:static int
    #####:19388:test_xmlCopyNamespaceList(void) {
    #####:19389:    int test_ret = 0;
        -:19390:
        -:19391:    int mem_base;
        -:19392:    xmlNsPtr ret_val;
        -:19393:    xmlNsPtr cur; /* the first namespace */
        -:19394:    int n_cur;
        -:19395:
    #####:19396:    for (n_cur = 0;n_cur < gen_nb_xmlNsPtr;n_cur++) {
    #####:19397:        mem_base = xmlMemBlocks();
    #####:19398:        cur = gen_xmlNsPtr(n_cur, 0);
        -:19399:
    #####:19400:        ret_val = xmlCopyNamespaceList(cur);
    #####:19401:        if (ret_val != NULL) xmlFreeNsList(ret_val);
    #####:19402:        desret_xmlNsPtr(ret_val);
    #####:19403:        call_tests++;
    #####:19404:        des_xmlNsPtr(n_cur, cur, 0);
    #####:19405:        xmlResetLastError();
    #####:19406:        if (mem_base != xmlMemBlocks()) {
    #####:19407:            printf("Leak of %d blocks found in xmlCopyNamespaceList",
    #####:19408:	           xmlMemBlocks() - mem_base);
    #####:19409:	    test_ret++;
    #####:19410:            printf(" %d", n_cur);
    #####:19411:            printf("\n");
        -:19412:        }
        -:19413:    }
    #####:19414:    function_tests++;
        -:19415:
    #####:19416:    return(test_ret);
        -:19417:}
        -:19418:
        -:19419:
        -:19420:static int
    #####:19421:test_xmlCopyNode(void) {
    #####:19422:    int test_ret = 0;
        -:19423:
        -:19424:    int mem_base;
        -:19425:    xmlNodePtr ret_val;
        -:19426:    xmlNodePtr node; /* the node */
        -:19427:    int n_node;
        -:19428:    int extended; /* if 1 do a recursive copy (properties, namespaces and children when applicable) if 2 copy properties and namespaces (when applicable) */
        -:19429:    int n_extended;
        -:19430:
    #####:19431:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:19432:    for (n_extended = 0;n_extended < gen_nb_int;n_extended++) {
    #####:19433:        mem_base = xmlMemBlocks();
    #####:19434:        node = gen_xmlNodePtr(n_node, 0);
    #####:19435:        extended = gen_int(n_extended, 1);
        -:19436:
    #####:19437:        ret_val = xmlCopyNode(node, extended);
    #####:19438:        desret_xmlNodePtr(ret_val);
    #####:19439:        call_tests++;
    #####:19440:        des_xmlNodePtr(n_node, node, 0);
    #####:19441:        des_int(n_extended, extended, 1);
    #####:19442:        xmlResetLastError();
    #####:19443:        if (mem_base != xmlMemBlocks()) {
    #####:19444:            printf("Leak of %d blocks found in xmlCopyNode",
    #####:19445:	           xmlMemBlocks() - mem_base);
    #####:19446:	    test_ret++;
    #####:19447:            printf(" %d", n_node);
    #####:19448:            printf(" %d", n_extended);
    #####:19449:            printf("\n");
        -:19450:        }
        -:19451:    }
        -:19452:    }
    #####:19453:    function_tests++;
        -:19454:
    #####:19455:    return(test_ret);
        -:19456:}
        -:19457:
        -:19458:
        -:19459:static int
    #####:19460:test_xmlCopyNodeList(void) {
    #####:19461:    int test_ret = 0;
        -:19462:
        -:19463:    int mem_base;
        -:19464:    xmlNodePtr ret_val;
        -:19465:    xmlNodePtr node; /* the first node in the list. */
        -:19466:    int n_node;
        -:19467:
    #####:19468:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:19469:        mem_base = xmlMemBlocks();
    #####:19470:        node = gen_xmlNodePtr(n_node, 0);
        -:19471:
    #####:19472:        ret_val = xmlCopyNodeList(node);
    #####:19473:        desret_xmlNodePtr(ret_val);
    #####:19474:        call_tests++;
    #####:19475:        des_xmlNodePtr(n_node, node, 0);
    #####:19476:        xmlResetLastError();
    #####:19477:        if (mem_base != xmlMemBlocks()) {
    #####:19478:            printf("Leak of %d blocks found in xmlCopyNodeList",
    #####:19479:	           xmlMemBlocks() - mem_base);
    #####:19480:	    test_ret++;
    #####:19481:            printf(" %d", n_node);
    #####:19482:            printf("\n");
        -:19483:        }
        -:19484:    }
    #####:19485:    function_tests++;
        -:19486:
    #####:19487:    return(test_ret);
        -:19488:}
        -:19489:
        -:19490:
        -:19491:static int
    #####:19492:test_xmlCopyProp(void) {
    #####:19493:    int test_ret = 0;
        -:19494:
        -:19495:    int mem_base;
        -:19496:    xmlAttrPtr ret_val;
        -:19497:    xmlNodePtr target; /* the element where the attribute will be grafted */
        -:19498:    int n_target;
        -:19499:    xmlAttrPtr cur; /* the attribute */
        -:19500:    int n_cur;
        -:19501:
    #####:19502:    for (n_target = 0;n_target < gen_nb_xmlNodePtr;n_target++) {
    #####:19503:    for (n_cur = 0;n_cur < gen_nb_xmlAttrPtr;n_cur++) {
    #####:19504:        mem_base = xmlMemBlocks();
    #####:19505:        target = gen_xmlNodePtr(n_target, 0);
    #####:19506:        cur = gen_xmlAttrPtr(n_cur, 1);
        -:19507:
    #####:19508:        ret_val = xmlCopyProp(target, cur);
    #####:19509:        desret_xmlAttrPtr(ret_val);
    #####:19510:        call_tests++;
    #####:19511:        des_xmlNodePtr(n_target, target, 0);
    #####:19512:        des_xmlAttrPtr(n_cur, cur, 1);
    #####:19513:        xmlResetLastError();
    #####:19514:        if (mem_base != xmlMemBlocks()) {
    #####:19515:            printf("Leak of %d blocks found in xmlCopyProp",
    #####:19516:	           xmlMemBlocks() - mem_base);
    #####:19517:	    test_ret++;
    #####:19518:            printf(" %d", n_target);
    #####:19519:            printf(" %d", n_cur);
    #####:19520:            printf("\n");
        -:19521:        }
        -:19522:    }
        -:19523:    }
    #####:19524:    function_tests++;
        -:19525:
    #####:19526:    return(test_ret);
        -:19527:}
        -:19528:
        -:19529:
        -:19530:static int
    #####:19531:test_xmlCopyPropList(void) {
    #####:19532:    int test_ret = 0;
        -:19533:
        -:19534:    int mem_base;
        -:19535:    xmlAttrPtr ret_val;
        -:19536:    xmlNodePtr target; /* the element where the attributes will be grafted */
        -:19537:    int n_target;
        -:19538:    xmlAttrPtr cur; /* the first attribute */
        -:19539:    int n_cur;
        -:19540:
    #####:19541:    for (n_target = 0;n_target < gen_nb_xmlNodePtr;n_target++) {
    #####:19542:    for (n_cur = 0;n_cur < gen_nb_xmlAttrPtr;n_cur++) {
    #####:19543:        mem_base = xmlMemBlocks();
    #####:19544:        target = gen_xmlNodePtr(n_target, 0);
    #####:19545:        cur = gen_xmlAttrPtr(n_cur, 1);
        -:19546:
    #####:19547:        ret_val = xmlCopyPropList(target, cur);
    #####:19548:        desret_xmlAttrPtr(ret_val);
    #####:19549:        call_tests++;
    #####:19550:        des_xmlNodePtr(n_target, target, 0);
    #####:19551:        des_xmlAttrPtr(n_cur, cur, 1);
    #####:19552:        xmlResetLastError();
    #####:19553:        if (mem_base != xmlMemBlocks()) {
    #####:19554:            printf("Leak of %d blocks found in xmlCopyPropList",
    #####:19555:	           xmlMemBlocks() - mem_base);
    #####:19556:	    test_ret++;
    #####:19557:            printf(" %d", n_target);
    #####:19558:            printf(" %d", n_cur);
    #####:19559:            printf("\n");
        -:19560:        }
        -:19561:    }
        -:19562:    }
    #####:19563:    function_tests++;
        -:19564:
    #####:19565:    return(test_ret);
        -:19566:}
        -:19567:
        -:19568:
        -:19569:static int
    #####:19570:test_xmlCreateIntSubset(void) {
    #####:19571:    int test_ret = 0;
        -:19572:
        -:19573:    int mem_base;
        -:19574:    xmlDtdPtr ret_val;
        -:19575:    xmlDocPtr doc; /* the document pointer */
        -:19576:    int n_doc;
        -:19577:    xmlChar * name; /* the DTD name */
        -:19578:    int n_name;
        -:19579:    xmlChar * ExternalID; /* the external (PUBLIC) ID */
        -:19580:    int n_ExternalID;
        -:19581:    xmlChar * SystemID; /* the system ID */
        -:19582:    int n_SystemID;
        -:19583:
    #####:19584:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:19585:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:19586:    for (n_ExternalID = 0;n_ExternalID < gen_nb_const_xmlChar_ptr;n_ExternalID++) {
    #####:19587:    for (n_SystemID = 0;n_SystemID < gen_nb_const_xmlChar_ptr;n_SystemID++) {
    #####:19588:        mem_base = xmlMemBlocks();
    #####:19589:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:19590:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:19591:        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 2);
    #####:19592:        SystemID = gen_const_xmlChar_ptr(n_SystemID, 3);
        -:19593:
    #####:19594:        ret_val = xmlCreateIntSubset(doc, (const xmlChar *)name, (const xmlChar *)ExternalID, (const xmlChar *)SystemID);
    #####:19595:        desret_xmlDtdPtr(ret_val);
    #####:19596:        call_tests++;
    #####:19597:        des_xmlDocPtr(n_doc, doc, 0);
    #####:19598:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:19599:        des_const_xmlChar_ptr(n_ExternalID, (const xmlChar *)ExternalID, 2);
    #####:19600:        des_const_xmlChar_ptr(n_SystemID, (const xmlChar *)SystemID, 3);
    #####:19601:        xmlResetLastError();
    #####:19602:        if (mem_base != xmlMemBlocks()) {
    #####:19603:            printf("Leak of %d blocks found in xmlCreateIntSubset",
    #####:19604:	           xmlMemBlocks() - mem_base);
    #####:19605:	    test_ret++;
    #####:19606:            printf(" %d", n_doc);
    #####:19607:            printf(" %d", n_name);
    #####:19608:            printf(" %d", n_ExternalID);
    #####:19609:            printf(" %d", n_SystemID);
    #####:19610:            printf("\n");
        -:19611:        }
        -:19612:    }
        -:19613:    }
        -:19614:    }
        -:19615:    }
    #####:19616:    function_tests++;
        -:19617:
    #####:19618:    return(test_ret);
        -:19619:}
        -:19620:
        -:19621:
        -:19622:#define gen_nb_xmlDOMWrapCtxtPtr 1
    #####:19623:static xmlDOMWrapCtxtPtr gen_xmlDOMWrapCtxtPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:19624:    return(NULL);
        -:19625:}
    #####:19626:static void des_xmlDOMWrapCtxtPtr(int no ATTRIBUTE_UNUSED, xmlDOMWrapCtxtPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:19627:}
        -:19628:
        -:19629:static int
    #####:19630:test_xmlDOMWrapAdoptNode(void) {
    #####:19631:    int test_ret = 0;
        -:19632:
        -:19633:    int mem_base;
        -:19634:    int ret_val;
        -:19635:    xmlDOMWrapCtxtPtr ctxt; /* the optional context for custom processing */
        -:19636:    int n_ctxt;
        -:19637:    xmlDocPtr sourceDoc; /* the optional sourceDoc */
        -:19638:    int n_sourceDoc;
        -:19639:    xmlNodePtr node; /* the node to start with */
        -:19640:    int n_node;
        -:19641:    xmlDocPtr destDoc; /* the destination doc */
        -:19642:    int n_destDoc;
        -:19643:    xmlNodePtr destParent; /* the optional new parent of @node in @destDoc */
        -:19644:    int n_destParent;
        -:19645:    int options; /* option flags */
        -:19646:    int n_options;
        -:19647:
    #####:19648:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlDOMWrapCtxtPtr;n_ctxt++) {
    #####:19649:    for (n_sourceDoc = 0;n_sourceDoc < gen_nb_xmlDocPtr;n_sourceDoc++) {
    #####:19650:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:19651:    for (n_destDoc = 0;n_destDoc < gen_nb_xmlDocPtr;n_destDoc++) {
    #####:19652:    for (n_destParent = 0;n_destParent < gen_nb_xmlNodePtr;n_destParent++) {
    #####:19653:    for (n_options = 0;n_options < gen_nb_int;n_options++) {
    #####:19654:        mem_base = xmlMemBlocks();
    #####:19655:        ctxt = gen_xmlDOMWrapCtxtPtr(n_ctxt, 0);
    #####:19656:        sourceDoc = gen_xmlDocPtr(n_sourceDoc, 1);
    #####:19657:        node = gen_xmlNodePtr(n_node, 2);
    #####:19658:        destDoc = gen_xmlDocPtr(n_destDoc, 3);
    #####:19659:        destParent = gen_xmlNodePtr(n_destParent, 4);
    #####:19660:        options = gen_int(n_options, 5);
        -:19661:
    #####:19662:        ret_val = xmlDOMWrapAdoptNode(ctxt, sourceDoc, node, destDoc, destParent, options);
    #####:19663:        if ((node != NULL) && (node->parent == NULL)) {xmlUnlinkNode(node);xmlFreeNode(node);node = NULL;}
    #####:19664:        desret_int(ret_val);
    #####:19665:        call_tests++;
    #####:19666:        des_xmlDOMWrapCtxtPtr(n_ctxt, ctxt, 0);
    #####:19667:        des_xmlDocPtr(n_sourceDoc, sourceDoc, 1);
    #####:19668:        des_xmlNodePtr(n_node, node, 2);
    #####:19669:        des_xmlDocPtr(n_destDoc, destDoc, 3);
    #####:19670:        des_xmlNodePtr(n_destParent, destParent, 4);
    #####:19671:        des_int(n_options, options, 5);
    #####:19672:        xmlResetLastError();
    #####:19673:        if (mem_base != xmlMemBlocks()) {
    #####:19674:            printf("Leak of %d blocks found in xmlDOMWrapAdoptNode",
    #####:19675:	           xmlMemBlocks() - mem_base);
    #####:19676:	    test_ret++;
    #####:19677:            printf(" %d", n_ctxt);
    #####:19678:            printf(" %d", n_sourceDoc);
    #####:19679:            printf(" %d", n_node);
    #####:19680:            printf(" %d", n_destDoc);
    #####:19681:            printf(" %d", n_destParent);
    #####:19682:            printf(" %d", n_options);
    #####:19683:            printf("\n");
        -:19684:        }
        -:19685:    }
        -:19686:    }
        -:19687:    }
        -:19688:    }
        -:19689:    }
        -:19690:    }
    #####:19691:    function_tests++;
        -:19692:
    #####:19693:    return(test_ret);
        -:19694:}
        -:19695:
        -:19696:
        -:19697:static int
    #####:19698:test_xmlDOMWrapCloneNode(void) {
    #####:19699:    int test_ret = 0;
        -:19700:
        -:19701:    int mem_base;
        -:19702:    int ret_val;
        -:19703:    xmlDOMWrapCtxtPtr ctxt; /* the optional context for custom processing */
        -:19704:    int n_ctxt;
        -:19705:    xmlDocPtr sourceDoc; /* the optional sourceDoc */
        -:19706:    int n_sourceDoc;
        -:19707:    xmlNodePtr node; /* the node to start with */
        -:19708:    int n_node;
        -:19709:    xmlNodePtr * resNode; /* the clone of the given @node */
        -:19710:    int n_resNode;
        -:19711:    xmlDocPtr destDoc; /* the destination doc */
        -:19712:    int n_destDoc;
        -:19713:    xmlNodePtr destParent; /* the optional new parent of @node in @destDoc */
        -:19714:    int n_destParent;
        -:19715:    int deep; /* descend into child if set */
        -:19716:    int n_deep;
        -:19717:    int options; /* option flags */
        -:19718:    int n_options;
        -:19719:
    #####:19720:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlDOMWrapCtxtPtr;n_ctxt++) {
    #####:19721:    for (n_sourceDoc = 0;n_sourceDoc < gen_nb_xmlDocPtr;n_sourceDoc++) {
    #####:19722:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:19723:    for (n_resNode = 0;n_resNode < gen_nb_xmlNodePtr_ptr;n_resNode++) {
    #####:19724:    for (n_destDoc = 0;n_destDoc < gen_nb_xmlDocPtr;n_destDoc++) {
    #####:19725:    for (n_destParent = 0;n_destParent < gen_nb_xmlNodePtr;n_destParent++) {
    #####:19726:    for (n_deep = 0;n_deep < gen_nb_int;n_deep++) {
    #####:19727:    for (n_options = 0;n_options < gen_nb_int;n_options++) {
    #####:19728:        mem_base = xmlMemBlocks();
    #####:19729:        ctxt = gen_xmlDOMWrapCtxtPtr(n_ctxt, 0);
    #####:19730:        sourceDoc = gen_xmlDocPtr(n_sourceDoc, 1);
    #####:19731:        node = gen_xmlNodePtr(n_node, 2);
    #####:19732:        resNode = gen_xmlNodePtr_ptr(n_resNode, 3);
    #####:19733:        destDoc = gen_xmlDocPtr(n_destDoc, 4);
    #####:19734:        destParent = gen_xmlNodePtr(n_destParent, 5);
    #####:19735:        deep = gen_int(n_deep, 6);
    #####:19736:        options = gen_int(n_options, 7);
        -:19737:
    #####:19738:        ret_val = xmlDOMWrapCloneNode(ctxt, sourceDoc, node, resNode, destDoc, destParent, deep, options);
    #####:19739:        desret_int(ret_val);
    #####:19740:        call_tests++;
    #####:19741:        des_xmlDOMWrapCtxtPtr(n_ctxt, ctxt, 0);
    #####:19742:        des_xmlDocPtr(n_sourceDoc, sourceDoc, 1);
    #####:19743:        des_xmlNodePtr(n_node, node, 2);
    #####:19744:        des_xmlNodePtr_ptr(n_resNode, resNode, 3);
    #####:19745:        des_xmlDocPtr(n_destDoc, destDoc, 4);
    #####:19746:        des_xmlNodePtr(n_destParent, destParent, 5);
    #####:19747:        des_int(n_deep, deep, 6);
    #####:19748:        des_int(n_options, options, 7);
    #####:19749:        xmlResetLastError();
    #####:19750:        if (mem_base != xmlMemBlocks()) {
    #####:19751:            printf("Leak of %d blocks found in xmlDOMWrapCloneNode",
    #####:19752:	           xmlMemBlocks() - mem_base);
    #####:19753:	    test_ret++;
    #####:19754:            printf(" %d", n_ctxt);
    #####:19755:            printf(" %d", n_sourceDoc);
    #####:19756:            printf(" %d", n_node);
    #####:19757:            printf(" %d", n_resNode);
    #####:19758:            printf(" %d", n_destDoc);
    #####:19759:            printf(" %d", n_destParent);
    #####:19760:            printf(" %d", n_deep);
    #####:19761:            printf(" %d", n_options);
    #####:19762:            printf("\n");
        -:19763:        }
        -:19764:    }
        -:19765:    }
        -:19766:    }
        -:19767:    }
        -:19768:    }
        -:19769:    }
        -:19770:    }
        -:19771:    }
    #####:19772:    function_tests++;
        -:19773:
    #####:19774:    return(test_ret);
        -:19775:}
        -:19776:
        -:19777:
        -:19778:static int
    #####:19779:test_xmlDOMWrapNewCtxt(void) {
    #####:19780:    int test_ret = 0;
        -:19781:
        -:19782:
        -:19783:    /* missing type support */
    #####:19784:    return(test_ret);
        -:19785:}
        -:19786:
        -:19787:
        -:19788:static int
    #####:19789:test_xmlDOMWrapReconcileNamespaces(void) {
    #####:19790:    int test_ret = 0;
        -:19791:
        -:19792:    int mem_base;
        -:19793:    int ret_val;
        -:19794:    xmlDOMWrapCtxtPtr ctxt; /* DOM wrapper context, unused at the moment */
        -:19795:    int n_ctxt;
        -:19796:    xmlNodePtr elem; /* the element-node */
        -:19797:    int n_elem;
        -:19798:    int options; /* option flags */
        -:19799:    int n_options;
        -:19800:
    #####:19801:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlDOMWrapCtxtPtr;n_ctxt++) {
    #####:19802:    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    #####:19803:    for (n_options = 0;n_options < gen_nb_int;n_options++) {
    #####:19804:        mem_base = xmlMemBlocks();
    #####:19805:        ctxt = gen_xmlDOMWrapCtxtPtr(n_ctxt, 0);
    #####:19806:        elem = gen_xmlNodePtr(n_elem, 1);
    #####:19807:        options = gen_int(n_options, 2);
        -:19808:
    #####:19809:        ret_val = xmlDOMWrapReconcileNamespaces(ctxt, elem, options);
    #####:19810:        desret_int(ret_val);
    #####:19811:        call_tests++;
    #####:19812:        des_xmlDOMWrapCtxtPtr(n_ctxt, ctxt, 0);
    #####:19813:        des_xmlNodePtr(n_elem, elem, 1);
    #####:19814:        des_int(n_options, options, 2);
    #####:19815:        xmlResetLastError();
    #####:19816:        if (mem_base != xmlMemBlocks()) {
    #####:19817:            printf("Leak of %d blocks found in xmlDOMWrapReconcileNamespaces",
    #####:19818:	           xmlMemBlocks() - mem_base);
    #####:19819:	    test_ret++;
    #####:19820:            printf(" %d", n_ctxt);
    #####:19821:            printf(" %d", n_elem);
    #####:19822:            printf(" %d", n_options);
    #####:19823:            printf("\n");
        -:19824:        }
        -:19825:    }
        -:19826:    }
        -:19827:    }
    #####:19828:    function_tests++;
        -:19829:
    #####:19830:    return(test_ret);
        -:19831:}
        -:19832:
        -:19833:
        -:19834:static int
    #####:19835:test_xmlDOMWrapRemoveNode(void) {
    #####:19836:    int test_ret = 0;
        -:19837:
        -:19838:    int mem_base;
        -:19839:    int ret_val;
        -:19840:    xmlDOMWrapCtxtPtr ctxt; /* a DOM wrapper context */
        -:19841:    int n_ctxt;
        -:19842:    xmlDocPtr doc; /* the doc */
        -:19843:    int n_doc;
        -:19844:    xmlNodePtr node; /* the node to be removed. */
        -:19845:    int n_node;
        -:19846:    int options; /* set of options, unused at the moment */
        -:19847:    int n_options;
        -:19848:
    #####:19849:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlDOMWrapCtxtPtr;n_ctxt++) {
    #####:19850:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:19851:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:19852:    for (n_options = 0;n_options < gen_nb_int;n_options++) {
    #####:19853:        mem_base = xmlMemBlocks();
    #####:19854:        ctxt = gen_xmlDOMWrapCtxtPtr(n_ctxt, 0);
    #####:19855:        doc = gen_xmlDocPtr(n_doc, 1);
    #####:19856:        node = gen_xmlNodePtr(n_node, 2);
    #####:19857:        options = gen_int(n_options, 3);
        -:19858:
    #####:19859:        ret_val = xmlDOMWrapRemoveNode(ctxt, doc, node, options);
    #####:19860:        desret_int(ret_val);
    #####:19861:        call_tests++;
    #####:19862:        des_xmlDOMWrapCtxtPtr(n_ctxt, ctxt, 0);
    #####:19863:        des_xmlDocPtr(n_doc, doc, 1);
    #####:19864:        des_xmlNodePtr(n_node, node, 2);
    #####:19865:        des_int(n_options, options, 3);
    #####:19866:        xmlResetLastError();
    #####:19867:        if (mem_base != xmlMemBlocks()) {
    #####:19868:            printf("Leak of %d blocks found in xmlDOMWrapRemoveNode",
    #####:19869:	           xmlMemBlocks() - mem_base);
    #####:19870:	    test_ret++;
    #####:19871:            printf(" %d", n_ctxt);
    #####:19872:            printf(" %d", n_doc);
    #####:19873:            printf(" %d", n_node);
    #####:19874:            printf(" %d", n_options);
    #####:19875:            printf("\n");
        -:19876:        }
        -:19877:    }
        -:19878:    }
        -:19879:    }
        -:19880:    }
    #####:19881:    function_tests++;
        -:19882:
    #####:19883:    return(test_ret);
        -:19884:}
        -:19885:
        -:19886:
        -:19887:static int
    #####:19888:test_xmlDocCopyNode(void) {
    #####:19889:    int test_ret = 0;
        -:19890:
        -:19891:    int mem_base;
        -:19892:    xmlNodePtr ret_val;
        -:19893:    xmlNodePtr node; /* the node */
        -:19894:    int n_node;
        -:19895:    xmlDocPtr doc; /* the document */
        -:19896:    int n_doc;
        -:19897:    int extended; /* if 1 do a recursive copy (properties, namespaces and children when applicable) if 2 copy properties and namespaces (when applicable) */
        -:19898:    int n_extended;
        -:19899:
    #####:19900:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:19901:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:19902:    for (n_extended = 0;n_extended < gen_nb_int;n_extended++) {
    #####:19903:        mem_base = xmlMemBlocks();
    #####:19904:        node = gen_xmlNodePtr(n_node, 0);
    #####:19905:        doc = gen_xmlDocPtr(n_doc, 1);
    #####:19906:        extended = gen_int(n_extended, 2);
        -:19907:
    #####:19908:        ret_val = xmlDocCopyNode(node, doc, extended);
    #####:19909:        desret_xmlNodePtr(ret_val);
    #####:19910:        call_tests++;
    #####:19911:        des_xmlNodePtr(n_node, node, 0);
    #####:19912:        des_xmlDocPtr(n_doc, doc, 1);
    #####:19913:        des_int(n_extended, extended, 2);
    #####:19914:        xmlResetLastError();
    #####:19915:        if (mem_base != xmlMemBlocks()) {
    #####:19916:            printf("Leak of %d blocks found in xmlDocCopyNode",
    #####:19917:	           xmlMemBlocks() - mem_base);
    #####:19918:	    test_ret++;
    #####:19919:            printf(" %d", n_node);
    #####:19920:            printf(" %d", n_doc);
    #####:19921:            printf(" %d", n_extended);
    #####:19922:            printf("\n");
        -:19923:        }
        -:19924:    }
        -:19925:    }
        -:19926:    }
    #####:19927:    function_tests++;
        -:19928:
    #####:19929:    return(test_ret);
        -:19930:}
        -:19931:
        -:19932:
        -:19933:static int
    #####:19934:test_xmlDocCopyNodeList(void) {
    #####:19935:    int test_ret = 0;
        -:19936:
        -:19937:    int mem_base;
        -:19938:    xmlNodePtr ret_val;
        -:19939:    xmlDocPtr doc; /* the target document */
        -:19940:    int n_doc;
        -:19941:    xmlNodePtr node; /* the first node in the list. */
        -:19942:    int n_node;
        -:19943:
    #####:19944:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:19945:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:19946:        mem_base = xmlMemBlocks();
    #####:19947:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:19948:        node = gen_xmlNodePtr(n_node, 1);
        -:19949:
    #####:19950:        ret_val = xmlDocCopyNodeList(doc, node);
    #####:19951:        desret_xmlNodePtr(ret_val);
    #####:19952:        call_tests++;
    #####:19953:        des_xmlDocPtr(n_doc, doc, 0);
    #####:19954:        des_xmlNodePtr(n_node, node, 1);
    #####:19955:        xmlResetLastError();
    #####:19956:        if (mem_base != xmlMemBlocks()) {
    #####:19957:            printf("Leak of %d blocks found in xmlDocCopyNodeList",
    #####:19958:	           xmlMemBlocks() - mem_base);
    #####:19959:	    test_ret++;
    #####:19960:            printf(" %d", n_doc);
    #####:19961:            printf(" %d", n_node);
    #####:19962:            printf("\n");
        -:19963:        }
        -:19964:    }
        -:19965:    }
    #####:19966:    function_tests++;
        -:19967:
    #####:19968:    return(test_ret);
        -:19969:}
        -:19970:
        -:19971:
        -:19972:static int
    #####:19973:test_xmlDocDump(void) {
    #####:19974:    int test_ret = 0;
        -:19975:
        -:19976:#if defined(LIBXML_OUTPUT_ENABLED)
        -:19977:    int mem_base;
        -:19978:    int ret_val;
        -:19979:    FILE * f; /* the FILE* */
        -:19980:    int n_f;
        -:19981:    xmlDocPtr cur; /* the document */
        -:19982:    int n_cur;
        -:19983:
    #####:19984:    for (n_f = 0;n_f < gen_nb_FILE_ptr;n_f++) {
    #####:19985:    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    #####:19986:        mem_base = xmlMemBlocks();
    #####:19987:        f = gen_FILE_ptr(n_f, 0);
    #####:19988:        cur = gen_xmlDocPtr(n_cur, 1);
        -:19989:
    #####:19990:        ret_val = xmlDocDump(f, cur);
    #####:19991:        desret_int(ret_val);
    #####:19992:        call_tests++;
    #####:19993:        des_FILE_ptr(n_f, f, 0);
    #####:19994:        des_xmlDocPtr(n_cur, cur, 1);
    #####:19995:        xmlResetLastError();
    #####:19996:        if (mem_base != xmlMemBlocks()) {
    #####:19997:            printf("Leak of %d blocks found in xmlDocDump",
    #####:19998:	           xmlMemBlocks() - mem_base);
    #####:19999:	    test_ret++;
    #####:20000:            printf(" %d", n_f);
    #####:20001:            printf(" %d", n_cur);
    #####:20002:            printf("\n");
        -:20003:        }
        -:20004:    }
        -:20005:    }
    #####:20006:    function_tests++;
        -:20007:#endif
        -:20008:
    #####:20009:    return(test_ret);
        -:20010:}
        -:20011:
        -:20012:
        -:20013:static int
    #####:20014:test_xmlDocDumpFormatMemory(void) {
    #####:20015:    int test_ret = 0;
        -:20016:
        -:20017:#if defined(LIBXML_OUTPUT_ENABLED)
        -:20018:    int mem_base;
        -:20019:    xmlDocPtr cur; /* the document */
        -:20020:    int n_cur;
        -:20021:    xmlChar ** mem; /* OUT: the memory pointer */
        -:20022:    int n_mem;
        -:20023:    int * size; /* OUT: the memory length */
        -:20024:    int n_size;
        -:20025:    int format; /* should formatting spaces been added */
        -:20026:    int n_format;
        -:20027:
    #####:20028:    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    #####:20029:    for (n_mem = 0;n_mem < gen_nb_xmlChar_ptr_ptr;n_mem++) {
    #####:20030:    for (n_size = 0;n_size < gen_nb_int_ptr;n_size++) {
    #####:20031:    for (n_format = 0;n_format < gen_nb_int;n_format++) {
    #####:20032:        mem_base = xmlMemBlocks();
    #####:20033:        cur = gen_xmlDocPtr(n_cur, 0);
    #####:20034:        mem = gen_xmlChar_ptr_ptr(n_mem, 1);
    #####:20035:        size = gen_int_ptr(n_size, 2);
    #####:20036:        format = gen_int(n_format, 3);
        -:20037:
    #####:20038:        xmlDocDumpFormatMemory(cur, mem, size, format);
    #####:20039:        call_tests++;
    #####:20040:        des_xmlDocPtr(n_cur, cur, 0);
    #####:20041:        des_xmlChar_ptr_ptr(n_mem, mem, 1);
    #####:20042:        des_int_ptr(n_size, size, 2);
    #####:20043:        des_int(n_format, format, 3);
    #####:20044:        xmlResetLastError();
    #####:20045:        if (mem_base != xmlMemBlocks()) {
    #####:20046:            printf("Leak of %d blocks found in xmlDocDumpFormatMemory",
    #####:20047:	           xmlMemBlocks() - mem_base);
    #####:20048:	    test_ret++;
    #####:20049:            printf(" %d", n_cur);
    #####:20050:            printf(" %d", n_mem);
    #####:20051:            printf(" %d", n_size);
    #####:20052:            printf(" %d", n_format);
    #####:20053:            printf("\n");
        -:20054:        }
        -:20055:    }
        -:20056:    }
        -:20057:    }
        -:20058:    }
    #####:20059:    function_tests++;
        -:20060:#endif
        -:20061:
    #####:20062:    return(test_ret);
        -:20063:}
        -:20064:
        -:20065:
        -:20066:static int
    #####:20067:test_xmlDocDumpFormatMemoryEnc(void) {
    #####:20068:    int test_ret = 0;
        -:20069:
        -:20070:#if defined(LIBXML_OUTPUT_ENABLED)
        -:20071:    int mem_base;
        -:20072:    xmlDocPtr out_doc; /* Document to generate XML text from */
        -:20073:    int n_out_doc;
        -:20074:    xmlChar ** doc_txt_ptr; /* Memory pointer for allocated XML text */
        -:20075:    int n_doc_txt_ptr;
        -:20076:    int * doc_txt_len; /* Length of the generated XML text */
        -:20077:    int n_doc_txt_len;
        -:20078:    char * txt_encoding; /* Character encoding to use when generating XML text */
        -:20079:    int n_txt_encoding;
        -:20080:    int format; /* should formatting spaces been added */
        -:20081:    int n_format;
        -:20082:
    #####:20083:    for (n_out_doc = 0;n_out_doc < gen_nb_xmlDocPtr;n_out_doc++) {
    #####:20084:    for (n_doc_txt_ptr = 0;n_doc_txt_ptr < gen_nb_xmlChar_ptr_ptr;n_doc_txt_ptr++) {
    #####:20085:    for (n_doc_txt_len = 0;n_doc_txt_len < gen_nb_int_ptr;n_doc_txt_len++) {
    #####:20086:    for (n_txt_encoding = 0;n_txt_encoding < gen_nb_const_char_ptr;n_txt_encoding++) {
    #####:20087:    for (n_format = 0;n_format < gen_nb_int;n_format++) {
    #####:20088:        mem_base = xmlMemBlocks();
    #####:20089:        out_doc = gen_xmlDocPtr(n_out_doc, 0);
    #####:20090:        doc_txt_ptr = gen_xmlChar_ptr_ptr(n_doc_txt_ptr, 1);
    #####:20091:        doc_txt_len = gen_int_ptr(n_doc_txt_len, 2);
    #####:20092:        txt_encoding = gen_const_char_ptr(n_txt_encoding, 3);
    #####:20093:        format = gen_int(n_format, 4);
        -:20094:
    #####:20095:        xmlDocDumpFormatMemoryEnc(out_doc, doc_txt_ptr, doc_txt_len, (const char *)txt_encoding, format);
    #####:20096:        call_tests++;
    #####:20097:        des_xmlDocPtr(n_out_doc, out_doc, 0);
    #####:20098:        des_xmlChar_ptr_ptr(n_doc_txt_ptr, doc_txt_ptr, 1);
    #####:20099:        des_int_ptr(n_doc_txt_len, doc_txt_len, 2);
    #####:20100:        des_const_char_ptr(n_txt_encoding, (const char *)txt_encoding, 3);
    #####:20101:        des_int(n_format, format, 4);
    #####:20102:        xmlResetLastError();
    #####:20103:        if (mem_base != xmlMemBlocks()) {
    #####:20104:            printf("Leak of %d blocks found in xmlDocDumpFormatMemoryEnc",
    #####:20105:	           xmlMemBlocks() - mem_base);
    #####:20106:	    test_ret++;
    #####:20107:            printf(" %d", n_out_doc);
    #####:20108:            printf(" %d", n_doc_txt_ptr);
    #####:20109:            printf(" %d", n_doc_txt_len);
    #####:20110:            printf(" %d", n_txt_encoding);
    #####:20111:            printf(" %d", n_format);
    #####:20112:            printf("\n");
        -:20113:        }
        -:20114:    }
        -:20115:    }
        -:20116:    }
        -:20117:    }
        -:20118:    }
    #####:20119:    function_tests++;
        -:20120:#endif
        -:20121:
    #####:20122:    return(test_ret);
        -:20123:}
        -:20124:
        -:20125:
        -:20126:static int
    #####:20127:test_xmlDocDumpMemory(void) {
    #####:20128:    int test_ret = 0;
        -:20129:
        -:20130:#if defined(LIBXML_OUTPUT_ENABLED)
        -:20131:    int mem_base;
        -:20132:    xmlDocPtr cur; /* the document */
        -:20133:    int n_cur;
        -:20134:    xmlChar ** mem; /* OUT: the memory pointer */
        -:20135:    int n_mem;
        -:20136:    int * size; /* OUT: the memory length */
        -:20137:    int n_size;
        -:20138:
    #####:20139:    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    #####:20140:    for (n_mem = 0;n_mem < gen_nb_xmlChar_ptr_ptr;n_mem++) {
    #####:20141:    for (n_size = 0;n_size < gen_nb_int_ptr;n_size++) {
    #####:20142:        mem_base = xmlMemBlocks();
    #####:20143:        cur = gen_xmlDocPtr(n_cur, 0);
    #####:20144:        mem = gen_xmlChar_ptr_ptr(n_mem, 1);
    #####:20145:        size = gen_int_ptr(n_size, 2);
        -:20146:
    #####:20147:        xmlDocDumpMemory(cur, mem, size);
    #####:20148:        call_tests++;
    #####:20149:        des_xmlDocPtr(n_cur, cur, 0);
    #####:20150:        des_xmlChar_ptr_ptr(n_mem, mem, 1);
    #####:20151:        des_int_ptr(n_size, size, 2);
    #####:20152:        xmlResetLastError();
    #####:20153:        if (mem_base != xmlMemBlocks()) {
    #####:20154:            printf("Leak of %d blocks found in xmlDocDumpMemory",
    #####:20155:	           xmlMemBlocks() - mem_base);
    #####:20156:	    test_ret++;
    #####:20157:            printf(" %d", n_cur);
    #####:20158:            printf(" %d", n_mem);
    #####:20159:            printf(" %d", n_size);
    #####:20160:            printf("\n");
        -:20161:        }
        -:20162:    }
        -:20163:    }
        -:20164:    }
    #####:20165:    function_tests++;
        -:20166:#endif
        -:20167:
    #####:20168:    return(test_ret);
        -:20169:}
        -:20170:
        -:20171:
        -:20172:static int
    #####:20173:test_xmlDocDumpMemoryEnc(void) {
    #####:20174:    int test_ret = 0;
        -:20175:
        -:20176:#if defined(LIBXML_OUTPUT_ENABLED)
        -:20177:    int mem_base;
        -:20178:    xmlDocPtr out_doc; /* Document to generate XML text from */
        -:20179:    int n_out_doc;
        -:20180:    xmlChar ** doc_txt_ptr; /* Memory pointer for allocated XML text */
        -:20181:    int n_doc_txt_ptr;
        -:20182:    int * doc_txt_len; /* Length of the generated XML text */
        -:20183:    int n_doc_txt_len;
        -:20184:    char * txt_encoding; /* Character encoding to use when generating XML text */
        -:20185:    int n_txt_encoding;
        -:20186:
    #####:20187:    for (n_out_doc = 0;n_out_doc < gen_nb_xmlDocPtr;n_out_doc++) {
    #####:20188:    for (n_doc_txt_ptr = 0;n_doc_txt_ptr < gen_nb_xmlChar_ptr_ptr;n_doc_txt_ptr++) {
    #####:20189:    for (n_doc_txt_len = 0;n_doc_txt_len < gen_nb_int_ptr;n_doc_txt_len++) {
    #####:20190:    for (n_txt_encoding = 0;n_txt_encoding < gen_nb_const_char_ptr;n_txt_encoding++) {
    #####:20191:        mem_base = xmlMemBlocks();
    #####:20192:        out_doc = gen_xmlDocPtr(n_out_doc, 0);
    #####:20193:        doc_txt_ptr = gen_xmlChar_ptr_ptr(n_doc_txt_ptr, 1);
    #####:20194:        doc_txt_len = gen_int_ptr(n_doc_txt_len, 2);
    #####:20195:        txt_encoding = gen_const_char_ptr(n_txt_encoding, 3);
        -:20196:
    #####:20197:        xmlDocDumpMemoryEnc(out_doc, doc_txt_ptr, doc_txt_len, (const char *)txt_encoding);
    #####:20198:        call_tests++;
    #####:20199:        des_xmlDocPtr(n_out_doc, out_doc, 0);
    #####:20200:        des_xmlChar_ptr_ptr(n_doc_txt_ptr, doc_txt_ptr, 1);
    #####:20201:        des_int_ptr(n_doc_txt_len, doc_txt_len, 2);
    #####:20202:        des_const_char_ptr(n_txt_encoding, (const char *)txt_encoding, 3);
    #####:20203:        xmlResetLastError();
    #####:20204:        if (mem_base != xmlMemBlocks()) {
    #####:20205:            printf("Leak of %d blocks found in xmlDocDumpMemoryEnc",
    #####:20206:	           xmlMemBlocks() - mem_base);
    #####:20207:	    test_ret++;
    #####:20208:            printf(" %d", n_out_doc);
    #####:20209:            printf(" %d", n_doc_txt_ptr);
    #####:20210:            printf(" %d", n_doc_txt_len);
    #####:20211:            printf(" %d", n_txt_encoding);
    #####:20212:            printf("\n");
        -:20213:        }
        -:20214:    }
        -:20215:    }
        -:20216:    }
        -:20217:    }
    #####:20218:    function_tests++;
        -:20219:#endif
        -:20220:
    #####:20221:    return(test_ret);
        -:20222:}
        -:20223:
        -:20224:
        -:20225:static int
    #####:20226:test_xmlDocFormatDump(void) {
    #####:20227:    int test_ret = 0;
        -:20228:
        -:20229:#if defined(LIBXML_OUTPUT_ENABLED)
        -:20230:    int mem_base;
        -:20231:    int ret_val;
        -:20232:    FILE * f; /* the FILE* */
        -:20233:    int n_f;
        -:20234:    xmlDocPtr cur; /* the document */
        -:20235:    int n_cur;
        -:20236:    int format; /* should formatting spaces been added */
        -:20237:    int n_format;
        -:20238:
    #####:20239:    for (n_f = 0;n_f < gen_nb_FILE_ptr;n_f++) {
    #####:20240:    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    #####:20241:    for (n_format = 0;n_format < gen_nb_int;n_format++) {
    #####:20242:        mem_base = xmlMemBlocks();
    #####:20243:        f = gen_FILE_ptr(n_f, 0);
    #####:20244:        cur = gen_xmlDocPtr(n_cur, 1);
    #####:20245:        format = gen_int(n_format, 2);
        -:20246:
    #####:20247:        ret_val = xmlDocFormatDump(f, cur, format);
    #####:20248:        desret_int(ret_val);
    #####:20249:        call_tests++;
    #####:20250:        des_FILE_ptr(n_f, f, 0);
    #####:20251:        des_xmlDocPtr(n_cur, cur, 1);
    #####:20252:        des_int(n_format, format, 2);
    #####:20253:        xmlResetLastError();
    #####:20254:        if (mem_base != xmlMemBlocks()) {
    #####:20255:            printf("Leak of %d blocks found in xmlDocFormatDump",
    #####:20256:	           xmlMemBlocks() - mem_base);
    #####:20257:	    test_ret++;
    #####:20258:            printf(" %d", n_f);
    #####:20259:            printf(" %d", n_cur);
    #####:20260:            printf(" %d", n_format);
    #####:20261:            printf("\n");
        -:20262:        }
        -:20263:    }
        -:20264:    }
        -:20265:    }
    #####:20266:    function_tests++;
        -:20267:#endif
        -:20268:
    #####:20269:    return(test_ret);
        -:20270:}
        -:20271:
        -:20272:
        -:20273:static int
    #####:20274:test_xmlDocGetRootElement(void) {
    #####:20275:    int test_ret = 0;
        -:20276:
        -:20277:    int mem_base;
        -:20278:    xmlNodePtr ret_val;
        -:20279:    xmlDoc * doc; /* the document */
        -:20280:    int n_doc;
        -:20281:
    #####:20282:    for (n_doc = 0;n_doc < gen_nb_const_xmlDoc_ptr;n_doc++) {
    #####:20283:        mem_base = xmlMemBlocks();
    #####:20284:        doc = gen_const_xmlDoc_ptr(n_doc, 0);
        -:20285:
    #####:20286:        ret_val = xmlDocGetRootElement((const xmlDoc *)doc);
    #####:20287:        desret_xmlNodePtr(ret_val);
    #####:20288:        call_tests++;
    #####:20289:        des_const_xmlDoc_ptr(n_doc, (const xmlDoc *)doc, 0);
    #####:20290:        xmlResetLastError();
    #####:20291:        if (mem_base != xmlMemBlocks()) {
    #####:20292:            printf("Leak of %d blocks found in xmlDocGetRootElement",
    #####:20293:	           xmlMemBlocks() - mem_base);
    #####:20294:	    test_ret++;
    #####:20295:            printf(" %d", n_doc);
    #####:20296:            printf("\n");
        -:20297:        }
        -:20298:    }
    #####:20299:    function_tests++;
        -:20300:
    #####:20301:    return(test_ret);
        -:20302:}
        -:20303:
        -:20304:
        -:20305:static int
    #####:20306:test_xmlDocSetRootElement(void) {
    #####:20307:    int test_ret = 0;
        -:20308:
        -:20309:#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED)
        -:20310:    int mem_base;
        -:20311:    xmlNodePtr ret_val;
        -:20312:    xmlDocPtr doc; /* the document */
        -:20313:    int n_doc;
        -:20314:    xmlNodePtr root; /* the new document root element, if root is NULL no action is taken, to remove a node from a document use xmlUnlinkNode(root) instead. */
        -:20315:    int n_root;
        -:20316:
    #####:20317:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:20318:    for (n_root = 0;n_root < gen_nb_xmlNodePtr_in;n_root++) {
    #####:20319:        mem_base = xmlMemBlocks();
    #####:20320:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:20321:        root = gen_xmlNodePtr_in(n_root, 1);
        -:20322:
    #####:20323:        ret_val = xmlDocSetRootElement(doc, root);
    #####:20324:        if (doc == NULL) { xmlFreeNode(root) ; root = NULL ; }
    #####:20325:        desret_xmlNodePtr(ret_val);
    #####:20326:        call_tests++;
    #####:20327:        des_xmlDocPtr(n_doc, doc, 0);
    #####:20328:        des_xmlNodePtr_in(n_root, root, 1);
    #####:20329:        xmlResetLastError();
    #####:20330:        if (mem_base != xmlMemBlocks()) {
    #####:20331:            printf("Leak of %d blocks found in xmlDocSetRootElement",
    #####:20332:	           xmlMemBlocks() - mem_base);
    #####:20333:	    test_ret++;
    #####:20334:            printf(" %d", n_doc);
    #####:20335:            printf(" %d", n_root);
    #####:20336:            printf("\n");
        -:20337:        }
        -:20338:    }
        -:20339:    }
    #####:20340:    function_tests++;
        -:20341:#endif
        -:20342:
    #####:20343:    return(test_ret);
        -:20344:}
        -:20345:
        -:20346:
        -:20347:static int
    #####:20348:test_xmlElemDump(void) {
    #####:20349:    int test_ret = 0;
        -:20350:
        -:20351:#if defined(LIBXML_OUTPUT_ENABLED)
        -:20352:    int mem_base;
        -:20353:    FILE * f; /* the FILE * for the output */
        -:20354:    int n_f;
        -:20355:    xmlDocPtr doc; /* the document */
        -:20356:    int n_doc;
        -:20357:    xmlNodePtr cur; /* the current node */
        -:20358:    int n_cur;
        -:20359:
    #####:20360:    for (n_f = 0;n_f < gen_nb_FILE_ptr;n_f++) {
    #####:20361:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:20362:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####:20363:        mem_base = xmlMemBlocks();
    #####:20364:        f = gen_FILE_ptr(n_f, 0);
    #####:20365:        doc = gen_xmlDocPtr(n_doc, 1);
    #####:20366:        cur = gen_xmlNodePtr(n_cur, 2);
        -:20367:
    #####:20368:        xmlElemDump(f, doc, cur);
    #####:20369:        call_tests++;
    #####:20370:        des_FILE_ptr(n_f, f, 0);
    #####:20371:        des_xmlDocPtr(n_doc, doc, 1);
    #####:20372:        des_xmlNodePtr(n_cur, cur, 2);
    #####:20373:        xmlResetLastError();
    #####:20374:        if (mem_base != xmlMemBlocks()) {
    #####:20375:            printf("Leak of %d blocks found in xmlElemDump",
    #####:20376:	           xmlMemBlocks() - mem_base);
    #####:20377:	    test_ret++;
    #####:20378:            printf(" %d", n_f);
    #####:20379:            printf(" %d", n_doc);
    #####:20380:            printf(" %d", n_cur);
    #####:20381:            printf("\n");
        -:20382:        }
        -:20383:    }
        -:20384:    }
        -:20385:    }
    #####:20386:    function_tests++;
        -:20387:#endif
        -:20388:
    #####:20389:    return(test_ret);
        -:20390:}
        -:20391:
        -:20392:
        -:20393:static int
    #####:20394:test_xmlFirstElementChild(void) {
    #####:20395:    int test_ret = 0;
        -:20396:
        -:20397:#if defined(LIBXML_TREE_ENABLED)
        -:20398:    int mem_base;
        -:20399:    xmlNodePtr ret_val;
        -:20400:    xmlNodePtr parent; /* the parent node */
        -:20401:    int n_parent;
        -:20402:
    #####:20403:    for (n_parent = 0;n_parent < gen_nb_xmlNodePtr;n_parent++) {
    #####:20404:        mem_base = xmlMemBlocks();
    #####:20405:        parent = gen_xmlNodePtr(n_parent, 0);
        -:20406:
    #####:20407:        ret_val = xmlFirstElementChild(parent);
    #####:20408:        desret_xmlNodePtr(ret_val);
    #####:20409:        call_tests++;
    #####:20410:        des_xmlNodePtr(n_parent, parent, 0);
    #####:20411:        xmlResetLastError();
    #####:20412:        if (mem_base != xmlMemBlocks()) {
    #####:20413:            printf("Leak of %d blocks found in xmlFirstElementChild",
    #####:20414:	           xmlMemBlocks() - mem_base);
    #####:20415:	    test_ret++;
    #####:20416:            printf(" %d", n_parent);
    #####:20417:            printf("\n");
        -:20418:        }
        -:20419:    }
    #####:20420:    function_tests++;
        -:20421:#endif
        -:20422:
    #####:20423:    return(test_ret);
        -:20424:}
        -:20425:
        -:20426:
        -:20427:static int
    #####:20428:test_xmlGetBufferAllocationScheme(void) {
    #####:20429:    int test_ret = 0;
        -:20430:
        -:20431:    int mem_base;
        -:20432:    xmlBufferAllocationScheme ret_val;
        -:20433:
    #####:20434:        mem_base = xmlMemBlocks();
        -:20435:
    #####:20436:        ret_val = xmlGetBufferAllocationScheme();
    #####:20437:        desret_xmlBufferAllocationScheme(ret_val);
    #####:20438:        call_tests++;
    #####:20439:        xmlResetLastError();
    #####:20440:        if (mem_base != xmlMemBlocks()) {
    #####:20441:            printf("Leak of %d blocks found in xmlGetBufferAllocationScheme",
    #####:20442:	           xmlMemBlocks() - mem_base);
    #####:20443:	    test_ret++;
    #####:20444:            printf("\n");
        -:20445:        }
    #####:20446:    function_tests++;
        -:20447:
    #####:20448:    return(test_ret);
        -:20449:}
        -:20450:
        -:20451:
        -:20452:static int
    #####:20453:test_xmlGetCompressMode(void) {
    #####:20454:    int test_ret = 0;
        -:20455:
        -:20456:    int mem_base;
        -:20457:    int ret_val;
        -:20458:
    #####:20459:        mem_base = xmlMemBlocks();
        -:20460:
    #####:20461:        ret_val = xmlGetCompressMode();
    #####:20462:        desret_int(ret_val);
    #####:20463:        call_tests++;
    #####:20464:        xmlResetLastError();
    #####:20465:        if (mem_base != xmlMemBlocks()) {
    #####:20466:            printf("Leak of %d blocks found in xmlGetCompressMode",
    #####:20467:	           xmlMemBlocks() - mem_base);
    #####:20468:	    test_ret++;
    #####:20469:            printf("\n");
        -:20470:        }
    #####:20471:    function_tests++;
        -:20472:
    #####:20473:    return(test_ret);
        -:20474:}
        -:20475:
        -:20476:
        -:20477:static int
    #####:20478:test_xmlGetDocCompressMode(void) {
    #####:20479:    int test_ret = 0;
        -:20480:
        -:20481:    int mem_base;
        -:20482:    int ret_val;
        -:20483:    xmlDoc * doc; /* the document */
        -:20484:    int n_doc;
        -:20485:
    #####:20486:    for (n_doc = 0;n_doc < gen_nb_const_xmlDoc_ptr;n_doc++) {
    #####:20487:        mem_base = xmlMemBlocks();
    #####:20488:        doc = gen_const_xmlDoc_ptr(n_doc, 0);
        -:20489:
    #####:20490:        ret_val = xmlGetDocCompressMode((const xmlDoc *)doc);
    #####:20491:        desret_int(ret_val);
    #####:20492:        call_tests++;
    #####:20493:        des_const_xmlDoc_ptr(n_doc, (const xmlDoc *)doc, 0);
    #####:20494:        xmlResetLastError();
    #####:20495:        if (mem_base != xmlMemBlocks()) {
    #####:20496:            printf("Leak of %d blocks found in xmlGetDocCompressMode",
    #####:20497:	           xmlMemBlocks() - mem_base);
    #####:20498:	    test_ret++;
    #####:20499:            printf(" %d", n_doc);
    #####:20500:            printf("\n");
        -:20501:        }
        -:20502:    }
    #####:20503:    function_tests++;
        -:20504:
    #####:20505:    return(test_ret);
        -:20506:}
        -:20507:
        -:20508:
        -:20509:static int
    #####:20510:test_xmlGetIntSubset(void) {
    #####:20511:    int test_ret = 0;
        -:20512:
        -:20513:    int mem_base;
        -:20514:    xmlDtdPtr ret_val;
        -:20515:    xmlDoc * doc; /* the document pointer */
        -:20516:    int n_doc;
        -:20517:
    #####:20518:    for (n_doc = 0;n_doc < gen_nb_const_xmlDoc_ptr;n_doc++) {
    #####:20519:        mem_base = xmlMemBlocks();
    #####:20520:        doc = gen_const_xmlDoc_ptr(n_doc, 0);
        -:20521:
    #####:20522:        ret_val = xmlGetIntSubset((const xmlDoc *)doc);
    #####:20523:        desret_xmlDtdPtr(ret_val);
    #####:20524:        call_tests++;
    #####:20525:        des_const_xmlDoc_ptr(n_doc, (const xmlDoc *)doc, 0);
    #####:20526:        xmlResetLastError();
    #####:20527:        if (mem_base != xmlMemBlocks()) {
    #####:20528:            printf("Leak of %d blocks found in xmlGetIntSubset",
    #####:20529:	           xmlMemBlocks() - mem_base);
    #####:20530:	    test_ret++;
    #####:20531:            printf(" %d", n_doc);
    #####:20532:            printf("\n");
        -:20533:        }
        -:20534:    }
    #####:20535:    function_tests++;
        -:20536:
    #####:20537:    return(test_ret);
        -:20538:}
        -:20539:
        -:20540:
        -:20541:static int
    #####:20542:test_xmlGetLastChild(void) {
    #####:20543:    int test_ret = 0;
        -:20544:
        -:20545:    int mem_base;
        -:20546:    xmlNodePtr ret_val;
        -:20547:    xmlNode * parent; /* the parent node */
        -:20548:    int n_parent;
        -:20549:
    #####:20550:    for (n_parent = 0;n_parent < gen_nb_const_xmlNode_ptr;n_parent++) {
    #####:20551:        mem_base = xmlMemBlocks();
    #####:20552:        parent = gen_const_xmlNode_ptr(n_parent, 0);
        -:20553:
    #####:20554:        ret_val = xmlGetLastChild((const xmlNode *)parent);
    #####:20555:        desret_xmlNodePtr(ret_val);
    #####:20556:        call_tests++;
    #####:20557:        des_const_xmlNode_ptr(n_parent, (const xmlNode *)parent, 0);
    #####:20558:        xmlResetLastError();
    #####:20559:        if (mem_base != xmlMemBlocks()) {
    #####:20560:            printf("Leak of %d blocks found in xmlGetLastChild",
    #####:20561:	           xmlMemBlocks() - mem_base);
    #####:20562:	    test_ret++;
    #####:20563:            printf(" %d", n_parent);
    #####:20564:            printf("\n");
        -:20565:        }
        -:20566:    }
    #####:20567:    function_tests++;
        -:20568:
    #####:20569:    return(test_ret);
        -:20570:}
        -:20571:
        -:20572:
        -:20573:static int
    #####:20574:test_xmlGetLineNo(void) {
    #####:20575:    int test_ret = 0;
        -:20576:
        -:20577:    int mem_base;
        -:20578:    long ret_val;
        -:20579:    xmlNode * node; /* valid node */
        -:20580:    int n_node;
        -:20581:
    #####:20582:    for (n_node = 0;n_node < gen_nb_const_xmlNode_ptr;n_node++) {
    #####:20583:        mem_base = xmlMemBlocks();
    #####:20584:        node = gen_const_xmlNode_ptr(n_node, 0);
        -:20585:
    #####:20586:        ret_val = xmlGetLineNo((const xmlNode *)node);
    #####:20587:        desret_long(ret_val);
    #####:20588:        call_tests++;
    #####:20589:        des_const_xmlNode_ptr(n_node, (const xmlNode *)node, 0);
    #####:20590:        xmlResetLastError();
    #####:20591:        if (mem_base != xmlMemBlocks()) {
    #####:20592:            printf("Leak of %d blocks found in xmlGetLineNo",
    #####:20593:	           xmlMemBlocks() - mem_base);
    #####:20594:	    test_ret++;
    #####:20595:            printf(" %d", n_node);
    #####:20596:            printf("\n");
        -:20597:        }
        -:20598:    }
    #####:20599:    function_tests++;
        -:20600:
    #####:20601:    return(test_ret);
        -:20602:}
        -:20603:
        -:20604:
        -:20605:static int
    #####:20606:test_xmlGetNoNsProp(void) {
    #####:20607:    int test_ret = 0;
        -:20608:
        -:20609:    int mem_base;
        -:20610:    xmlChar * ret_val;
        -:20611:    xmlNode * node; /* the node */
        -:20612:    int n_node;
        -:20613:    xmlChar * name; /* the attribute name */
        -:20614:    int n_name;
        -:20615:
    #####:20616:    for (n_node = 0;n_node < gen_nb_const_xmlNode_ptr;n_node++) {
    #####:20617:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:20618:        mem_base = xmlMemBlocks();
    #####:20619:        node = gen_const_xmlNode_ptr(n_node, 0);
    #####:20620:        name = gen_const_xmlChar_ptr(n_name, 1);
        -:20621:
    #####:20622:        ret_val = xmlGetNoNsProp((const xmlNode *)node, (const xmlChar *)name);
    #####:20623:        desret_xmlChar_ptr(ret_val);
    #####:20624:        call_tests++;
    #####:20625:        des_const_xmlNode_ptr(n_node, (const xmlNode *)node, 0);
    #####:20626:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:20627:        xmlResetLastError();
    #####:20628:        if (mem_base != xmlMemBlocks()) {
    #####:20629:            printf("Leak of %d blocks found in xmlGetNoNsProp",
    #####:20630:	           xmlMemBlocks() - mem_base);
    #####:20631:	    test_ret++;
    #####:20632:            printf(" %d", n_node);
    #####:20633:            printf(" %d", n_name);
    #####:20634:            printf("\n");
        -:20635:        }
        -:20636:    }
        -:20637:    }
    #####:20638:    function_tests++;
        -:20639:
    #####:20640:    return(test_ret);
        -:20641:}
        -:20642:
        -:20643:
        -:20644:static int
    #####:20645:test_xmlGetNodePath(void) {
    #####:20646:    int test_ret = 0;
        -:20647:
        -:20648:#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_DEBUG_ENABLED)
        -:20649:    int mem_base;
        -:20650:    xmlChar * ret_val;
        -:20651:    xmlNode * node; /* a node */
        -:20652:    int n_node;
        -:20653:
    #####:20654:    for (n_node = 0;n_node < gen_nb_const_xmlNode_ptr;n_node++) {
    #####:20655:        mem_base = xmlMemBlocks();
    #####:20656:        node = gen_const_xmlNode_ptr(n_node, 0);
        -:20657:
    #####:20658:        ret_val = xmlGetNodePath((const xmlNode *)node);
    #####:20659:        desret_xmlChar_ptr(ret_val);
    #####:20660:        call_tests++;
    #####:20661:        des_const_xmlNode_ptr(n_node, (const xmlNode *)node, 0);
    #####:20662:        xmlResetLastError();
    #####:20663:        if (mem_base != xmlMemBlocks()) {
    #####:20664:            printf("Leak of %d blocks found in xmlGetNodePath",
    #####:20665:	           xmlMemBlocks() - mem_base);
    #####:20666:	    test_ret++;
    #####:20667:            printf(" %d", n_node);
    #####:20668:            printf("\n");
        -:20669:        }
        -:20670:    }
    #####:20671:    function_tests++;
        -:20672:#endif
        -:20673:
    #####:20674:    return(test_ret);
        -:20675:}
        -:20676:
        -:20677:
        -:20678:static int
    #####:20679:test_xmlGetNsList(void) {
    #####:20680:    int test_ret = 0;
        -:20681:
        -:20682:
        -:20683:    /* missing type support */
    #####:20684:    return(test_ret);
        -:20685:}
        -:20686:
        -:20687:
        -:20688:static int
    #####:20689:test_xmlGetNsProp(void) {
    #####:20690:    int test_ret = 0;
        -:20691:
        -:20692:    int mem_base;
        -:20693:    xmlChar * ret_val;
        -:20694:    xmlNode * node; /* the node */
        -:20695:    int n_node;
        -:20696:    xmlChar * name; /* the attribute name */
        -:20697:    int n_name;
        -:20698:    xmlChar * nameSpace; /* the URI of the namespace */
        -:20699:    int n_nameSpace;
        -:20700:
    #####:20701:    for (n_node = 0;n_node < gen_nb_const_xmlNode_ptr;n_node++) {
    #####:20702:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:20703:    for (n_nameSpace = 0;n_nameSpace < gen_nb_const_xmlChar_ptr;n_nameSpace++) {
    #####:20704:        mem_base = xmlMemBlocks();
    #####:20705:        node = gen_const_xmlNode_ptr(n_node, 0);
    #####:20706:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:20707:        nameSpace = gen_const_xmlChar_ptr(n_nameSpace, 2);
        -:20708:
    #####:20709:        ret_val = xmlGetNsProp((const xmlNode *)node, (const xmlChar *)name, (const xmlChar *)nameSpace);
    #####:20710:        desret_xmlChar_ptr(ret_val);
    #####:20711:        call_tests++;
    #####:20712:        des_const_xmlNode_ptr(n_node, (const xmlNode *)node, 0);
    #####:20713:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:20714:        des_const_xmlChar_ptr(n_nameSpace, (const xmlChar *)nameSpace, 2);
    #####:20715:        xmlResetLastError();
    #####:20716:        if (mem_base != xmlMemBlocks()) {
    #####:20717:            printf("Leak of %d blocks found in xmlGetNsProp",
    #####:20718:	           xmlMemBlocks() - mem_base);
    #####:20719:	    test_ret++;
    #####:20720:            printf(" %d", n_node);
    #####:20721:            printf(" %d", n_name);
    #####:20722:            printf(" %d", n_nameSpace);
    #####:20723:            printf("\n");
        -:20724:        }
        -:20725:    }
        -:20726:    }
        -:20727:    }
    #####:20728:    function_tests++;
        -:20729:
    #####:20730:    return(test_ret);
        -:20731:}
        -:20732:
        -:20733:
        -:20734:static int
    #####:20735:test_xmlGetProp(void) {
    #####:20736:    int test_ret = 0;
        -:20737:
        -:20738:    int mem_base;
        -:20739:    xmlChar * ret_val;
        -:20740:    xmlNode * node; /* the node */
        -:20741:    int n_node;
        -:20742:    xmlChar * name; /* the attribute name */
        -:20743:    int n_name;
        -:20744:
    #####:20745:    for (n_node = 0;n_node < gen_nb_const_xmlNode_ptr;n_node++) {
    #####:20746:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:20747:        mem_base = xmlMemBlocks();
    #####:20748:        node = gen_const_xmlNode_ptr(n_node, 0);
    #####:20749:        name = gen_const_xmlChar_ptr(n_name, 1);
        -:20750:
    #####:20751:        ret_val = xmlGetProp((const xmlNode *)node, (const xmlChar *)name);
    #####:20752:        desret_xmlChar_ptr(ret_val);
    #####:20753:        call_tests++;
    #####:20754:        des_const_xmlNode_ptr(n_node, (const xmlNode *)node, 0);
    #####:20755:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:20756:        xmlResetLastError();
    #####:20757:        if (mem_base != xmlMemBlocks()) {
    #####:20758:            printf("Leak of %d blocks found in xmlGetProp",
    #####:20759:	           xmlMemBlocks() - mem_base);
    #####:20760:	    test_ret++;
    #####:20761:            printf(" %d", n_node);
    #####:20762:            printf(" %d", n_name);
    #####:20763:            printf("\n");
        -:20764:        }
        -:20765:    }
        -:20766:    }
    #####:20767:    function_tests++;
        -:20768:
    #####:20769:    return(test_ret);
        -:20770:}
        -:20771:
        -:20772:
        -:20773:static int
    #####:20774:test_xmlHasNsProp(void) {
    #####:20775:    int test_ret = 0;
        -:20776:
        -:20777:    int mem_base;
        -:20778:    xmlAttrPtr ret_val;
        -:20779:    xmlNode * node; /* the node */
        -:20780:    int n_node;
        -:20781:    xmlChar * name; /* the attribute name */
        -:20782:    int n_name;
        -:20783:    xmlChar * nameSpace; /* the URI of the namespace */
        -:20784:    int n_nameSpace;
        -:20785:
    #####:20786:    for (n_node = 0;n_node < gen_nb_const_xmlNode_ptr;n_node++) {
    #####:20787:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:20788:    for (n_nameSpace = 0;n_nameSpace < gen_nb_const_xmlChar_ptr;n_nameSpace++) {
    #####:20789:        mem_base = xmlMemBlocks();
    #####:20790:        node = gen_const_xmlNode_ptr(n_node, 0);
    #####:20791:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:20792:        nameSpace = gen_const_xmlChar_ptr(n_nameSpace, 2);
        -:20793:
    #####:20794:        ret_val = xmlHasNsProp((const xmlNode *)node, (const xmlChar *)name, (const xmlChar *)nameSpace);
    #####:20795:        desret_xmlAttrPtr(ret_val);
    #####:20796:        call_tests++;
    #####:20797:        des_const_xmlNode_ptr(n_node, (const xmlNode *)node, 0);
    #####:20798:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:20799:        des_const_xmlChar_ptr(n_nameSpace, (const xmlChar *)nameSpace, 2);
    #####:20800:        xmlResetLastError();
    #####:20801:        if (mem_base != xmlMemBlocks()) {
    #####:20802:            printf("Leak of %d blocks found in xmlHasNsProp",
    #####:20803:	           xmlMemBlocks() - mem_base);
    #####:20804:	    test_ret++;
    #####:20805:            printf(" %d", n_node);
    #####:20806:            printf(" %d", n_name);
    #####:20807:            printf(" %d", n_nameSpace);
    #####:20808:            printf("\n");
        -:20809:        }
        -:20810:    }
        -:20811:    }
        -:20812:    }
    #####:20813:    function_tests++;
        -:20814:
    #####:20815:    return(test_ret);
        -:20816:}
        -:20817:
        -:20818:
        -:20819:static int
    #####:20820:test_xmlHasProp(void) {
    #####:20821:    int test_ret = 0;
        -:20822:
        -:20823:    int mem_base;
        -:20824:    xmlAttrPtr ret_val;
        -:20825:    xmlNode * node; /* the node */
        -:20826:    int n_node;
        -:20827:    xmlChar * name; /* the attribute name */
        -:20828:    int n_name;
        -:20829:
    #####:20830:    for (n_node = 0;n_node < gen_nb_const_xmlNode_ptr;n_node++) {
    #####:20831:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:20832:        mem_base = xmlMemBlocks();
    #####:20833:        node = gen_const_xmlNode_ptr(n_node, 0);
    #####:20834:        name = gen_const_xmlChar_ptr(n_name, 1);
        -:20835:
    #####:20836:        ret_val = xmlHasProp((const xmlNode *)node, (const xmlChar *)name);
    #####:20837:        desret_xmlAttrPtr(ret_val);
    #####:20838:        call_tests++;
    #####:20839:        des_const_xmlNode_ptr(n_node, (const xmlNode *)node, 0);
    #####:20840:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:20841:        xmlResetLastError();
    #####:20842:        if (mem_base != xmlMemBlocks()) {
    #####:20843:            printf("Leak of %d blocks found in xmlHasProp",
    #####:20844:	           xmlMemBlocks() - mem_base);
    #####:20845:	    test_ret++;
    #####:20846:            printf(" %d", n_node);
    #####:20847:            printf(" %d", n_name);
    #####:20848:            printf("\n");
        -:20849:        }
        -:20850:    }
        -:20851:    }
    #####:20852:    function_tests++;
        -:20853:
    #####:20854:    return(test_ret);
        -:20855:}
        -:20856:
        -:20857:
        -:20858:static int
    #####:20859:test_xmlIsBlankNode(void) {
    #####:20860:    int test_ret = 0;
        -:20861:
        -:20862:    int mem_base;
        -:20863:    int ret_val;
        -:20864:    xmlNode * node; /* the node */
        -:20865:    int n_node;
        -:20866:
    #####:20867:    for (n_node = 0;n_node < gen_nb_const_xmlNode_ptr;n_node++) {
    #####:20868:        mem_base = xmlMemBlocks();
    #####:20869:        node = gen_const_xmlNode_ptr(n_node, 0);
        -:20870:
    #####:20871:        ret_val = xmlIsBlankNode((const xmlNode *)node);
    #####:20872:        desret_int(ret_val);
    #####:20873:        call_tests++;
    #####:20874:        des_const_xmlNode_ptr(n_node, (const xmlNode *)node, 0);
    #####:20875:        xmlResetLastError();
    #####:20876:        if (mem_base != xmlMemBlocks()) {
    #####:20877:            printf("Leak of %d blocks found in xmlIsBlankNode",
    #####:20878:	           xmlMemBlocks() - mem_base);
    #####:20879:	    test_ret++;
    #####:20880:            printf(" %d", n_node);
    #####:20881:            printf("\n");
        -:20882:        }
        -:20883:    }
    #####:20884:    function_tests++;
        -:20885:
    #####:20886:    return(test_ret);
        -:20887:}
        -:20888:
        -:20889:
        -:20890:static int
    #####:20891:test_xmlIsXHTML(void) {
    #####:20892:    int test_ret = 0;
        -:20893:
        -:20894:    int mem_base;
        -:20895:    int ret_val;
        -:20896:    xmlChar * systemID; /* the system identifier */
        -:20897:    int n_systemID;
        -:20898:    xmlChar * publicID; /* the public identifier */
        -:20899:    int n_publicID;
        -:20900:
    #####:20901:    for (n_systemID = 0;n_systemID < gen_nb_const_xmlChar_ptr;n_systemID++) {
    #####:20902:    for (n_publicID = 0;n_publicID < gen_nb_const_xmlChar_ptr;n_publicID++) {
    #####:20903:        mem_base = xmlMemBlocks();
    #####:20904:        systemID = gen_const_xmlChar_ptr(n_systemID, 0);
    #####:20905:        publicID = gen_const_xmlChar_ptr(n_publicID, 1);
        -:20906:
    #####:20907:        ret_val = xmlIsXHTML((const xmlChar *)systemID, (const xmlChar *)publicID);
    #####:20908:        desret_int(ret_val);
    #####:20909:        call_tests++;
    #####:20910:        des_const_xmlChar_ptr(n_systemID, (const xmlChar *)systemID, 0);
    #####:20911:        des_const_xmlChar_ptr(n_publicID, (const xmlChar *)publicID, 1);
    #####:20912:        xmlResetLastError();
    #####:20913:        if (mem_base != xmlMemBlocks()) {
    #####:20914:            printf("Leak of %d blocks found in xmlIsXHTML",
    #####:20915:	           xmlMemBlocks() - mem_base);
    #####:20916:	    test_ret++;
    #####:20917:            printf(" %d", n_systemID);
    #####:20918:            printf(" %d", n_publicID);
    #####:20919:            printf("\n");
        -:20920:        }
        -:20921:    }
        -:20922:    }
    #####:20923:    function_tests++;
        -:20924:
    #####:20925:    return(test_ret);
        -:20926:}
        -:20927:
        -:20928:
        -:20929:static int
    #####:20930:test_xmlLastElementChild(void) {
    #####:20931:    int test_ret = 0;
        -:20932:
        -:20933:#if defined(LIBXML_TREE_ENABLED)
        -:20934:    int mem_base;
        -:20935:    xmlNodePtr ret_val;
        -:20936:    xmlNodePtr parent; /* the parent node */
        -:20937:    int n_parent;
        -:20938:
    #####:20939:    for (n_parent = 0;n_parent < gen_nb_xmlNodePtr;n_parent++) {
    #####:20940:        mem_base = xmlMemBlocks();
    #####:20941:        parent = gen_xmlNodePtr(n_parent, 0);
        -:20942:
    #####:20943:        ret_val = xmlLastElementChild(parent);
    #####:20944:        desret_xmlNodePtr(ret_val);
    #####:20945:        call_tests++;
    #####:20946:        des_xmlNodePtr(n_parent, parent, 0);
    #####:20947:        xmlResetLastError();
    #####:20948:        if (mem_base != xmlMemBlocks()) {
    #####:20949:            printf("Leak of %d blocks found in xmlLastElementChild",
    #####:20950:	           xmlMemBlocks() - mem_base);
    #####:20951:	    test_ret++;
    #####:20952:            printf(" %d", n_parent);
    #####:20953:            printf("\n");
        -:20954:        }
        -:20955:    }
    #####:20956:    function_tests++;
        -:20957:#endif
        -:20958:
    #####:20959:    return(test_ret);
        -:20960:}
        -:20961:
        -:20962:
        -:20963:static int
    #####:20964:test_xmlNewCDataBlock(void) {
    #####:20965:    int test_ret = 0;
        -:20966:
        -:20967:    int mem_base;
        -:20968:    xmlNodePtr ret_val;
        -:20969:    xmlDocPtr doc; /* the document */
        -:20970:    int n_doc;
        -:20971:    xmlChar * content; /* the CDATA block content content */
        -:20972:    int n_content;
        -:20973:    int len; /* the length of the block */
        -:20974:    int n_len;
        -:20975:
    #####:20976:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:20977:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:20978:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:20979:        mem_base = xmlMemBlocks();
    #####:20980:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:20981:        content = gen_const_xmlChar_ptr(n_content, 1);
    #####:20982:        len = gen_int(n_len, 2);
        -:20983:
    #####:20984:        ret_val = xmlNewCDataBlock(doc, (const xmlChar *)content, len);
    #####:20985:        desret_xmlNodePtr(ret_val);
    #####:20986:        call_tests++;
    #####:20987:        des_xmlDocPtr(n_doc, doc, 0);
    #####:20988:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
    #####:20989:        des_int(n_len, len, 2);
    #####:20990:        xmlResetLastError();
    #####:20991:        if (mem_base != xmlMemBlocks()) {
    #####:20992:            printf("Leak of %d blocks found in xmlNewCDataBlock",
    #####:20993:	           xmlMemBlocks() - mem_base);
    #####:20994:	    test_ret++;
    #####:20995:            printf(" %d", n_doc);
    #####:20996:            printf(" %d", n_content);
    #####:20997:            printf(" %d", n_len);
    #####:20998:            printf("\n");
        -:20999:        }
        -:21000:    }
        -:21001:    }
        -:21002:    }
    #####:21003:    function_tests++;
        -:21004:
    #####:21005:    return(test_ret);
        -:21006:}
        -:21007:
        -:21008:
        -:21009:static int
    #####:21010:test_xmlNewCharRef(void) {
    #####:21011:    int test_ret = 0;
        -:21012:
        -:21013:    int mem_base;
        -:21014:    xmlNodePtr ret_val;
        -:21015:    xmlDocPtr doc; /* the document */
        -:21016:    int n_doc;
        -:21017:    xmlChar * name; /* the char ref string, starting with # or "&# ... ;" */
        -:21018:    int n_name;
        -:21019:
    #####:21020:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:21021:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:21022:        mem_base = xmlMemBlocks();
    #####:21023:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:21024:        name = gen_const_xmlChar_ptr(n_name, 1);
        -:21025:
    #####:21026:        ret_val = xmlNewCharRef(doc, (const xmlChar *)name);
    #####:21027:        desret_xmlNodePtr(ret_val);
    #####:21028:        call_tests++;
    #####:21029:        des_xmlDocPtr(n_doc, doc, 0);
    #####:21030:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:21031:        xmlResetLastError();
    #####:21032:        if (mem_base != xmlMemBlocks()) {
    #####:21033:            printf("Leak of %d blocks found in xmlNewCharRef",
    #####:21034:	           xmlMemBlocks() - mem_base);
    #####:21035:	    test_ret++;
    #####:21036:            printf(" %d", n_doc);
    #####:21037:            printf(" %d", n_name);
    #####:21038:            printf("\n");
        -:21039:        }
        -:21040:    }
        -:21041:    }
    #####:21042:    function_tests++;
        -:21043:
    #####:21044:    return(test_ret);
        -:21045:}
        -:21046:
        -:21047:
        -:21048:static int
    #####:21049:test_xmlNewChild(void) {
    #####:21050:    int test_ret = 0;
        -:21051:
        -:21052:#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
        -:21053:#ifdef LIBXML_TREE_ENABLED
        -:21054:    int mem_base;
        -:21055:    xmlNodePtr ret_val;
        -:21056:    xmlNodePtr parent; /* the parent node */
        -:21057:    int n_parent;
        -:21058:    xmlNsPtr ns; /* a namespace if any */
        -:21059:    int n_ns;
        -:21060:    xmlChar * name; /* the name of the child */
        -:21061:    int n_name;
        -:21062:    xmlChar * content; /* the XML content of the child if any. */
        -:21063:    int n_content;
        -:21064:
    #####:21065:    for (n_parent = 0;n_parent < gen_nb_xmlNodePtr;n_parent++) {
    #####:21066:    for (n_ns = 0;n_ns < gen_nb_xmlNsPtr;n_ns++) {
    #####:21067:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:21068:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:21069:        mem_base = xmlMemBlocks();
    #####:21070:        parent = gen_xmlNodePtr(n_parent, 0);
    #####:21071:        ns = gen_xmlNsPtr(n_ns, 1);
    #####:21072:        name = gen_const_xmlChar_ptr(n_name, 2);
    #####:21073:        content = gen_const_xmlChar_ptr(n_content, 3);
        -:21074:
    #####:21075:        ret_val = xmlNewChild(parent, ns, (const xmlChar *)name, (const xmlChar *)content);
    #####:21076:        desret_xmlNodePtr(ret_val);
    #####:21077:        call_tests++;
    #####:21078:        des_xmlNodePtr(n_parent, parent, 0);
    #####:21079:        des_xmlNsPtr(n_ns, ns, 1);
    #####:21080:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
    #####:21081:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 3);
    #####:21082:        xmlResetLastError();
    #####:21083:        if (mem_base != xmlMemBlocks()) {
    #####:21084:            printf("Leak of %d blocks found in xmlNewChild",
    #####:21085:	           xmlMemBlocks() - mem_base);
    #####:21086:	    test_ret++;
    #####:21087:            printf(" %d", n_parent);
    #####:21088:            printf(" %d", n_ns);
    #####:21089:            printf(" %d", n_name);
    #####:21090:            printf(" %d", n_content);
    #####:21091:            printf("\n");
        -:21092:        }
        -:21093:    }
        -:21094:    }
        -:21095:    }
        -:21096:    }
    #####:21097:    function_tests++;
        -:21098:#endif
        -:21099:#endif
        -:21100:
    #####:21101:    return(test_ret);
        -:21102:}
        -:21103:
        -:21104:
        -:21105:static int
    #####:21106:test_xmlNewComment(void) {
    #####:21107:    int test_ret = 0;
        -:21108:
        -:21109:    int mem_base;
        -:21110:    xmlNodePtr ret_val;
        -:21111:    xmlChar * content; /* the comment content */
        -:21112:    int n_content;
        -:21113:
    #####:21114:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:21115:        mem_base = xmlMemBlocks();
    #####:21116:        content = gen_const_xmlChar_ptr(n_content, 0);
        -:21117:
    #####:21118:        ret_val = xmlNewComment((const xmlChar *)content);
    #####:21119:        desret_xmlNodePtr(ret_val);
    #####:21120:        call_tests++;
    #####:21121:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 0);
    #####:21122:        xmlResetLastError();
    #####:21123:        if (mem_base != xmlMemBlocks()) {
    #####:21124:            printf("Leak of %d blocks found in xmlNewComment",
    #####:21125:	           xmlMemBlocks() - mem_base);
    #####:21126:	    test_ret++;
    #####:21127:            printf(" %d", n_content);
    #####:21128:            printf("\n");
        -:21129:        }
        -:21130:    }
    #####:21131:    function_tests++;
        -:21132:
    #####:21133:    return(test_ret);
        -:21134:}
        -:21135:
        -:21136:
        -:21137:static int
    #####:21138:test_xmlNewDoc(void) {
    #####:21139:    int test_ret = 0;
        -:21140:
        -:21141:    int mem_base;
        -:21142:    xmlDocPtr ret_val;
        -:21143:    xmlChar * version; /* xmlChar string giving the version of XML "1.0" */
        -:21144:    int n_version;
        -:21145:
    #####:21146:    for (n_version = 0;n_version < gen_nb_const_xmlChar_ptr;n_version++) {
    #####:21147:        mem_base = xmlMemBlocks();
    #####:21148:        version = gen_const_xmlChar_ptr(n_version, 0);
        -:21149:
    #####:21150:        ret_val = xmlNewDoc((const xmlChar *)version);
    #####:21151:        desret_xmlDocPtr(ret_val);
    #####:21152:        call_tests++;
    #####:21153:        des_const_xmlChar_ptr(n_version, (const xmlChar *)version, 0);
    #####:21154:        xmlResetLastError();
    #####:21155:        if (mem_base != xmlMemBlocks()) {
    #####:21156:            printf("Leak of %d blocks found in xmlNewDoc",
    #####:21157:	           xmlMemBlocks() - mem_base);
    #####:21158:	    test_ret++;
    #####:21159:            printf(" %d", n_version);
    #####:21160:            printf("\n");
        -:21161:        }
        -:21162:    }
    #####:21163:    function_tests++;
        -:21164:
    #####:21165:    return(test_ret);
        -:21166:}
        -:21167:
        -:21168:
        -:21169:static int
    #####:21170:test_xmlNewDocComment(void) {
    #####:21171:    int test_ret = 0;
        -:21172:
        -:21173:    int mem_base;
        -:21174:    xmlNodePtr ret_val;
        -:21175:    xmlDocPtr doc; /* the document */
        -:21176:    int n_doc;
        -:21177:    xmlChar * content; /* the comment content */
        -:21178:    int n_content;
        -:21179:
    #####:21180:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:21181:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:21182:        mem_base = xmlMemBlocks();
    #####:21183:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:21184:        content = gen_const_xmlChar_ptr(n_content, 1);
        -:21185:
    #####:21186:        ret_val = xmlNewDocComment(doc, (const xmlChar *)content);
    #####:21187:        desret_xmlNodePtr(ret_val);
    #####:21188:        call_tests++;
    #####:21189:        des_xmlDocPtr(n_doc, doc, 0);
    #####:21190:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
    #####:21191:        xmlResetLastError();
    #####:21192:        if (mem_base != xmlMemBlocks()) {
    #####:21193:            printf("Leak of %d blocks found in xmlNewDocComment",
    #####:21194:	           xmlMemBlocks() - mem_base);
    #####:21195:	    test_ret++;
    #####:21196:            printf(" %d", n_doc);
    #####:21197:            printf(" %d", n_content);
    #####:21198:            printf("\n");
        -:21199:        }
        -:21200:    }
        -:21201:    }
    #####:21202:    function_tests++;
        -:21203:
    #####:21204:    return(test_ret);
        -:21205:}
        -:21206:
        -:21207:
        -:21208:static int
    #####:21209:test_xmlNewDocFragment(void) {
    #####:21210:    int test_ret = 0;
        -:21211:
        -:21212:#if defined(LIBXML_TREE_ENABLED)
        -:21213:    int mem_base;
        -:21214:    xmlNodePtr ret_val;
        -:21215:    xmlDocPtr doc; /* the document owning the fragment */
        -:21216:    int n_doc;
        -:21217:
    #####:21218:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:21219:        mem_base = xmlMemBlocks();
    #####:21220:        doc = gen_xmlDocPtr(n_doc, 0);
        -:21221:
    #####:21222:        ret_val = xmlNewDocFragment(doc);
    #####:21223:        desret_xmlNodePtr(ret_val);
    #####:21224:        call_tests++;
    #####:21225:        des_xmlDocPtr(n_doc, doc, 0);
    #####:21226:        xmlResetLastError();
    #####:21227:        if (mem_base != xmlMemBlocks()) {
    #####:21228:            printf("Leak of %d blocks found in xmlNewDocFragment",
    #####:21229:	           xmlMemBlocks() - mem_base);
    #####:21230:	    test_ret++;
    #####:21231:            printf(" %d", n_doc);
    #####:21232:            printf("\n");
        -:21233:        }
        -:21234:    }
    #####:21235:    function_tests++;
        -:21236:#endif
        -:21237:
    #####:21238:    return(test_ret);
        -:21239:}
        -:21240:
        -:21241:
        -:21242:static int
    #####:21243:test_xmlNewDocNode(void) {
    #####:21244:    int test_ret = 0;
        -:21245:
        -:21246:    int mem_base;
        -:21247:    xmlNodePtr ret_val;
        -:21248:    xmlDocPtr doc; /* the document */
        -:21249:    int n_doc;
        -:21250:    xmlNsPtr ns; /* namespace if any */
        -:21251:    int n_ns;
        -:21252:    xmlChar * name; /* the node name */
        -:21253:    int n_name;
        -:21254:    xmlChar * content; /* the XML text content if any */
        -:21255:    int n_content;
        -:21256:
    #####:21257:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:21258:    for (n_ns = 0;n_ns < gen_nb_xmlNsPtr;n_ns++) {
    #####:21259:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:21260:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:21261:        mem_base = xmlMemBlocks();
    #####:21262:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:21263:        ns = gen_xmlNsPtr(n_ns, 1);
    #####:21264:        name = gen_const_xmlChar_ptr(n_name, 2);
    #####:21265:        content = gen_const_xmlChar_ptr(n_content, 3);
        -:21266:
    #####:21267:        ret_val = xmlNewDocNode(doc, ns, (const xmlChar *)name, (const xmlChar *)content);
    #####:21268:        desret_xmlNodePtr(ret_val);
    #####:21269:        call_tests++;
    #####:21270:        des_xmlDocPtr(n_doc, doc, 0);
    #####:21271:        des_xmlNsPtr(n_ns, ns, 1);
    #####:21272:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
    #####:21273:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 3);
    #####:21274:        xmlResetLastError();
    #####:21275:        if (mem_base != xmlMemBlocks()) {
    #####:21276:            printf("Leak of %d blocks found in xmlNewDocNode",
    #####:21277:	           xmlMemBlocks() - mem_base);
    #####:21278:	    test_ret++;
    #####:21279:            printf(" %d", n_doc);
    #####:21280:            printf(" %d", n_ns);
    #####:21281:            printf(" %d", n_name);
    #####:21282:            printf(" %d", n_content);
    #####:21283:            printf("\n");
        -:21284:        }
        -:21285:    }
        -:21286:    }
        -:21287:    }
        -:21288:    }
    #####:21289:    function_tests++;
        -:21290:
    #####:21291:    return(test_ret);
        -:21292:}
        -:21293:
        -:21294:
        -:21295:static int
    #####:21296:test_xmlNewDocNodeEatName(void) {
    #####:21297:    int test_ret = 0;
        -:21298:
        -:21299:    int mem_base;
        -:21300:    xmlNodePtr ret_val;
        -:21301:    xmlDocPtr doc; /* the document */
        -:21302:    int n_doc;
        -:21303:    xmlNsPtr ns; /* namespace if any */
        -:21304:    int n_ns;
        -:21305:    xmlChar * name; /* the node name */
        -:21306:    int n_name;
        -:21307:    xmlChar * content; /* the XML text content if any */
        -:21308:    int n_content;
        -:21309:
    #####:21310:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:21311:    for (n_ns = 0;n_ns < gen_nb_xmlNsPtr;n_ns++) {
    #####:21312:    for (n_name = 0;n_name < gen_nb_eaten_name;n_name++) {
    #####:21313:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:21314:        mem_base = xmlMemBlocks();
    #####:21315:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:21316:        ns = gen_xmlNsPtr(n_ns, 1);
    #####:21317:        name = gen_eaten_name(n_name, 2);
    #####:21318:        content = gen_const_xmlChar_ptr(n_content, 3);
        -:21319:
    #####:21320:        ret_val = xmlNewDocNodeEatName(doc, ns, name, (const xmlChar *)content);
    #####:21321:        desret_xmlNodePtr(ret_val);
    #####:21322:        call_tests++;
    #####:21323:        des_xmlDocPtr(n_doc, doc, 0);
    #####:21324:        des_xmlNsPtr(n_ns, ns, 1);
    #####:21325:        des_eaten_name(n_name, name, 2);
    #####:21326:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 3);
    #####:21327:        xmlResetLastError();
    #####:21328:        if (mem_base != xmlMemBlocks()) {
    #####:21329:            printf("Leak of %d blocks found in xmlNewDocNodeEatName",
    #####:21330:	           xmlMemBlocks() - mem_base);
    #####:21331:	    test_ret++;
    #####:21332:            printf(" %d", n_doc);
    #####:21333:            printf(" %d", n_ns);
    #####:21334:            printf(" %d", n_name);
    #####:21335:            printf(" %d", n_content);
    #####:21336:            printf("\n");
        -:21337:        }
        -:21338:    }
        -:21339:    }
        -:21340:    }
        -:21341:    }
    #####:21342:    function_tests++;
        -:21343:
    #####:21344:    return(test_ret);
        -:21345:}
        -:21346:
        -:21347:
        -:21348:static int
    #####:21349:test_xmlNewDocPI(void) {
    #####:21350:    int test_ret = 0;
        -:21351:
        -:21352:    int mem_base;
        -:21353:    xmlNodePtr ret_val;
        -:21354:    xmlDocPtr doc; /* the target document */
        -:21355:    int n_doc;
        -:21356:    xmlChar * name; /* the processing instruction name */
        -:21357:    int n_name;
        -:21358:    xmlChar * content; /* the PI content */
        -:21359:    int n_content;
        -:21360:
    #####:21361:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:21362:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:21363:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:21364:        mem_base = xmlMemBlocks();
    #####:21365:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:21366:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:21367:        content = gen_const_xmlChar_ptr(n_content, 2);
        -:21368:
    #####:21369:        ret_val = xmlNewDocPI(doc, (const xmlChar *)name, (const xmlChar *)content);
    #####:21370:        desret_xmlNodePtr(ret_val);
    #####:21371:        call_tests++;
    #####:21372:        des_xmlDocPtr(n_doc, doc, 0);
    #####:21373:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:21374:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 2);
    #####:21375:        xmlResetLastError();
    #####:21376:        if (mem_base != xmlMemBlocks()) {
    #####:21377:            printf("Leak of %d blocks found in xmlNewDocPI",
    #####:21378:	           xmlMemBlocks() - mem_base);
    #####:21379:	    test_ret++;
    #####:21380:            printf(" %d", n_doc);
    #####:21381:            printf(" %d", n_name);
    #####:21382:            printf(" %d", n_content);
    #####:21383:            printf("\n");
        -:21384:        }
        -:21385:    }
        -:21386:    }
        -:21387:    }
    #####:21388:    function_tests++;
        -:21389:
    #####:21390:    return(test_ret);
        -:21391:}
        -:21392:
        -:21393:
        -:21394:static int
    #####:21395:test_xmlNewDocProp(void) {
    #####:21396:    int test_ret = 0;
        -:21397:
        -:21398:    int mem_base;
        -:21399:    xmlAttrPtr ret_val;
        -:21400:    xmlDocPtr doc; /* the document */
        -:21401:    int n_doc;
        -:21402:    xmlChar * name; /* the name of the attribute */
        -:21403:    int n_name;
        -:21404:    xmlChar * value; /* the value of the attribute */
        -:21405:    int n_value;
        -:21406:
    #####:21407:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:21408:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:21409:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:21410:        mem_base = xmlMemBlocks();
    #####:21411:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:21412:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:21413:        value = gen_const_xmlChar_ptr(n_value, 2);
        -:21414:
    #####:21415:        ret_val = xmlNewDocProp(doc, (const xmlChar *)name, (const xmlChar *)value);
    #####:21416:        desret_xmlAttrPtr(ret_val);
    #####:21417:        call_tests++;
    #####:21418:        des_xmlDocPtr(n_doc, doc, 0);
    #####:21419:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:21420:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 2);
    #####:21421:        xmlResetLastError();
    #####:21422:        if (mem_base != xmlMemBlocks()) {
    #####:21423:            printf("Leak of %d blocks found in xmlNewDocProp",
    #####:21424:	           xmlMemBlocks() - mem_base);
    #####:21425:	    test_ret++;
    #####:21426:            printf(" %d", n_doc);
    #####:21427:            printf(" %d", n_name);
    #####:21428:            printf(" %d", n_value);
    #####:21429:            printf("\n");
        -:21430:        }
        -:21431:    }
        -:21432:    }
        -:21433:    }
    #####:21434:    function_tests++;
        -:21435:
    #####:21436:    return(test_ret);
        -:21437:}
        -:21438:
        -:21439:
        -:21440:static int
    #####:21441:test_xmlNewDocRawNode(void) {
    #####:21442:    int test_ret = 0;
        -:21443:
        -:21444:#if defined(LIBXML_TREE_ENABLED)
        -:21445:#ifdef LIBXML_TREE_ENABLED
        -:21446:    int mem_base;
        -:21447:    xmlNodePtr ret_val;
        -:21448:    xmlDocPtr doc; /* the document */
        -:21449:    int n_doc;
        -:21450:    xmlNsPtr ns; /* namespace if any */
        -:21451:    int n_ns;
        -:21452:    xmlChar * name; /* the node name */
        -:21453:    int n_name;
        -:21454:    xmlChar * content; /* the text content if any */
        -:21455:    int n_content;
        -:21456:
    #####:21457:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:21458:    for (n_ns = 0;n_ns < gen_nb_xmlNsPtr;n_ns++) {
    #####:21459:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:21460:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:21461:        mem_base = xmlMemBlocks();
    #####:21462:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:21463:        ns = gen_xmlNsPtr(n_ns, 1);
    #####:21464:        name = gen_const_xmlChar_ptr(n_name, 2);
    #####:21465:        content = gen_const_xmlChar_ptr(n_content, 3);
        -:21466:
    #####:21467:        ret_val = xmlNewDocRawNode(doc, ns, (const xmlChar *)name, (const xmlChar *)content);
    #####:21468:        desret_xmlNodePtr(ret_val);
    #####:21469:        call_tests++;
    #####:21470:        des_xmlDocPtr(n_doc, doc, 0);
    #####:21471:        des_xmlNsPtr(n_ns, ns, 1);
    #####:21472:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
    #####:21473:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 3);
    #####:21474:        xmlResetLastError();
    #####:21475:        if (mem_base != xmlMemBlocks()) {
    #####:21476:            printf("Leak of %d blocks found in xmlNewDocRawNode",
    #####:21477:	           xmlMemBlocks() - mem_base);
    #####:21478:	    test_ret++;
    #####:21479:            printf(" %d", n_doc);
    #####:21480:            printf(" %d", n_ns);
    #####:21481:            printf(" %d", n_name);
    #####:21482:            printf(" %d", n_content);
    #####:21483:            printf("\n");
        -:21484:        }
        -:21485:    }
        -:21486:    }
        -:21487:    }
        -:21488:    }
    #####:21489:    function_tests++;
        -:21490:#endif
        -:21491:#endif
        -:21492:
    #####:21493:    return(test_ret);
        -:21494:}
        -:21495:
        -:21496:
        -:21497:static int
    #####:21498:test_xmlNewDocText(void) {
    #####:21499:    int test_ret = 0;
        -:21500:
        -:21501:    int mem_base;
        -:21502:    xmlNodePtr ret_val;
        -:21503:    xmlDoc * doc; /* the document */
        -:21504:    int n_doc;
        -:21505:    xmlChar * content; /* the text content */
        -:21506:    int n_content;
        -:21507:
    #####:21508:    for (n_doc = 0;n_doc < gen_nb_const_xmlDoc_ptr;n_doc++) {
    #####:21509:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:21510:        mem_base = xmlMemBlocks();
    #####:21511:        doc = gen_const_xmlDoc_ptr(n_doc, 0);
    #####:21512:        content = gen_const_xmlChar_ptr(n_content, 1);
        -:21513:
    #####:21514:        ret_val = xmlNewDocText((const xmlDoc *)doc, (const xmlChar *)content);
    #####:21515:        desret_xmlNodePtr(ret_val);
    #####:21516:        call_tests++;
    #####:21517:        des_const_xmlDoc_ptr(n_doc, (const xmlDoc *)doc, 0);
    #####:21518:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
    #####:21519:        xmlResetLastError();
    #####:21520:        if (mem_base != xmlMemBlocks()) {
    #####:21521:            printf("Leak of %d blocks found in xmlNewDocText",
    #####:21522:	           xmlMemBlocks() - mem_base);
    #####:21523:	    test_ret++;
    #####:21524:            printf(" %d", n_doc);
    #####:21525:            printf(" %d", n_content);
    #####:21526:            printf("\n");
        -:21527:        }
        -:21528:    }
        -:21529:    }
    #####:21530:    function_tests++;
        -:21531:
    #####:21532:    return(test_ret);
        -:21533:}
        -:21534:
        -:21535:
        -:21536:static int
    #####:21537:test_xmlNewDocTextLen(void) {
    #####:21538:    int test_ret = 0;
        -:21539:
        -:21540:    int mem_base;
        -:21541:    xmlNodePtr ret_val;
        -:21542:    xmlDocPtr doc; /* the document */
        -:21543:    int n_doc;
        -:21544:    xmlChar * content; /* the text content */
        -:21545:    int n_content;
        -:21546:    int len; /* the text len. */
        -:21547:    int n_len;
        -:21548:
    #####:21549:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:21550:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:21551:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:21552:        mem_base = xmlMemBlocks();
    #####:21553:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:21554:        content = gen_const_xmlChar_ptr(n_content, 1);
    #####:21555:        len = gen_int(n_len, 2);
        -:21556:
    #####:21557:        ret_val = xmlNewDocTextLen(doc, (const xmlChar *)content, len);
    #####:21558:        desret_xmlNodePtr(ret_val);
    #####:21559:        call_tests++;
    #####:21560:        des_xmlDocPtr(n_doc, doc, 0);
    #####:21561:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
    #####:21562:        des_int(n_len, len, 2);
    #####:21563:        xmlResetLastError();
    #####:21564:        if (mem_base != xmlMemBlocks()) {
    #####:21565:            printf("Leak of %d blocks found in xmlNewDocTextLen",
    #####:21566:	           xmlMemBlocks() - mem_base);
    #####:21567:	    test_ret++;
    #####:21568:            printf(" %d", n_doc);
    #####:21569:            printf(" %d", n_content);
    #####:21570:            printf(" %d", n_len);
    #####:21571:            printf("\n");
        -:21572:        }
        -:21573:    }
        -:21574:    }
        -:21575:    }
    #####:21576:    function_tests++;
        -:21577:
    #####:21578:    return(test_ret);
        -:21579:}
        -:21580:
        -:21581:
        -:21582:static int
    #####:21583:test_xmlNewDtd(void) {
    #####:21584:    int test_ret = 0;
        -:21585:
        -:21586:    int mem_base;
        -:21587:    xmlDtdPtr ret_val;
        -:21588:    xmlDocPtr doc; /* the document pointer */
        -:21589:    int n_doc;
        -:21590:    xmlChar * name; /* the DTD name */
        -:21591:    int n_name;
        -:21592:    xmlChar * ExternalID; /* the external ID */
        -:21593:    int n_ExternalID;
        -:21594:    xmlChar * SystemID; /* the system ID */
        -:21595:    int n_SystemID;
        -:21596:
    #####:21597:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:21598:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:21599:    for (n_ExternalID = 0;n_ExternalID < gen_nb_const_xmlChar_ptr;n_ExternalID++) {
    #####:21600:    for (n_SystemID = 0;n_SystemID < gen_nb_const_xmlChar_ptr;n_SystemID++) {
    #####:21601:        mem_base = xmlMemBlocks();
    #####:21602:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:21603:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:21604:        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 2);
    #####:21605:        SystemID = gen_const_xmlChar_ptr(n_SystemID, 3);
        -:21606:
    #####:21607:        ret_val = xmlNewDtd(doc, (const xmlChar *)name, (const xmlChar *)ExternalID, (const xmlChar *)SystemID);
    #####:21608:        desret_xmlDtdPtr(ret_val);
    #####:21609:        call_tests++;
    #####:21610:        des_xmlDocPtr(n_doc, doc, 0);
    #####:21611:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:21612:        des_const_xmlChar_ptr(n_ExternalID, (const xmlChar *)ExternalID, 2);
    #####:21613:        des_const_xmlChar_ptr(n_SystemID, (const xmlChar *)SystemID, 3);
    #####:21614:        xmlResetLastError();
    #####:21615:        if (mem_base != xmlMemBlocks()) {
    #####:21616:            printf("Leak of %d blocks found in xmlNewDtd",
    #####:21617:	           xmlMemBlocks() - mem_base);
    #####:21618:	    test_ret++;
    #####:21619:            printf(" %d", n_doc);
    #####:21620:            printf(" %d", n_name);
    #####:21621:            printf(" %d", n_ExternalID);
    #####:21622:            printf(" %d", n_SystemID);
    #####:21623:            printf("\n");
        -:21624:        }
        -:21625:    }
        -:21626:    }
        -:21627:    }
        -:21628:    }
    #####:21629:    function_tests++;
        -:21630:
    #####:21631:    return(test_ret);
        -:21632:}
        -:21633:
        -:21634:
        -:21635:static int
    #####:21636:test_xmlNewNode(void) {
    #####:21637:    int test_ret = 0;
        -:21638:
        -:21639:    int mem_base;
        -:21640:    xmlNodePtr ret_val;
        -:21641:    xmlNsPtr ns; /* namespace if any */
        -:21642:    int n_ns;
        -:21643:    xmlChar * name; /* the node name */
        -:21644:    int n_name;
        -:21645:
    #####:21646:    for (n_ns = 0;n_ns < gen_nb_xmlNsPtr;n_ns++) {
    #####:21647:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:21648:        mem_base = xmlMemBlocks();
    #####:21649:        ns = gen_xmlNsPtr(n_ns, 0);
    #####:21650:        name = gen_const_xmlChar_ptr(n_name, 1);
        -:21651:
    #####:21652:        ret_val = xmlNewNode(ns, (const xmlChar *)name);
    #####:21653:        desret_xmlNodePtr(ret_val);
    #####:21654:        call_tests++;
    #####:21655:        des_xmlNsPtr(n_ns, ns, 0);
    #####:21656:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:21657:        xmlResetLastError();
    #####:21658:        if (mem_base != xmlMemBlocks()) {
    #####:21659:            printf("Leak of %d blocks found in xmlNewNode",
    #####:21660:	           xmlMemBlocks() - mem_base);
    #####:21661:	    test_ret++;
    #####:21662:            printf(" %d", n_ns);
    #####:21663:            printf(" %d", n_name);
    #####:21664:            printf("\n");
        -:21665:        }
        -:21666:    }
        -:21667:    }
    #####:21668:    function_tests++;
        -:21669:
    #####:21670:    return(test_ret);
        -:21671:}
        -:21672:
        -:21673:
        -:21674:static int
    #####:21675:test_xmlNewNodeEatName(void) {
    #####:21676:    int test_ret = 0;
        -:21677:
        -:21678:    int mem_base;
        -:21679:    xmlNodePtr ret_val;
        -:21680:    xmlNsPtr ns; /* namespace if any */
        -:21681:    int n_ns;
        -:21682:    xmlChar * name; /* the node name */
        -:21683:    int n_name;
        -:21684:
    #####:21685:    for (n_ns = 0;n_ns < gen_nb_xmlNsPtr;n_ns++) {
    #####:21686:    for (n_name = 0;n_name < gen_nb_eaten_name;n_name++) {
    #####:21687:        mem_base = xmlMemBlocks();
    #####:21688:        ns = gen_xmlNsPtr(n_ns, 0);
    #####:21689:        name = gen_eaten_name(n_name, 1);
        -:21690:
    #####:21691:        ret_val = xmlNewNodeEatName(ns, name);
    #####:21692:        desret_xmlNodePtr(ret_val);
    #####:21693:        call_tests++;
    #####:21694:        des_xmlNsPtr(n_ns, ns, 0);
    #####:21695:        des_eaten_name(n_name, name, 1);
    #####:21696:        xmlResetLastError();
    #####:21697:        if (mem_base != xmlMemBlocks()) {
    #####:21698:            printf("Leak of %d blocks found in xmlNewNodeEatName",
    #####:21699:	           xmlMemBlocks() - mem_base);
    #####:21700:	    test_ret++;
    #####:21701:            printf(" %d", n_ns);
    #####:21702:            printf(" %d", n_name);
    #####:21703:            printf("\n");
        -:21704:        }
        -:21705:    }
        -:21706:    }
    #####:21707:    function_tests++;
        -:21708:
    #####:21709:    return(test_ret);
        -:21710:}
        -:21711:
        -:21712:
        -:21713:static int
    #####:21714:test_xmlNewNs(void) {
    #####:21715:    int test_ret = 0;
        -:21716:
        -:21717:    int mem_base;
        -:21718:    xmlNsPtr ret_val;
        -:21719:    xmlNodePtr node; /* the element carrying the namespace */
        -:21720:    int n_node;
        -:21721:    xmlChar * href; /* the URI associated */
        -:21722:    int n_href;
        -:21723:    xmlChar * prefix; /* the prefix for the namespace */
        -:21724:    int n_prefix;
        -:21725:
    #####:21726:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:21727:    for (n_href = 0;n_href < gen_nb_const_xmlChar_ptr;n_href++) {
    #####:21728:    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    #####:21729:        mem_base = xmlMemBlocks();
    #####:21730:        node = gen_xmlNodePtr(n_node, 0);
    #####:21731:        href = gen_const_xmlChar_ptr(n_href, 1);
    #####:21732:        prefix = gen_const_xmlChar_ptr(n_prefix, 2);
        -:21733:
    #####:21734:        ret_val = xmlNewNs(node, (const xmlChar *)href, (const xmlChar *)prefix);
    #####:21735:        if ((node == NULL) && (ret_val != NULL)) xmlFreeNs(ret_val);
    #####:21736:        desret_xmlNsPtr(ret_val);
    #####:21737:        call_tests++;
    #####:21738:        des_xmlNodePtr(n_node, node, 0);
    #####:21739:        des_const_xmlChar_ptr(n_href, (const xmlChar *)href, 1);
    #####:21740:        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 2);
    #####:21741:        xmlResetLastError();
    #####:21742:        if (mem_base != xmlMemBlocks()) {
    #####:21743:            printf("Leak of %d blocks found in xmlNewNs",
    #####:21744:	           xmlMemBlocks() - mem_base);
    #####:21745:	    test_ret++;
    #####:21746:            printf(" %d", n_node);
    #####:21747:            printf(" %d", n_href);
    #####:21748:            printf(" %d", n_prefix);
    #####:21749:            printf("\n");
        -:21750:        }
        -:21751:    }
        -:21752:    }
        -:21753:    }
    #####:21754:    function_tests++;
        -:21755:
    #####:21756:    return(test_ret);
        -:21757:}
        -:21758:
        -:21759:
        -:21760:static int
    #####:21761:test_xmlNewNsProp(void) {
    #####:21762:    int test_ret = 0;
        -:21763:
        -:21764:    int mem_base;
        -:21765:    xmlAttrPtr ret_val;
        -:21766:    xmlNodePtr node; /* the holding node */
        -:21767:    int n_node;
        -:21768:    xmlNsPtr ns; /* the namespace */
        -:21769:    int n_ns;
        -:21770:    xmlChar * name; /* the name of the attribute */
        -:21771:    int n_name;
        -:21772:    xmlChar * value; /* the value of the attribute */
        -:21773:    int n_value;
        -:21774:
    #####:21775:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:21776:    for (n_ns = 0;n_ns < gen_nb_xmlNsPtr;n_ns++) {
    #####:21777:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:21778:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:21779:        mem_base = xmlMemBlocks();
    #####:21780:        node = gen_xmlNodePtr(n_node, 0);
    #####:21781:        ns = gen_xmlNsPtr(n_ns, 1);
    #####:21782:        name = gen_const_xmlChar_ptr(n_name, 2);
    #####:21783:        value = gen_const_xmlChar_ptr(n_value, 3);
        -:21784:
    #####:21785:        ret_val = xmlNewNsProp(node, ns, (const xmlChar *)name, (const xmlChar *)value);
    #####:21786:        desret_xmlAttrPtr(ret_val);
    #####:21787:        call_tests++;
    #####:21788:        des_xmlNodePtr(n_node, node, 0);
    #####:21789:        des_xmlNsPtr(n_ns, ns, 1);
    #####:21790:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
    #####:21791:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 3);
    #####:21792:        xmlResetLastError();
    #####:21793:        if (mem_base != xmlMemBlocks()) {
    #####:21794:            printf("Leak of %d blocks found in xmlNewNsProp",
    #####:21795:	           xmlMemBlocks() - mem_base);
    #####:21796:	    test_ret++;
    #####:21797:            printf(" %d", n_node);
    #####:21798:            printf(" %d", n_ns);
    #####:21799:            printf(" %d", n_name);
    #####:21800:            printf(" %d", n_value);
    #####:21801:            printf("\n");
        -:21802:        }
        -:21803:    }
        -:21804:    }
        -:21805:    }
        -:21806:    }
    #####:21807:    function_tests++;
        -:21808:
    #####:21809:    return(test_ret);
        -:21810:}
        -:21811:
        -:21812:
        -:21813:static int
    #####:21814:test_xmlNewNsPropEatName(void) {
    #####:21815:    int test_ret = 0;
        -:21816:
        -:21817:    int mem_base;
        -:21818:    xmlAttrPtr ret_val;
        -:21819:    xmlNodePtr node; /* the holding node */
        -:21820:    int n_node;
        -:21821:    xmlNsPtr ns; /* the namespace */
        -:21822:    int n_ns;
        -:21823:    xmlChar * name; /* the name of the attribute */
        -:21824:    int n_name;
        -:21825:    xmlChar * value; /* the value of the attribute */
        -:21826:    int n_value;
        -:21827:
    #####:21828:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:21829:    for (n_ns = 0;n_ns < gen_nb_xmlNsPtr;n_ns++) {
    #####:21830:    for (n_name = 0;n_name < gen_nb_eaten_name;n_name++) {
    #####:21831:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:21832:        mem_base = xmlMemBlocks();
    #####:21833:        node = gen_xmlNodePtr(n_node, 0);
    #####:21834:        ns = gen_xmlNsPtr(n_ns, 1);
    #####:21835:        name = gen_eaten_name(n_name, 2);
    #####:21836:        value = gen_const_xmlChar_ptr(n_value, 3);
        -:21837:
    #####:21838:        ret_val = xmlNewNsPropEatName(node, ns, name, (const xmlChar *)value);
    #####:21839:        desret_xmlAttrPtr(ret_val);
    #####:21840:        call_tests++;
    #####:21841:        des_xmlNodePtr(n_node, node, 0);
    #####:21842:        des_xmlNsPtr(n_ns, ns, 1);
    #####:21843:        des_eaten_name(n_name, name, 2);
    #####:21844:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 3);
    #####:21845:        xmlResetLastError();
    #####:21846:        if (mem_base != xmlMemBlocks()) {
    #####:21847:            printf("Leak of %d blocks found in xmlNewNsPropEatName",
    #####:21848:	           xmlMemBlocks() - mem_base);
    #####:21849:	    test_ret++;
    #####:21850:            printf(" %d", n_node);
    #####:21851:            printf(" %d", n_ns);
    #####:21852:            printf(" %d", n_name);
    #####:21853:            printf(" %d", n_value);
    #####:21854:            printf("\n");
        -:21855:        }
        -:21856:    }
        -:21857:    }
        -:21858:    }
        -:21859:    }
    #####:21860:    function_tests++;
        -:21861:
    #####:21862:    return(test_ret);
        -:21863:}
        -:21864:
        -:21865:
        -:21866:static int
    #####:21867:test_xmlNewPI(void) {
    #####:21868:    int test_ret = 0;
        -:21869:
        -:21870:    int mem_base;
        -:21871:    xmlNodePtr ret_val;
        -:21872:    xmlChar * name; /* the processing instruction name */
        -:21873:    int n_name;
        -:21874:    xmlChar * content; /* the PI content */
        -:21875:    int n_content;
        -:21876:
    #####:21877:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:21878:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:21879:        mem_base = xmlMemBlocks();
    #####:21880:        name = gen_const_xmlChar_ptr(n_name, 0);
    #####:21881:        content = gen_const_xmlChar_ptr(n_content, 1);
        -:21882:
    #####:21883:        ret_val = xmlNewPI((const xmlChar *)name, (const xmlChar *)content);
    #####:21884:        desret_xmlNodePtr(ret_val);
    #####:21885:        call_tests++;
    #####:21886:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 0);
    #####:21887:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
    #####:21888:        xmlResetLastError();
    #####:21889:        if (mem_base != xmlMemBlocks()) {
    #####:21890:            printf("Leak of %d blocks found in xmlNewPI",
    #####:21891:	           xmlMemBlocks() - mem_base);
    #####:21892:	    test_ret++;
    #####:21893:            printf(" %d", n_name);
    #####:21894:            printf(" %d", n_content);
    #####:21895:            printf("\n");
        -:21896:        }
        -:21897:    }
        -:21898:    }
    #####:21899:    function_tests++;
        -:21900:
    #####:21901:    return(test_ret);
        -:21902:}
        -:21903:
        -:21904:
        -:21905:static int
    #####:21906:test_xmlNewProp(void) {
    #####:21907:    int test_ret = 0;
        -:21908:
        -:21909:#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
        -:21910:#ifdef LIBXML_TREE_ENABLED
        -:21911:    int mem_base;
        -:21912:    xmlAttrPtr ret_val;
        -:21913:    xmlNodePtr node; /* the holding node */
        -:21914:    int n_node;
        -:21915:    xmlChar * name; /* the name of the attribute */
        -:21916:    int n_name;
        -:21917:    xmlChar * value; /* the value of the attribute */
        -:21918:    int n_value;
        -:21919:
    #####:21920:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:21921:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:21922:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:21923:        mem_base = xmlMemBlocks();
    #####:21924:        node = gen_xmlNodePtr(n_node, 0);
    #####:21925:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:21926:        value = gen_const_xmlChar_ptr(n_value, 2);
        -:21927:
    #####:21928:        ret_val = xmlNewProp(node, (const xmlChar *)name, (const xmlChar *)value);
    #####:21929:        desret_xmlAttrPtr(ret_val);
    #####:21930:        call_tests++;
    #####:21931:        des_xmlNodePtr(n_node, node, 0);
    #####:21932:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:21933:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 2);
    #####:21934:        xmlResetLastError();
    #####:21935:        if (mem_base != xmlMemBlocks()) {
    #####:21936:            printf("Leak of %d blocks found in xmlNewProp",
    #####:21937:	           xmlMemBlocks() - mem_base);
    #####:21938:	    test_ret++;
    #####:21939:            printf(" %d", n_node);
    #####:21940:            printf(" %d", n_name);
    #####:21941:            printf(" %d", n_value);
    #####:21942:            printf("\n");
        -:21943:        }
        -:21944:    }
        -:21945:    }
        -:21946:    }
    #####:21947:    function_tests++;
        -:21948:#endif
        -:21949:#endif
        -:21950:
    #####:21951:    return(test_ret);
        -:21952:}
        -:21953:
        -:21954:
        -:21955:static int
    #####:21956:test_xmlNewReference(void) {
    #####:21957:    int test_ret = 0;
        -:21958:
        -:21959:    int mem_base;
        -:21960:    xmlNodePtr ret_val;
        -:21961:    xmlDoc * doc; /* the document */
        -:21962:    int n_doc;
        -:21963:    xmlChar * name; /* the reference name, or the reference string with & and ; */
        -:21964:    int n_name;
        -:21965:
    #####:21966:    for (n_doc = 0;n_doc < gen_nb_const_xmlDoc_ptr;n_doc++) {
    #####:21967:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:21968:        mem_base = xmlMemBlocks();
    #####:21969:        doc = gen_const_xmlDoc_ptr(n_doc, 0);
    #####:21970:        name = gen_const_xmlChar_ptr(n_name, 1);
        -:21971:
    #####:21972:        ret_val = xmlNewReference((const xmlDoc *)doc, (const xmlChar *)name);
    #####:21973:        desret_xmlNodePtr(ret_val);
    #####:21974:        call_tests++;
    #####:21975:        des_const_xmlDoc_ptr(n_doc, (const xmlDoc *)doc, 0);
    #####:21976:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:21977:        xmlResetLastError();
    #####:21978:        if (mem_base != xmlMemBlocks()) {
    #####:21979:            printf("Leak of %d blocks found in xmlNewReference",
    #####:21980:	           xmlMemBlocks() - mem_base);
    #####:21981:	    test_ret++;
    #####:21982:            printf(" %d", n_doc);
    #####:21983:            printf(" %d", n_name);
    #####:21984:            printf("\n");
        -:21985:        }
        -:21986:    }
        -:21987:    }
    #####:21988:    function_tests++;
        -:21989:
    #####:21990:    return(test_ret);
        -:21991:}
        -:21992:
        -:21993:
        -:21994:static int
    #####:21995:test_xmlNewText(void) {
    #####:21996:    int test_ret = 0;
        -:21997:
        -:21998:    int mem_base;
        -:21999:    xmlNodePtr ret_val;
        -:22000:    xmlChar * content; /* the text content */
        -:22001:    int n_content;
        -:22002:
    #####:22003:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:22004:        mem_base = xmlMemBlocks();
    #####:22005:        content = gen_const_xmlChar_ptr(n_content, 0);
        -:22006:
    #####:22007:        ret_val = xmlNewText((const xmlChar *)content);
    #####:22008:        desret_xmlNodePtr(ret_val);
    #####:22009:        call_tests++;
    #####:22010:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 0);
    #####:22011:        xmlResetLastError();
    #####:22012:        if (mem_base != xmlMemBlocks()) {
    #####:22013:            printf("Leak of %d blocks found in xmlNewText",
    #####:22014:	           xmlMemBlocks() - mem_base);
    #####:22015:	    test_ret++;
    #####:22016:            printf(" %d", n_content);
    #####:22017:            printf("\n");
        -:22018:        }
        -:22019:    }
    #####:22020:    function_tests++;
        -:22021:
    #####:22022:    return(test_ret);
        -:22023:}
        -:22024:
        -:22025:
        -:22026:static int
    #####:22027:test_xmlNewTextChild(void) {
    #####:22028:    int test_ret = 0;
        -:22029:
        -:22030:#if defined(LIBXML_TREE_ENABLED)
        -:22031:#ifdef LIBXML_TREE_ENABLED
        -:22032:    int mem_base;
        -:22033:    xmlNodePtr ret_val;
        -:22034:    xmlNodePtr parent; /* the parent node */
        -:22035:    int n_parent;
        -:22036:    xmlNsPtr ns; /* a namespace if any */
        -:22037:    int n_ns;
        -:22038:    xmlChar * name; /* the name of the child */
        -:22039:    int n_name;
        -:22040:    xmlChar * content; /* the text content of the child if any. */
        -:22041:    int n_content;
        -:22042:
    #####:22043:    for (n_parent = 0;n_parent < gen_nb_xmlNodePtr;n_parent++) {
    #####:22044:    for (n_ns = 0;n_ns < gen_nb_xmlNsPtr;n_ns++) {
    #####:22045:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:22046:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:22047:        mem_base = xmlMemBlocks();
    #####:22048:        parent = gen_xmlNodePtr(n_parent, 0);
    #####:22049:        ns = gen_xmlNsPtr(n_ns, 1);
    #####:22050:        name = gen_const_xmlChar_ptr(n_name, 2);
    #####:22051:        content = gen_const_xmlChar_ptr(n_content, 3);
        -:22052:
    #####:22053:        ret_val = xmlNewTextChild(parent, ns, (const xmlChar *)name, (const xmlChar *)content);
    #####:22054:        desret_xmlNodePtr(ret_val);
    #####:22055:        call_tests++;
    #####:22056:        des_xmlNodePtr(n_parent, parent, 0);
    #####:22057:        des_xmlNsPtr(n_ns, ns, 1);
    #####:22058:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
    #####:22059:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 3);
    #####:22060:        xmlResetLastError();
    #####:22061:        if (mem_base != xmlMemBlocks()) {
    #####:22062:            printf("Leak of %d blocks found in xmlNewTextChild",
    #####:22063:	           xmlMemBlocks() - mem_base);
    #####:22064:	    test_ret++;
    #####:22065:            printf(" %d", n_parent);
    #####:22066:            printf(" %d", n_ns);
    #####:22067:            printf(" %d", n_name);
    #####:22068:            printf(" %d", n_content);
    #####:22069:            printf("\n");
        -:22070:        }
        -:22071:    }
        -:22072:    }
        -:22073:    }
        -:22074:    }
    #####:22075:    function_tests++;
        -:22076:#endif
        -:22077:#endif
        -:22078:
    #####:22079:    return(test_ret);
        -:22080:}
        -:22081:
        -:22082:
        -:22083:static int
    #####:22084:test_xmlNewTextLen(void) {
    #####:22085:    int test_ret = 0;
        -:22086:
        -:22087:    int mem_base;
        -:22088:    xmlNodePtr ret_val;
        -:22089:    xmlChar * content; /* the text content */
        -:22090:    int n_content;
        -:22091:    int len; /* the text len. */
        -:22092:    int n_len;
        -:22093:
    #####:22094:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:22095:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:22096:        mem_base = xmlMemBlocks();
    #####:22097:        content = gen_const_xmlChar_ptr(n_content, 0);
    #####:22098:        len = gen_int(n_len, 1);
        -:22099:
    #####:22100:        ret_val = xmlNewTextLen((const xmlChar *)content, len);
    #####:22101:        desret_xmlNodePtr(ret_val);
    #####:22102:        call_tests++;
    #####:22103:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 0);
    #####:22104:        des_int(n_len, len, 1);
    #####:22105:        xmlResetLastError();
    #####:22106:        if (mem_base != xmlMemBlocks()) {
    #####:22107:            printf("Leak of %d blocks found in xmlNewTextLen",
    #####:22108:	           xmlMemBlocks() - mem_base);
    #####:22109:	    test_ret++;
    #####:22110:            printf(" %d", n_content);
    #####:22111:            printf(" %d", n_len);
    #####:22112:            printf("\n");
        -:22113:        }
        -:22114:    }
        -:22115:    }
    #####:22116:    function_tests++;
        -:22117:
    #####:22118:    return(test_ret);
        -:22119:}
        -:22120:
        -:22121:
        -:22122:static int
    #####:22123:test_xmlNextElementSibling(void) {
    #####:22124:    int test_ret = 0;
        -:22125:
        -:22126:#if defined(LIBXML_TREE_ENABLED)
        -:22127:    int mem_base;
        -:22128:    xmlNodePtr ret_val;
        -:22129:    xmlNodePtr node; /* the current node */
        -:22130:    int n_node;
        -:22131:
    #####:22132:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:22133:        mem_base = xmlMemBlocks();
    #####:22134:        node = gen_xmlNodePtr(n_node, 0);
        -:22135:
    #####:22136:        ret_val = xmlNextElementSibling(node);
    #####:22137:        desret_xmlNodePtr(ret_val);
    #####:22138:        call_tests++;
    #####:22139:        des_xmlNodePtr(n_node, node, 0);
    #####:22140:        xmlResetLastError();
    #####:22141:        if (mem_base != xmlMemBlocks()) {
    #####:22142:            printf("Leak of %d blocks found in xmlNextElementSibling",
    #####:22143:	           xmlMemBlocks() - mem_base);
    #####:22144:	    test_ret++;
    #####:22145:            printf(" %d", n_node);
    #####:22146:            printf("\n");
        -:22147:        }
        -:22148:    }
    #####:22149:    function_tests++;
        -:22150:#endif
        -:22151:
    #####:22152:    return(test_ret);
        -:22153:}
        -:22154:
        -:22155:
        -:22156:static int
    #####:22157:test_xmlNodeAddContent(void) {
    #####:22158:    int test_ret = 0;
        -:22159:
        -:22160:    int mem_base;
        -:22161:    xmlNodePtr cur; /* the node being modified */
        -:22162:    int n_cur;
        -:22163:    xmlChar * content; /* extra content */
        -:22164:    int n_content;
        -:22165:
    #####:22166:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####:22167:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:22168:        mem_base = xmlMemBlocks();
    #####:22169:        cur = gen_xmlNodePtr(n_cur, 0);
    #####:22170:        content = gen_const_xmlChar_ptr(n_content, 1);
        -:22171:
    #####:22172:        xmlNodeAddContent(cur, (const xmlChar *)content);
    #####:22173:        call_tests++;
    #####:22174:        des_xmlNodePtr(n_cur, cur, 0);
    #####:22175:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
    #####:22176:        xmlResetLastError();
    #####:22177:        if (mem_base != xmlMemBlocks()) {
    #####:22178:            printf("Leak of %d blocks found in xmlNodeAddContent",
    #####:22179:	           xmlMemBlocks() - mem_base);
    #####:22180:	    test_ret++;
    #####:22181:            printf(" %d", n_cur);
    #####:22182:            printf(" %d", n_content);
    #####:22183:            printf("\n");
        -:22184:        }
        -:22185:    }
        -:22186:    }
    #####:22187:    function_tests++;
        -:22188:
    #####:22189:    return(test_ret);
        -:22190:}
        -:22191:
        -:22192:
        -:22193:static int
    #####:22194:test_xmlNodeAddContentLen(void) {
    #####:22195:    int test_ret = 0;
        -:22196:
        -:22197:    int mem_base;
        -:22198:    xmlNodePtr cur; /* the node being modified */
        -:22199:    int n_cur;
        -:22200:    xmlChar * content; /* extra content */
        -:22201:    int n_content;
        -:22202:    int len; /* the size of @content */
        -:22203:    int n_len;
        -:22204:
    #####:22205:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####:22206:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:22207:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:22208:        mem_base = xmlMemBlocks();
    #####:22209:        cur = gen_xmlNodePtr(n_cur, 0);
    #####:22210:        content = gen_const_xmlChar_ptr(n_content, 1);
    #####:22211:        len = gen_int(n_len, 2);
        -:22212:
    #####:22213:        xmlNodeAddContentLen(cur, (const xmlChar *)content, len);
    #####:22214:        call_tests++;
    #####:22215:        des_xmlNodePtr(n_cur, cur, 0);
    #####:22216:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
    #####:22217:        des_int(n_len, len, 2);
    #####:22218:        xmlResetLastError();
    #####:22219:        if (mem_base != xmlMemBlocks()) {
    #####:22220:            printf("Leak of %d blocks found in xmlNodeAddContentLen",
    #####:22221:	           xmlMemBlocks() - mem_base);
    #####:22222:	    test_ret++;
    #####:22223:            printf(" %d", n_cur);
    #####:22224:            printf(" %d", n_content);
    #####:22225:            printf(" %d", n_len);
    #####:22226:            printf("\n");
        -:22227:        }
        -:22228:    }
        -:22229:    }
        -:22230:    }
    #####:22231:    function_tests++;
        -:22232:
    #####:22233:    return(test_ret);
        -:22234:}
        -:22235:
        -:22236:
        -:22237:static int
    #####:22238:test_xmlNodeBufGetContent(void) {
    #####:22239:    int test_ret = 0;
        -:22240:
        -:22241:    int mem_base;
        -:22242:    int ret_val;
        -:22243:    xmlBufferPtr buffer; /* a buffer */
        -:22244:    int n_buffer;
        -:22245:    xmlNode * cur; /* the node being read */
        -:22246:    int n_cur;
        -:22247:
    #####:22248:    for (n_buffer = 0;n_buffer < gen_nb_xmlBufferPtr;n_buffer++) {
    #####:22249:    for (n_cur = 0;n_cur < gen_nb_const_xmlNode_ptr;n_cur++) {
    #####:22250:        mem_base = xmlMemBlocks();
    #####:22251:        buffer = gen_xmlBufferPtr(n_buffer, 0);
    #####:22252:        cur = gen_const_xmlNode_ptr(n_cur, 1);
        -:22253:
    #####:22254:        ret_val = xmlNodeBufGetContent(buffer, (const xmlNode *)cur);
    #####:22255:        desret_int(ret_val);
    #####:22256:        call_tests++;
    #####:22257:        des_xmlBufferPtr(n_buffer, buffer, 0);
    #####:22258:        des_const_xmlNode_ptr(n_cur, (const xmlNode *)cur, 1);
    #####:22259:        xmlResetLastError();
    #####:22260:        if (mem_base != xmlMemBlocks()) {
    #####:22261:            printf("Leak of %d blocks found in xmlNodeBufGetContent",
    #####:22262:	           xmlMemBlocks() - mem_base);
    #####:22263:	    test_ret++;
    #####:22264:            printf(" %d", n_buffer);
    #####:22265:            printf(" %d", n_cur);
    #####:22266:            printf("\n");
        -:22267:        }
        -:22268:    }
        -:22269:    }
    #####:22270:    function_tests++;
        -:22271:
    #####:22272:    return(test_ret);
        -:22273:}
        -:22274:
        -:22275:
        -:22276:static int
    #####:22277:test_xmlNodeDump(void) {
    #####:22278:    int test_ret = 0;
        -:22279:
        -:22280:#if defined(LIBXML_OUTPUT_ENABLED)
        -:22281:    int mem_base;
        -:22282:    int ret_val;
        -:22283:    xmlBufferPtr buf; /* the XML buffer output */
        -:22284:    int n_buf;
        -:22285:    xmlDocPtr doc; /* the document */
        -:22286:    int n_doc;
        -:22287:    xmlNodePtr cur; /* the current node */
        -:22288:    int n_cur;
        -:22289:    int level; /* the imbrication level for indenting */
        -:22290:    int n_level;
        -:22291:    int format; /* is formatting allowed */
        -:22292:    int n_format;
        -:22293:
    #####:22294:    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    #####:22295:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:22296:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####:22297:    for (n_level = 0;n_level < gen_nb_int;n_level++) {
    #####:22298:    for (n_format = 0;n_format < gen_nb_int;n_format++) {
    #####:22299:        mem_base = xmlMemBlocks();
    #####:22300:        buf = gen_xmlBufferPtr(n_buf, 0);
    #####:22301:        doc = gen_xmlDocPtr(n_doc, 1);
    #####:22302:        cur = gen_xmlNodePtr(n_cur, 2);
    #####:22303:        level = gen_int(n_level, 3);
    #####:22304:        format = gen_int(n_format, 4);
        -:22305:
    #####:22306:        ret_val = xmlNodeDump(buf, doc, cur, level, format);
    #####:22307:        desret_int(ret_val);
    #####:22308:        call_tests++;
    #####:22309:        des_xmlBufferPtr(n_buf, buf, 0);
    #####:22310:        des_xmlDocPtr(n_doc, doc, 1);
    #####:22311:        des_xmlNodePtr(n_cur, cur, 2);
    #####:22312:        des_int(n_level, level, 3);
    #####:22313:        des_int(n_format, format, 4);
    #####:22314:        xmlResetLastError();
    #####:22315:        if (mem_base != xmlMemBlocks()) {
    #####:22316:            printf("Leak of %d blocks found in xmlNodeDump",
    #####:22317:	           xmlMemBlocks() - mem_base);
    #####:22318:	    test_ret++;
    #####:22319:            printf(" %d", n_buf);
    #####:22320:            printf(" %d", n_doc);
    #####:22321:            printf(" %d", n_cur);
    #####:22322:            printf(" %d", n_level);
    #####:22323:            printf(" %d", n_format);
    #####:22324:            printf("\n");
        -:22325:        }
        -:22326:    }
        -:22327:    }
        -:22328:    }
        -:22329:    }
        -:22330:    }
    #####:22331:    function_tests++;
        -:22332:#endif
        -:22333:
    #####:22334:    return(test_ret);
        -:22335:}
        -:22336:
        -:22337:
        -:22338:static int
    #####:22339:test_xmlNodeDumpOutput(void) {
    #####:22340:    int test_ret = 0;
        -:22341:
        -:22342:#if defined(LIBXML_OUTPUT_ENABLED)
        -:22343:    int mem_base;
        -:22344:    xmlOutputBufferPtr buf; /* the XML buffer output */
        -:22345:    int n_buf;
        -:22346:    xmlDocPtr doc; /* the document */
        -:22347:    int n_doc;
        -:22348:    xmlNodePtr cur; /* the current node */
        -:22349:    int n_cur;
        -:22350:    int level; /* the imbrication level for indenting */
        -:22351:    int n_level;
        -:22352:    int format; /* is formatting allowed */
        -:22353:    int n_format;
        -:22354:    char * encoding; /* an optional encoding string */
        -:22355:    int n_encoding;
        -:22356:
    #####:22357:    for (n_buf = 0;n_buf < gen_nb_xmlOutputBufferPtr;n_buf++) {
    #####:22358:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:22359:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####:22360:    for (n_level = 0;n_level < gen_nb_int;n_level++) {
    #####:22361:    for (n_format = 0;n_format < gen_nb_int;n_format++) {
    #####:22362:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####:22363:        mem_base = xmlMemBlocks();
    #####:22364:        buf = gen_xmlOutputBufferPtr(n_buf, 0);
    #####:22365:        doc = gen_xmlDocPtr(n_doc, 1);
    #####:22366:        cur = gen_xmlNodePtr(n_cur, 2);
    #####:22367:        level = gen_int(n_level, 3);
    #####:22368:        format = gen_int(n_format, 4);
    #####:22369:        encoding = gen_const_char_ptr(n_encoding, 5);
        -:22370:
    #####:22371:        xmlNodeDumpOutput(buf, doc, cur, level, format, (const char *)encoding);
    #####:22372:        call_tests++;
    #####:22373:        des_xmlOutputBufferPtr(n_buf, buf, 0);
    #####:22374:        des_xmlDocPtr(n_doc, doc, 1);
    #####:22375:        des_xmlNodePtr(n_cur, cur, 2);
    #####:22376:        des_int(n_level, level, 3);
    #####:22377:        des_int(n_format, format, 4);
    #####:22378:        des_const_char_ptr(n_encoding, (const char *)encoding, 5);
    #####:22379:        xmlResetLastError();
    #####:22380:        if (mem_base != xmlMemBlocks()) {
    #####:22381:            printf("Leak of %d blocks found in xmlNodeDumpOutput",
    #####:22382:	           xmlMemBlocks() - mem_base);
    #####:22383:	    test_ret++;
    #####:22384:            printf(" %d", n_buf);
    #####:22385:            printf(" %d", n_doc);
    #####:22386:            printf(" %d", n_cur);
    #####:22387:            printf(" %d", n_level);
    #####:22388:            printf(" %d", n_format);
    #####:22389:            printf(" %d", n_encoding);
    #####:22390:            printf("\n");
        -:22391:        }
        -:22392:    }
        -:22393:    }
        -:22394:    }
        -:22395:    }
        -:22396:    }
        -:22397:    }
    #####:22398:    function_tests++;
        -:22399:#endif
        -:22400:
    #####:22401:    return(test_ret);
        -:22402:}
        -:22403:
        -:22404:
        -:22405:static int
    #####:22406:test_xmlNodeGetBase(void) {
    #####:22407:    int test_ret = 0;
        -:22408:
        -:22409:    int mem_base;
        -:22410:    xmlChar * ret_val;
        -:22411:    xmlDoc * doc; /* the document the node pertains to */
        -:22412:    int n_doc;
        -:22413:    xmlNode * cur; /* the node being checked */
        -:22414:    int n_cur;
        -:22415:
    #####:22416:    for (n_doc = 0;n_doc < gen_nb_const_xmlDoc_ptr;n_doc++) {
    #####:22417:    for (n_cur = 0;n_cur < gen_nb_const_xmlNode_ptr;n_cur++) {
    #####:22418:        mem_base = xmlMemBlocks();
    #####:22419:        doc = gen_const_xmlDoc_ptr(n_doc, 0);
    #####:22420:        cur = gen_const_xmlNode_ptr(n_cur, 1);
        -:22421:
    #####:22422:        ret_val = xmlNodeGetBase((const xmlDoc *)doc, (const xmlNode *)cur);
    #####:22423:        desret_xmlChar_ptr(ret_val);
    #####:22424:        call_tests++;
    #####:22425:        des_const_xmlDoc_ptr(n_doc, (const xmlDoc *)doc, 0);
    #####:22426:        des_const_xmlNode_ptr(n_cur, (const xmlNode *)cur, 1);
    #####:22427:        xmlResetLastError();
    #####:22428:        if (mem_base != xmlMemBlocks()) {
    #####:22429:            printf("Leak of %d blocks found in xmlNodeGetBase",
    #####:22430:	           xmlMemBlocks() - mem_base);
    #####:22431:	    test_ret++;
    #####:22432:            printf(" %d", n_doc);
    #####:22433:            printf(" %d", n_cur);
    #####:22434:            printf("\n");
        -:22435:        }
        -:22436:    }
        -:22437:    }
    #####:22438:    function_tests++;
        -:22439:
    #####:22440:    return(test_ret);
        -:22441:}
        -:22442:
        -:22443:
        -:22444:static int
    #####:22445:test_xmlNodeGetContent(void) {
    #####:22446:    int test_ret = 0;
        -:22447:
        -:22448:    int mem_base;
        -:22449:    xmlChar * ret_val;
        -:22450:    xmlNode * cur; /* the node being read */
        -:22451:    int n_cur;
        -:22452:
    #####:22453:    for (n_cur = 0;n_cur < gen_nb_const_xmlNode_ptr;n_cur++) {
    #####:22454:        mem_base = xmlMemBlocks();
    #####:22455:        cur = gen_const_xmlNode_ptr(n_cur, 0);
        -:22456:
    #####:22457:        ret_val = xmlNodeGetContent((const xmlNode *)cur);
    #####:22458:        desret_xmlChar_ptr(ret_val);
    #####:22459:        call_tests++;
    #####:22460:        des_const_xmlNode_ptr(n_cur, (const xmlNode *)cur, 0);
    #####:22461:        xmlResetLastError();
    #####:22462:        if (mem_base != xmlMemBlocks()) {
    #####:22463:            printf("Leak of %d blocks found in xmlNodeGetContent",
    #####:22464:	           xmlMemBlocks() - mem_base);
    #####:22465:	    test_ret++;
    #####:22466:            printf(" %d", n_cur);
    #####:22467:            printf("\n");
        -:22468:        }
        -:22469:    }
    #####:22470:    function_tests++;
        -:22471:
    #####:22472:    return(test_ret);
        -:22473:}
        -:22474:
        -:22475:
        -:22476:static int
    #####:22477:test_xmlNodeGetLang(void) {
    #####:22478:    int test_ret = 0;
        -:22479:
        -:22480:    int mem_base;
        -:22481:    xmlChar * ret_val;
        -:22482:    xmlNode * cur; /* the node being checked */
        -:22483:    int n_cur;
        -:22484:
    #####:22485:    for (n_cur = 0;n_cur < gen_nb_const_xmlNode_ptr;n_cur++) {
    #####:22486:        mem_base = xmlMemBlocks();
    #####:22487:        cur = gen_const_xmlNode_ptr(n_cur, 0);
        -:22488:
    #####:22489:        ret_val = xmlNodeGetLang((const xmlNode *)cur);
    #####:22490:        desret_xmlChar_ptr(ret_val);
    #####:22491:        call_tests++;
    #####:22492:        des_const_xmlNode_ptr(n_cur, (const xmlNode *)cur, 0);
    #####:22493:        xmlResetLastError();
    #####:22494:        if (mem_base != xmlMemBlocks()) {
    #####:22495:            printf("Leak of %d blocks found in xmlNodeGetLang",
    #####:22496:	           xmlMemBlocks() - mem_base);
    #####:22497:	    test_ret++;
    #####:22498:            printf(" %d", n_cur);
    #####:22499:            printf("\n");
        -:22500:        }
        -:22501:    }
    #####:22502:    function_tests++;
        -:22503:
    #####:22504:    return(test_ret);
        -:22505:}
        -:22506:
        -:22507:
        -:22508:static int
    #####:22509:test_xmlNodeGetSpacePreserve(void) {
    #####:22510:    int test_ret = 0;
        -:22511:
        -:22512:    int mem_base;
        -:22513:    int ret_val;
        -:22514:    xmlNode * cur; /* the node being checked */
        -:22515:    int n_cur;
        -:22516:
    #####:22517:    for (n_cur = 0;n_cur < gen_nb_const_xmlNode_ptr;n_cur++) {
    #####:22518:        mem_base = xmlMemBlocks();
    #####:22519:        cur = gen_const_xmlNode_ptr(n_cur, 0);
        -:22520:
    #####:22521:        ret_val = xmlNodeGetSpacePreserve((const xmlNode *)cur);
    #####:22522:        desret_int(ret_val);
    #####:22523:        call_tests++;
    #####:22524:        des_const_xmlNode_ptr(n_cur, (const xmlNode *)cur, 0);
    #####:22525:        xmlResetLastError();
    #####:22526:        if (mem_base != xmlMemBlocks()) {
    #####:22527:            printf("Leak of %d blocks found in xmlNodeGetSpacePreserve",
    #####:22528:	           xmlMemBlocks() - mem_base);
    #####:22529:	    test_ret++;
    #####:22530:            printf(" %d", n_cur);
    #####:22531:            printf("\n");
        -:22532:        }
        -:22533:    }
    #####:22534:    function_tests++;
        -:22535:
    #####:22536:    return(test_ret);
        -:22537:}
        -:22538:
        -:22539:
        -:22540:static int
    #####:22541:test_xmlNodeIsText(void) {
    #####:22542:    int test_ret = 0;
        -:22543:
        -:22544:    int mem_base;
        -:22545:    int ret_val;
        -:22546:    xmlNode * node; /* the node */
        -:22547:    int n_node;
        -:22548:
    #####:22549:    for (n_node = 0;n_node < gen_nb_const_xmlNode_ptr;n_node++) {
    #####:22550:        mem_base = xmlMemBlocks();
    #####:22551:        node = gen_const_xmlNode_ptr(n_node, 0);
        -:22552:
    #####:22553:        ret_val = xmlNodeIsText((const xmlNode *)node);
    #####:22554:        desret_int(ret_val);
    #####:22555:        call_tests++;
    #####:22556:        des_const_xmlNode_ptr(n_node, (const xmlNode *)node, 0);
    #####:22557:        xmlResetLastError();
    #####:22558:        if (mem_base != xmlMemBlocks()) {
    #####:22559:            printf("Leak of %d blocks found in xmlNodeIsText",
    #####:22560:	           xmlMemBlocks() - mem_base);
    #####:22561:	    test_ret++;
    #####:22562:            printf(" %d", n_node);
    #####:22563:            printf("\n");
        -:22564:        }
        -:22565:    }
    #####:22566:    function_tests++;
        -:22567:
    #####:22568:    return(test_ret);
        -:22569:}
        -:22570:
        -:22571:
        -:22572:static int
    #####:22573:test_xmlNodeListGetRawString(void) {
    #####:22574:    int test_ret = 0;
        -:22575:
        -:22576:#if defined(LIBXML_TREE_ENABLED)
        -:22577:    int mem_base;
        -:22578:    xmlChar * ret_val;
        -:22579:    xmlDoc * doc; /* the document */
        -:22580:    int n_doc;
        -:22581:    xmlNode * list; /* a Node list */
        -:22582:    int n_list;
        -:22583:    int inLine; /* should we replace entity contents or show their external form */
        -:22584:    int n_inLine;
        -:22585:
    #####:22586:    for (n_doc = 0;n_doc < gen_nb_const_xmlDoc_ptr;n_doc++) {
    #####:22587:    for (n_list = 0;n_list < gen_nb_const_xmlNode_ptr;n_list++) {
    #####:22588:    for (n_inLine = 0;n_inLine < gen_nb_int;n_inLine++) {
    #####:22589:        mem_base = xmlMemBlocks();
    #####:22590:        doc = gen_const_xmlDoc_ptr(n_doc, 0);
    #####:22591:        list = gen_const_xmlNode_ptr(n_list, 1);
    #####:22592:        inLine = gen_int(n_inLine, 2);
        -:22593:
    #####:22594:        ret_val = xmlNodeListGetRawString((const xmlDoc *)doc, (const xmlNode *)list, inLine);
    #####:22595:        desret_xmlChar_ptr(ret_val);
    #####:22596:        call_tests++;
    #####:22597:        des_const_xmlDoc_ptr(n_doc, (const xmlDoc *)doc, 0);
    #####:22598:        des_const_xmlNode_ptr(n_list, (const xmlNode *)list, 1);
    #####:22599:        des_int(n_inLine, inLine, 2);
    #####:22600:        xmlResetLastError();
    #####:22601:        if (mem_base != xmlMemBlocks()) {
    #####:22602:            printf("Leak of %d blocks found in xmlNodeListGetRawString",
    #####:22603:	           xmlMemBlocks() - mem_base);
    #####:22604:	    test_ret++;
    #####:22605:            printf(" %d", n_doc);
    #####:22606:            printf(" %d", n_list);
    #####:22607:            printf(" %d", n_inLine);
    #####:22608:            printf("\n");
        -:22609:        }
        -:22610:    }
        -:22611:    }
        -:22612:    }
    #####:22613:    function_tests++;
        -:22614:#endif
        -:22615:
    #####:22616:    return(test_ret);
        -:22617:}
        -:22618:
        -:22619:
        -:22620:static int
    #####:22621:test_xmlNodeListGetString(void) {
    #####:22622:    int test_ret = 0;
        -:22623:
        -:22624:    int mem_base;
        -:22625:    xmlChar * ret_val;
        -:22626:    xmlDocPtr doc; /* the document */
        -:22627:    int n_doc;
        -:22628:    xmlNode * list; /* a Node list */
        -:22629:    int n_list;
        -:22630:    int inLine; /* should we replace entity contents or show their external form */
        -:22631:    int n_inLine;
        -:22632:
    #####:22633:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:22634:    for (n_list = 0;n_list < gen_nb_const_xmlNode_ptr;n_list++) {
    #####:22635:    for (n_inLine = 0;n_inLine < gen_nb_int;n_inLine++) {
    #####:22636:        mem_base = xmlMemBlocks();
    #####:22637:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:22638:        list = gen_const_xmlNode_ptr(n_list, 1);
    #####:22639:        inLine = gen_int(n_inLine, 2);
        -:22640:
    #####:22641:        ret_val = xmlNodeListGetString(doc, (const xmlNode *)list, inLine);
    #####:22642:        desret_xmlChar_ptr(ret_val);
    #####:22643:        call_tests++;
    #####:22644:        des_xmlDocPtr(n_doc, doc, 0);
    #####:22645:        des_const_xmlNode_ptr(n_list, (const xmlNode *)list, 1);
    #####:22646:        des_int(n_inLine, inLine, 2);
    #####:22647:        xmlResetLastError();
    #####:22648:        if (mem_base != xmlMemBlocks()) {
    #####:22649:            printf("Leak of %d blocks found in xmlNodeListGetString",
    #####:22650:	           xmlMemBlocks() - mem_base);
    #####:22651:	    test_ret++;
    #####:22652:            printf(" %d", n_doc);
    #####:22653:            printf(" %d", n_list);
    #####:22654:            printf(" %d", n_inLine);
    #####:22655:            printf("\n");
        -:22656:        }
        -:22657:    }
        -:22658:    }
        -:22659:    }
    #####:22660:    function_tests++;
        -:22661:
    #####:22662:    return(test_ret);
        -:22663:}
        -:22664:
        -:22665:
        -:22666:static int
    #####:22667:test_xmlNodeSetBase(void) {
    #####:22668:    int test_ret = 0;
        -:22669:
        -:22670:#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED)
        -:22671:    int mem_base;
        -:22672:    xmlNodePtr cur; /* the node being changed */
        -:22673:    int n_cur;
        -:22674:    xmlChar * uri; /* the new base URI */
        -:22675:    int n_uri;
        -:22676:
    #####:22677:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####:22678:    for (n_uri = 0;n_uri < gen_nb_const_xmlChar_ptr;n_uri++) {
    #####:22679:        mem_base = xmlMemBlocks();
    #####:22680:        cur = gen_xmlNodePtr(n_cur, 0);
    #####:22681:        uri = gen_const_xmlChar_ptr(n_uri, 1);
        -:22682:
    #####:22683:        xmlNodeSetBase(cur, (const xmlChar *)uri);
    #####:22684:        call_tests++;
    #####:22685:        des_xmlNodePtr(n_cur, cur, 0);
    #####:22686:        des_const_xmlChar_ptr(n_uri, (const xmlChar *)uri, 1);
    #####:22687:        xmlResetLastError();
    #####:22688:        if (mem_base != xmlMemBlocks()) {
    #####:22689:            printf("Leak of %d blocks found in xmlNodeSetBase",
    #####:22690:	           xmlMemBlocks() - mem_base);
    #####:22691:	    test_ret++;
    #####:22692:            printf(" %d", n_cur);
    #####:22693:            printf(" %d", n_uri);
    #####:22694:            printf("\n");
        -:22695:        }
        -:22696:    }
        -:22697:    }
    #####:22698:    function_tests++;
        -:22699:#endif
        -:22700:
    #####:22701:    return(test_ret);
        -:22702:}
        -:22703:
        -:22704:
        -:22705:static int
    #####:22706:test_xmlNodeSetContent(void) {
    #####:22707:    int test_ret = 0;
        -:22708:
        -:22709:    int mem_base;
        -:22710:    xmlNodePtr cur; /* the node being modified */
        -:22711:    int n_cur;
        -:22712:    xmlChar * content; /* the new value of the content */
        -:22713:    int n_content;
        -:22714:
    #####:22715:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####:22716:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:22717:        mem_base = xmlMemBlocks();
    #####:22718:        cur = gen_xmlNodePtr(n_cur, 0);
    #####:22719:        content = gen_const_xmlChar_ptr(n_content, 1);
        -:22720:
    #####:22721:        xmlNodeSetContent(cur, (const xmlChar *)content);
    #####:22722:        call_tests++;
    #####:22723:        des_xmlNodePtr(n_cur, cur, 0);
    #####:22724:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
    #####:22725:        xmlResetLastError();
    #####:22726:        if (mem_base != xmlMemBlocks()) {
    #####:22727:            printf("Leak of %d blocks found in xmlNodeSetContent",
    #####:22728:	           xmlMemBlocks() - mem_base);
    #####:22729:	    test_ret++;
    #####:22730:            printf(" %d", n_cur);
    #####:22731:            printf(" %d", n_content);
    #####:22732:            printf("\n");
        -:22733:        }
        -:22734:    }
        -:22735:    }
    #####:22736:    function_tests++;
        -:22737:
    #####:22738:    return(test_ret);
        -:22739:}
        -:22740:
        -:22741:
        -:22742:static int
    #####:22743:test_xmlNodeSetContentLen(void) {
    #####:22744:    int test_ret = 0;
        -:22745:
        -:22746:#if defined(LIBXML_TREE_ENABLED)
        -:22747:    int mem_base;
        -:22748:    xmlNodePtr cur; /* the node being modified */
        -:22749:    int n_cur;
        -:22750:    xmlChar * content; /* the new value of the content */
        -:22751:    int n_content;
        -:22752:    int len; /* the size of @content */
        -:22753:    int n_len;
        -:22754:
    #####:22755:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####:22756:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:22757:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:22758:        mem_base = xmlMemBlocks();
    #####:22759:        cur = gen_xmlNodePtr(n_cur, 0);
    #####:22760:        content = gen_const_xmlChar_ptr(n_content, 1);
    #####:22761:        len = gen_int(n_len, 2);
        -:22762:
    #####:22763:        xmlNodeSetContentLen(cur, (const xmlChar *)content, len);
    #####:22764:        call_tests++;
    #####:22765:        des_xmlNodePtr(n_cur, cur, 0);
    #####:22766:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
    #####:22767:        des_int(n_len, len, 2);
    #####:22768:        xmlResetLastError();
    #####:22769:        if (mem_base != xmlMemBlocks()) {
    #####:22770:            printf("Leak of %d blocks found in xmlNodeSetContentLen",
    #####:22771:	           xmlMemBlocks() - mem_base);
    #####:22772:	    test_ret++;
    #####:22773:            printf(" %d", n_cur);
    #####:22774:            printf(" %d", n_content);
    #####:22775:            printf(" %d", n_len);
    #####:22776:            printf("\n");
        -:22777:        }
        -:22778:    }
        -:22779:    }
        -:22780:    }
    #####:22781:    function_tests++;
        -:22782:#endif
        -:22783:
    #####:22784:    return(test_ret);
        -:22785:}
        -:22786:
        -:22787:
        -:22788:static int
    #####:22789:test_xmlNodeSetLang(void) {
    #####:22790:    int test_ret = 0;
        -:22791:
        -:22792:#if defined(LIBXML_TREE_ENABLED)
        -:22793:    int mem_base;
        -:22794:    xmlNodePtr cur; /* the node being changed */
        -:22795:    int n_cur;
        -:22796:    xmlChar * lang; /* the language description */
        -:22797:    int n_lang;
        -:22798:
    #####:22799:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####:22800:    for (n_lang = 0;n_lang < gen_nb_const_xmlChar_ptr;n_lang++) {
    #####:22801:        mem_base = xmlMemBlocks();
    #####:22802:        cur = gen_xmlNodePtr(n_cur, 0);
    #####:22803:        lang = gen_const_xmlChar_ptr(n_lang, 1);
        -:22804:
    #####:22805:        xmlNodeSetLang(cur, (const xmlChar *)lang);
    #####:22806:        call_tests++;
    #####:22807:        des_xmlNodePtr(n_cur, cur, 0);
    #####:22808:        des_const_xmlChar_ptr(n_lang, (const xmlChar *)lang, 1);
    #####:22809:        xmlResetLastError();
    #####:22810:        if (mem_base != xmlMemBlocks()) {
    #####:22811:            printf("Leak of %d blocks found in xmlNodeSetLang",
    #####:22812:	           xmlMemBlocks() - mem_base);
    #####:22813:	    test_ret++;
    #####:22814:            printf(" %d", n_cur);
    #####:22815:            printf(" %d", n_lang);
    #####:22816:            printf("\n");
        -:22817:        }
        -:22818:    }
        -:22819:    }
    #####:22820:    function_tests++;
        -:22821:#endif
        -:22822:
    #####:22823:    return(test_ret);
        -:22824:}
        -:22825:
        -:22826:
        -:22827:static int
    #####:22828:test_xmlNodeSetName(void) {
    #####:22829:    int test_ret = 0;
        -:22830:
        -:22831:#if defined(LIBXML_TREE_ENABLED)
        -:22832:    int mem_base;
        -:22833:    xmlNodePtr cur; /* the node being changed */
        -:22834:    int n_cur;
        -:22835:    xmlChar * name; /* the new tag name */
        -:22836:    int n_name;
        -:22837:
    #####:22838:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####:22839:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:22840:        mem_base = xmlMemBlocks();
    #####:22841:        cur = gen_xmlNodePtr(n_cur, 0);
    #####:22842:        name = gen_const_xmlChar_ptr(n_name, 1);
        -:22843:
    #####:22844:        xmlNodeSetName(cur, (const xmlChar *)name);
    #####:22845:        call_tests++;
    #####:22846:        des_xmlNodePtr(n_cur, cur, 0);
    #####:22847:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:22848:        xmlResetLastError();
    #####:22849:        if (mem_base != xmlMemBlocks()) {
    #####:22850:            printf("Leak of %d blocks found in xmlNodeSetName",
    #####:22851:	           xmlMemBlocks() - mem_base);
    #####:22852:	    test_ret++;
    #####:22853:            printf(" %d", n_cur);
    #####:22854:            printf(" %d", n_name);
    #####:22855:            printf("\n");
        -:22856:        }
        -:22857:    }
        -:22858:    }
    #####:22859:    function_tests++;
        -:22860:#endif
        -:22861:
    #####:22862:    return(test_ret);
        -:22863:}
        -:22864:
        -:22865:
        -:22866:static int
    #####:22867:test_xmlNodeSetSpacePreserve(void) {
    #####:22868:    int test_ret = 0;
        -:22869:
        -:22870:#if defined(LIBXML_TREE_ENABLED)
        -:22871:    int mem_base;
        -:22872:    xmlNodePtr cur; /* the node being changed */
        -:22873:    int n_cur;
        -:22874:    int val; /* the xml:space value ("0": default, 1: "preserve") */
        -:22875:    int n_val;
        -:22876:
    #####:22877:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####:22878:    for (n_val = 0;n_val < gen_nb_int;n_val++) {
    #####:22879:        mem_base = xmlMemBlocks();
    #####:22880:        cur = gen_xmlNodePtr(n_cur, 0);
    #####:22881:        val = gen_int(n_val, 1);
        -:22882:
    #####:22883:        xmlNodeSetSpacePreserve(cur, val);
    #####:22884:        call_tests++;
    #####:22885:        des_xmlNodePtr(n_cur, cur, 0);
    #####:22886:        des_int(n_val, val, 1);
    #####:22887:        xmlResetLastError();
    #####:22888:        if (mem_base != xmlMemBlocks()) {
    #####:22889:            printf("Leak of %d blocks found in xmlNodeSetSpacePreserve",
    #####:22890:	           xmlMemBlocks() - mem_base);
    #####:22891:	    test_ret++;
    #####:22892:            printf(" %d", n_cur);
    #####:22893:            printf(" %d", n_val);
    #####:22894:            printf("\n");
        -:22895:        }
        -:22896:    }
        -:22897:    }
    #####:22898:    function_tests++;
        -:22899:#endif
        -:22900:
    #####:22901:    return(test_ret);
        -:22902:}
        -:22903:
        -:22904:
        -:22905:static int
    #####:22906:test_xmlPreviousElementSibling(void) {
    #####:22907:    int test_ret = 0;
        -:22908:
        -:22909:#if defined(LIBXML_TREE_ENABLED)
        -:22910:    int mem_base;
        -:22911:    xmlNodePtr ret_val;
        -:22912:    xmlNodePtr node; /* the current node */
        -:22913:    int n_node;
        -:22914:
    #####:22915:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:22916:        mem_base = xmlMemBlocks();
    #####:22917:        node = gen_xmlNodePtr(n_node, 0);
        -:22918:
    #####:22919:        ret_val = xmlPreviousElementSibling(node);
    #####:22920:        desret_xmlNodePtr(ret_val);
    #####:22921:        call_tests++;
    #####:22922:        des_xmlNodePtr(n_node, node, 0);
    #####:22923:        xmlResetLastError();
    #####:22924:        if (mem_base != xmlMemBlocks()) {
    #####:22925:            printf("Leak of %d blocks found in xmlPreviousElementSibling",
    #####:22926:	           xmlMemBlocks() - mem_base);
    #####:22927:	    test_ret++;
    #####:22928:            printf(" %d", n_node);
    #####:22929:            printf("\n");
        -:22930:        }
        -:22931:    }
    #####:22932:    function_tests++;
        -:22933:#endif
        -:22934:
    #####:22935:    return(test_ret);
        -:22936:}
        -:22937:
        -:22938:
        -:22939:static int
    #####:22940:test_xmlReconciliateNs(void) {
    #####:22941:    int test_ret = 0;
        -:22942:
        -:22943:#if defined(LIBXML_TREE_ENABLED)
        -:22944:#ifdef LIBXML_TREE_ENABLED
        -:22945:    int mem_base;
        -:22946:    int ret_val;
        -:22947:    xmlDocPtr doc; /* the document */
        -:22948:    int n_doc;
        -:22949:    xmlNodePtr tree; /* a node defining the subtree to reconciliate */
        -:22950:    int n_tree;
        -:22951:
    #####:22952:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:22953:    for (n_tree = 0;n_tree < gen_nb_xmlNodePtr;n_tree++) {
    #####:22954:        mem_base = xmlMemBlocks();
    #####:22955:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:22956:        tree = gen_xmlNodePtr(n_tree, 1);
        -:22957:
    #####:22958:        ret_val = xmlReconciliateNs(doc, tree);
    #####:22959:        desret_int(ret_val);
    #####:22960:        call_tests++;
    #####:22961:        des_xmlDocPtr(n_doc, doc, 0);
    #####:22962:        des_xmlNodePtr(n_tree, tree, 1);
    #####:22963:        xmlResetLastError();
    #####:22964:        if (mem_base != xmlMemBlocks()) {
    #####:22965:            printf("Leak of %d blocks found in xmlReconciliateNs",
    #####:22966:	           xmlMemBlocks() - mem_base);
    #####:22967:	    test_ret++;
    #####:22968:            printf(" %d", n_doc);
    #####:22969:            printf(" %d", n_tree);
    #####:22970:            printf("\n");
        -:22971:        }
        -:22972:    }
        -:22973:    }
    #####:22974:    function_tests++;
        -:22975:#endif
        -:22976:#endif
        -:22977:
    #####:22978:    return(test_ret);
        -:22979:}
        -:22980:
        -:22981:
        -:22982:static int
    #####:22983:test_xmlRemoveProp(void) {
    #####:22984:    int test_ret = 0;
        -:22985:
        -:22986:    int mem_base;
        -:22987:    int ret_val;
        -:22988:    xmlAttrPtr cur; /* an attribute */
        -:22989:    int n_cur;
        -:22990:
    #####:22991:    for (n_cur = 0;n_cur < gen_nb_xmlAttrPtr;n_cur++) {
    #####:22992:        mem_base = xmlMemBlocks();
    #####:22993:        cur = gen_xmlAttrPtr(n_cur, 0);
        -:22994:
    #####:22995:        ret_val = xmlRemoveProp(cur);
    #####:22996:        cur = NULL;
    #####:22997:        desret_int(ret_val);
    #####:22998:        call_tests++;
    #####:22999:        des_xmlAttrPtr(n_cur, cur, 0);
    #####:23000:        xmlResetLastError();
    #####:23001:        if (mem_base != xmlMemBlocks()) {
    #####:23002:            printf("Leak of %d blocks found in xmlRemoveProp",
    #####:23003:	           xmlMemBlocks() - mem_base);
    #####:23004:	    test_ret++;
    #####:23005:            printf(" %d", n_cur);
    #####:23006:            printf("\n");
        -:23007:        }
        -:23008:    }
    #####:23009:    function_tests++;
        -:23010:
    #####:23011:    return(test_ret);
        -:23012:}
        -:23013:
        -:23014:
        -:23015:static int
    #####:23016:test_xmlReplaceNode(void) {
    #####:23017:    int test_ret = 0;
        -:23018:
        -:23019:#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED)
        -:23020:    int mem_base;
        -:23021:    xmlNodePtr ret_val;
        -:23022:    xmlNodePtr old; /* the old node */
        -:23023:    int n_old;
        -:23024:    xmlNodePtr cur; /* the node */
        -:23025:    int n_cur;
        -:23026:
    #####:23027:    for (n_old = 0;n_old < gen_nb_xmlNodePtr;n_old++) {
    #####:23028:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr_in;n_cur++) {
    #####:23029:        mem_base = xmlMemBlocks();
    #####:23030:        old = gen_xmlNodePtr(n_old, 0);
    #####:23031:        cur = gen_xmlNodePtr_in(n_cur, 1);
        -:23032:
    #####:23033:        ret_val = xmlReplaceNode(old, cur);
    #####:23034:        if (cur != NULL) {
    #####:23035:              xmlUnlinkNode(cur);
    #####:23036:              xmlFreeNode(cur) ; cur = NULL ; }
    #####:23037:          if (old != NULL) {
    #####:23038:              xmlUnlinkNode(old);
    #####:23039:              xmlFreeNode(old) ; old = NULL ; }
    #####:23040:	  ret_val = NULL;
    #####:23041:        desret_xmlNodePtr(ret_val);
    #####:23042:        call_tests++;
    #####:23043:        des_xmlNodePtr(n_old, old, 0);
    #####:23044:        des_xmlNodePtr_in(n_cur, cur, 1);
    #####:23045:        xmlResetLastError();
    #####:23046:        if (mem_base != xmlMemBlocks()) {
    #####:23047:            printf("Leak of %d blocks found in xmlReplaceNode",
    #####:23048:	           xmlMemBlocks() - mem_base);
    #####:23049:	    test_ret++;
    #####:23050:            printf(" %d", n_old);
    #####:23051:            printf(" %d", n_cur);
    #####:23052:            printf("\n");
        -:23053:        }
        -:23054:    }
        -:23055:    }
    #####:23056:    function_tests++;
        -:23057:#endif
        -:23058:
    #####:23059:    return(test_ret);
        -:23060:}
        -:23061:
        -:23062:
        -:23063:static int
    #####:23064:test_xmlSaveFile(void) {
    #####:23065:    int test_ret = 0;
        -:23066:
        -:23067:#if defined(LIBXML_OUTPUT_ENABLED)
        -:23068:    int mem_base;
        -:23069:    int ret_val;
        -:23070:    const char * filename; /* the filename (or URL) */
        -:23071:    int n_filename;
        -:23072:    xmlDocPtr cur; /* the document */
        -:23073:    int n_cur;
        -:23074:
    #####:23075:    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    #####:23076:    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    #####:23077:        mem_base = xmlMemBlocks();
    #####:23078:        filename = gen_fileoutput(n_filename, 0);
    #####:23079:        cur = gen_xmlDocPtr(n_cur, 1);
        -:23080:
    #####:23081:        ret_val = xmlSaveFile(filename, cur);
    #####:23082:        desret_int(ret_val);
    #####:23083:        call_tests++;
    #####:23084:        des_fileoutput(n_filename, filename, 0);
    #####:23085:        des_xmlDocPtr(n_cur, cur, 1);
    #####:23086:        xmlResetLastError();
    #####:23087:        if (mem_base != xmlMemBlocks()) {
    #####:23088:            printf("Leak of %d blocks found in xmlSaveFile",
    #####:23089:	           xmlMemBlocks() - mem_base);
    #####:23090:	    test_ret++;
    #####:23091:            printf(" %d", n_filename);
    #####:23092:            printf(" %d", n_cur);
    #####:23093:            printf("\n");
        -:23094:        }
        -:23095:    }
        -:23096:    }
    #####:23097:    function_tests++;
        -:23098:#endif
        -:23099:
    #####:23100:    return(test_ret);
        -:23101:}
        -:23102:
        -:23103:
        -:23104:static int
    #####:23105:test_xmlSaveFileEnc(void) {
    #####:23106:    int test_ret = 0;
        -:23107:
        -:23108:#if defined(LIBXML_OUTPUT_ENABLED)
        -:23109:    int mem_base;
        -:23110:    int ret_val;
        -:23111:    const char * filename; /* the filename (or URL) */
        -:23112:    int n_filename;
        -:23113:    xmlDocPtr cur; /* the document */
        -:23114:    int n_cur;
        -:23115:    char * encoding; /* the name of an encoding (or NULL) */
        -:23116:    int n_encoding;
        -:23117:
    #####:23118:    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    #####:23119:    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    #####:23120:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####:23121:        mem_base = xmlMemBlocks();
    #####:23122:        filename = gen_fileoutput(n_filename, 0);
    #####:23123:        cur = gen_xmlDocPtr(n_cur, 1);
    #####:23124:        encoding = gen_const_char_ptr(n_encoding, 2);
        -:23125:
    #####:23126:        ret_val = xmlSaveFileEnc(filename, cur, (const char *)encoding);
    #####:23127:        desret_int(ret_val);
    #####:23128:        call_tests++;
    #####:23129:        des_fileoutput(n_filename, filename, 0);
    #####:23130:        des_xmlDocPtr(n_cur, cur, 1);
    #####:23131:        des_const_char_ptr(n_encoding, (const char *)encoding, 2);
    #####:23132:        xmlResetLastError();
    #####:23133:        if (mem_base != xmlMemBlocks()) {
    #####:23134:            printf("Leak of %d blocks found in xmlSaveFileEnc",
    #####:23135:	           xmlMemBlocks() - mem_base);
    #####:23136:	    test_ret++;
    #####:23137:            printf(" %d", n_filename);
    #####:23138:            printf(" %d", n_cur);
    #####:23139:            printf(" %d", n_encoding);
    #####:23140:            printf("\n");
        -:23141:        }
        -:23142:    }
        -:23143:    }
        -:23144:    }
    #####:23145:    function_tests++;
        -:23146:#endif
        -:23147:
    #####:23148:    return(test_ret);
        -:23149:}
        -:23150:
        -:23151:
        -:23152:static int
    #####:23153:test_xmlSaveFileTo(void) {
    #####:23154:    int test_ret = 0;
        -:23155:
        -:23156:#if defined(LIBXML_OUTPUT_ENABLED)
        -:23157:    int mem_base;
        -:23158:    int ret_val;
        -:23159:    xmlOutputBufferPtr buf; /* an output I/O buffer */
        -:23160:    int n_buf;
        -:23161:    xmlDocPtr cur; /* the document */
        -:23162:    int n_cur;
        -:23163:    char * encoding; /* the encoding if any assuming the I/O layer handles the trancoding */
        -:23164:    int n_encoding;
        -:23165:
    #####:23166:    for (n_buf = 0;n_buf < gen_nb_xmlOutputBufferPtr;n_buf++) {
    #####:23167:    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    #####:23168:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####:23169:        mem_base = xmlMemBlocks();
    #####:23170:        buf = gen_xmlOutputBufferPtr(n_buf, 0);
    #####:23171:        cur = gen_xmlDocPtr(n_cur, 1);
    #####:23172:        encoding = gen_const_char_ptr(n_encoding, 2);
        -:23173:
    #####:23174:        ret_val = xmlSaveFileTo(buf, cur, (const char *)encoding);
    #####:23175:        buf = NULL;
    #####:23176:        desret_int(ret_val);
    #####:23177:        call_tests++;
    #####:23178:        des_xmlOutputBufferPtr(n_buf, buf, 0);
    #####:23179:        des_xmlDocPtr(n_cur, cur, 1);
    #####:23180:        des_const_char_ptr(n_encoding, (const char *)encoding, 2);
    #####:23181:        xmlResetLastError();
    #####:23182:        if (mem_base != xmlMemBlocks()) {
    #####:23183:            printf("Leak of %d blocks found in xmlSaveFileTo",
    #####:23184:	           xmlMemBlocks() - mem_base);
    #####:23185:	    test_ret++;
    #####:23186:            printf(" %d", n_buf);
    #####:23187:            printf(" %d", n_cur);
    #####:23188:            printf(" %d", n_encoding);
    #####:23189:            printf("\n");
        -:23190:        }
        -:23191:    }
        -:23192:    }
        -:23193:    }
    #####:23194:    function_tests++;
        -:23195:#endif
        -:23196:
    #####:23197:    return(test_ret);
        -:23198:}
        -:23199:
        -:23200:
        -:23201:static int
    #####:23202:test_xmlSaveFormatFile(void) {
    #####:23203:    int test_ret = 0;
        -:23204:
        -:23205:#if defined(LIBXML_OUTPUT_ENABLED)
        -:23206:    int mem_base;
        -:23207:    int ret_val;
        -:23208:    const char * filename; /* the filename (or URL) */
        -:23209:    int n_filename;
        -:23210:    xmlDocPtr cur; /* the document */
        -:23211:    int n_cur;
        -:23212:    int format; /* should formatting spaces been added */
        -:23213:    int n_format;
        -:23214:
    #####:23215:    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    #####:23216:    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    #####:23217:    for (n_format = 0;n_format < gen_nb_int;n_format++) {
    #####:23218:        mem_base = xmlMemBlocks();
    #####:23219:        filename = gen_fileoutput(n_filename, 0);
    #####:23220:        cur = gen_xmlDocPtr(n_cur, 1);
    #####:23221:        format = gen_int(n_format, 2);
        -:23222:
    #####:23223:        ret_val = xmlSaveFormatFile(filename, cur, format);
    #####:23224:        desret_int(ret_val);
    #####:23225:        call_tests++;
    #####:23226:        des_fileoutput(n_filename, filename, 0);
    #####:23227:        des_xmlDocPtr(n_cur, cur, 1);
    #####:23228:        des_int(n_format, format, 2);
    #####:23229:        xmlResetLastError();
    #####:23230:        if (mem_base != xmlMemBlocks()) {
    #####:23231:            printf("Leak of %d blocks found in xmlSaveFormatFile",
    #####:23232:	           xmlMemBlocks() - mem_base);
    #####:23233:	    test_ret++;
    #####:23234:            printf(" %d", n_filename);
    #####:23235:            printf(" %d", n_cur);
    #####:23236:            printf(" %d", n_format);
    #####:23237:            printf("\n");
        -:23238:        }
        -:23239:    }
        -:23240:    }
        -:23241:    }
    #####:23242:    function_tests++;
        -:23243:#endif
        -:23244:
    #####:23245:    return(test_ret);
        -:23246:}
        -:23247:
        -:23248:
        -:23249:static int
    #####:23250:test_xmlSaveFormatFileEnc(void) {
    #####:23251:    int test_ret = 0;
        -:23252:
        -:23253:#if defined(LIBXML_OUTPUT_ENABLED)
        -:23254:    int mem_base;
        -:23255:    int ret_val;
        -:23256:    const char * filename; /* the filename or URL to output */
        -:23257:    int n_filename;
        -:23258:    xmlDocPtr cur; /* the document being saved */
        -:23259:    int n_cur;
        -:23260:    char * encoding; /* the name of the encoding to use or NULL. */
        -:23261:    int n_encoding;
        -:23262:    int format; /* should formatting spaces be added. */
        -:23263:    int n_format;
        -:23264:
    #####:23265:    for (n_filename = 0;n_filename < gen_nb_fileoutput;n_filename++) {
    #####:23266:    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    #####:23267:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####:23268:    for (n_format = 0;n_format < gen_nb_int;n_format++) {
    #####:23269:        mem_base = xmlMemBlocks();
    #####:23270:        filename = gen_fileoutput(n_filename, 0);
    #####:23271:        cur = gen_xmlDocPtr(n_cur, 1);
    #####:23272:        encoding = gen_const_char_ptr(n_encoding, 2);
    #####:23273:        format = gen_int(n_format, 3);
        -:23274:
    #####:23275:        ret_val = xmlSaveFormatFileEnc(filename, cur, (const char *)encoding, format);
    #####:23276:        desret_int(ret_val);
    #####:23277:        call_tests++;
    #####:23278:        des_fileoutput(n_filename, filename, 0);
    #####:23279:        des_xmlDocPtr(n_cur, cur, 1);
    #####:23280:        des_const_char_ptr(n_encoding, (const char *)encoding, 2);
    #####:23281:        des_int(n_format, format, 3);
    #####:23282:        xmlResetLastError();
    #####:23283:        if (mem_base != xmlMemBlocks()) {
    #####:23284:            printf("Leak of %d blocks found in xmlSaveFormatFileEnc",
    #####:23285:	           xmlMemBlocks() - mem_base);
    #####:23286:	    test_ret++;
    #####:23287:            printf(" %d", n_filename);
    #####:23288:            printf(" %d", n_cur);
    #####:23289:            printf(" %d", n_encoding);
    #####:23290:            printf(" %d", n_format);
    #####:23291:            printf("\n");
        -:23292:        }
        -:23293:    }
        -:23294:    }
        -:23295:    }
        -:23296:    }
    #####:23297:    function_tests++;
        -:23298:#endif
        -:23299:
    #####:23300:    return(test_ret);
        -:23301:}
        -:23302:
        -:23303:
        -:23304:static int
    #####:23305:test_xmlSaveFormatFileTo(void) {
    #####:23306:    int test_ret = 0;
        -:23307:
        -:23308:#if defined(LIBXML_OUTPUT_ENABLED)
        -:23309:    int mem_base;
        -:23310:    int ret_val;
        -:23311:    xmlOutputBufferPtr buf; /* an output I/O buffer */
        -:23312:    int n_buf;
        -:23313:    xmlDocPtr cur; /* the document */
        -:23314:    int n_cur;
        -:23315:    char * encoding; /* the encoding if any assuming the I/O layer handles the trancoding */
        -:23316:    int n_encoding;
        -:23317:    int format; /* should formatting spaces been added */
        -:23318:    int n_format;
        -:23319:
    #####:23320:    for (n_buf = 0;n_buf < gen_nb_xmlOutputBufferPtr;n_buf++) {
    #####:23321:    for (n_cur = 0;n_cur < gen_nb_xmlDocPtr;n_cur++) {
    #####:23322:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####:23323:    for (n_format = 0;n_format < gen_nb_int;n_format++) {
    #####:23324:        mem_base = xmlMemBlocks();
    #####:23325:        buf = gen_xmlOutputBufferPtr(n_buf, 0);
    #####:23326:        cur = gen_xmlDocPtr(n_cur, 1);
    #####:23327:        encoding = gen_const_char_ptr(n_encoding, 2);
    #####:23328:        format = gen_int(n_format, 3);
        -:23329:
    #####:23330:        ret_val = xmlSaveFormatFileTo(buf, cur, (const char *)encoding, format);
    #####:23331:        buf = NULL;
    #####:23332:        desret_int(ret_val);
    #####:23333:        call_tests++;
    #####:23334:        des_xmlOutputBufferPtr(n_buf, buf, 0);
    #####:23335:        des_xmlDocPtr(n_cur, cur, 1);
    #####:23336:        des_const_char_ptr(n_encoding, (const char *)encoding, 2);
    #####:23337:        des_int(n_format, format, 3);
    #####:23338:        xmlResetLastError();
    #####:23339:        if (mem_base != xmlMemBlocks()) {
    #####:23340:            printf("Leak of %d blocks found in xmlSaveFormatFileTo",
    #####:23341:	           xmlMemBlocks() - mem_base);
    #####:23342:	    test_ret++;
    #####:23343:            printf(" %d", n_buf);
    #####:23344:            printf(" %d", n_cur);
    #####:23345:            printf(" %d", n_encoding);
    #####:23346:            printf(" %d", n_format);
    #####:23347:            printf("\n");
        -:23348:        }
        -:23349:    }
        -:23350:    }
        -:23351:    }
        -:23352:    }
    #####:23353:    function_tests++;
        -:23354:#endif
        -:23355:
    #####:23356:    return(test_ret);
        -:23357:}
        -:23358:
        -:23359:
        -:23360:static int
    #####:23361:test_xmlSearchNs(void) {
    #####:23362:    int test_ret = 0;
        -:23363:
        -:23364:    int mem_base;
        -:23365:    xmlNsPtr ret_val;
        -:23366:    xmlDocPtr doc; /* the document */
        -:23367:    int n_doc;
        -:23368:    xmlNodePtr node; /* the current node */
        -:23369:    int n_node;
        -:23370:    xmlChar * nameSpace; /* the namespace prefix */
        -:23371:    int n_nameSpace;
        -:23372:
    #####:23373:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:23374:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:23375:    for (n_nameSpace = 0;n_nameSpace < gen_nb_const_xmlChar_ptr;n_nameSpace++) {
    #####:23376:        mem_base = xmlMemBlocks();
    #####:23377:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:23378:        node = gen_xmlNodePtr(n_node, 1);
    #####:23379:        nameSpace = gen_const_xmlChar_ptr(n_nameSpace, 2);
        -:23380:
    #####:23381:        ret_val = xmlSearchNs(doc, node, (const xmlChar *)nameSpace);
    #####:23382:        desret_xmlNsPtr(ret_val);
    #####:23383:        call_tests++;
    #####:23384:        des_xmlDocPtr(n_doc, doc, 0);
    #####:23385:        des_xmlNodePtr(n_node, node, 1);
    #####:23386:        des_const_xmlChar_ptr(n_nameSpace, (const xmlChar *)nameSpace, 2);
    #####:23387:        xmlResetLastError();
    #####:23388:        if (mem_base != xmlMemBlocks()) {
    #####:23389:            printf("Leak of %d blocks found in xmlSearchNs",
    #####:23390:	           xmlMemBlocks() - mem_base);
    #####:23391:	    test_ret++;
    #####:23392:            printf(" %d", n_doc);
    #####:23393:            printf(" %d", n_node);
    #####:23394:            printf(" %d", n_nameSpace);
    #####:23395:            printf("\n");
        -:23396:        }
        -:23397:    }
        -:23398:    }
        -:23399:    }
    #####:23400:    function_tests++;
        -:23401:
    #####:23402:    return(test_ret);
        -:23403:}
        -:23404:
        -:23405:
        -:23406:static int
    #####:23407:test_xmlSearchNsByHref(void) {
    #####:23408:    int test_ret = 0;
        -:23409:
        -:23410:    int mem_base;
        -:23411:    xmlNsPtr ret_val;
        -:23412:    xmlDocPtr doc; /* the document */
        -:23413:    int n_doc;
        -:23414:    xmlNodePtr node; /* the current node */
        -:23415:    int n_node;
        -:23416:    xmlChar * href; /* the namespace value */
        -:23417:    int n_href;
        -:23418:
    #####:23419:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:23420:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:23421:    for (n_href = 0;n_href < gen_nb_const_xmlChar_ptr;n_href++) {
    #####:23422:        mem_base = xmlMemBlocks();
    #####:23423:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:23424:        node = gen_xmlNodePtr(n_node, 1);
    #####:23425:        href = gen_const_xmlChar_ptr(n_href, 2);
        -:23426:
    #####:23427:        ret_val = xmlSearchNsByHref(doc, node, (const xmlChar *)href);
    #####:23428:        desret_xmlNsPtr(ret_val);
    #####:23429:        call_tests++;
    #####:23430:        des_xmlDocPtr(n_doc, doc, 0);
    #####:23431:        des_xmlNodePtr(n_node, node, 1);
    #####:23432:        des_const_xmlChar_ptr(n_href, (const xmlChar *)href, 2);
    #####:23433:        xmlResetLastError();
    #####:23434:        if (mem_base != xmlMemBlocks()) {
    #####:23435:            printf("Leak of %d blocks found in xmlSearchNsByHref",
    #####:23436:	           xmlMemBlocks() - mem_base);
    #####:23437:	    test_ret++;
    #####:23438:            printf(" %d", n_doc);
    #####:23439:            printf(" %d", n_node);
    #####:23440:            printf(" %d", n_href);
    #####:23441:            printf("\n");
        -:23442:        }
        -:23443:    }
        -:23444:    }
        -:23445:    }
    #####:23446:    function_tests++;
        -:23447:
    #####:23448:    return(test_ret);
        -:23449:}
        -:23450:
        -:23451:
        -:23452:static int
    #####:23453:test_xmlSetBufferAllocationScheme(void) {
    #####:23454:    int test_ret = 0;
        -:23455:
        -:23456:    int mem_base;
        -:23457:    xmlBufferAllocationScheme scheme; /* allocation method to use */
        -:23458:    int n_scheme;
        -:23459:
    #####:23460:    for (n_scheme = 0;n_scheme < gen_nb_xmlBufferAllocationScheme;n_scheme++) {
    #####:23461:        mem_base = xmlMemBlocks();
    #####:23462:        scheme = gen_xmlBufferAllocationScheme(n_scheme, 0);
        -:23463:
    #####:23464:        xmlSetBufferAllocationScheme(scheme);
    #####:23465:        call_tests++;
    #####:23466:        des_xmlBufferAllocationScheme(n_scheme, scheme, 0);
    #####:23467:        xmlResetLastError();
    #####:23468:        if (mem_base != xmlMemBlocks()) {
    #####:23469:            printf("Leak of %d blocks found in xmlSetBufferAllocationScheme",
    #####:23470:	           xmlMemBlocks() - mem_base);
    #####:23471:	    test_ret++;
    #####:23472:            printf(" %d", n_scheme);
    #####:23473:            printf("\n");
        -:23474:        }
        -:23475:    }
    #####:23476:    function_tests++;
        -:23477:
    #####:23478:    return(test_ret);
        -:23479:}
        -:23480:
        -:23481:
        -:23482:static int
    #####:23483:test_xmlSetCompressMode(void) {
    #####:23484:    int test_ret = 0;
        -:23485:
        -:23486:    int mem_base;
        -:23487:    int mode; /* the compression ratio */
        -:23488:    int n_mode;
        -:23489:
    #####:23490:    for (n_mode = 0;n_mode < gen_nb_int;n_mode++) {
    #####:23491:        mem_base = xmlMemBlocks();
    #####:23492:        mode = gen_int(n_mode, 0);
        -:23493:
    #####:23494:        xmlSetCompressMode(mode);
    #####:23495:        call_tests++;
    #####:23496:        des_int(n_mode, mode, 0);
    #####:23497:        xmlResetLastError();
    #####:23498:        if (mem_base != xmlMemBlocks()) {
    #####:23499:            printf("Leak of %d blocks found in xmlSetCompressMode",
    #####:23500:	           xmlMemBlocks() - mem_base);
    #####:23501:	    test_ret++;
    #####:23502:            printf(" %d", n_mode);
    #####:23503:            printf("\n");
        -:23504:        }
        -:23505:    }
    #####:23506:    function_tests++;
        -:23507:
    #####:23508:    return(test_ret);
        -:23509:}
        -:23510:
        -:23511:
        -:23512:static int
    #####:23513:test_xmlSetDocCompressMode(void) {
    #####:23514:    int test_ret = 0;
        -:23515:
        -:23516:    int mem_base;
        -:23517:    xmlDocPtr doc; /* the document */
        -:23518:    int n_doc;
        -:23519:    int mode; /* the compression ratio */
        -:23520:    int n_mode;
        -:23521:
    #####:23522:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:23523:    for (n_mode = 0;n_mode < gen_nb_int;n_mode++) {
    #####:23524:        mem_base = xmlMemBlocks();
    #####:23525:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:23526:        mode = gen_int(n_mode, 1);
        -:23527:
    #####:23528:        xmlSetDocCompressMode(doc, mode);
    #####:23529:        call_tests++;
    #####:23530:        des_xmlDocPtr(n_doc, doc, 0);
    #####:23531:        des_int(n_mode, mode, 1);
    #####:23532:        xmlResetLastError();
    #####:23533:        if (mem_base != xmlMemBlocks()) {
    #####:23534:            printf("Leak of %d blocks found in xmlSetDocCompressMode",
    #####:23535:	           xmlMemBlocks() - mem_base);
    #####:23536:	    test_ret++;
    #####:23537:            printf(" %d", n_doc);
    #####:23538:            printf(" %d", n_mode);
    #####:23539:            printf("\n");
        -:23540:        }
        -:23541:    }
        -:23542:    }
    #####:23543:    function_tests++;
        -:23544:
    #####:23545:    return(test_ret);
        -:23546:}
        -:23547:
        -:23548:
        -:23549:static int
    #####:23550:test_xmlSetNs(void) {
    #####:23551:    int test_ret = 0;
        -:23552:
        -:23553:    int mem_base;
        -:23554:    xmlNodePtr node; /* a node in the document */
        -:23555:    int n_node;
        -:23556:    xmlNsPtr ns; /* a namespace pointer */
        -:23557:    int n_ns;
        -:23558:
    #####:23559:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:23560:    for (n_ns = 0;n_ns < gen_nb_xmlNsPtr;n_ns++) {
    #####:23561:        mem_base = xmlMemBlocks();
    #####:23562:        node = gen_xmlNodePtr(n_node, 0);
    #####:23563:        ns = gen_xmlNsPtr(n_ns, 1);
        -:23564:
    #####:23565:        xmlSetNs(node, ns);
    #####:23566:        call_tests++;
    #####:23567:        des_xmlNodePtr(n_node, node, 0);
    #####:23568:        des_xmlNsPtr(n_ns, ns, 1);
    #####:23569:        xmlResetLastError();
    #####:23570:        if (mem_base != xmlMemBlocks()) {
    #####:23571:            printf("Leak of %d blocks found in xmlSetNs",
    #####:23572:	           xmlMemBlocks() - mem_base);
    #####:23573:	    test_ret++;
    #####:23574:            printf(" %d", n_node);
    #####:23575:            printf(" %d", n_ns);
    #####:23576:            printf("\n");
        -:23577:        }
        -:23578:    }
        -:23579:    }
    #####:23580:    function_tests++;
        -:23581:
    #####:23582:    return(test_ret);
        -:23583:}
        -:23584:
        -:23585:
        -:23586:static int
    #####:23587:test_xmlSetNsProp(void) {
    #####:23588:    int test_ret = 0;
        -:23589:
        -:23590:#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED)
        -:23591:    int mem_base;
        -:23592:    xmlAttrPtr ret_val;
        -:23593:    xmlNodePtr node; /* the node */
        -:23594:    int n_node;
        -:23595:    xmlNsPtr ns; /* the namespace definition */
        -:23596:    int n_ns;
        -:23597:    xmlChar * name; /* the attribute name */
        -:23598:    int n_name;
        -:23599:    xmlChar * value; /* the attribute value */
        -:23600:    int n_value;
        -:23601:
    #####:23602:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:23603:    for (n_ns = 0;n_ns < gen_nb_xmlNsPtr;n_ns++) {
    #####:23604:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:23605:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:23606:        mem_base = xmlMemBlocks();
    #####:23607:        node = gen_xmlNodePtr(n_node, 0);
    #####:23608:        ns = gen_xmlNsPtr(n_ns, 1);
    #####:23609:        name = gen_const_xmlChar_ptr(n_name, 2);
    #####:23610:        value = gen_const_xmlChar_ptr(n_value, 3);
        -:23611:
    #####:23612:        ret_val = xmlSetNsProp(node, ns, (const xmlChar *)name, (const xmlChar *)value);
    #####:23613:        desret_xmlAttrPtr(ret_val);
    #####:23614:        call_tests++;
    #####:23615:        des_xmlNodePtr(n_node, node, 0);
    #####:23616:        des_xmlNsPtr(n_ns, ns, 1);
    #####:23617:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
    #####:23618:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 3);
    #####:23619:        xmlResetLastError();
    #####:23620:        if (mem_base != xmlMemBlocks()) {
    #####:23621:            printf("Leak of %d blocks found in xmlSetNsProp",
    #####:23622:	           xmlMemBlocks() - mem_base);
    #####:23623:	    test_ret++;
    #####:23624:            printf(" %d", n_node);
    #####:23625:            printf(" %d", n_ns);
    #####:23626:            printf(" %d", n_name);
    #####:23627:            printf(" %d", n_value);
    #####:23628:            printf("\n");
        -:23629:        }
        -:23630:    }
        -:23631:    }
        -:23632:    }
        -:23633:    }
    #####:23634:    function_tests++;
        -:23635:#endif
        -:23636:
    #####:23637:    return(test_ret);
        -:23638:}
        -:23639:
        -:23640:
        -:23641:static int
    #####:23642:test_xmlSetProp(void) {
    #####:23643:    int test_ret = 0;
        -:23644:
        -:23645:#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED)
        -:23646:    int mem_base;
        -:23647:    xmlAttrPtr ret_val;
        -:23648:    xmlNodePtr node; /* the node */
        -:23649:    int n_node;
        -:23650:    xmlChar * name; /* the attribute name (a QName) */
        -:23651:    int n_name;
        -:23652:    xmlChar * value; /* the attribute value */
        -:23653:    int n_value;
        -:23654:
    #####:23655:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:23656:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:23657:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:23658:        mem_base = xmlMemBlocks();
    #####:23659:        node = gen_xmlNodePtr(n_node, 0);
    #####:23660:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:23661:        value = gen_const_xmlChar_ptr(n_value, 2);
        -:23662:
    #####:23663:        ret_val = xmlSetProp(node, (const xmlChar *)name, (const xmlChar *)value);
    #####:23664:        desret_xmlAttrPtr(ret_val);
    #####:23665:        call_tests++;
    #####:23666:        des_xmlNodePtr(n_node, node, 0);
    #####:23667:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:23668:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 2);
    #####:23669:        xmlResetLastError();
    #####:23670:        if (mem_base != xmlMemBlocks()) {
    #####:23671:            printf("Leak of %d blocks found in xmlSetProp",
    #####:23672:	           xmlMemBlocks() - mem_base);
    #####:23673:	    test_ret++;
    #####:23674:            printf(" %d", n_node);
    #####:23675:            printf(" %d", n_name);
    #####:23676:            printf(" %d", n_value);
    #####:23677:            printf("\n");
        -:23678:        }
        -:23679:    }
        -:23680:    }
        -:23681:    }
    #####:23682:    function_tests++;
        -:23683:#endif
        -:23684:
    #####:23685:    return(test_ret);
        -:23686:}
        -:23687:
        -:23688:
        -:23689:static int
    #####:23690:test_xmlSplitQName2(void) {
    #####:23691:    int test_ret = 0;
        -:23692:
        -:23693:    int mem_base;
        -:23694:    xmlChar * ret_val;
        -:23695:    xmlChar * name; /* the full QName */
        -:23696:    int n_name;
        -:23697:    xmlChar ** prefix; /* a xmlChar ** */
        -:23698:    int n_prefix;
        -:23699:
    #####:23700:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:23701:    for (n_prefix = 0;n_prefix < gen_nb_xmlChar_ptr_ptr;n_prefix++) {
    #####:23702:        mem_base = xmlMemBlocks();
    #####:23703:        name = gen_const_xmlChar_ptr(n_name, 0);
    #####:23704:        prefix = gen_xmlChar_ptr_ptr(n_prefix, 1);
        -:23705:
    #####:23706:        ret_val = xmlSplitQName2((const xmlChar *)name, prefix);
    #####:23707:        desret_xmlChar_ptr(ret_val);
    #####:23708:        call_tests++;
    #####:23709:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 0);
    #####:23710:        des_xmlChar_ptr_ptr(n_prefix, prefix, 1);
    #####:23711:        xmlResetLastError();
    #####:23712:        if (mem_base != xmlMemBlocks()) {
    #####:23713:            printf("Leak of %d blocks found in xmlSplitQName2",
    #####:23714:	           xmlMemBlocks() - mem_base);
    #####:23715:	    test_ret++;
    #####:23716:            printf(" %d", n_name);
    #####:23717:            printf(" %d", n_prefix);
    #####:23718:            printf("\n");
        -:23719:        }
        -:23720:    }
        -:23721:    }
    #####:23722:    function_tests++;
        -:23723:
    #####:23724:    return(test_ret);
        -:23725:}
        -:23726:
        -:23727:
        -:23728:static int
    #####:23729:test_xmlSplitQName3(void) {
    #####:23730:    int test_ret = 0;
        -:23731:
        -:23732:    int mem_base;
        -:23733:    const xmlChar * ret_val;
        -:23734:    xmlChar * name; /* the full QName */
        -:23735:    int n_name;
        -:23736:    int * len; /* an int * */
        -:23737:    int n_len;
        -:23738:
    #####:23739:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:23740:    for (n_len = 0;n_len < gen_nb_int_ptr;n_len++) {
    #####:23741:        mem_base = xmlMemBlocks();
    #####:23742:        name = gen_const_xmlChar_ptr(n_name, 0);
    #####:23743:        len = gen_int_ptr(n_len, 1);
        -:23744:
    #####:23745:        ret_val = xmlSplitQName3((const xmlChar *)name, len);
    #####:23746:        desret_const_xmlChar_ptr(ret_val);
    #####:23747:        call_tests++;
    #####:23748:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 0);
    #####:23749:        des_int_ptr(n_len, len, 1);
    #####:23750:        xmlResetLastError();
    #####:23751:        if (mem_base != xmlMemBlocks()) {
    #####:23752:            printf("Leak of %d blocks found in xmlSplitQName3",
    #####:23753:	           xmlMemBlocks() - mem_base);
    #####:23754:	    test_ret++;
    #####:23755:            printf(" %d", n_name);
    #####:23756:            printf(" %d", n_len);
    #####:23757:            printf("\n");
        -:23758:        }
        -:23759:    }
        -:23760:    }
    #####:23761:    function_tests++;
        -:23762:
    #####:23763:    return(test_ret);
        -:23764:}
        -:23765:
        -:23766:
        -:23767:static int
    #####:23768:test_xmlStringGetNodeList(void) {
    #####:23769:    int test_ret = 0;
        -:23770:
        -:23771:    int mem_base;
        -:23772:    xmlNodePtr ret_val;
        -:23773:    xmlDoc * doc; /* the document */
        -:23774:    int n_doc;
        -:23775:    xmlChar * value; /* the value of the attribute */
        -:23776:    int n_value;
        -:23777:
    #####:23778:    for (n_doc = 0;n_doc < gen_nb_const_xmlDoc_ptr;n_doc++) {
    #####:23779:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:23780:        mem_base = xmlMemBlocks();
    #####:23781:        doc = gen_const_xmlDoc_ptr(n_doc, 0);
    #####:23782:        value = gen_const_xmlChar_ptr(n_value, 1);
        -:23783:
    #####:23784:        ret_val = xmlStringGetNodeList((const xmlDoc *)doc, (const xmlChar *)value);
    #####:23785:        desret_xmlNodePtr(ret_val);
    #####:23786:        call_tests++;
    #####:23787:        des_const_xmlDoc_ptr(n_doc, (const xmlDoc *)doc, 0);
    #####:23788:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 1);
    #####:23789:        xmlResetLastError();
    #####:23790:        if (mem_base != xmlMemBlocks()) {
    #####:23791:            printf("Leak of %d blocks found in xmlStringGetNodeList",
    #####:23792:	           xmlMemBlocks() - mem_base);
    #####:23793:	    test_ret++;
    #####:23794:            printf(" %d", n_doc);
    #####:23795:            printf(" %d", n_value);
    #####:23796:            printf("\n");
        -:23797:        }
        -:23798:    }
        -:23799:    }
    #####:23800:    function_tests++;
        -:23801:
    #####:23802:    return(test_ret);
        -:23803:}
        -:23804:
        -:23805:
        -:23806:static int
    #####:23807:test_xmlStringLenGetNodeList(void) {
    #####:23808:    int test_ret = 0;
        -:23809:
        -:23810:    int mem_base;
        -:23811:    xmlNodePtr ret_val;
        -:23812:    xmlDoc * doc; /* the document */
        -:23813:    int n_doc;
        -:23814:    xmlChar * value; /* the value of the text */
        -:23815:    int n_value;
        -:23816:    int len; /* the length of the string value */
        -:23817:    int n_len;
        -:23818:
    #####:23819:    for (n_doc = 0;n_doc < gen_nb_const_xmlDoc_ptr;n_doc++) {
    #####:23820:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:23821:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:23822:        mem_base = xmlMemBlocks();
    #####:23823:        doc = gen_const_xmlDoc_ptr(n_doc, 0);
    #####:23824:        value = gen_const_xmlChar_ptr(n_value, 1);
    #####:23825:        len = gen_int(n_len, 2);
        -:23826:
    #####:23827:        ret_val = xmlStringLenGetNodeList((const xmlDoc *)doc, (const xmlChar *)value, len);
    #####:23828:        desret_xmlNodePtr(ret_val);
    #####:23829:        call_tests++;
    #####:23830:        des_const_xmlDoc_ptr(n_doc, (const xmlDoc *)doc, 0);
    #####:23831:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 1);
    #####:23832:        des_int(n_len, len, 2);
    #####:23833:        xmlResetLastError();
    #####:23834:        if (mem_base != xmlMemBlocks()) {
    #####:23835:            printf("Leak of %d blocks found in xmlStringLenGetNodeList",
    #####:23836:	           xmlMemBlocks() - mem_base);
    #####:23837:	    test_ret++;
    #####:23838:            printf(" %d", n_doc);
    #####:23839:            printf(" %d", n_value);
    #####:23840:            printf(" %d", n_len);
    #####:23841:            printf("\n");
        -:23842:        }
        -:23843:    }
        -:23844:    }
        -:23845:    }
    #####:23846:    function_tests++;
        -:23847:
    #####:23848:    return(test_ret);
        -:23849:}
        -:23850:
        -:23851:
        -:23852:static int
    #####:23853:test_xmlTextConcat(void) {
    #####:23854:    int test_ret = 0;
        -:23855:
        -:23856:    int mem_base;
        -:23857:    int ret_val;
        -:23858:    xmlNodePtr node; /* the node */
        -:23859:    int n_node;
        -:23860:    xmlChar * content; /* the content */
        -:23861:    int n_content;
        -:23862:    int len; /* @content length */
        -:23863:    int n_len;
        -:23864:
    #####:23865:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:23866:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:23867:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:23868:        mem_base = xmlMemBlocks();
    #####:23869:        node = gen_xmlNodePtr(n_node, 0);
    #####:23870:        content = gen_const_xmlChar_ptr(n_content, 1);
    #####:23871:        len = gen_int(n_len, 2);
        -:23872:
    #####:23873:        ret_val = xmlTextConcat(node, (const xmlChar *)content, len);
    #####:23874:        desret_int(ret_val);
    #####:23875:        call_tests++;
    #####:23876:        des_xmlNodePtr(n_node, node, 0);
    #####:23877:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
    #####:23878:        des_int(n_len, len, 2);
    #####:23879:        xmlResetLastError();
    #####:23880:        if (mem_base != xmlMemBlocks()) {
    #####:23881:            printf("Leak of %d blocks found in xmlTextConcat",
    #####:23882:	           xmlMemBlocks() - mem_base);
    #####:23883:	    test_ret++;
    #####:23884:            printf(" %d", n_node);
    #####:23885:            printf(" %d", n_content);
    #####:23886:            printf(" %d", n_len);
    #####:23887:            printf("\n");
        -:23888:        }
        -:23889:    }
        -:23890:    }
        -:23891:    }
    #####:23892:    function_tests++;
        -:23893:
    #####:23894:    return(test_ret);
        -:23895:}
        -:23896:
        -:23897:
        -:23898:static int
    #####:23899:test_xmlTextMerge(void) {
    #####:23900:    int test_ret = 0;
        -:23901:
        -:23902:    int mem_base;
        -:23903:    xmlNodePtr ret_val;
        -:23904:    xmlNodePtr first; /* the first text node */
        -:23905:    int n_first;
        -:23906:    xmlNodePtr second; /* the second text node being merged */
        -:23907:    int n_second;
        -:23908:
    #####:23909:    for (n_first = 0;n_first < gen_nb_xmlNodePtr_in;n_first++) {
    #####:23910:    for (n_second = 0;n_second < gen_nb_xmlNodePtr_in;n_second++) {
    #####:23911:        mem_base = xmlMemBlocks();
    #####:23912:        first = gen_xmlNodePtr_in(n_first, 0);
    #####:23913:        second = gen_xmlNodePtr_in(n_second, 1);
        -:23914:
    #####:23915:        ret_val = xmlTextMerge(first, second);
    #####:23916:        if ((first != NULL) && (first->type != XML_TEXT_NODE)) {
    #####:23917:              xmlUnlinkNode(second);
    #####:23918:              xmlFreeNode(second) ; second = NULL ; }
    #####:23919:        desret_xmlNodePtr(ret_val);
    #####:23920:        call_tests++;
    #####:23921:        des_xmlNodePtr_in(n_first, first, 0);
    #####:23922:        des_xmlNodePtr_in(n_second, second, 1);
    #####:23923:        xmlResetLastError();
    #####:23924:        if (mem_base != xmlMemBlocks()) {
    #####:23925:            printf("Leak of %d blocks found in xmlTextMerge",
    #####:23926:	           xmlMemBlocks() - mem_base);
    #####:23927:	    test_ret++;
    #####:23928:            printf(" %d", n_first);
    #####:23929:            printf(" %d", n_second);
    #####:23930:            printf("\n");
        -:23931:        }
        -:23932:    }
        -:23933:    }
    #####:23934:    function_tests++;
        -:23935:
    #####:23936:    return(test_ret);
        -:23937:}
        -:23938:
        -:23939:
        -:23940:static int
    #####:23941:test_xmlUnsetNsProp(void) {
    #####:23942:    int test_ret = 0;
        -:23943:
        -:23944:#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
        -:23945:    int mem_base;
        -:23946:    int ret_val;
        -:23947:    xmlNodePtr node; /* the node */
        -:23948:    int n_node;
        -:23949:    xmlNsPtr ns; /* the namespace definition */
        -:23950:    int n_ns;
        -:23951:    xmlChar * name; /* the attribute name */
        -:23952:    int n_name;
        -:23953:
    #####:23954:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:23955:    for (n_ns = 0;n_ns < gen_nb_xmlNsPtr;n_ns++) {
    #####:23956:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:23957:        mem_base = xmlMemBlocks();
    #####:23958:        node = gen_xmlNodePtr(n_node, 0);
    #####:23959:        ns = gen_xmlNsPtr(n_ns, 1);
    #####:23960:        name = gen_const_xmlChar_ptr(n_name, 2);
        -:23961:
    #####:23962:        ret_val = xmlUnsetNsProp(node, ns, (const xmlChar *)name);
    #####:23963:        desret_int(ret_val);
    #####:23964:        call_tests++;
    #####:23965:        des_xmlNodePtr(n_node, node, 0);
    #####:23966:        des_xmlNsPtr(n_ns, ns, 1);
    #####:23967:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
    #####:23968:        xmlResetLastError();
    #####:23969:        if (mem_base != xmlMemBlocks()) {
    #####:23970:            printf("Leak of %d blocks found in xmlUnsetNsProp",
    #####:23971:	           xmlMemBlocks() - mem_base);
    #####:23972:	    test_ret++;
    #####:23973:            printf(" %d", n_node);
    #####:23974:            printf(" %d", n_ns);
    #####:23975:            printf(" %d", n_name);
    #####:23976:            printf("\n");
        -:23977:        }
        -:23978:    }
        -:23979:    }
        -:23980:    }
    #####:23981:    function_tests++;
        -:23982:#endif
        -:23983:
    #####:23984:    return(test_ret);
        -:23985:}
        -:23986:
        -:23987:
        -:23988:static int
    #####:23989:test_xmlUnsetProp(void) {
    #####:23990:    int test_ret = 0;
        -:23991:
        -:23992:#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
        -:23993:    int mem_base;
        -:23994:    int ret_val;
        -:23995:    xmlNodePtr node; /* the node */
        -:23996:    int n_node;
        -:23997:    xmlChar * name; /* the attribute name */
        -:23998:    int n_name;
        -:23999:
    #####:24000:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:24001:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:24002:        mem_base = xmlMemBlocks();
    #####:24003:        node = gen_xmlNodePtr(n_node, 0);
    #####:24004:        name = gen_const_xmlChar_ptr(n_name, 1);
        -:24005:
    #####:24006:        ret_val = xmlUnsetProp(node, (const xmlChar *)name);
    #####:24007:        desret_int(ret_val);
    #####:24008:        call_tests++;
    #####:24009:        des_xmlNodePtr(n_node, node, 0);
    #####:24010:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:24011:        xmlResetLastError();
    #####:24012:        if (mem_base != xmlMemBlocks()) {
    #####:24013:            printf("Leak of %d blocks found in xmlUnsetProp",
    #####:24014:	           xmlMemBlocks() - mem_base);
    #####:24015:	    test_ret++;
    #####:24016:            printf(" %d", n_node);
    #####:24017:            printf(" %d", n_name);
    #####:24018:            printf("\n");
        -:24019:        }
        -:24020:    }
        -:24021:    }
    #####:24022:    function_tests++;
        -:24023:#endif
        -:24024:
    #####:24025:    return(test_ret);
        -:24026:}
        -:24027:
        -:24028:
        -:24029:static int
    #####:24030:test_xmlValidateNCName(void) {
    #####:24031:    int test_ret = 0;
        -:24032:
        -:24033:#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_DEBUG_ENABLED) || defined (LIBXML_HTML_ENABLED) || defined(LIBXML_SAX1_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_WRITER_ENABLED) || defined(LIBXML_DOCB_ENABLED) || defined(LIBXML_LEGACY_ENABLED)
        -:24034:#ifdef LIBXML_TREE_ENABLED
        -:24035:    int mem_base;
        -:24036:    int ret_val;
        -:24037:    xmlChar * value; /* the value to check */
        -:24038:    int n_value;
        -:24039:    int space; /* allow spaces in front and end of the string */
        -:24040:    int n_space;
        -:24041:
    #####:24042:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:24043:    for (n_space = 0;n_space < gen_nb_int;n_space++) {
    #####:24044:        mem_base = xmlMemBlocks();
    #####:24045:        value = gen_const_xmlChar_ptr(n_value, 0);
    #####:24046:        space = gen_int(n_space, 1);
        -:24047:
    #####:24048:        ret_val = xmlValidateNCName((const xmlChar *)value, space);
    #####:24049:        desret_int(ret_val);
    #####:24050:        call_tests++;
    #####:24051:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 0);
    #####:24052:        des_int(n_space, space, 1);
    #####:24053:        xmlResetLastError();
    #####:24054:        if (mem_base != xmlMemBlocks()) {
    #####:24055:            printf("Leak of %d blocks found in xmlValidateNCName",
    #####:24056:	           xmlMemBlocks() - mem_base);
    #####:24057:	    test_ret++;
    #####:24058:            printf(" %d", n_value);
    #####:24059:            printf(" %d", n_space);
    #####:24060:            printf("\n");
        -:24061:        }
        -:24062:    }
        -:24063:    }
    #####:24064:    function_tests++;
        -:24065:#endif
        -:24066:#endif
        -:24067:
    #####:24068:    return(test_ret);
        -:24069:}
        -:24070:
        -:24071:
        -:24072:static int
    #####:24073:test_xmlValidateNMToken(void) {
    #####:24074:    int test_ret = 0;
        -:24075:
        -:24076:#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
        -:24077:#ifdef LIBXML_TREE_ENABLED
        -:24078:    int mem_base;
        -:24079:    int ret_val;
        -:24080:    xmlChar * value; /* the value to check */
        -:24081:    int n_value;
        -:24082:    int space; /* allow spaces in front and end of the string */
        -:24083:    int n_space;
        -:24084:
    #####:24085:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:24086:    for (n_space = 0;n_space < gen_nb_int;n_space++) {
    #####:24087:        mem_base = xmlMemBlocks();
    #####:24088:        value = gen_const_xmlChar_ptr(n_value, 0);
    #####:24089:        space = gen_int(n_space, 1);
        -:24090:
    #####:24091:        ret_val = xmlValidateNMToken((const xmlChar *)value, space);
    #####:24092:        desret_int(ret_val);
    #####:24093:        call_tests++;
    #####:24094:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 0);
    #####:24095:        des_int(n_space, space, 1);
    #####:24096:        xmlResetLastError();
    #####:24097:        if (mem_base != xmlMemBlocks()) {
    #####:24098:            printf("Leak of %d blocks found in xmlValidateNMToken",
    #####:24099:	           xmlMemBlocks() - mem_base);
    #####:24100:	    test_ret++;
    #####:24101:            printf(" %d", n_value);
    #####:24102:            printf(" %d", n_space);
    #####:24103:            printf("\n");
        -:24104:        }
        -:24105:    }
        -:24106:    }
    #####:24107:    function_tests++;
        -:24108:#endif
        -:24109:#endif
        -:24110:
    #####:24111:    return(test_ret);
        -:24112:}
        -:24113:
        -:24114:
        -:24115:static int
    #####:24116:test_xmlValidateName(void) {
    #####:24117:    int test_ret = 0;
        -:24118:
        -:24119:#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
        -:24120:#ifdef LIBXML_TREE_ENABLED
        -:24121:    int mem_base;
        -:24122:    int ret_val;
        -:24123:    xmlChar * value; /* the value to check */
        -:24124:    int n_value;
        -:24125:    int space; /* allow spaces in front and end of the string */
        -:24126:    int n_space;
        -:24127:
    #####:24128:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:24129:    for (n_space = 0;n_space < gen_nb_int;n_space++) {
    #####:24130:        mem_base = xmlMemBlocks();
    #####:24131:        value = gen_const_xmlChar_ptr(n_value, 0);
    #####:24132:        space = gen_int(n_space, 1);
        -:24133:
    #####:24134:        ret_val = xmlValidateName((const xmlChar *)value, space);
    #####:24135:        desret_int(ret_val);
    #####:24136:        call_tests++;
    #####:24137:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 0);
    #####:24138:        des_int(n_space, space, 1);
    #####:24139:        xmlResetLastError();
    #####:24140:        if (mem_base != xmlMemBlocks()) {
    #####:24141:            printf("Leak of %d blocks found in xmlValidateName",
    #####:24142:	           xmlMemBlocks() - mem_base);
    #####:24143:	    test_ret++;
    #####:24144:            printf(" %d", n_value);
    #####:24145:            printf(" %d", n_space);
    #####:24146:            printf("\n");
        -:24147:        }
        -:24148:    }
        -:24149:    }
    #####:24150:    function_tests++;
        -:24151:#endif
        -:24152:#endif
        -:24153:
    #####:24154:    return(test_ret);
        -:24155:}
        -:24156:
        -:24157:
        -:24158:static int
    #####:24159:test_xmlValidateQName(void) {
    #####:24160:    int test_ret = 0;
        -:24161:
        -:24162:#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
        -:24163:#ifdef LIBXML_TREE_ENABLED
        -:24164:    int mem_base;
        -:24165:    int ret_val;
        -:24166:    xmlChar * value; /* the value to check */
        -:24167:    int n_value;
        -:24168:    int space; /* allow spaces in front and end of the string */
        -:24169:    int n_space;
        -:24170:
    #####:24171:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:24172:    for (n_space = 0;n_space < gen_nb_int;n_space++) {
    #####:24173:        mem_base = xmlMemBlocks();
    #####:24174:        value = gen_const_xmlChar_ptr(n_value, 0);
    #####:24175:        space = gen_int(n_space, 1);
        -:24176:
    #####:24177:        ret_val = xmlValidateQName((const xmlChar *)value, space);
    #####:24178:        desret_int(ret_val);
    #####:24179:        call_tests++;
    #####:24180:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 0);
    #####:24181:        des_int(n_space, space, 1);
    #####:24182:        xmlResetLastError();
    #####:24183:        if (mem_base != xmlMemBlocks()) {
    #####:24184:            printf("Leak of %d blocks found in xmlValidateQName",
    #####:24185:	           xmlMemBlocks() - mem_base);
    #####:24186:	    test_ret++;
    #####:24187:            printf(" %d", n_value);
    #####:24188:            printf(" %d", n_space);
    #####:24189:            printf("\n");
        -:24190:        }
        -:24191:    }
        -:24192:    }
    #####:24193:    function_tests++;
        -:24194:#endif
        -:24195:#endif
        -:24196:
    #####:24197:    return(test_ret);
        -:24198:}
        -:24199:
        -:24200:static int
    #####:24201:test_tree(void) {
    #####:24202:    int test_ret = 0;
        -:24203:
    #####:24204:    if (quiet == 0) printf("Testing tree : 142 of 164 functions ...\n");
    #####:24205:    test_ret += test_xmlAddChild();
    #####:24206:    test_ret += test_xmlAddChildList();
    #####:24207:    test_ret += test_xmlAddNextSibling();
    #####:24208:    test_ret += test_xmlAddPrevSibling();
    #####:24209:    test_ret += test_xmlAddSibling();
    #####:24210:    test_ret += test_xmlAttrSerializeTxtContent();
    #####:24211:    test_ret += test_xmlBufContent();
    #####:24212:    test_ret += test_xmlBufEnd();
    #####:24213:    test_ret += test_xmlBufGetNodeContent();
    #####:24214:    test_ret += test_xmlBufNodeDump();
    #####:24215:    test_ret += test_xmlBufShrink();
    #####:24216:    test_ret += test_xmlBufUse();
    #####:24217:    test_ret += test_xmlBufferAdd();
    #####:24218:    test_ret += test_xmlBufferAddHead();
    #####:24219:    test_ret += test_xmlBufferCCat();
    #####:24220:    test_ret += test_xmlBufferCat();
    #####:24221:    test_ret += test_xmlBufferContent();
    #####:24222:    test_ret += test_xmlBufferCreate();
    #####:24223:    test_ret += test_xmlBufferCreateSize();
    #####:24224:    test_ret += test_xmlBufferCreateStatic();
    #####:24225:    test_ret += test_xmlBufferDetach();
    #####:24226:    test_ret += test_xmlBufferEmpty();
    #####:24227:    test_ret += test_xmlBufferGrow();
    #####:24228:    test_ret += test_xmlBufferLength();
    #####:24229:    test_ret += test_xmlBufferResize();
    #####:24230:    test_ret += test_xmlBufferSetAllocationScheme();
    #####:24231:    test_ret += test_xmlBufferShrink();
    #####:24232:    test_ret += test_xmlBufferWriteCHAR();
    #####:24233:    test_ret += test_xmlBufferWriteChar();
    #####:24234:    test_ret += test_xmlBufferWriteQuotedString();
    #####:24235:    test_ret += test_xmlBuildQName();
    #####:24236:    test_ret += test_xmlChildElementCount();
    #####:24237:    test_ret += test_xmlCopyDoc();
    #####:24238:    test_ret += test_xmlCopyDtd();
    #####:24239:    test_ret += test_xmlCopyNamespace();
    #####:24240:    test_ret += test_xmlCopyNamespaceList();
    #####:24241:    test_ret += test_xmlCopyNode();
    #####:24242:    test_ret += test_xmlCopyNodeList();
    #####:24243:    test_ret += test_xmlCopyProp();
    #####:24244:    test_ret += test_xmlCopyPropList();
    #####:24245:    test_ret += test_xmlCreateIntSubset();
    #####:24246:    test_ret += test_xmlDOMWrapAdoptNode();
    #####:24247:    test_ret += test_xmlDOMWrapCloneNode();
    #####:24248:    test_ret += test_xmlDOMWrapNewCtxt();
    #####:24249:    test_ret += test_xmlDOMWrapReconcileNamespaces();
    #####:24250:    test_ret += test_xmlDOMWrapRemoveNode();
    #####:24251:    test_ret += test_xmlDocCopyNode();
    #####:24252:    test_ret += test_xmlDocCopyNodeList();
    #####:24253:    test_ret += test_xmlDocDump();
    #####:24254:    test_ret += test_xmlDocDumpFormatMemory();
    #####:24255:    test_ret += test_xmlDocDumpFormatMemoryEnc();
    #####:24256:    test_ret += test_xmlDocDumpMemory();
    #####:24257:    test_ret += test_xmlDocDumpMemoryEnc();
    #####:24258:    test_ret += test_xmlDocFormatDump();
    #####:24259:    test_ret += test_xmlDocGetRootElement();
    #####:24260:    test_ret += test_xmlDocSetRootElement();
    #####:24261:    test_ret += test_xmlElemDump();
    #####:24262:    test_ret += test_xmlFirstElementChild();
    #####:24263:    test_ret += test_xmlGetBufferAllocationScheme();
    #####:24264:    test_ret += test_xmlGetCompressMode();
    #####:24265:    test_ret += test_xmlGetDocCompressMode();
    #####:24266:    test_ret += test_xmlGetIntSubset();
    #####:24267:    test_ret += test_xmlGetLastChild();
    #####:24268:    test_ret += test_xmlGetLineNo();
    #####:24269:    test_ret += test_xmlGetNoNsProp();
    #####:24270:    test_ret += test_xmlGetNodePath();
    #####:24271:    test_ret += test_xmlGetNsList();
    #####:24272:    test_ret += test_xmlGetNsProp();
    #####:24273:    test_ret += test_xmlGetProp();
    #####:24274:    test_ret += test_xmlHasNsProp();
    #####:24275:    test_ret += test_xmlHasProp();
    #####:24276:    test_ret += test_xmlIsBlankNode();
    #####:24277:    test_ret += test_xmlIsXHTML();
    #####:24278:    test_ret += test_xmlLastElementChild();
    #####:24279:    test_ret += test_xmlNewCDataBlock();
    #####:24280:    test_ret += test_xmlNewCharRef();
    #####:24281:    test_ret += test_xmlNewChild();
    #####:24282:    test_ret += test_xmlNewComment();
    #####:24283:    test_ret += test_xmlNewDoc();
    #####:24284:    test_ret += test_xmlNewDocComment();
    #####:24285:    test_ret += test_xmlNewDocFragment();
    #####:24286:    test_ret += test_xmlNewDocNode();
    #####:24287:    test_ret += test_xmlNewDocNodeEatName();
    #####:24288:    test_ret += test_xmlNewDocPI();
    #####:24289:    test_ret += test_xmlNewDocProp();
    #####:24290:    test_ret += test_xmlNewDocRawNode();
    #####:24291:    test_ret += test_xmlNewDocText();
    #####:24292:    test_ret += test_xmlNewDocTextLen();
    #####:24293:    test_ret += test_xmlNewDtd();
    #####:24294:    test_ret += test_xmlNewNode();
    #####:24295:    test_ret += test_xmlNewNodeEatName();
    #####:24296:    test_ret += test_xmlNewNs();
    #####:24297:    test_ret += test_xmlNewNsProp();
    #####:24298:    test_ret += test_xmlNewNsPropEatName();
    #####:24299:    test_ret += test_xmlNewPI();
    #####:24300:    test_ret += test_xmlNewProp();
    #####:24301:    test_ret += test_xmlNewReference();
    #####:24302:    test_ret += test_xmlNewText();
    #####:24303:    test_ret += test_xmlNewTextChild();
    #####:24304:    test_ret += test_xmlNewTextLen();
    #####:24305:    test_ret += test_xmlNextElementSibling();
    #####:24306:    test_ret += test_xmlNodeAddContent();
    #####:24307:    test_ret += test_xmlNodeAddContentLen();
    #####:24308:    test_ret += test_xmlNodeBufGetContent();
    #####:24309:    test_ret += test_xmlNodeDump();
    #####:24310:    test_ret += test_xmlNodeDumpOutput();
    #####:24311:    test_ret += test_xmlNodeGetBase();
    #####:24312:    test_ret += test_xmlNodeGetContent();
    #####:24313:    test_ret += test_xmlNodeGetLang();
    #####:24314:    test_ret += test_xmlNodeGetSpacePreserve();
    #####:24315:    test_ret += test_xmlNodeIsText();
    #####:24316:    test_ret += test_xmlNodeListGetRawString();
    #####:24317:    test_ret += test_xmlNodeListGetString();
    #####:24318:    test_ret += test_xmlNodeSetBase();
    #####:24319:    test_ret += test_xmlNodeSetContent();
    #####:24320:    test_ret += test_xmlNodeSetContentLen();
    #####:24321:    test_ret += test_xmlNodeSetLang();
    #####:24322:    test_ret += test_xmlNodeSetName();
    #####:24323:    test_ret += test_xmlNodeSetSpacePreserve();
    #####:24324:    test_ret += test_xmlPreviousElementSibling();
    #####:24325:    test_ret += test_xmlReconciliateNs();
    #####:24326:    test_ret += test_xmlRemoveProp();
    #####:24327:    test_ret += test_xmlReplaceNode();
    #####:24328:    test_ret += test_xmlSaveFile();
    #####:24329:    test_ret += test_xmlSaveFileEnc();
    #####:24330:    test_ret += test_xmlSaveFileTo();
    #####:24331:    test_ret += test_xmlSaveFormatFile();
    #####:24332:    test_ret += test_xmlSaveFormatFileEnc();
    #####:24333:    test_ret += test_xmlSaveFormatFileTo();
    #####:24334:    test_ret += test_xmlSearchNs();
    #####:24335:    test_ret += test_xmlSearchNsByHref();
    #####:24336:    test_ret += test_xmlSetBufferAllocationScheme();
    #####:24337:    test_ret += test_xmlSetCompressMode();
    #####:24338:    test_ret += test_xmlSetDocCompressMode();
    #####:24339:    test_ret += test_xmlSetNs();
    #####:24340:    test_ret += test_xmlSetNsProp();
    #####:24341:    test_ret += test_xmlSetProp();
    #####:24342:    test_ret += test_xmlSplitQName2();
    #####:24343:    test_ret += test_xmlSplitQName3();
    #####:24344:    test_ret += test_xmlStringGetNodeList();
    #####:24345:    test_ret += test_xmlStringLenGetNodeList();
    #####:24346:    test_ret += test_xmlTextConcat();
    #####:24347:    test_ret += test_xmlTextMerge();
    #####:24348:    test_ret += test_xmlUnsetNsProp();
    #####:24349:    test_ret += test_xmlUnsetProp();
    #####:24350:    test_ret += test_xmlValidateNCName();
    #####:24351:    test_ret += test_xmlValidateNMToken();
    #####:24352:    test_ret += test_xmlValidateName();
    #####:24353:    test_ret += test_xmlValidateQName();
        -:24354:
    #####:24355:    if (test_ret != 0)
    #####:24356:	printf("Module tree: %d errors\n", test_ret);
    #####:24357:    return(test_ret);
        -:24358:}
        -:24359:
        -:24360:static int
    #####:24361:test_xmlBuildRelativeURI(void) {
    #####:24362:    int test_ret = 0;
        -:24363:
        -:24364:    int mem_base;
        -:24365:    xmlChar * ret_val;
        -:24366:    xmlChar * URI; /* the URI reference under consideration */
        -:24367:    int n_URI;
        -:24368:    xmlChar * base; /* the base value */
        -:24369:    int n_base;
        -:24370:
    #####:24371:    for (n_URI = 0;n_URI < gen_nb_const_xmlChar_ptr;n_URI++) {
    #####:24372:    for (n_base = 0;n_base < gen_nb_const_xmlChar_ptr;n_base++) {
    #####:24373:        mem_base = xmlMemBlocks();
    #####:24374:        URI = gen_const_xmlChar_ptr(n_URI, 0);
    #####:24375:        base = gen_const_xmlChar_ptr(n_base, 1);
        -:24376:
    #####:24377:        ret_val = xmlBuildRelativeURI((const xmlChar *)URI, (const xmlChar *)base);
    #####:24378:        desret_xmlChar_ptr(ret_val);
    #####:24379:        call_tests++;
    #####:24380:        des_const_xmlChar_ptr(n_URI, (const xmlChar *)URI, 0);
    #####:24381:        des_const_xmlChar_ptr(n_base, (const xmlChar *)base, 1);
    #####:24382:        xmlResetLastError();
    #####:24383:        if (mem_base != xmlMemBlocks()) {
    #####:24384:            printf("Leak of %d blocks found in xmlBuildRelativeURI",
    #####:24385:	           xmlMemBlocks() - mem_base);
    #####:24386:	    test_ret++;
    #####:24387:            printf(" %d", n_URI);
    #####:24388:            printf(" %d", n_base);
    #####:24389:            printf("\n");
        -:24390:        }
        -:24391:    }
        -:24392:    }
    #####:24393:    function_tests++;
        -:24394:
    #####:24395:    return(test_ret);
        -:24396:}
        -:24397:
        -:24398:
        -:24399:static int
    #####:24400:test_xmlBuildURI(void) {
    #####:24401:    int test_ret = 0;
        -:24402:
        -:24403:    int mem_base;
        -:24404:    xmlChar * ret_val;
        -:24405:    xmlChar * URI; /* the URI instance found in the document */
        -:24406:    int n_URI;
        -:24407:    xmlChar * base; /* the base value */
        -:24408:    int n_base;
        -:24409:
    #####:24410:    for (n_URI = 0;n_URI < gen_nb_const_xmlChar_ptr;n_URI++) {
    #####:24411:    for (n_base = 0;n_base < gen_nb_const_xmlChar_ptr;n_base++) {
    #####:24412:        mem_base = xmlMemBlocks();
    #####:24413:        URI = gen_const_xmlChar_ptr(n_URI, 0);
    #####:24414:        base = gen_const_xmlChar_ptr(n_base, 1);
        -:24415:
    #####:24416:        ret_val = xmlBuildURI((const xmlChar *)URI, (const xmlChar *)base);
    #####:24417:        desret_xmlChar_ptr(ret_val);
    #####:24418:        call_tests++;
    #####:24419:        des_const_xmlChar_ptr(n_URI, (const xmlChar *)URI, 0);
    #####:24420:        des_const_xmlChar_ptr(n_base, (const xmlChar *)base, 1);
    #####:24421:        xmlResetLastError();
    #####:24422:        if (mem_base != xmlMemBlocks()) {
    #####:24423:            printf("Leak of %d blocks found in xmlBuildURI",
    #####:24424:	           xmlMemBlocks() - mem_base);
    #####:24425:	    test_ret++;
    #####:24426:            printf(" %d", n_URI);
    #####:24427:            printf(" %d", n_base);
    #####:24428:            printf("\n");
        -:24429:        }
        -:24430:    }
        -:24431:    }
    #####:24432:    function_tests++;
        -:24433:
    #####:24434:    return(test_ret);
        -:24435:}
        -:24436:
        -:24437:
        -:24438:static int
    #####:24439:test_xmlCanonicPath(void) {
    #####:24440:    int test_ret = 0;
        -:24441:
        -:24442:    int mem_base;
        -:24443:    xmlChar * ret_val;
        -:24444:    xmlChar * path; /* the resource locator in a filesystem notation */
        -:24445:    int n_path;
        -:24446:
    #####:24447:    for (n_path = 0;n_path < gen_nb_const_xmlChar_ptr;n_path++) {
    #####:24448:        mem_base = xmlMemBlocks();
    #####:24449:        path = gen_const_xmlChar_ptr(n_path, 0);
        -:24450:
    #####:24451:        ret_val = xmlCanonicPath((const xmlChar *)path);
    #####:24452:        desret_xmlChar_ptr(ret_val);
    #####:24453:        call_tests++;
    #####:24454:        des_const_xmlChar_ptr(n_path, (const xmlChar *)path, 0);
    #####:24455:        xmlResetLastError();
    #####:24456:        if (mem_base != xmlMemBlocks()) {
    #####:24457:            printf("Leak of %d blocks found in xmlCanonicPath",
    #####:24458:	           xmlMemBlocks() - mem_base);
    #####:24459:	    test_ret++;
    #####:24460:            printf(" %d", n_path);
    #####:24461:            printf("\n");
        -:24462:        }
        -:24463:    }
    #####:24464:    function_tests++;
        -:24465:
    #####:24466:    return(test_ret);
        -:24467:}
        -:24468:
        -:24469:
        -:24470:static int
    #####:24471:test_xmlCreateURI(void) {
    #####:24472:    int test_ret = 0;
        -:24473:
        -:24474:
        -:24475:    /* missing type support */
    #####:24476:    return(test_ret);
        -:24477:}
        -:24478:
        -:24479:
        -:24480:static int
    #####:24481:test_xmlNormalizeURIPath(void) {
    #####:24482:    int test_ret = 0;
        -:24483:
        -:24484:    int mem_base;
        -:24485:    int ret_val;
        -:24486:    char * path; /* pointer to the path string */
        -:24487:    int n_path;
        -:24488:
    #####:24489:    for (n_path = 0;n_path < gen_nb_char_ptr;n_path++) {
    #####:24490:        mem_base = xmlMemBlocks();
    #####:24491:        path = gen_char_ptr(n_path, 0);
        -:24492:
    #####:24493:        ret_val = xmlNormalizeURIPath(path);
    #####:24494:        desret_int(ret_val);
    #####:24495:        call_tests++;
    #####:24496:        des_char_ptr(n_path, path, 0);
    #####:24497:        xmlResetLastError();
    #####:24498:        if (mem_base != xmlMemBlocks()) {
    #####:24499:            printf("Leak of %d blocks found in xmlNormalizeURIPath",
    #####:24500:	           xmlMemBlocks() - mem_base);
    #####:24501:	    test_ret++;
    #####:24502:            printf(" %d", n_path);
    #####:24503:            printf("\n");
        -:24504:        }
        -:24505:    }
    #####:24506:    function_tests++;
        -:24507:
    #####:24508:    return(test_ret);
        -:24509:}
        -:24510:
        -:24511:
        -:24512:static int
    #####:24513:test_xmlParseURI(void) {
    #####:24514:    int test_ret = 0;
        -:24515:
        -:24516:
        -:24517:    /* missing type support */
    #####:24518:    return(test_ret);
        -:24519:}
        -:24520:
        -:24521:
        -:24522:static int
    #####:24523:test_xmlParseURIRaw(void) {
    #####:24524:    int test_ret = 0;
        -:24525:
        -:24526:
        -:24527:    /* missing type support */
    #####:24528:    return(test_ret);
        -:24529:}
        -:24530:
        -:24531:
        -:24532:#define gen_nb_xmlURIPtr 1
    #####:24533:static xmlURIPtr gen_xmlURIPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:24534:    return(NULL);
        -:24535:}
    #####:24536:static void des_xmlURIPtr(int no ATTRIBUTE_UNUSED, xmlURIPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:24537:}
        -:24538:
        -:24539:static int
    #####:24540:test_xmlParseURIReference(void) {
    #####:24541:    int test_ret = 0;
        -:24542:
        -:24543:    int mem_base;
        -:24544:    int ret_val;
        -:24545:    xmlURIPtr uri; /* pointer to an URI structure */
        -:24546:    int n_uri;
        -:24547:    char * str; /* the string to analyze */
        -:24548:    int n_str;
        -:24549:
    #####:24550:    for (n_uri = 0;n_uri < gen_nb_xmlURIPtr;n_uri++) {
    #####:24551:    for (n_str = 0;n_str < gen_nb_const_char_ptr;n_str++) {
    #####:24552:        mem_base = xmlMemBlocks();
    #####:24553:        uri = gen_xmlURIPtr(n_uri, 0);
    #####:24554:        str = gen_const_char_ptr(n_str, 1);
        -:24555:
    #####:24556:        ret_val = xmlParseURIReference(uri, (const char *)str);
    #####:24557:        desret_int(ret_val);
    #####:24558:        call_tests++;
    #####:24559:        des_xmlURIPtr(n_uri, uri, 0);
    #####:24560:        des_const_char_ptr(n_str, (const char *)str, 1);
    #####:24561:        xmlResetLastError();
    #####:24562:        if (mem_base != xmlMemBlocks()) {
    #####:24563:            printf("Leak of %d blocks found in xmlParseURIReference",
    #####:24564:	           xmlMemBlocks() - mem_base);
    #####:24565:	    test_ret++;
    #####:24566:            printf(" %d", n_uri);
    #####:24567:            printf(" %d", n_str);
    #####:24568:            printf("\n");
        -:24569:        }
        -:24570:    }
        -:24571:    }
    #####:24572:    function_tests++;
        -:24573:
    #####:24574:    return(test_ret);
        -:24575:}
        -:24576:
        -:24577:
        -:24578:static int
    #####:24579:test_xmlPathToURI(void) {
    #####:24580:    int test_ret = 0;
        -:24581:
        -:24582:    int mem_base;
        -:24583:    xmlChar * ret_val;
        -:24584:    xmlChar * path; /* the resource locator in a filesystem notation */
        -:24585:    int n_path;
        -:24586:
    #####:24587:    for (n_path = 0;n_path < gen_nb_const_xmlChar_ptr;n_path++) {
    #####:24588:        mem_base = xmlMemBlocks();
    #####:24589:        path = gen_const_xmlChar_ptr(n_path, 0);
        -:24590:
    #####:24591:        ret_val = xmlPathToURI((const xmlChar *)path);
    #####:24592:        desret_xmlChar_ptr(ret_val);
    #####:24593:        call_tests++;
    #####:24594:        des_const_xmlChar_ptr(n_path, (const xmlChar *)path, 0);
    #####:24595:        xmlResetLastError();
    #####:24596:        if (mem_base != xmlMemBlocks()) {
    #####:24597:            printf("Leak of %d blocks found in xmlPathToURI",
    #####:24598:	           xmlMemBlocks() - mem_base);
    #####:24599:	    test_ret++;
    #####:24600:            printf(" %d", n_path);
    #####:24601:            printf("\n");
        -:24602:        }
        -:24603:    }
    #####:24604:    function_tests++;
        -:24605:
    #####:24606:    return(test_ret);
        -:24607:}
        -:24608:
        -:24609:
        -:24610:static int
    #####:24611:test_xmlPrintURI(void) {
    #####:24612:    int test_ret = 0;
        -:24613:
        -:24614:    int mem_base;
        -:24615:    FILE * stream; /* a FILE* for the output */
        -:24616:    int n_stream;
        -:24617:    xmlURIPtr uri; /* pointer to an xmlURI */
        -:24618:    int n_uri;
        -:24619:
    #####:24620:    for (n_stream = 0;n_stream < gen_nb_FILE_ptr;n_stream++) {
    #####:24621:    for (n_uri = 0;n_uri < gen_nb_xmlURIPtr;n_uri++) {
    #####:24622:        mem_base = xmlMemBlocks();
    #####:24623:        stream = gen_FILE_ptr(n_stream, 0);
    #####:24624:        uri = gen_xmlURIPtr(n_uri, 1);
        -:24625:
    #####:24626:        xmlPrintURI(stream, uri);
    #####:24627:        call_tests++;
    #####:24628:        des_FILE_ptr(n_stream, stream, 0);
    #####:24629:        des_xmlURIPtr(n_uri, uri, 1);
    #####:24630:        xmlResetLastError();
    #####:24631:        if (mem_base != xmlMemBlocks()) {
    #####:24632:            printf("Leak of %d blocks found in xmlPrintURI",
    #####:24633:	           xmlMemBlocks() - mem_base);
    #####:24634:	    test_ret++;
    #####:24635:            printf(" %d", n_stream);
    #####:24636:            printf(" %d", n_uri);
    #####:24637:            printf("\n");
        -:24638:        }
        -:24639:    }
        -:24640:    }
    #####:24641:    function_tests++;
        -:24642:
    #####:24643:    return(test_ret);
        -:24644:}
        -:24645:
        -:24646:
        -:24647:static int
    #####:24648:test_xmlSaveUri(void) {
    #####:24649:    int test_ret = 0;
        -:24650:
        -:24651:    int mem_base;
        -:24652:    xmlChar * ret_val;
        -:24653:    xmlURIPtr uri; /* pointer to an xmlURI */
        -:24654:    int n_uri;
        -:24655:
    #####:24656:    for (n_uri = 0;n_uri < gen_nb_xmlURIPtr;n_uri++) {
    #####:24657:        mem_base = xmlMemBlocks();
    #####:24658:        uri = gen_xmlURIPtr(n_uri, 0);
        -:24659:
    #####:24660:        ret_val = xmlSaveUri(uri);
    #####:24661:        desret_xmlChar_ptr(ret_val);
    #####:24662:        call_tests++;
    #####:24663:        des_xmlURIPtr(n_uri, uri, 0);
    #####:24664:        xmlResetLastError();
    #####:24665:        if (mem_base != xmlMemBlocks()) {
    #####:24666:            printf("Leak of %d blocks found in xmlSaveUri",
    #####:24667:	           xmlMemBlocks() - mem_base);
    #####:24668:	    test_ret++;
    #####:24669:            printf(" %d", n_uri);
    #####:24670:            printf("\n");
        -:24671:        }
        -:24672:    }
    #####:24673:    function_tests++;
        -:24674:
    #####:24675:    return(test_ret);
        -:24676:}
        -:24677:
        -:24678:
        -:24679:static int
    #####:24680:test_xmlURIEscape(void) {
    #####:24681:    int test_ret = 0;
        -:24682:
        -:24683:    int mem_base;
        -:24684:    xmlChar * ret_val;
        -:24685:    xmlChar * str; /* the string of the URI to escape */
        -:24686:    int n_str;
        -:24687:
    #####:24688:    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    #####:24689:        mem_base = xmlMemBlocks();
    #####:24690:        str = gen_const_xmlChar_ptr(n_str, 0);
        -:24691:
    #####:24692:        ret_val = xmlURIEscape((const xmlChar *)str);
    #####:24693:        desret_xmlChar_ptr(ret_val);
    #####:24694:        call_tests++;
    #####:24695:        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 0);
    #####:24696:        xmlResetLastError();
    #####:24697:        if (mem_base != xmlMemBlocks()) {
    #####:24698:            printf("Leak of %d blocks found in xmlURIEscape",
    #####:24699:	           xmlMemBlocks() - mem_base);
    #####:24700:	    test_ret++;
    #####:24701:            printf(" %d", n_str);
    #####:24702:            printf("\n");
        -:24703:        }
        -:24704:    }
    #####:24705:    function_tests++;
        -:24706:
    #####:24707:    return(test_ret);
        -:24708:}
        -:24709:
        -:24710:
        -:24711:static int
    #####:24712:test_xmlURIEscapeStr(void) {
    #####:24713:    int test_ret = 0;
        -:24714:
        -:24715:    int mem_base;
        -:24716:    xmlChar * ret_val;
        -:24717:    xmlChar * str; /* string to escape */
        -:24718:    int n_str;
        -:24719:    xmlChar * list; /* exception list string of chars not to escape */
        -:24720:    int n_list;
        -:24721:
    #####:24722:    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    #####:24723:    for (n_list = 0;n_list < gen_nb_const_xmlChar_ptr;n_list++) {
    #####:24724:        mem_base = xmlMemBlocks();
    #####:24725:        str = gen_const_xmlChar_ptr(n_str, 0);
    #####:24726:        list = gen_const_xmlChar_ptr(n_list, 1);
        -:24727:
    #####:24728:        ret_val = xmlURIEscapeStr((const xmlChar *)str, (const xmlChar *)list);
    #####:24729:        desret_xmlChar_ptr(ret_val);
    #####:24730:        call_tests++;
    #####:24731:        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 0);
    #####:24732:        des_const_xmlChar_ptr(n_list, (const xmlChar *)list, 1);
    #####:24733:        xmlResetLastError();
    #####:24734:        if (mem_base != xmlMemBlocks()) {
    #####:24735:            printf("Leak of %d blocks found in xmlURIEscapeStr",
    #####:24736:	           xmlMemBlocks() - mem_base);
    #####:24737:	    test_ret++;
    #####:24738:            printf(" %d", n_str);
    #####:24739:            printf(" %d", n_list);
    #####:24740:            printf("\n");
        -:24741:        }
        -:24742:    }
        -:24743:    }
    #####:24744:    function_tests++;
        -:24745:
    #####:24746:    return(test_ret);
        -:24747:}
        -:24748:
        -:24749:
        -:24750:static int
    #####:24751:test_xmlURIUnescapeString(void) {
    #####:24752:    int test_ret = 0;
        -:24753:
        -:24754:
        -:24755:    /* missing type support */
    #####:24756:    return(test_ret);
        -:24757:}
        -:24758:
        -:24759:static int
    #####:24760:test_uri(void) {
    #####:24761:    int test_ret = 0;
        -:24762:
    #####:24763:    if (quiet == 0) printf("Testing uri : 10 of 15 functions ...\n");
    #####:24764:    test_ret += test_xmlBuildRelativeURI();
    #####:24765:    test_ret += test_xmlBuildURI();
    #####:24766:    test_ret += test_xmlCanonicPath();
    #####:24767:    test_ret += test_xmlCreateURI();
    #####:24768:    test_ret += test_xmlNormalizeURIPath();
    #####:24769:    test_ret += test_xmlParseURI();
    #####:24770:    test_ret += test_xmlParseURIRaw();
    #####:24771:    test_ret += test_xmlParseURIReference();
    #####:24772:    test_ret += test_xmlPathToURI();
    #####:24773:    test_ret += test_xmlPrintURI();
    #####:24774:    test_ret += test_xmlSaveUri();
    #####:24775:    test_ret += test_xmlURIEscape();
    #####:24776:    test_ret += test_xmlURIEscapeStr();
    #####:24777:    test_ret += test_xmlURIUnescapeString();
        -:24778:
    #####:24779:    if (test_ret != 0)
    #####:24780:	printf("Module uri: %d errors\n", test_ret);
    #####:24781:    return(test_ret);
        -:24782:}
        -:24783:
        -:24784:static int
    #####:24785:test_xmlAddAttributeDecl(void) {
    #####:24786:    int test_ret = 0;
        -:24787:
        -:24788:    int mem_base;
        -:24789:    xmlAttributePtr ret_val;
        -:24790:    xmlValidCtxtPtr ctxt; /* the validation context */
        -:24791:    int n_ctxt;
        -:24792:    xmlDtdPtr dtd; /* pointer to the DTD */
        -:24793:    int n_dtd;
        -:24794:    xmlChar * elem; /* the element name */
        -:24795:    int n_elem;
        -:24796:    xmlChar * name; /* the attribute name */
        -:24797:    int n_name;
        -:24798:    xmlChar * ns; /* the attribute namespace prefix */
        -:24799:    int n_ns;
        -:24800:    xmlAttributeType type; /* the attribute type */
        -:24801:    int n_type;
        -:24802:    xmlAttributeDefault def; /* the attribute default type */
        -:24803:    int n_def;
        -:24804:    xmlChar * defaultValue; /* the attribute default value */
        -:24805:    int n_defaultValue;
        -:24806:    xmlEnumerationPtr tree; /* if it's an enumeration, the associated list */
        -:24807:    int n_tree;
        -:24808:
    #####:24809:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    #####:24810:    for (n_dtd = 0;n_dtd < gen_nb_xmlDtdPtr;n_dtd++) {
    #####:24811:    for (n_elem = 0;n_elem < gen_nb_const_xmlChar_ptr;n_elem++) {
    #####:24812:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:24813:    for (n_ns = 0;n_ns < gen_nb_const_xmlChar_ptr;n_ns++) {
    #####:24814:    for (n_type = 0;n_type < gen_nb_xmlAttributeType;n_type++) {
    #####:24815:    for (n_def = 0;n_def < gen_nb_xmlAttributeDefault;n_def++) {
    #####:24816:    for (n_defaultValue = 0;n_defaultValue < gen_nb_const_xmlChar_ptr;n_defaultValue++) {
    #####:24817:    for (n_tree = 0;n_tree < gen_nb_xmlEnumerationPtr;n_tree++) {
    #####:24818:        mem_base = xmlMemBlocks();
    #####:24819:        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
    #####:24820:        dtd = gen_xmlDtdPtr(n_dtd, 1);
    #####:24821:        elem = gen_const_xmlChar_ptr(n_elem, 2);
    #####:24822:        name = gen_const_xmlChar_ptr(n_name, 3);
    #####:24823:        ns = gen_const_xmlChar_ptr(n_ns, 4);
    #####:24824:        type = gen_xmlAttributeType(n_type, 5);
    #####:24825:        def = gen_xmlAttributeDefault(n_def, 6);
    #####:24826:        defaultValue = gen_const_xmlChar_ptr(n_defaultValue, 7);
    #####:24827:        tree = gen_xmlEnumerationPtr(n_tree, 8);
        -:24828:
    #####:24829:        ret_val = xmlAddAttributeDecl(ctxt, dtd, (const xmlChar *)elem, (const xmlChar *)name, (const xmlChar *)ns, type, def, (const xmlChar *)defaultValue, tree);
    #####:24830:        desret_xmlAttributePtr(ret_val);
    #####:24831:        call_tests++;
    #####:24832:        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:24833:        des_xmlDtdPtr(n_dtd, dtd, 1);
    #####:24834:        des_const_xmlChar_ptr(n_elem, (const xmlChar *)elem, 2);
    #####:24835:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 3);
    #####:24836:        des_const_xmlChar_ptr(n_ns, (const xmlChar *)ns, 4);
    #####:24837:        des_xmlAttributeType(n_type, type, 5);
    #####:24838:        des_xmlAttributeDefault(n_def, def, 6);
    #####:24839:        des_const_xmlChar_ptr(n_defaultValue, (const xmlChar *)defaultValue, 7);
    #####:24840:        des_xmlEnumerationPtr(n_tree, tree, 8);
    #####:24841:        xmlResetLastError();
    #####:24842:        if (mem_base != xmlMemBlocks()) {
    #####:24843:            printf("Leak of %d blocks found in xmlAddAttributeDecl",
    #####:24844:	           xmlMemBlocks() - mem_base);
    #####:24845:	    test_ret++;
    #####:24846:            printf(" %d", n_ctxt);
    #####:24847:            printf(" %d", n_dtd);
    #####:24848:            printf(" %d", n_elem);
    #####:24849:            printf(" %d", n_name);
    #####:24850:            printf(" %d", n_ns);
    #####:24851:            printf(" %d", n_type);
    #####:24852:            printf(" %d", n_def);
    #####:24853:            printf(" %d", n_defaultValue);
    #####:24854:            printf(" %d", n_tree);
    #####:24855:            printf("\n");
        -:24856:        }
        -:24857:    }
        -:24858:    }
        -:24859:    }
        -:24860:    }
        -:24861:    }
        -:24862:    }
        -:24863:    }
        -:24864:    }
        -:24865:    }
    #####:24866:    function_tests++;
        -:24867:
    #####:24868:    return(test_ret);
        -:24869:}
        -:24870:
        -:24871:
        -:24872:static int
    #####:24873:test_xmlAddElementDecl(void) {
    #####:24874:    int test_ret = 0;
        -:24875:
        -:24876:    int mem_base;
        -:24877:    xmlElementPtr ret_val;
        -:24878:    xmlValidCtxtPtr ctxt; /* the validation context */
        -:24879:    int n_ctxt;
        -:24880:    xmlDtdPtr dtd; /* pointer to the DTD */
        -:24881:    int n_dtd;
        -:24882:    xmlChar * name; /* the entity name */
        -:24883:    int n_name;
        -:24884:    xmlElementTypeVal type; /* the element type */
        -:24885:    int n_type;
        -:24886:    xmlElementContentPtr content; /* the element content tree or NULL */
        -:24887:    int n_content;
        -:24888:
    #####:24889:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    #####:24890:    for (n_dtd = 0;n_dtd < gen_nb_xmlDtdPtr;n_dtd++) {
    #####:24891:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:24892:    for (n_type = 0;n_type < gen_nb_xmlElementTypeVal;n_type++) {
    #####:24893:    for (n_content = 0;n_content < gen_nb_xmlElementContentPtr;n_content++) {
    #####:24894:        mem_base = xmlMemBlocks();
    #####:24895:        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
    #####:24896:        dtd = gen_xmlDtdPtr(n_dtd, 1);
    #####:24897:        name = gen_const_xmlChar_ptr(n_name, 2);
    #####:24898:        type = gen_xmlElementTypeVal(n_type, 3);
    #####:24899:        content = gen_xmlElementContentPtr(n_content, 4);
        -:24900:
    #####:24901:        ret_val = xmlAddElementDecl(ctxt, dtd, (const xmlChar *)name, type, content);
    #####:24902:        desret_xmlElementPtr(ret_val);
    #####:24903:        call_tests++;
    #####:24904:        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:24905:        des_xmlDtdPtr(n_dtd, dtd, 1);
    #####:24906:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
    #####:24907:        des_xmlElementTypeVal(n_type, type, 3);
    #####:24908:        des_xmlElementContentPtr(n_content, content, 4);
    #####:24909:        xmlResetLastError();
    #####:24910:        if (mem_base != xmlMemBlocks()) {
    #####:24911:            printf("Leak of %d blocks found in xmlAddElementDecl",
    #####:24912:	           xmlMemBlocks() - mem_base);
    #####:24913:	    test_ret++;
    #####:24914:            printf(" %d", n_ctxt);
    #####:24915:            printf(" %d", n_dtd);
    #####:24916:            printf(" %d", n_name);
    #####:24917:            printf(" %d", n_type);
    #####:24918:            printf(" %d", n_content);
    #####:24919:            printf("\n");
        -:24920:        }
        -:24921:    }
        -:24922:    }
        -:24923:    }
        -:24924:    }
        -:24925:    }
    #####:24926:    function_tests++;
        -:24927:
    #####:24928:    return(test_ret);
        -:24929:}
        -:24930:
        -:24931:
        -:24932:static int
    #####:24933:test_xmlAddID(void) {
    #####:24934:    int test_ret = 0;
        -:24935:
        -:24936:
        -:24937:    /* missing type support */
    #####:24938:    return(test_ret);
        -:24939:}
        -:24940:
        -:24941:
        -:24942:static int
    #####:24943:test_xmlAddNotationDecl(void) {
    #####:24944:    int test_ret = 0;
        -:24945:
        -:24946:
        -:24947:    /* missing type support */
    #####:24948:    return(test_ret);
        -:24949:}
        -:24950:
        -:24951:
        -:24952:static int
    #####:24953:test_xmlAddRef(void) {
    #####:24954:    int test_ret = 0;
        -:24955:
        -:24956:
        -:24957:    /* missing type support */
    #####:24958:    return(test_ret);
        -:24959:}
        -:24960:
        -:24961:
        -:24962:#define gen_nb_xmlAttributeTablePtr 1
    #####:24963:static xmlAttributeTablePtr gen_xmlAttributeTablePtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:24964:    return(NULL);
        -:24965:}
    #####:24966:static void des_xmlAttributeTablePtr(int no ATTRIBUTE_UNUSED, xmlAttributeTablePtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:24967:}
        -:24968:
        -:24969:static int
    #####:24970:test_xmlCopyAttributeTable(void) {
    #####:24971:    int test_ret = 0;
        -:24972:
        -:24973:
        -:24974:    /* missing type support */
    #####:24975:    return(test_ret);
        -:24976:}
        -:24977:
        -:24978:
        -:24979:static int
    #####:24980:test_xmlCopyDocElementContent(void) {
    #####:24981:    int test_ret = 0;
        -:24982:
        -:24983:    int mem_base;
        -:24984:    xmlElementContentPtr ret_val;
        -:24985:    xmlDocPtr doc; /* the document owning the element declaration */
        -:24986:    int n_doc;
        -:24987:    xmlElementContentPtr cur; /* An element content pointer. */
        -:24988:    int n_cur;
        -:24989:
    #####:24990:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:24991:    for (n_cur = 0;n_cur < gen_nb_xmlElementContentPtr;n_cur++) {
    #####:24992:        mem_base = xmlMemBlocks();
    #####:24993:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:24994:        cur = gen_xmlElementContentPtr(n_cur, 1);
        -:24995:
    #####:24996:        ret_val = xmlCopyDocElementContent(doc, cur);
    #####:24997:        desret_xmlElementContentPtr(ret_val);
    #####:24998:        call_tests++;
    #####:24999:        des_xmlDocPtr(n_doc, doc, 0);
    #####:25000:        des_xmlElementContentPtr(n_cur, cur, 1);
    #####:25001:        xmlResetLastError();
    #####:25002:        if (mem_base != xmlMemBlocks()) {
    #####:25003:            printf("Leak of %d blocks found in xmlCopyDocElementContent",
    #####:25004:	           xmlMemBlocks() - mem_base);
    #####:25005:	    test_ret++;
    #####:25006:            printf(" %d", n_doc);
    #####:25007:            printf(" %d", n_cur);
    #####:25008:            printf("\n");
        -:25009:        }
        -:25010:    }
        -:25011:    }
    #####:25012:    function_tests++;
        -:25013:
    #####:25014:    return(test_ret);
        -:25015:}
        -:25016:
        -:25017:
        -:25018:static int
    #####:25019:test_xmlCopyElementContent(void) {
    #####:25020:    int test_ret = 0;
        -:25021:
        -:25022:    int mem_base;
        -:25023:    xmlElementContentPtr ret_val;
        -:25024:    xmlElementContentPtr cur; /* An element content pointer. */
        -:25025:    int n_cur;
        -:25026:
    #####:25027:    for (n_cur = 0;n_cur < gen_nb_xmlElementContentPtr;n_cur++) {
    #####:25028:        mem_base = xmlMemBlocks();
    #####:25029:        cur = gen_xmlElementContentPtr(n_cur, 0);
        -:25030:
    #####:25031:        ret_val = xmlCopyElementContent(cur);
    #####:25032:        desret_xmlElementContentPtr(ret_val);
    #####:25033:        call_tests++;
    #####:25034:        des_xmlElementContentPtr(n_cur, cur, 0);
    #####:25035:        xmlResetLastError();
    #####:25036:        if (mem_base != xmlMemBlocks()) {
    #####:25037:            printf("Leak of %d blocks found in xmlCopyElementContent",
    #####:25038:	           xmlMemBlocks() - mem_base);
    #####:25039:	    test_ret++;
    #####:25040:            printf(" %d", n_cur);
    #####:25041:            printf("\n");
        -:25042:        }
        -:25043:    }
    #####:25044:    function_tests++;
        -:25045:
    #####:25046:    return(test_ret);
        -:25047:}
        -:25048:
        -:25049:
        -:25050:#define gen_nb_xmlElementTablePtr 1
    #####:25051:static xmlElementTablePtr gen_xmlElementTablePtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:25052:    return(NULL);
        -:25053:}
    #####:25054:static void des_xmlElementTablePtr(int no ATTRIBUTE_UNUSED, xmlElementTablePtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:25055:}
        -:25056:
        -:25057:static int
    #####:25058:test_xmlCopyElementTable(void) {
    #####:25059:    int test_ret = 0;
        -:25060:
        -:25061:
        -:25062:    /* missing type support */
    #####:25063:    return(test_ret);
        -:25064:}
        -:25065:
        -:25066:
        -:25067:static int
    #####:25068:test_xmlCopyEnumeration(void) {
    #####:25069:    int test_ret = 0;
        -:25070:
        -:25071:
        -:25072:    /* missing type support */
    #####:25073:    return(test_ret);
        -:25074:}
        -:25075:
        -:25076:
        -:25077:#define gen_nb_xmlNotationTablePtr 1
    #####:25078:static xmlNotationTablePtr gen_xmlNotationTablePtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:25079:    return(NULL);
        -:25080:}
    #####:25081:static void des_xmlNotationTablePtr(int no ATTRIBUTE_UNUSED, xmlNotationTablePtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:25082:}
        -:25083:
        -:25084:static int
    #####:25085:test_xmlCopyNotationTable(void) {
    #####:25086:    int test_ret = 0;
        -:25087:
        -:25088:
        -:25089:    /* missing type support */
    #####:25090:    return(test_ret);
        -:25091:}
        -:25092:
        -:25093:
        -:25094:static int
    #####:25095:test_xmlCreateEnumeration(void) {
    #####:25096:    int test_ret = 0;
        -:25097:
        -:25098:
        -:25099:    /* missing type support */
    #####:25100:    return(test_ret);
        -:25101:}
        -:25102:
        -:25103:
        -:25104:#define gen_nb_xmlAttributePtr 1
    #####:25105:static xmlAttributePtr gen_xmlAttributePtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:25106:    return(NULL);
        -:25107:}
    #####:25108:static void des_xmlAttributePtr(int no ATTRIBUTE_UNUSED, xmlAttributePtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:25109:}
        -:25110:
        -:25111:static int
    #####:25112:test_xmlDumpAttributeDecl(void) {
    #####:25113:    int test_ret = 0;
        -:25114:
        -:25115:#if defined(LIBXML_OUTPUT_ENABLED)
        -:25116:    int mem_base;
        -:25117:    xmlBufferPtr buf; /* the XML buffer output */
        -:25118:    int n_buf;
        -:25119:    xmlAttributePtr attr; /* An attribute declaration */
        -:25120:    int n_attr;
        -:25121:
    #####:25122:    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    #####:25123:    for (n_attr = 0;n_attr < gen_nb_xmlAttributePtr;n_attr++) {
    #####:25124:        mem_base = xmlMemBlocks();
    #####:25125:        buf = gen_xmlBufferPtr(n_buf, 0);
    #####:25126:        attr = gen_xmlAttributePtr(n_attr, 1);
        -:25127:
    #####:25128:        xmlDumpAttributeDecl(buf, attr);
    #####:25129:        call_tests++;
    #####:25130:        des_xmlBufferPtr(n_buf, buf, 0);
    #####:25131:        des_xmlAttributePtr(n_attr, attr, 1);
    #####:25132:        xmlResetLastError();
    #####:25133:        if (mem_base != xmlMemBlocks()) {
    #####:25134:            printf("Leak of %d blocks found in xmlDumpAttributeDecl",
    #####:25135:	           xmlMemBlocks() - mem_base);
    #####:25136:	    test_ret++;
    #####:25137:            printf(" %d", n_buf);
    #####:25138:            printf(" %d", n_attr);
    #####:25139:            printf("\n");
        -:25140:        }
        -:25141:    }
        -:25142:    }
    #####:25143:    function_tests++;
        -:25144:#endif
        -:25145:
    #####:25146:    return(test_ret);
        -:25147:}
        -:25148:
        -:25149:
        -:25150:static int
    #####:25151:test_xmlDumpAttributeTable(void) {
    #####:25152:    int test_ret = 0;
        -:25153:
        -:25154:#if defined(LIBXML_OUTPUT_ENABLED)
        -:25155:    int mem_base;
        -:25156:    xmlBufferPtr buf; /* the XML buffer output */
        -:25157:    int n_buf;
        -:25158:    xmlAttributeTablePtr table; /* An attribute table */
        -:25159:    int n_table;
        -:25160:
    #####:25161:    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    #####:25162:    for (n_table = 0;n_table < gen_nb_xmlAttributeTablePtr;n_table++) {
    #####:25163:        mem_base = xmlMemBlocks();
    #####:25164:        buf = gen_xmlBufferPtr(n_buf, 0);
    #####:25165:        table = gen_xmlAttributeTablePtr(n_table, 1);
        -:25166:
    #####:25167:        xmlDumpAttributeTable(buf, table);
    #####:25168:        call_tests++;
    #####:25169:        des_xmlBufferPtr(n_buf, buf, 0);
    #####:25170:        des_xmlAttributeTablePtr(n_table, table, 1);
    #####:25171:        xmlResetLastError();
    #####:25172:        if (mem_base != xmlMemBlocks()) {
    #####:25173:            printf("Leak of %d blocks found in xmlDumpAttributeTable",
    #####:25174:	           xmlMemBlocks() - mem_base);
    #####:25175:	    test_ret++;
    #####:25176:            printf(" %d", n_buf);
    #####:25177:            printf(" %d", n_table);
    #####:25178:            printf("\n");
        -:25179:        }
        -:25180:    }
        -:25181:    }
    #####:25182:    function_tests++;
        -:25183:#endif
        -:25184:
    #####:25185:    return(test_ret);
        -:25186:}
        -:25187:
        -:25188:
        -:25189:#define gen_nb_xmlElementPtr 1
    #####:25190:static xmlElementPtr gen_xmlElementPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:25191:    return(NULL);
        -:25192:}
    #####:25193:static void des_xmlElementPtr(int no ATTRIBUTE_UNUSED, xmlElementPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:25194:}
        -:25195:
        -:25196:static int
    #####:25197:test_xmlDumpElementDecl(void) {
    #####:25198:    int test_ret = 0;
        -:25199:
        -:25200:#if defined(LIBXML_OUTPUT_ENABLED)
        -:25201:    int mem_base;
        -:25202:    xmlBufferPtr buf; /* the XML buffer output */
        -:25203:    int n_buf;
        -:25204:    xmlElementPtr elem; /* An element table */
        -:25205:    int n_elem;
        -:25206:
    #####:25207:    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    #####:25208:    for (n_elem = 0;n_elem < gen_nb_xmlElementPtr;n_elem++) {
    #####:25209:        mem_base = xmlMemBlocks();
    #####:25210:        buf = gen_xmlBufferPtr(n_buf, 0);
    #####:25211:        elem = gen_xmlElementPtr(n_elem, 1);
        -:25212:
    #####:25213:        xmlDumpElementDecl(buf, elem);
    #####:25214:        call_tests++;
    #####:25215:        des_xmlBufferPtr(n_buf, buf, 0);
    #####:25216:        des_xmlElementPtr(n_elem, elem, 1);
    #####:25217:        xmlResetLastError();
    #####:25218:        if (mem_base != xmlMemBlocks()) {
    #####:25219:            printf("Leak of %d blocks found in xmlDumpElementDecl",
    #####:25220:	           xmlMemBlocks() - mem_base);
    #####:25221:	    test_ret++;
    #####:25222:            printf(" %d", n_buf);
    #####:25223:            printf(" %d", n_elem);
    #####:25224:            printf("\n");
        -:25225:        }
        -:25226:    }
        -:25227:    }
    #####:25228:    function_tests++;
        -:25229:#endif
        -:25230:
    #####:25231:    return(test_ret);
        -:25232:}
        -:25233:
        -:25234:
        -:25235:static int
    #####:25236:test_xmlDumpElementTable(void) {
    #####:25237:    int test_ret = 0;
        -:25238:
        -:25239:#if defined(LIBXML_OUTPUT_ENABLED)
        -:25240:    int mem_base;
        -:25241:    xmlBufferPtr buf; /* the XML buffer output */
        -:25242:    int n_buf;
        -:25243:    xmlElementTablePtr table; /* An element table */
        -:25244:    int n_table;
        -:25245:
    #####:25246:    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    #####:25247:    for (n_table = 0;n_table < gen_nb_xmlElementTablePtr;n_table++) {
    #####:25248:        mem_base = xmlMemBlocks();
    #####:25249:        buf = gen_xmlBufferPtr(n_buf, 0);
    #####:25250:        table = gen_xmlElementTablePtr(n_table, 1);
        -:25251:
    #####:25252:        xmlDumpElementTable(buf, table);
    #####:25253:        call_tests++;
    #####:25254:        des_xmlBufferPtr(n_buf, buf, 0);
    #####:25255:        des_xmlElementTablePtr(n_table, table, 1);
    #####:25256:        xmlResetLastError();
    #####:25257:        if (mem_base != xmlMemBlocks()) {
    #####:25258:            printf("Leak of %d blocks found in xmlDumpElementTable",
    #####:25259:	           xmlMemBlocks() - mem_base);
    #####:25260:	    test_ret++;
    #####:25261:            printf(" %d", n_buf);
    #####:25262:            printf(" %d", n_table);
    #####:25263:            printf("\n");
        -:25264:        }
        -:25265:    }
        -:25266:    }
    #####:25267:    function_tests++;
        -:25268:#endif
        -:25269:
    #####:25270:    return(test_ret);
        -:25271:}
        -:25272:
        -:25273:
        -:25274:#define gen_nb_xmlNotationPtr 1
    #####:25275:static xmlNotationPtr gen_xmlNotationPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:25276:    return(NULL);
        -:25277:}
    #####:25278:static void des_xmlNotationPtr(int no ATTRIBUTE_UNUSED, xmlNotationPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:25279:}
        -:25280:
        -:25281:static int
    #####:25282:test_xmlDumpNotationDecl(void) {
    #####:25283:    int test_ret = 0;
        -:25284:
        -:25285:#if defined(LIBXML_OUTPUT_ENABLED)
        -:25286:    int mem_base;
        -:25287:    xmlBufferPtr buf; /* the XML buffer output */
        -:25288:    int n_buf;
        -:25289:    xmlNotationPtr nota; /* A notation declaration */
        -:25290:    int n_nota;
        -:25291:
    #####:25292:    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    #####:25293:    for (n_nota = 0;n_nota < gen_nb_xmlNotationPtr;n_nota++) {
    #####:25294:        mem_base = xmlMemBlocks();
    #####:25295:        buf = gen_xmlBufferPtr(n_buf, 0);
    #####:25296:        nota = gen_xmlNotationPtr(n_nota, 1);
        -:25297:
    #####:25298:        xmlDumpNotationDecl(buf, nota);
    #####:25299:        call_tests++;
    #####:25300:        des_xmlBufferPtr(n_buf, buf, 0);
    #####:25301:        des_xmlNotationPtr(n_nota, nota, 1);
    #####:25302:        xmlResetLastError();
    #####:25303:        if (mem_base != xmlMemBlocks()) {
    #####:25304:            printf("Leak of %d blocks found in xmlDumpNotationDecl",
    #####:25305:	           xmlMemBlocks() - mem_base);
    #####:25306:	    test_ret++;
    #####:25307:            printf(" %d", n_buf);
    #####:25308:            printf(" %d", n_nota);
    #####:25309:            printf("\n");
        -:25310:        }
        -:25311:    }
        -:25312:    }
    #####:25313:    function_tests++;
        -:25314:#endif
        -:25315:
    #####:25316:    return(test_ret);
        -:25317:}
        -:25318:
        -:25319:
        -:25320:static int
    #####:25321:test_xmlDumpNotationTable(void) {
    #####:25322:    int test_ret = 0;
        -:25323:
        -:25324:#if defined(LIBXML_OUTPUT_ENABLED)
        -:25325:    int mem_base;
        -:25326:    xmlBufferPtr buf; /* the XML buffer output */
        -:25327:    int n_buf;
        -:25328:    xmlNotationTablePtr table; /* A notation table */
        -:25329:    int n_table;
        -:25330:
    #####:25331:    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    #####:25332:    for (n_table = 0;n_table < gen_nb_xmlNotationTablePtr;n_table++) {
    #####:25333:        mem_base = xmlMemBlocks();
    #####:25334:        buf = gen_xmlBufferPtr(n_buf, 0);
    #####:25335:        table = gen_xmlNotationTablePtr(n_table, 1);
        -:25336:
    #####:25337:        xmlDumpNotationTable(buf, table);
    #####:25338:        call_tests++;
    #####:25339:        des_xmlBufferPtr(n_buf, buf, 0);
    #####:25340:        des_xmlNotationTablePtr(n_table, table, 1);
    #####:25341:        xmlResetLastError();
    #####:25342:        if (mem_base != xmlMemBlocks()) {
    #####:25343:            printf("Leak of %d blocks found in xmlDumpNotationTable",
    #####:25344:	           xmlMemBlocks() - mem_base);
    #####:25345:	    test_ret++;
    #####:25346:            printf(" %d", n_buf);
    #####:25347:            printf(" %d", n_table);
    #####:25348:            printf("\n");
        -:25349:        }
        -:25350:    }
        -:25351:    }
    #####:25352:    function_tests++;
        -:25353:#endif
        -:25354:
    #####:25355:    return(test_ret);
        -:25356:}
        -:25357:
        -:25358:
        -:25359:static int
    #####:25360:test_xmlGetDtdAttrDesc(void) {
    #####:25361:    int test_ret = 0;
        -:25362:
        -:25363:    int mem_base;
        -:25364:    xmlAttributePtr ret_val;
        -:25365:    xmlDtdPtr dtd; /* a pointer to the DtD to search */
        -:25366:    int n_dtd;
        -:25367:    xmlChar * elem; /* the element name */
        -:25368:    int n_elem;
        -:25369:    xmlChar * name; /* the attribute name */
        -:25370:    int n_name;
        -:25371:
    #####:25372:    for (n_dtd = 0;n_dtd < gen_nb_xmlDtdPtr;n_dtd++) {
    #####:25373:    for (n_elem = 0;n_elem < gen_nb_const_xmlChar_ptr;n_elem++) {
    #####:25374:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:25375:        mem_base = xmlMemBlocks();
    #####:25376:        dtd = gen_xmlDtdPtr(n_dtd, 0);
    #####:25377:        elem = gen_const_xmlChar_ptr(n_elem, 1);
    #####:25378:        name = gen_const_xmlChar_ptr(n_name, 2);
        -:25379:
    #####:25380:        ret_val = xmlGetDtdAttrDesc(dtd, (const xmlChar *)elem, (const xmlChar *)name);
    #####:25381:        desret_xmlAttributePtr(ret_val);
    #####:25382:        call_tests++;
    #####:25383:        des_xmlDtdPtr(n_dtd, dtd, 0);
    #####:25384:        des_const_xmlChar_ptr(n_elem, (const xmlChar *)elem, 1);
    #####:25385:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
    #####:25386:        xmlResetLastError();
    #####:25387:        if (mem_base != xmlMemBlocks()) {
    #####:25388:            printf("Leak of %d blocks found in xmlGetDtdAttrDesc",
    #####:25389:	           xmlMemBlocks() - mem_base);
    #####:25390:	    test_ret++;
    #####:25391:            printf(" %d", n_dtd);
    #####:25392:            printf(" %d", n_elem);
    #####:25393:            printf(" %d", n_name);
    #####:25394:            printf("\n");
        -:25395:        }
        -:25396:    }
        -:25397:    }
        -:25398:    }
    #####:25399:    function_tests++;
        -:25400:
    #####:25401:    return(test_ret);
        -:25402:}
        -:25403:
        -:25404:
        -:25405:static int
    #####:25406:test_xmlGetDtdElementDesc(void) {
    #####:25407:    int test_ret = 0;
        -:25408:
        -:25409:    int mem_base;
        -:25410:    xmlElementPtr ret_val;
        -:25411:    xmlDtdPtr dtd; /* a pointer to the DtD to search */
        -:25412:    int n_dtd;
        -:25413:    xmlChar * name; /* the element name */
        -:25414:    int n_name;
        -:25415:
    #####:25416:    for (n_dtd = 0;n_dtd < gen_nb_xmlDtdPtr;n_dtd++) {
    #####:25417:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:25418:        mem_base = xmlMemBlocks();
    #####:25419:        dtd = gen_xmlDtdPtr(n_dtd, 0);
    #####:25420:        name = gen_const_xmlChar_ptr(n_name, 1);
        -:25421:
    #####:25422:        ret_val = xmlGetDtdElementDesc(dtd, (const xmlChar *)name);
    #####:25423:        desret_xmlElementPtr(ret_val);
    #####:25424:        call_tests++;
    #####:25425:        des_xmlDtdPtr(n_dtd, dtd, 0);
    #####:25426:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:25427:        xmlResetLastError();
    #####:25428:        if (mem_base != xmlMemBlocks()) {
    #####:25429:            printf("Leak of %d blocks found in xmlGetDtdElementDesc",
    #####:25430:	           xmlMemBlocks() - mem_base);
    #####:25431:	    test_ret++;
    #####:25432:            printf(" %d", n_dtd);
    #####:25433:            printf(" %d", n_name);
    #####:25434:            printf("\n");
        -:25435:        }
        -:25436:    }
        -:25437:    }
    #####:25438:    function_tests++;
        -:25439:
    #####:25440:    return(test_ret);
        -:25441:}
        -:25442:
        -:25443:
        -:25444:static int
    #####:25445:test_xmlGetDtdNotationDesc(void) {
    #####:25446:    int test_ret = 0;
        -:25447:
        -:25448:
        -:25449:    /* missing type support */
    #####:25450:    return(test_ret);
        -:25451:}
        -:25452:
        -:25453:
        -:25454:static int
    #####:25455:test_xmlGetDtdQAttrDesc(void) {
    #####:25456:    int test_ret = 0;
        -:25457:
        -:25458:    int mem_base;
        -:25459:    xmlAttributePtr ret_val;
        -:25460:    xmlDtdPtr dtd; /* a pointer to the DtD to search */
        -:25461:    int n_dtd;
        -:25462:    xmlChar * elem; /* the element name */
        -:25463:    int n_elem;
        -:25464:    xmlChar * name; /* the attribute name */
        -:25465:    int n_name;
        -:25466:    xmlChar * prefix; /* the attribute namespace prefix */
        -:25467:    int n_prefix;
        -:25468:
    #####:25469:    for (n_dtd = 0;n_dtd < gen_nb_xmlDtdPtr;n_dtd++) {
    #####:25470:    for (n_elem = 0;n_elem < gen_nb_const_xmlChar_ptr;n_elem++) {
    #####:25471:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:25472:    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    #####:25473:        mem_base = xmlMemBlocks();
    #####:25474:        dtd = gen_xmlDtdPtr(n_dtd, 0);
    #####:25475:        elem = gen_const_xmlChar_ptr(n_elem, 1);
    #####:25476:        name = gen_const_xmlChar_ptr(n_name, 2);
    #####:25477:        prefix = gen_const_xmlChar_ptr(n_prefix, 3);
        -:25478:
    #####:25479:        ret_val = xmlGetDtdQAttrDesc(dtd, (const xmlChar *)elem, (const xmlChar *)name, (const xmlChar *)prefix);
    #####:25480:        desret_xmlAttributePtr(ret_val);
    #####:25481:        call_tests++;
    #####:25482:        des_xmlDtdPtr(n_dtd, dtd, 0);
    #####:25483:        des_const_xmlChar_ptr(n_elem, (const xmlChar *)elem, 1);
    #####:25484:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
    #####:25485:        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 3);
    #####:25486:        xmlResetLastError();
    #####:25487:        if (mem_base != xmlMemBlocks()) {
    #####:25488:            printf("Leak of %d blocks found in xmlGetDtdQAttrDesc",
    #####:25489:	           xmlMemBlocks() - mem_base);
    #####:25490:	    test_ret++;
    #####:25491:            printf(" %d", n_dtd);
    #####:25492:            printf(" %d", n_elem);
    #####:25493:            printf(" %d", n_name);
    #####:25494:            printf(" %d", n_prefix);
    #####:25495:            printf("\n");
        -:25496:        }
        -:25497:    }
        -:25498:    }
        -:25499:    }
        -:25500:    }
    #####:25501:    function_tests++;
        -:25502:
    #####:25503:    return(test_ret);
        -:25504:}
        -:25505:
        -:25506:
        -:25507:static int
    #####:25508:test_xmlGetDtdQElementDesc(void) {
    #####:25509:    int test_ret = 0;
        -:25510:
        -:25511:    int mem_base;
        -:25512:    xmlElementPtr ret_val;
        -:25513:    xmlDtdPtr dtd; /* a pointer to the DtD to search */
        -:25514:    int n_dtd;
        -:25515:    xmlChar * name; /* the element name */
        -:25516:    int n_name;
        -:25517:    xmlChar * prefix; /* the element namespace prefix */
        -:25518:    int n_prefix;
        -:25519:
    #####:25520:    for (n_dtd = 0;n_dtd < gen_nb_xmlDtdPtr;n_dtd++) {
    #####:25521:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:25522:    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    #####:25523:        mem_base = xmlMemBlocks();
    #####:25524:        dtd = gen_xmlDtdPtr(n_dtd, 0);
    #####:25525:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:25526:        prefix = gen_const_xmlChar_ptr(n_prefix, 2);
        -:25527:
    #####:25528:        ret_val = xmlGetDtdQElementDesc(dtd, (const xmlChar *)name, (const xmlChar *)prefix);
    #####:25529:        desret_xmlElementPtr(ret_val);
    #####:25530:        call_tests++;
    #####:25531:        des_xmlDtdPtr(n_dtd, dtd, 0);
    #####:25532:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:25533:        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 2);
    #####:25534:        xmlResetLastError();
    #####:25535:        if (mem_base != xmlMemBlocks()) {
    #####:25536:            printf("Leak of %d blocks found in xmlGetDtdQElementDesc",
    #####:25537:	           xmlMemBlocks() - mem_base);
    #####:25538:	    test_ret++;
    #####:25539:            printf(" %d", n_dtd);
    #####:25540:            printf(" %d", n_name);
    #####:25541:            printf(" %d", n_prefix);
    #####:25542:            printf("\n");
        -:25543:        }
        -:25544:    }
        -:25545:    }
        -:25546:    }
    #####:25547:    function_tests++;
        -:25548:
    #####:25549:    return(test_ret);
        -:25550:}
        -:25551:
        -:25552:
        -:25553:static int
    #####:25554:test_xmlGetID(void) {
    #####:25555:    int test_ret = 0;
        -:25556:
        -:25557:    int mem_base;
        -:25558:    xmlAttrPtr ret_val;
        -:25559:    xmlDocPtr doc; /* pointer to the document */
        -:25560:    int n_doc;
        -:25561:    xmlChar * ID; /* the ID value */
        -:25562:    int n_ID;
        -:25563:
    #####:25564:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:25565:    for (n_ID = 0;n_ID < gen_nb_const_xmlChar_ptr;n_ID++) {
    #####:25566:        mem_base = xmlMemBlocks();
    #####:25567:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:25568:        ID = gen_const_xmlChar_ptr(n_ID, 1);
        -:25569:
    #####:25570:        ret_val = xmlGetID(doc, (const xmlChar *)ID);
    #####:25571:        desret_xmlAttrPtr(ret_val);
    #####:25572:        call_tests++;
    #####:25573:        des_xmlDocPtr(n_doc, doc, 0);
    #####:25574:        des_const_xmlChar_ptr(n_ID, (const xmlChar *)ID, 1);
    #####:25575:        xmlResetLastError();
    #####:25576:        if (mem_base != xmlMemBlocks()) {
    #####:25577:            printf("Leak of %d blocks found in xmlGetID",
    #####:25578:	           xmlMemBlocks() - mem_base);
    #####:25579:	    test_ret++;
    #####:25580:            printf(" %d", n_doc);
    #####:25581:            printf(" %d", n_ID);
    #####:25582:            printf("\n");
        -:25583:        }
        -:25584:    }
        -:25585:    }
    #####:25586:    function_tests++;
        -:25587:
    #####:25588:    return(test_ret);
        -:25589:}
        -:25590:
        -:25591:
        -:25592:static int
    #####:25593:test_xmlGetRefs(void) {
    #####:25594:    int test_ret = 0;
        -:25595:
        -:25596:
        -:25597:    /* missing type support */
    #####:25598:    return(test_ret);
        -:25599:}
        -:25600:
        -:25601:
        -:25602:static int
    #####:25603:test_xmlIsID(void) {
    #####:25604:    int test_ret = 0;
        -:25605:
        -:25606:    int mem_base;
        -:25607:    int ret_val;
        -:25608:    xmlDocPtr doc; /* the document */
        -:25609:    int n_doc;
        -:25610:    xmlNodePtr elem; /* the element carrying the attribute */
        -:25611:    int n_elem;
        -:25612:    xmlAttrPtr attr; /* the attribute */
        -:25613:    int n_attr;
        -:25614:
    #####:25615:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:25616:    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    #####:25617:    for (n_attr = 0;n_attr < gen_nb_xmlAttrPtr;n_attr++) {
    #####:25618:        mem_base = xmlMemBlocks();
    #####:25619:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:25620:        elem = gen_xmlNodePtr(n_elem, 1);
    #####:25621:        attr = gen_xmlAttrPtr(n_attr, 2);
        -:25622:
    #####:25623:        ret_val = xmlIsID(doc, elem, attr);
    #####:25624:        desret_int(ret_val);
    #####:25625:        call_tests++;
    #####:25626:        des_xmlDocPtr(n_doc, doc, 0);
    #####:25627:        des_xmlNodePtr(n_elem, elem, 1);
    #####:25628:        des_xmlAttrPtr(n_attr, attr, 2);
    #####:25629:        xmlResetLastError();
    #####:25630:        if (mem_base != xmlMemBlocks()) {
    #####:25631:            printf("Leak of %d blocks found in xmlIsID",
    #####:25632:	           xmlMemBlocks() - mem_base);
    #####:25633:	    test_ret++;
    #####:25634:            printf(" %d", n_doc);
    #####:25635:            printf(" %d", n_elem);
    #####:25636:            printf(" %d", n_attr);
    #####:25637:            printf("\n");
        -:25638:        }
        -:25639:    }
        -:25640:    }
        -:25641:    }
    #####:25642:    function_tests++;
        -:25643:
    #####:25644:    return(test_ret);
        -:25645:}
        -:25646:
        -:25647:
        -:25648:static int
    #####:25649:test_xmlIsMixedElement(void) {
    #####:25650:    int test_ret = 0;
        -:25651:
        -:25652:    int mem_base;
        -:25653:    int ret_val;
        -:25654:    xmlDocPtr doc; /* the document */
        -:25655:    int n_doc;
        -:25656:    xmlChar * name; /* the element name */
        -:25657:    int n_name;
        -:25658:
    #####:25659:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:25660:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:25661:        mem_base = xmlMemBlocks();
    #####:25662:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:25663:        name = gen_const_xmlChar_ptr(n_name, 1);
        -:25664:
    #####:25665:        ret_val = xmlIsMixedElement(doc, (const xmlChar *)name);
    #####:25666:        desret_int(ret_val);
    #####:25667:        call_tests++;
    #####:25668:        des_xmlDocPtr(n_doc, doc, 0);
    #####:25669:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:25670:        xmlResetLastError();
    #####:25671:        if (mem_base != xmlMemBlocks()) {
    #####:25672:            printf("Leak of %d blocks found in xmlIsMixedElement",
    #####:25673:	           xmlMemBlocks() - mem_base);
    #####:25674:	    test_ret++;
    #####:25675:            printf(" %d", n_doc);
    #####:25676:            printf(" %d", n_name);
    #####:25677:            printf("\n");
        -:25678:        }
        -:25679:    }
        -:25680:    }
    #####:25681:    function_tests++;
        -:25682:
    #####:25683:    return(test_ret);
        -:25684:}
        -:25685:
        -:25686:
        -:25687:static int
    #####:25688:test_xmlIsRef(void) {
    #####:25689:    int test_ret = 0;
        -:25690:
        -:25691:    int mem_base;
        -:25692:    int ret_val;
        -:25693:    xmlDocPtr doc; /* the document */
        -:25694:    int n_doc;
        -:25695:    xmlNodePtr elem; /* the element carrying the attribute */
        -:25696:    int n_elem;
        -:25697:    xmlAttrPtr attr; /* the attribute */
        -:25698:    int n_attr;
        -:25699:
    #####:25700:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:25701:    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    #####:25702:    for (n_attr = 0;n_attr < gen_nb_xmlAttrPtr;n_attr++) {
    #####:25703:        mem_base = xmlMemBlocks();
    #####:25704:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:25705:        elem = gen_xmlNodePtr(n_elem, 1);
    #####:25706:        attr = gen_xmlAttrPtr(n_attr, 2);
        -:25707:
    #####:25708:        ret_val = xmlIsRef(doc, elem, attr);
    #####:25709:        desret_int(ret_val);
    #####:25710:        call_tests++;
    #####:25711:        des_xmlDocPtr(n_doc, doc, 0);
    #####:25712:        des_xmlNodePtr(n_elem, elem, 1);
    #####:25713:        des_xmlAttrPtr(n_attr, attr, 2);
    #####:25714:        xmlResetLastError();
    #####:25715:        if (mem_base != xmlMemBlocks()) {
    #####:25716:            printf("Leak of %d blocks found in xmlIsRef",
    #####:25717:	           xmlMemBlocks() - mem_base);
    #####:25718:	    test_ret++;
    #####:25719:            printf(" %d", n_doc);
    #####:25720:            printf(" %d", n_elem);
    #####:25721:            printf(" %d", n_attr);
    #####:25722:            printf("\n");
        -:25723:        }
        -:25724:    }
        -:25725:    }
        -:25726:    }
    #####:25727:    function_tests++;
        -:25728:
    #####:25729:    return(test_ret);
        -:25730:}
        -:25731:
        -:25732:
        -:25733:static int
    #####:25734:test_xmlNewDocElementContent(void) {
    #####:25735:    int test_ret = 0;
        -:25736:
        -:25737:    int mem_base;
        -:25738:    xmlElementContentPtr ret_val;
        -:25739:    xmlDocPtr doc; /* the document */
        -:25740:    int n_doc;
        -:25741:    xmlChar * name; /* the subelement name or NULL */
        -:25742:    int n_name;
        -:25743:    xmlElementContentType type; /* the type of element content decl */
        -:25744:    int n_type;
        -:25745:
    #####:25746:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:25747:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:25748:    for (n_type = 0;n_type < gen_nb_xmlElementContentType;n_type++) {
    #####:25749:        mem_base = xmlMemBlocks();
    #####:25750:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:25751:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:25752:        type = gen_xmlElementContentType(n_type, 2);
        -:25753:
    #####:25754:        ret_val = xmlNewDocElementContent(doc, (const xmlChar *)name, type);
    #####:25755:        xmlFreeDocElementContent(doc, ret_val); ret_val = NULL;
    #####:25756:        desret_xmlElementContentPtr(ret_val);
    #####:25757:        call_tests++;
    #####:25758:        des_xmlDocPtr(n_doc, doc, 0);
    #####:25759:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:25760:        des_xmlElementContentType(n_type, type, 2);
    #####:25761:        xmlResetLastError();
    #####:25762:        if (mem_base != xmlMemBlocks()) {
    #####:25763:            printf("Leak of %d blocks found in xmlNewDocElementContent",
    #####:25764:	           xmlMemBlocks() - mem_base);
    #####:25765:	    test_ret++;
    #####:25766:            printf(" %d", n_doc);
    #####:25767:            printf(" %d", n_name);
    #####:25768:            printf(" %d", n_type);
    #####:25769:            printf("\n");
        -:25770:        }
        -:25771:    }
        -:25772:    }
        -:25773:    }
    #####:25774:    function_tests++;
        -:25775:
    #####:25776:    return(test_ret);
        -:25777:}
        -:25778:
        -:25779:
        -:25780:static int
    #####:25781:test_xmlNewElementContent(void) {
    #####:25782:    int test_ret = 0;
        -:25783:
        -:25784:    int mem_base;
        -:25785:    xmlElementContentPtr ret_val;
        -:25786:    xmlChar * name; /* the subelement name or NULL */
        -:25787:    int n_name;
        -:25788:    xmlElementContentType type; /* the type of element content decl */
        -:25789:    int n_type;
        -:25790:
    #####:25791:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:25792:    for (n_type = 0;n_type < gen_nb_xmlElementContentType;n_type++) {
    #####:25793:        mem_base = xmlMemBlocks();
    #####:25794:        name = gen_const_xmlChar_ptr(n_name, 0);
    #####:25795:        type = gen_xmlElementContentType(n_type, 1);
        -:25796:
    #####:25797:        ret_val = xmlNewElementContent((const xmlChar *)name, type);
    #####:25798:        desret_xmlElementContentPtr(ret_val);
    #####:25799:        call_tests++;
    #####:25800:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 0);
    #####:25801:        des_xmlElementContentType(n_type, type, 1);
    #####:25802:        xmlResetLastError();
    #####:25803:        if (mem_base != xmlMemBlocks()) {
    #####:25804:            printf("Leak of %d blocks found in xmlNewElementContent",
    #####:25805:	           xmlMemBlocks() - mem_base);
    #####:25806:	    test_ret++;
    #####:25807:            printf(" %d", n_name);
    #####:25808:            printf(" %d", n_type);
    #####:25809:            printf("\n");
        -:25810:        }
        -:25811:    }
        -:25812:    }
    #####:25813:    function_tests++;
        -:25814:
    #####:25815:    return(test_ret);
        -:25816:}
        -:25817:
        -:25818:
        -:25819:static int
    #####:25820:test_xmlNewValidCtxt(void) {
    #####:25821:    int test_ret = 0;
        -:25822:
        -:25823:
        -:25824:    /* missing type support */
    #####:25825:    return(test_ret);
        -:25826:}
        -:25827:
        -:25828:
        -:25829:static int
    #####:25830:test_xmlRemoveID(void) {
    #####:25831:    int test_ret = 0;
        -:25832:
        -:25833:    int mem_base;
        -:25834:    int ret_val;
        -:25835:    xmlDocPtr doc; /* the document */
        -:25836:    int n_doc;
        -:25837:    xmlAttrPtr attr; /* the attribute */
        -:25838:    int n_attr;
        -:25839:
    #####:25840:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:25841:    for (n_attr = 0;n_attr < gen_nb_xmlAttrPtr;n_attr++) {
    #####:25842:        mem_base = xmlMemBlocks();
    #####:25843:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:25844:        attr = gen_xmlAttrPtr(n_attr, 1);
        -:25845:
    #####:25846:        ret_val = xmlRemoveID(doc, attr);
    #####:25847:        desret_int(ret_val);
    #####:25848:        call_tests++;
    #####:25849:        des_xmlDocPtr(n_doc, doc, 0);
    #####:25850:        des_xmlAttrPtr(n_attr, attr, 1);
    #####:25851:        xmlResetLastError();
    #####:25852:        if (mem_base != xmlMemBlocks()) {
    #####:25853:            printf("Leak of %d blocks found in xmlRemoveID",
    #####:25854:	           xmlMemBlocks() - mem_base);
    #####:25855:	    test_ret++;
    #####:25856:            printf(" %d", n_doc);
    #####:25857:            printf(" %d", n_attr);
    #####:25858:            printf("\n");
        -:25859:        }
        -:25860:    }
        -:25861:    }
    #####:25862:    function_tests++;
        -:25863:
    #####:25864:    return(test_ret);
        -:25865:}
        -:25866:
        -:25867:
        -:25868:static int
    #####:25869:test_xmlRemoveRef(void) {
    #####:25870:    int test_ret = 0;
        -:25871:
        -:25872:    int mem_base;
        -:25873:    int ret_val;
        -:25874:    xmlDocPtr doc; /* the document */
        -:25875:    int n_doc;
        -:25876:    xmlAttrPtr attr; /* the attribute */
        -:25877:    int n_attr;
        -:25878:
    #####:25879:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:25880:    for (n_attr = 0;n_attr < gen_nb_xmlAttrPtr;n_attr++) {
    #####:25881:        mem_base = xmlMemBlocks();
    #####:25882:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:25883:        attr = gen_xmlAttrPtr(n_attr, 1);
        -:25884:
    #####:25885:        ret_val = xmlRemoveRef(doc, attr);
    #####:25886:        desret_int(ret_val);
    #####:25887:        call_tests++;
    #####:25888:        des_xmlDocPtr(n_doc, doc, 0);
    #####:25889:        des_xmlAttrPtr(n_attr, attr, 1);
    #####:25890:        xmlResetLastError();
    #####:25891:        if (mem_base != xmlMemBlocks()) {
    #####:25892:            printf("Leak of %d blocks found in xmlRemoveRef",
    #####:25893:	           xmlMemBlocks() - mem_base);
    #####:25894:	    test_ret++;
    #####:25895:            printf(" %d", n_doc);
    #####:25896:            printf(" %d", n_attr);
    #####:25897:            printf("\n");
        -:25898:        }
        -:25899:    }
        -:25900:    }
    #####:25901:    function_tests++;
        -:25902:
    #####:25903:    return(test_ret);
        -:25904:}
        -:25905:
        -:25906:
        -:25907:static int
    #####:25908:test_xmlSnprintfElementContent(void) {
    #####:25909:    int test_ret = 0;
        -:25910:
        -:25911:    int mem_base;
        -:25912:    char * buf; /* an output buffer */
        -:25913:    int n_buf;
        -:25914:    int size; /* the buffer size */
        -:25915:    int n_size;
        -:25916:    xmlElementContentPtr content; /* An element table */
        -:25917:    int n_content;
        -:25918:    int englob; /* 1 if one must print the englobing parenthesis, 0 otherwise */
        -:25919:    int n_englob;
        -:25920:
    #####:25921:    for (n_buf = 0;n_buf < gen_nb_char_ptr;n_buf++) {
    #####:25922:    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    #####:25923:    for (n_content = 0;n_content < gen_nb_xmlElementContentPtr;n_content++) {
    #####:25924:    for (n_englob = 0;n_englob < gen_nb_int;n_englob++) {
    #####:25925:        mem_base = xmlMemBlocks();
    #####:25926:        buf = gen_char_ptr(n_buf, 0);
    #####:25927:        size = gen_int(n_size, 1);
    #####:25928:        content = gen_xmlElementContentPtr(n_content, 2);
    #####:25929:        englob = gen_int(n_englob, 3);
        -:25930:
    #####:25931:        xmlSnprintfElementContent(buf, size, content, englob);
    #####:25932:        call_tests++;
    #####:25933:        des_char_ptr(n_buf, buf, 0);
    #####:25934:        des_int(n_size, size, 1);
    #####:25935:        des_xmlElementContentPtr(n_content, content, 2);
    #####:25936:        des_int(n_englob, englob, 3);
    #####:25937:        xmlResetLastError();
    #####:25938:        if (mem_base != xmlMemBlocks()) {
    #####:25939:            printf("Leak of %d blocks found in xmlSnprintfElementContent",
    #####:25940:	           xmlMemBlocks() - mem_base);
    #####:25941:	    test_ret++;
    #####:25942:            printf(" %d", n_buf);
    #####:25943:            printf(" %d", n_size);
    #####:25944:            printf(" %d", n_content);
    #####:25945:            printf(" %d", n_englob);
    #####:25946:            printf("\n");
        -:25947:        }
        -:25948:    }
        -:25949:    }
        -:25950:    }
        -:25951:    }
    #####:25952:    function_tests++;
        -:25953:
    #####:25954:    return(test_ret);
        -:25955:}
        -:25956:
        -:25957:
        -:25958:static int
    #####:25959:test_xmlSprintfElementContent(void) {
    #####:25960:    int test_ret = 0;
        -:25961:
        -:25962:#if defined(LIBXML_OUTPUT_ENABLED)
        -:25963:#ifdef LIBXML_OUTPUT_ENABLED
        -:25964:    int mem_base;
        -:25965:    char * buf; /* an output buffer */
        -:25966:    int n_buf;
        -:25967:    xmlElementContentPtr content; /* An element table */
        -:25968:    int n_content;
        -:25969:    int englob; /* 1 if one must print the englobing parenthesis, 0 otherwise */
        -:25970:    int n_englob;
        -:25971:
    #####:25972:    for (n_buf = 0;n_buf < gen_nb_char_ptr;n_buf++) {
    #####:25973:    for (n_content = 0;n_content < gen_nb_xmlElementContentPtr;n_content++) {
    #####:25974:    for (n_englob = 0;n_englob < gen_nb_int;n_englob++) {
    #####:25975:        mem_base = xmlMemBlocks();
    #####:25976:        buf = gen_char_ptr(n_buf, 0);
    #####:25977:        content = gen_xmlElementContentPtr(n_content, 1);
    #####:25978:        englob = gen_int(n_englob, 2);
        -:25979:
    #####:25980:        xmlSprintfElementContent(buf, content, englob);
    #####:25981:        call_tests++;
    #####:25982:        des_char_ptr(n_buf, buf, 0);
    #####:25983:        des_xmlElementContentPtr(n_content, content, 1);
    #####:25984:        des_int(n_englob, englob, 2);
    #####:25985:        xmlResetLastError();
    #####:25986:        if (mem_base != xmlMemBlocks()) {
    #####:25987:            printf("Leak of %d blocks found in xmlSprintfElementContent",
    #####:25988:	           xmlMemBlocks() - mem_base);
    #####:25989:	    test_ret++;
    #####:25990:            printf(" %d", n_buf);
    #####:25991:            printf(" %d", n_content);
    #####:25992:            printf(" %d", n_englob);
    #####:25993:            printf("\n");
        -:25994:        }
        -:25995:    }
        -:25996:    }
        -:25997:    }
    #####:25998:    function_tests++;
        -:25999:#endif
        -:26000:#endif
        -:26001:
    #####:26002:    return(test_ret);
        -:26003:}
        -:26004:
        -:26005:
        -:26006:static int
    #####:26007:test_xmlValidBuildContentModel(void) {
    #####:26008:    int test_ret = 0;
        -:26009:
        -:26010:#if defined(LIBXML_VALID_ENABLED) && defined(LIBXML_REGEXP_ENABLED)
        -:26011:    int mem_base;
        -:26012:    int ret_val;
        -:26013:    xmlValidCtxtPtr ctxt; /* a validation context */
        -:26014:    int n_ctxt;
        -:26015:    xmlElementPtr elem; /* an element declaration node */
        -:26016:    int n_elem;
        -:26017:
    #####:26018:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    #####:26019:    for (n_elem = 0;n_elem < gen_nb_xmlElementPtr;n_elem++) {
    #####:26020:        mem_base = xmlMemBlocks();
    #####:26021:        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
    #####:26022:        elem = gen_xmlElementPtr(n_elem, 1);
        -:26023:
    #####:26024:        ret_val = xmlValidBuildContentModel(ctxt, elem);
    #####:26025:        desret_int(ret_val);
    #####:26026:        call_tests++;
    #####:26027:        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:26028:        des_xmlElementPtr(n_elem, elem, 1);
    #####:26029:        xmlResetLastError();
    #####:26030:        if (mem_base != xmlMemBlocks()) {
    #####:26031:            printf("Leak of %d blocks found in xmlValidBuildContentModel",
    #####:26032:	           xmlMemBlocks() - mem_base);
    #####:26033:	    test_ret++;
    #####:26034:            printf(" %d", n_ctxt);
    #####:26035:            printf(" %d", n_elem);
    #####:26036:            printf("\n");
        -:26037:        }
        -:26038:    }
        -:26039:    }
    #####:26040:    function_tests++;
        -:26041:#endif
        -:26042:
    #####:26043:    return(test_ret);
        -:26044:}
        -:26045:
        -:26046:
        -:26047:static int
    #####:26048:test_xmlValidCtxtNormalizeAttributeValue(void) {
    #####:26049:    int test_ret = 0;
        -:26050:
        -:26051:#if defined(LIBXML_VALID_ENABLED)
        -:26052:    int mem_base;
        -:26053:    xmlChar * ret_val;
        -:26054:    xmlValidCtxtPtr ctxt; /* the validation context or NULL */
        -:26055:    int n_ctxt;
        -:26056:    xmlDocPtr doc; /* the document */
        -:26057:    int n_doc;
        -:26058:    xmlNodePtr elem; /* the parent */
        -:26059:    int n_elem;
        -:26060:    xmlChar * name; /* the attribute name */
        -:26061:    int n_name;
        -:26062:    xmlChar * value; /* the attribute value */
        -:26063:    int n_value;
        -:26064:
    #####:26065:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    #####:26066:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:26067:    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    #####:26068:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:26069:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:26070:        mem_base = xmlMemBlocks();
    #####:26071:        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
    #####:26072:        doc = gen_xmlDocPtr(n_doc, 1);
    #####:26073:        elem = gen_xmlNodePtr(n_elem, 2);
    #####:26074:        name = gen_const_xmlChar_ptr(n_name, 3);
    #####:26075:        value = gen_const_xmlChar_ptr(n_value, 4);
        -:26076:
    #####:26077:        ret_val = xmlValidCtxtNormalizeAttributeValue(ctxt, doc, elem, (const xmlChar *)name, (const xmlChar *)value);
    #####:26078:        desret_xmlChar_ptr(ret_val);
    #####:26079:        call_tests++;
    #####:26080:        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:26081:        des_xmlDocPtr(n_doc, doc, 1);
    #####:26082:        des_xmlNodePtr(n_elem, elem, 2);
    #####:26083:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 3);
    #####:26084:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 4);
    #####:26085:        xmlResetLastError();
    #####:26086:        if (mem_base != xmlMemBlocks()) {
    #####:26087:            printf("Leak of %d blocks found in xmlValidCtxtNormalizeAttributeValue",
    #####:26088:	           xmlMemBlocks() - mem_base);
    #####:26089:	    test_ret++;
    #####:26090:            printf(" %d", n_ctxt);
    #####:26091:            printf(" %d", n_doc);
    #####:26092:            printf(" %d", n_elem);
    #####:26093:            printf(" %d", n_name);
    #####:26094:            printf(" %d", n_value);
    #####:26095:            printf("\n");
        -:26096:        }
        -:26097:    }
        -:26098:    }
        -:26099:    }
        -:26100:    }
        -:26101:    }
    #####:26102:    function_tests++;
        -:26103:#endif
        -:26104:
    #####:26105:    return(test_ret);
        -:26106:}
        -:26107:
        -:26108:
        -:26109:#define gen_nb_xmlElementContent_ptr 1
    #####:26110:static xmlElementContent * gen_xmlElementContent_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:26111:    return(NULL);
        -:26112:}
    #####:26113:static void des_xmlElementContent_ptr(int no ATTRIBUTE_UNUSED, xmlElementContent * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:26114:}
        -:26115:
        -:26116:static int
    #####:26117:test_xmlValidGetPotentialChildren(void) {
    #####:26118:    int test_ret = 0;
        -:26119:
        -:26120:#if defined(LIBXML_VALID_ENABLED)
        -:26121:#ifdef LIBXML_VALID_ENABLED
        -:26122:    int mem_base;
        -:26123:    int ret_val;
        -:26124:    xmlElementContent * ctree; /* an element content tree */
        -:26125:    int n_ctree;
        -:26126:    xmlChar ** names; /* an array to store the list of child names */
        -:26127:    int n_names;
        -:26128:    int * len; /* a pointer to the number of element in the list */
        -:26129:    int n_len;
        -:26130:    int max; /* the size of the array */
        -:26131:    int n_max;
        -:26132:
    #####:26133:    for (n_ctree = 0;n_ctree < gen_nb_xmlElementContent_ptr;n_ctree++) {
    #####:26134:    for (n_names = 0;n_names < gen_nb_const_xmlChar_ptr_ptr;n_names++) {
    #####:26135:    for (n_len = 0;n_len < gen_nb_int_ptr;n_len++) {
    #####:26136:    for (n_max = 0;n_max < gen_nb_int;n_max++) {
    #####:26137:        mem_base = xmlMemBlocks();
    #####:26138:        ctree = gen_xmlElementContent_ptr(n_ctree, 0);
    #####:26139:        names = gen_const_xmlChar_ptr_ptr(n_names, 1);
    #####:26140:        len = gen_int_ptr(n_len, 2);
    #####:26141:        max = gen_int(n_max, 3);
        -:26142:
    #####:26143:        ret_val = xmlValidGetPotentialChildren(ctree, (const xmlChar **)names, len, max);
    #####:26144:        desret_int(ret_val);
    #####:26145:        call_tests++;
    #####:26146:        des_xmlElementContent_ptr(n_ctree, ctree, 0);
    #####:26147:        des_const_xmlChar_ptr_ptr(n_names, (const xmlChar **)names, 1);
    #####:26148:        des_int_ptr(n_len, len, 2);
    #####:26149:        des_int(n_max, max, 3);
    #####:26150:        xmlResetLastError();
    #####:26151:        if (mem_base != xmlMemBlocks()) {
    #####:26152:            printf("Leak of %d blocks found in xmlValidGetPotentialChildren",
    #####:26153:	           xmlMemBlocks() - mem_base);
    #####:26154:	    test_ret++;
    #####:26155:            printf(" %d", n_ctree);
    #####:26156:            printf(" %d", n_names);
    #####:26157:            printf(" %d", n_len);
    #####:26158:            printf(" %d", n_max);
    #####:26159:            printf("\n");
        -:26160:        }
        -:26161:    }
        -:26162:    }
        -:26163:    }
        -:26164:    }
    #####:26165:    function_tests++;
        -:26166:#endif
        -:26167:#endif
        -:26168:
    #####:26169:    return(test_ret);
        -:26170:}
        -:26171:
        -:26172:
        -:26173:static int
    #####:26174:test_xmlValidGetValidElements(void) {
    #####:26175:    int test_ret = 0;
        -:26176:
        -:26177:#if defined(LIBXML_VALID_ENABLED)
        -:26178:#ifdef LIBXML_VALID_ENABLED
        -:26179:    int mem_base;
        -:26180:    int ret_val;
        -:26181:    xmlNode * prev; /* an element to insert after */
        -:26182:    int n_prev;
        -:26183:    xmlNode * next; /* an element to insert next */
        -:26184:    int n_next;
        -:26185:    xmlChar ** names; /* an array to store the list of child names */
        -:26186:    int n_names;
        -:26187:    int max; /* the size of the array */
        -:26188:    int n_max;
        -:26189:
    #####:26190:    for (n_prev = 0;n_prev < gen_nb_xmlNodePtr;n_prev++) {
    #####:26191:    for (n_next = 0;n_next < gen_nb_xmlNodePtr;n_next++) {
    #####:26192:    for (n_names = 0;n_names < gen_nb_const_xmlChar_ptr_ptr;n_names++) {
    #####:26193:    for (n_max = 0;n_max < gen_nb_int;n_max++) {
    #####:26194:        mem_base = xmlMemBlocks();
    #####:26195:        prev = gen_xmlNodePtr(n_prev, 0);
    #####:26196:        next = gen_xmlNodePtr(n_next, 1);
    #####:26197:        names = gen_const_xmlChar_ptr_ptr(n_names, 2);
    #####:26198:        max = gen_int(n_max, 3);
        -:26199:
    #####:26200:        ret_val = xmlValidGetValidElements(prev, next, (const xmlChar **)names, max);
    #####:26201:        desret_int(ret_val);
    #####:26202:        call_tests++;
    #####:26203:        des_xmlNodePtr(n_prev, prev, 0);
    #####:26204:        des_xmlNodePtr(n_next, next, 1);
    #####:26205:        des_const_xmlChar_ptr_ptr(n_names, (const xmlChar **)names, 2);
    #####:26206:        des_int(n_max, max, 3);
    #####:26207:        xmlResetLastError();
    #####:26208:        if (mem_base != xmlMemBlocks()) {
    #####:26209:            printf("Leak of %d blocks found in xmlValidGetValidElements",
    #####:26210:	           xmlMemBlocks() - mem_base);
    #####:26211:	    test_ret++;
    #####:26212:            printf(" %d", n_prev);
    #####:26213:            printf(" %d", n_next);
    #####:26214:            printf(" %d", n_names);
    #####:26215:            printf(" %d", n_max);
    #####:26216:            printf("\n");
        -:26217:        }
        -:26218:    }
        -:26219:    }
        -:26220:    }
        -:26221:    }
    #####:26222:    function_tests++;
        -:26223:#endif
        -:26224:#endif
        -:26225:
    #####:26226:    return(test_ret);
        -:26227:}
        -:26228:
        -:26229:
        -:26230:static int
    #####:26231:test_xmlValidNormalizeAttributeValue(void) {
    #####:26232:    int test_ret = 0;
        -:26233:
        -:26234:#if defined(LIBXML_VALID_ENABLED)
        -:26235:    int mem_base;
        -:26236:    xmlChar * ret_val;
        -:26237:    xmlDocPtr doc; /* the document */
        -:26238:    int n_doc;
        -:26239:    xmlNodePtr elem; /* the parent */
        -:26240:    int n_elem;
        -:26241:    xmlChar * name; /* the attribute name */
        -:26242:    int n_name;
        -:26243:    xmlChar * value; /* the attribute value */
        -:26244:    int n_value;
        -:26245:
    #####:26246:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:26247:    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    #####:26248:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:26249:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:26250:        mem_base = xmlMemBlocks();
    #####:26251:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:26252:        elem = gen_xmlNodePtr(n_elem, 1);
    #####:26253:        name = gen_const_xmlChar_ptr(n_name, 2);
    #####:26254:        value = gen_const_xmlChar_ptr(n_value, 3);
        -:26255:
    #####:26256:        ret_val = xmlValidNormalizeAttributeValue(doc, elem, (const xmlChar *)name, (const xmlChar *)value);
    #####:26257:        desret_xmlChar_ptr(ret_val);
    #####:26258:        call_tests++;
    #####:26259:        des_xmlDocPtr(n_doc, doc, 0);
    #####:26260:        des_xmlNodePtr(n_elem, elem, 1);
    #####:26261:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
    #####:26262:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 3);
    #####:26263:        xmlResetLastError();
    #####:26264:        if (mem_base != xmlMemBlocks()) {
    #####:26265:            printf("Leak of %d blocks found in xmlValidNormalizeAttributeValue",
    #####:26266:	           xmlMemBlocks() - mem_base);
    #####:26267:	    test_ret++;
    #####:26268:            printf(" %d", n_doc);
    #####:26269:            printf(" %d", n_elem);
    #####:26270:            printf(" %d", n_name);
    #####:26271:            printf(" %d", n_value);
    #####:26272:            printf("\n");
        -:26273:        }
        -:26274:    }
        -:26275:    }
        -:26276:    }
        -:26277:    }
    #####:26278:    function_tests++;
        -:26279:#endif
        -:26280:
    #####:26281:    return(test_ret);
        -:26282:}
        -:26283:
        -:26284:
        -:26285:static int
    #####:26286:test_xmlValidateAttributeDecl(void) {
    #####:26287:    int test_ret = 0;
        -:26288:
        -:26289:#if defined(LIBXML_VALID_ENABLED)
        -:26290:    int mem_base;
        -:26291:    int ret_val;
        -:26292:    xmlValidCtxtPtr ctxt; /* the validation context */
        -:26293:    int n_ctxt;
        -:26294:    xmlDocPtr doc; /* a document instance */
        -:26295:    int n_doc;
        -:26296:    xmlAttributePtr attr; /* an attribute definition */
        -:26297:    int n_attr;
        -:26298:
    #####:26299:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    #####:26300:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:26301:    for (n_attr = 0;n_attr < gen_nb_xmlAttributePtr;n_attr++) {
    #####:26302:        mem_base = xmlMemBlocks();
    #####:26303:        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
    #####:26304:        doc = gen_xmlDocPtr(n_doc, 1);
    #####:26305:        attr = gen_xmlAttributePtr(n_attr, 2);
        -:26306:
    #####:26307:        ret_val = xmlValidateAttributeDecl(ctxt, doc, attr);
    #####:26308:        desret_int(ret_val);
    #####:26309:        call_tests++;
    #####:26310:        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:26311:        des_xmlDocPtr(n_doc, doc, 1);
    #####:26312:        des_xmlAttributePtr(n_attr, attr, 2);
    #####:26313:        xmlResetLastError();
    #####:26314:        if (mem_base != xmlMemBlocks()) {
    #####:26315:            printf("Leak of %d blocks found in xmlValidateAttributeDecl",
    #####:26316:	           xmlMemBlocks() - mem_base);
    #####:26317:	    test_ret++;
    #####:26318:            printf(" %d", n_ctxt);
    #####:26319:            printf(" %d", n_doc);
    #####:26320:            printf(" %d", n_attr);
    #####:26321:            printf("\n");
        -:26322:        }
        -:26323:    }
        -:26324:    }
        -:26325:    }
    #####:26326:    function_tests++;
        -:26327:#endif
        -:26328:
    #####:26329:    return(test_ret);
        -:26330:}
        -:26331:
        -:26332:
        -:26333:static int
    #####:26334:test_xmlValidateAttributeValue(void) {
    #####:26335:    int test_ret = 0;
        -:26336:
        -:26337:#if defined(LIBXML_VALID_ENABLED)
        -:26338:    int mem_base;
        -:26339:    int ret_val;
        -:26340:    xmlAttributeType type; /* an attribute type */
        -:26341:    int n_type;
        -:26342:    xmlChar * value; /* an attribute value */
        -:26343:    int n_value;
        -:26344:
    #####:26345:    for (n_type = 0;n_type < gen_nb_xmlAttributeType;n_type++) {
    #####:26346:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:26347:        mem_base = xmlMemBlocks();
    #####:26348:        type = gen_xmlAttributeType(n_type, 0);
    #####:26349:        value = gen_const_xmlChar_ptr(n_value, 1);
        -:26350:
    #####:26351:        ret_val = xmlValidateAttributeValue(type, (const xmlChar *)value);
    #####:26352:        desret_int(ret_val);
    #####:26353:        call_tests++;
    #####:26354:        des_xmlAttributeType(n_type, type, 0);
    #####:26355:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 1);
    #####:26356:        xmlResetLastError();
    #####:26357:        if (mem_base != xmlMemBlocks()) {
    #####:26358:            printf("Leak of %d blocks found in xmlValidateAttributeValue",
    #####:26359:	           xmlMemBlocks() - mem_base);
    #####:26360:	    test_ret++;
    #####:26361:            printf(" %d", n_type);
    #####:26362:            printf(" %d", n_value);
    #####:26363:            printf("\n");
        -:26364:        }
        -:26365:    }
        -:26366:    }
    #####:26367:    function_tests++;
        -:26368:#endif
        -:26369:
    #####:26370:    return(test_ret);
        -:26371:}
        -:26372:
        -:26373:
        -:26374:static int
    #####:26375:test_xmlValidateDocument(void) {
    #####:26376:    int test_ret = 0;
        -:26377:
        -:26378:#if defined(LIBXML_VALID_ENABLED)
        -:26379:    int mem_base;
        -:26380:    int ret_val;
        -:26381:    xmlValidCtxtPtr ctxt; /* the validation context */
        -:26382:    int n_ctxt;
        -:26383:    xmlDocPtr doc; /* a document instance */
        -:26384:    int n_doc;
        -:26385:
    #####:26386:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    #####:26387:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:26388:        mem_base = xmlMemBlocks();
    #####:26389:        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
    #####:26390:        doc = gen_xmlDocPtr(n_doc, 1);
        -:26391:
    #####:26392:        ret_val = xmlValidateDocument(ctxt, doc);
    #####:26393:        desret_int(ret_val);
    #####:26394:        call_tests++;
    #####:26395:        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:26396:        des_xmlDocPtr(n_doc, doc, 1);
    #####:26397:        xmlResetLastError();
    #####:26398:        if (mem_base != xmlMemBlocks()) {
    #####:26399:            printf("Leak of %d blocks found in xmlValidateDocument",
    #####:26400:	           xmlMemBlocks() - mem_base);
    #####:26401:	    test_ret++;
    #####:26402:            printf(" %d", n_ctxt);
    #####:26403:            printf(" %d", n_doc);
    #####:26404:            printf("\n");
        -:26405:        }
        -:26406:    }
        -:26407:    }
    #####:26408:    function_tests++;
        -:26409:#endif
        -:26410:
    #####:26411:    return(test_ret);
        -:26412:}
        -:26413:
        -:26414:
        -:26415:static int
    #####:26416:test_xmlValidateDocumentFinal(void) {
    #####:26417:    int test_ret = 0;
        -:26418:
        -:26419:#if defined(LIBXML_VALID_ENABLED)
        -:26420:    int mem_base;
        -:26421:    int ret_val;
        -:26422:    xmlValidCtxtPtr ctxt; /* the validation context */
        -:26423:    int n_ctxt;
        -:26424:    xmlDocPtr doc; /* a document instance */
        -:26425:    int n_doc;
        -:26426:
    #####:26427:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    #####:26428:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:26429:        mem_base = xmlMemBlocks();
    #####:26430:        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
    #####:26431:        doc = gen_xmlDocPtr(n_doc, 1);
        -:26432:
    #####:26433:        ret_val = xmlValidateDocumentFinal(ctxt, doc);
    #####:26434:        desret_int(ret_val);
    #####:26435:        call_tests++;
    #####:26436:        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:26437:        des_xmlDocPtr(n_doc, doc, 1);
    #####:26438:        xmlResetLastError();
    #####:26439:        if (mem_base != xmlMemBlocks()) {
    #####:26440:            printf("Leak of %d blocks found in xmlValidateDocumentFinal",
    #####:26441:	           xmlMemBlocks() - mem_base);
    #####:26442:	    test_ret++;
    #####:26443:            printf(" %d", n_ctxt);
    #####:26444:            printf(" %d", n_doc);
    #####:26445:            printf("\n");
        -:26446:        }
        -:26447:    }
        -:26448:    }
    #####:26449:    function_tests++;
        -:26450:#endif
        -:26451:
    #####:26452:    return(test_ret);
        -:26453:}
        -:26454:
        -:26455:
        -:26456:static int
    #####:26457:test_xmlValidateDtd(void) {
    #####:26458:    int test_ret = 0;
        -:26459:
        -:26460:#if defined(LIBXML_VALID_ENABLED)
        -:26461:    int mem_base;
        -:26462:    int ret_val;
        -:26463:    xmlValidCtxtPtr ctxt; /* the validation context */
        -:26464:    int n_ctxt;
        -:26465:    xmlDocPtr doc; /* a document instance */
        -:26466:    int n_doc;
        -:26467:    xmlDtdPtr dtd; /* a dtd instance */
        -:26468:    int n_dtd;
        -:26469:
    #####:26470:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    #####:26471:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:26472:    for (n_dtd = 0;n_dtd < gen_nb_xmlDtdPtr;n_dtd++) {
    #####:26473:        mem_base = xmlMemBlocks();
    #####:26474:        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
    #####:26475:        doc = gen_xmlDocPtr(n_doc, 1);
    #####:26476:        dtd = gen_xmlDtdPtr(n_dtd, 2);
        -:26477:
    #####:26478:        ret_val = xmlValidateDtd(ctxt, doc, dtd);
    #####:26479:        desret_int(ret_val);
    #####:26480:        call_tests++;
    #####:26481:        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:26482:        des_xmlDocPtr(n_doc, doc, 1);
    #####:26483:        des_xmlDtdPtr(n_dtd, dtd, 2);
    #####:26484:        xmlResetLastError();
    #####:26485:        if (mem_base != xmlMemBlocks()) {
    #####:26486:            printf("Leak of %d blocks found in xmlValidateDtd",
    #####:26487:	           xmlMemBlocks() - mem_base);
    #####:26488:	    test_ret++;
    #####:26489:            printf(" %d", n_ctxt);
    #####:26490:            printf(" %d", n_doc);
    #####:26491:            printf(" %d", n_dtd);
    #####:26492:            printf("\n");
        -:26493:        }
        -:26494:    }
        -:26495:    }
        -:26496:    }
    #####:26497:    function_tests++;
        -:26498:#endif
        -:26499:
    #####:26500:    return(test_ret);
        -:26501:}
        -:26502:
        -:26503:
        -:26504:static int
    #####:26505:test_xmlValidateDtdFinal(void) {
    #####:26506:    int test_ret = 0;
        -:26507:
        -:26508:#if defined(LIBXML_VALID_ENABLED)
        -:26509:    int mem_base;
        -:26510:    int ret_val;
        -:26511:    xmlValidCtxtPtr ctxt; /* the validation context */
        -:26512:    int n_ctxt;
        -:26513:    xmlDocPtr doc; /* a document instance */
        -:26514:    int n_doc;
        -:26515:
    #####:26516:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    #####:26517:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:26518:        mem_base = xmlMemBlocks();
    #####:26519:        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
    #####:26520:        doc = gen_xmlDocPtr(n_doc, 1);
        -:26521:
    #####:26522:        ret_val = xmlValidateDtdFinal(ctxt, doc);
    #####:26523:        desret_int(ret_val);
    #####:26524:        call_tests++;
    #####:26525:        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:26526:        des_xmlDocPtr(n_doc, doc, 1);
    #####:26527:        xmlResetLastError();
    #####:26528:        if (mem_base != xmlMemBlocks()) {
    #####:26529:            printf("Leak of %d blocks found in xmlValidateDtdFinal",
    #####:26530:	           xmlMemBlocks() - mem_base);
    #####:26531:	    test_ret++;
    #####:26532:            printf(" %d", n_ctxt);
    #####:26533:            printf(" %d", n_doc);
    #####:26534:            printf("\n");
        -:26535:        }
        -:26536:    }
        -:26537:    }
    #####:26538:    function_tests++;
        -:26539:#endif
        -:26540:
    #####:26541:    return(test_ret);
        -:26542:}
        -:26543:
        -:26544:
        -:26545:static int
    #####:26546:test_xmlValidateElement(void) {
    #####:26547:    int test_ret = 0;
        -:26548:
        -:26549:#if defined(LIBXML_VALID_ENABLED)
        -:26550:    int mem_base;
        -:26551:    int ret_val;
        -:26552:    xmlValidCtxtPtr ctxt; /* the validation context */
        -:26553:    int n_ctxt;
        -:26554:    xmlDocPtr doc; /* a document instance */
        -:26555:    int n_doc;
        -:26556:    xmlNodePtr elem; /* an element instance */
        -:26557:    int n_elem;
        -:26558:
    #####:26559:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    #####:26560:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:26561:    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    #####:26562:        mem_base = xmlMemBlocks();
    #####:26563:        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
    #####:26564:        doc = gen_xmlDocPtr(n_doc, 1);
    #####:26565:        elem = gen_xmlNodePtr(n_elem, 2);
        -:26566:
    #####:26567:        ret_val = xmlValidateElement(ctxt, doc, elem);
    #####:26568:        desret_int(ret_val);
    #####:26569:        call_tests++;
    #####:26570:        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:26571:        des_xmlDocPtr(n_doc, doc, 1);
    #####:26572:        des_xmlNodePtr(n_elem, elem, 2);
    #####:26573:        xmlResetLastError();
    #####:26574:        if (mem_base != xmlMemBlocks()) {
    #####:26575:            printf("Leak of %d blocks found in xmlValidateElement",
    #####:26576:	           xmlMemBlocks() - mem_base);
    #####:26577:	    test_ret++;
    #####:26578:            printf(" %d", n_ctxt);
    #####:26579:            printf(" %d", n_doc);
    #####:26580:            printf(" %d", n_elem);
    #####:26581:            printf("\n");
        -:26582:        }
        -:26583:    }
        -:26584:    }
        -:26585:    }
    #####:26586:    function_tests++;
        -:26587:#endif
        -:26588:
    #####:26589:    return(test_ret);
        -:26590:}
        -:26591:
        -:26592:
        -:26593:static int
    #####:26594:test_xmlValidateElementDecl(void) {
    #####:26595:    int test_ret = 0;
        -:26596:
        -:26597:#if defined(LIBXML_VALID_ENABLED)
        -:26598:    int mem_base;
        -:26599:    int ret_val;
        -:26600:    xmlValidCtxtPtr ctxt; /* the validation context */
        -:26601:    int n_ctxt;
        -:26602:    xmlDocPtr doc; /* a document instance */
        -:26603:    int n_doc;
        -:26604:    xmlElementPtr elem; /* an element definition */
        -:26605:    int n_elem;
        -:26606:
    #####:26607:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    #####:26608:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:26609:    for (n_elem = 0;n_elem < gen_nb_xmlElementPtr;n_elem++) {
    #####:26610:        mem_base = xmlMemBlocks();
    #####:26611:        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
    #####:26612:        doc = gen_xmlDocPtr(n_doc, 1);
    #####:26613:        elem = gen_xmlElementPtr(n_elem, 2);
        -:26614:
    #####:26615:        ret_val = xmlValidateElementDecl(ctxt, doc, elem);
    #####:26616:        desret_int(ret_val);
    #####:26617:        call_tests++;
    #####:26618:        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:26619:        des_xmlDocPtr(n_doc, doc, 1);
    #####:26620:        des_xmlElementPtr(n_elem, elem, 2);
    #####:26621:        xmlResetLastError();
    #####:26622:        if (mem_base != xmlMemBlocks()) {
    #####:26623:            printf("Leak of %d blocks found in xmlValidateElementDecl",
    #####:26624:	           xmlMemBlocks() - mem_base);
    #####:26625:	    test_ret++;
    #####:26626:            printf(" %d", n_ctxt);
    #####:26627:            printf(" %d", n_doc);
    #####:26628:            printf(" %d", n_elem);
    #####:26629:            printf("\n");
        -:26630:        }
        -:26631:    }
        -:26632:    }
        -:26633:    }
    #####:26634:    function_tests++;
        -:26635:#endif
        -:26636:
    #####:26637:    return(test_ret);
        -:26638:}
        -:26639:
        -:26640:
        -:26641:static int
    #####:26642:test_xmlValidateNameValue(void) {
    #####:26643:    int test_ret = 0;
        -:26644:
        -:26645:#if defined(LIBXML_VALID_ENABLED)
        -:26646:    int mem_base;
        -:26647:    int ret_val;
        -:26648:    xmlChar * value; /* an Name value */
        -:26649:    int n_value;
        -:26650:
    #####:26651:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:26652:        mem_base = xmlMemBlocks();
    #####:26653:        value = gen_const_xmlChar_ptr(n_value, 0);
        -:26654:
    #####:26655:        ret_val = xmlValidateNameValue((const xmlChar *)value);
    #####:26656:        desret_int(ret_val);
    #####:26657:        call_tests++;
    #####:26658:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 0);
    #####:26659:        xmlResetLastError();
    #####:26660:        if (mem_base != xmlMemBlocks()) {
    #####:26661:            printf("Leak of %d blocks found in xmlValidateNameValue",
    #####:26662:	           xmlMemBlocks() - mem_base);
    #####:26663:	    test_ret++;
    #####:26664:            printf(" %d", n_value);
    #####:26665:            printf("\n");
        -:26666:        }
        -:26667:    }
    #####:26668:    function_tests++;
        -:26669:#endif
        -:26670:
    #####:26671:    return(test_ret);
        -:26672:}
        -:26673:
        -:26674:
        -:26675:static int
    #####:26676:test_xmlValidateNamesValue(void) {
    #####:26677:    int test_ret = 0;
        -:26678:
        -:26679:#if defined(LIBXML_VALID_ENABLED)
        -:26680:    int mem_base;
        -:26681:    int ret_val;
        -:26682:    xmlChar * value; /* an Names value */
        -:26683:    int n_value;
        -:26684:
    #####:26685:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:26686:        mem_base = xmlMemBlocks();
    #####:26687:        value = gen_const_xmlChar_ptr(n_value, 0);
        -:26688:
    #####:26689:        ret_val = xmlValidateNamesValue((const xmlChar *)value);
    #####:26690:        desret_int(ret_val);
    #####:26691:        call_tests++;
    #####:26692:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 0);
    #####:26693:        xmlResetLastError();
    #####:26694:        if (mem_base != xmlMemBlocks()) {
    #####:26695:            printf("Leak of %d blocks found in xmlValidateNamesValue",
    #####:26696:	           xmlMemBlocks() - mem_base);
    #####:26697:	    test_ret++;
    #####:26698:            printf(" %d", n_value);
    #####:26699:            printf("\n");
        -:26700:        }
        -:26701:    }
    #####:26702:    function_tests++;
        -:26703:#endif
        -:26704:
    #####:26705:    return(test_ret);
        -:26706:}
        -:26707:
        -:26708:
        -:26709:static int
    #####:26710:test_xmlValidateNmtokenValue(void) {
    #####:26711:    int test_ret = 0;
        -:26712:
        -:26713:#if defined(LIBXML_VALID_ENABLED)
        -:26714:    int mem_base;
        -:26715:    int ret_val;
        -:26716:    xmlChar * value; /* an Nmtoken value */
        -:26717:    int n_value;
        -:26718:
    #####:26719:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:26720:        mem_base = xmlMemBlocks();
    #####:26721:        value = gen_const_xmlChar_ptr(n_value, 0);
        -:26722:
    #####:26723:        ret_val = xmlValidateNmtokenValue((const xmlChar *)value);
    #####:26724:        desret_int(ret_val);
    #####:26725:        call_tests++;
    #####:26726:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 0);
    #####:26727:        xmlResetLastError();
    #####:26728:        if (mem_base != xmlMemBlocks()) {
    #####:26729:            printf("Leak of %d blocks found in xmlValidateNmtokenValue",
    #####:26730:	           xmlMemBlocks() - mem_base);
    #####:26731:	    test_ret++;
    #####:26732:            printf(" %d", n_value);
    #####:26733:            printf("\n");
        -:26734:        }
        -:26735:    }
    #####:26736:    function_tests++;
        -:26737:#endif
        -:26738:
    #####:26739:    return(test_ret);
        -:26740:}
        -:26741:
        -:26742:
        -:26743:static int
    #####:26744:test_xmlValidateNmtokensValue(void) {
    #####:26745:    int test_ret = 0;
        -:26746:
        -:26747:#if defined(LIBXML_VALID_ENABLED)
        -:26748:    int mem_base;
        -:26749:    int ret_val;
        -:26750:    xmlChar * value; /* an Nmtokens value */
        -:26751:    int n_value;
        -:26752:
    #####:26753:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:26754:        mem_base = xmlMemBlocks();
    #####:26755:        value = gen_const_xmlChar_ptr(n_value, 0);
        -:26756:
    #####:26757:        ret_val = xmlValidateNmtokensValue((const xmlChar *)value);
    #####:26758:        desret_int(ret_val);
    #####:26759:        call_tests++;
    #####:26760:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 0);
    #####:26761:        xmlResetLastError();
    #####:26762:        if (mem_base != xmlMemBlocks()) {
    #####:26763:            printf("Leak of %d blocks found in xmlValidateNmtokensValue",
    #####:26764:	           xmlMemBlocks() - mem_base);
    #####:26765:	    test_ret++;
    #####:26766:            printf(" %d", n_value);
    #####:26767:            printf("\n");
        -:26768:        }
        -:26769:    }
    #####:26770:    function_tests++;
        -:26771:#endif
        -:26772:
    #####:26773:    return(test_ret);
        -:26774:}
        -:26775:
        -:26776:
        -:26777:static int
    #####:26778:test_xmlValidateNotationDecl(void) {
    #####:26779:    int test_ret = 0;
        -:26780:
        -:26781:#if defined(LIBXML_VALID_ENABLED)
        -:26782:    int mem_base;
        -:26783:    int ret_val;
        -:26784:    xmlValidCtxtPtr ctxt; /* the validation context */
        -:26785:    int n_ctxt;
        -:26786:    xmlDocPtr doc; /* a document instance */
        -:26787:    int n_doc;
        -:26788:    xmlNotationPtr nota; /* a notation definition */
        -:26789:    int n_nota;
        -:26790:
    #####:26791:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    #####:26792:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:26793:    for (n_nota = 0;n_nota < gen_nb_xmlNotationPtr;n_nota++) {
    #####:26794:        mem_base = xmlMemBlocks();
    #####:26795:        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
    #####:26796:        doc = gen_xmlDocPtr(n_doc, 1);
    #####:26797:        nota = gen_xmlNotationPtr(n_nota, 2);
        -:26798:
    #####:26799:        ret_val = xmlValidateNotationDecl(ctxt, doc, nota);
    #####:26800:        desret_int(ret_val);
    #####:26801:        call_tests++;
    #####:26802:        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:26803:        des_xmlDocPtr(n_doc, doc, 1);
    #####:26804:        des_xmlNotationPtr(n_nota, nota, 2);
    #####:26805:        xmlResetLastError();
    #####:26806:        if (mem_base != xmlMemBlocks()) {
    #####:26807:            printf("Leak of %d blocks found in xmlValidateNotationDecl",
    #####:26808:	           xmlMemBlocks() - mem_base);
    #####:26809:	    test_ret++;
    #####:26810:            printf(" %d", n_ctxt);
    #####:26811:            printf(" %d", n_doc);
    #####:26812:            printf(" %d", n_nota);
    #####:26813:            printf("\n");
        -:26814:        }
        -:26815:    }
        -:26816:    }
        -:26817:    }
    #####:26818:    function_tests++;
        -:26819:#endif
        -:26820:
    #####:26821:    return(test_ret);
        -:26822:}
        -:26823:
        -:26824:
        -:26825:static int
    #####:26826:test_xmlValidateNotationUse(void) {
    #####:26827:    int test_ret = 0;
        -:26828:
        -:26829:#if defined(LIBXML_VALID_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
        -:26830:    int mem_base;
        -:26831:    int ret_val;
        -:26832:    xmlValidCtxtPtr ctxt; /* the validation context */
        -:26833:    int n_ctxt;
        -:26834:    xmlDocPtr doc; /* the document */
        -:26835:    int n_doc;
        -:26836:    xmlChar * notationName; /* the notation name to check */
        -:26837:    int n_notationName;
        -:26838:
    #####:26839:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    #####:26840:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:26841:    for (n_notationName = 0;n_notationName < gen_nb_const_xmlChar_ptr;n_notationName++) {
    #####:26842:        mem_base = xmlMemBlocks();
    #####:26843:        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
    #####:26844:        doc = gen_xmlDocPtr(n_doc, 1);
    #####:26845:        notationName = gen_const_xmlChar_ptr(n_notationName, 2);
        -:26846:
    #####:26847:        ret_val = xmlValidateNotationUse(ctxt, doc, (const xmlChar *)notationName);
    #####:26848:        desret_int(ret_val);
    #####:26849:        call_tests++;
    #####:26850:        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:26851:        des_xmlDocPtr(n_doc, doc, 1);
    #####:26852:        des_const_xmlChar_ptr(n_notationName, (const xmlChar *)notationName, 2);
    #####:26853:        xmlResetLastError();
    #####:26854:        if (mem_base != xmlMemBlocks()) {
    #####:26855:            printf("Leak of %d blocks found in xmlValidateNotationUse",
    #####:26856:	           xmlMemBlocks() - mem_base);
    #####:26857:	    test_ret++;
    #####:26858:            printf(" %d", n_ctxt);
    #####:26859:            printf(" %d", n_doc);
    #####:26860:            printf(" %d", n_notationName);
    #####:26861:            printf("\n");
        -:26862:        }
        -:26863:    }
        -:26864:    }
        -:26865:    }
    #####:26866:    function_tests++;
        -:26867:#endif
        -:26868:
    #####:26869:    return(test_ret);
        -:26870:}
        -:26871:
        -:26872:
        -:26873:static int
    #####:26874:test_xmlValidateOneAttribute(void) {
    #####:26875:    int test_ret = 0;
        -:26876:
        -:26877:#if defined(LIBXML_VALID_ENABLED)
        -:26878:    int mem_base;
        -:26879:    int ret_val;
        -:26880:    xmlValidCtxtPtr ctxt; /* the validation context */
        -:26881:    int n_ctxt;
        -:26882:    xmlDocPtr doc; /* a document instance */
        -:26883:    int n_doc;
        -:26884:    xmlNodePtr elem; /* an element instance */
        -:26885:    int n_elem;
        -:26886:    xmlAttrPtr attr; /* an attribute instance */
        -:26887:    int n_attr;
        -:26888:    xmlChar * value; /* the attribute value (without entities processing) */
        -:26889:    int n_value;
        -:26890:
    #####:26891:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    #####:26892:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:26893:    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    #####:26894:    for (n_attr = 0;n_attr < gen_nb_xmlAttrPtr;n_attr++) {
    #####:26895:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:26896:        mem_base = xmlMemBlocks();
    #####:26897:        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
    #####:26898:        doc = gen_xmlDocPtr(n_doc, 1);
    #####:26899:        elem = gen_xmlNodePtr(n_elem, 2);
    #####:26900:        attr = gen_xmlAttrPtr(n_attr, 3);
    #####:26901:        value = gen_const_xmlChar_ptr(n_value, 4);
        -:26902:
    #####:26903:        ret_val = xmlValidateOneAttribute(ctxt, doc, elem, attr, (const xmlChar *)value);
    #####:26904:        desret_int(ret_val);
    #####:26905:        call_tests++;
    #####:26906:        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:26907:        des_xmlDocPtr(n_doc, doc, 1);
    #####:26908:        des_xmlNodePtr(n_elem, elem, 2);
    #####:26909:        des_xmlAttrPtr(n_attr, attr, 3);
    #####:26910:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 4);
    #####:26911:        xmlResetLastError();
    #####:26912:        if (mem_base != xmlMemBlocks()) {
    #####:26913:            printf("Leak of %d blocks found in xmlValidateOneAttribute",
    #####:26914:	           xmlMemBlocks() - mem_base);
    #####:26915:	    test_ret++;
    #####:26916:            printf(" %d", n_ctxt);
    #####:26917:            printf(" %d", n_doc);
    #####:26918:            printf(" %d", n_elem);
    #####:26919:            printf(" %d", n_attr);
    #####:26920:            printf(" %d", n_value);
    #####:26921:            printf("\n");
        -:26922:        }
        -:26923:    }
        -:26924:    }
        -:26925:    }
        -:26926:    }
        -:26927:    }
    #####:26928:    function_tests++;
        -:26929:#endif
        -:26930:
    #####:26931:    return(test_ret);
        -:26932:}
        -:26933:
        -:26934:
        -:26935:static int
    #####:26936:test_xmlValidateOneElement(void) {
    #####:26937:    int test_ret = 0;
        -:26938:
        -:26939:#if defined(LIBXML_VALID_ENABLED)
        -:26940:    int mem_base;
        -:26941:    int ret_val;
        -:26942:    xmlValidCtxtPtr ctxt; /* the validation context */
        -:26943:    int n_ctxt;
        -:26944:    xmlDocPtr doc; /* a document instance */
        -:26945:    int n_doc;
        -:26946:    xmlNodePtr elem; /* an element instance */
        -:26947:    int n_elem;
        -:26948:
    #####:26949:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    #####:26950:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:26951:    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    #####:26952:        mem_base = xmlMemBlocks();
    #####:26953:        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
    #####:26954:        doc = gen_xmlDocPtr(n_doc, 1);
    #####:26955:        elem = gen_xmlNodePtr(n_elem, 2);
        -:26956:
    #####:26957:        ret_val = xmlValidateOneElement(ctxt, doc, elem);
    #####:26958:        desret_int(ret_val);
    #####:26959:        call_tests++;
    #####:26960:        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:26961:        des_xmlDocPtr(n_doc, doc, 1);
    #####:26962:        des_xmlNodePtr(n_elem, elem, 2);
    #####:26963:        xmlResetLastError();
    #####:26964:        if (mem_base != xmlMemBlocks()) {
    #####:26965:            printf("Leak of %d blocks found in xmlValidateOneElement",
    #####:26966:	           xmlMemBlocks() - mem_base);
    #####:26967:	    test_ret++;
    #####:26968:            printf(" %d", n_ctxt);
    #####:26969:            printf(" %d", n_doc);
    #####:26970:            printf(" %d", n_elem);
    #####:26971:            printf("\n");
        -:26972:        }
        -:26973:    }
        -:26974:    }
        -:26975:    }
    #####:26976:    function_tests++;
        -:26977:#endif
        -:26978:
    #####:26979:    return(test_ret);
        -:26980:}
        -:26981:
        -:26982:
        -:26983:static int
    #####:26984:test_xmlValidateOneNamespace(void) {
    #####:26985:    int test_ret = 0;
        -:26986:
        -:26987:#if defined(LIBXML_VALID_ENABLED)
        -:26988:    int mem_base;
        -:26989:    int ret_val;
        -:26990:    xmlValidCtxtPtr ctxt; /* the validation context */
        -:26991:    int n_ctxt;
        -:26992:    xmlDocPtr doc; /* a document instance */
        -:26993:    int n_doc;
        -:26994:    xmlNodePtr elem; /* an element instance */
        -:26995:    int n_elem;
        -:26996:    xmlChar * prefix; /* the namespace prefix */
        -:26997:    int n_prefix;
        -:26998:    xmlNsPtr ns; /* an namespace declaration instance */
        -:26999:    int n_ns;
        -:27000:    xmlChar * value; /* the attribute value (without entities processing) */
        -:27001:    int n_value;
        -:27002:
    #####:27003:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    #####:27004:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:27005:    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    #####:27006:    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    #####:27007:    for (n_ns = 0;n_ns < gen_nb_xmlNsPtr;n_ns++) {
    #####:27008:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:27009:        mem_base = xmlMemBlocks();
    #####:27010:        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
    #####:27011:        doc = gen_xmlDocPtr(n_doc, 1);
    #####:27012:        elem = gen_xmlNodePtr(n_elem, 2);
    #####:27013:        prefix = gen_const_xmlChar_ptr(n_prefix, 3);
    #####:27014:        ns = gen_xmlNsPtr(n_ns, 4);
    #####:27015:        value = gen_const_xmlChar_ptr(n_value, 5);
        -:27016:
    #####:27017:        ret_val = xmlValidateOneNamespace(ctxt, doc, elem, (const xmlChar *)prefix, ns, (const xmlChar *)value);
    #####:27018:        desret_int(ret_val);
    #####:27019:        call_tests++;
    #####:27020:        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:27021:        des_xmlDocPtr(n_doc, doc, 1);
    #####:27022:        des_xmlNodePtr(n_elem, elem, 2);
    #####:27023:        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 3);
    #####:27024:        des_xmlNsPtr(n_ns, ns, 4);
    #####:27025:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 5);
    #####:27026:        xmlResetLastError();
    #####:27027:        if (mem_base != xmlMemBlocks()) {
    #####:27028:            printf("Leak of %d blocks found in xmlValidateOneNamespace",
    #####:27029:	           xmlMemBlocks() - mem_base);
    #####:27030:	    test_ret++;
    #####:27031:            printf(" %d", n_ctxt);
    #####:27032:            printf(" %d", n_doc);
    #####:27033:            printf(" %d", n_elem);
    #####:27034:            printf(" %d", n_prefix);
    #####:27035:            printf(" %d", n_ns);
    #####:27036:            printf(" %d", n_value);
    #####:27037:            printf("\n");
        -:27038:        }
        -:27039:    }
        -:27040:    }
        -:27041:    }
        -:27042:    }
        -:27043:    }
        -:27044:    }
    #####:27045:    function_tests++;
        -:27046:#endif
        -:27047:
    #####:27048:    return(test_ret);
        -:27049:}
        -:27050:
        -:27051:
        -:27052:static int
    #####:27053:test_xmlValidatePopElement(void) {
    #####:27054:    int test_ret = 0;
        -:27055:
        -:27056:#if defined(LIBXML_VALID_ENABLED) && defined(LIBXML_REGEXP_ENABLED)
        -:27057:    int mem_base;
        -:27058:    int ret_val;
        -:27059:    xmlValidCtxtPtr ctxt; /* the validation context */
        -:27060:    int n_ctxt;
        -:27061:    xmlDocPtr doc; /* a document instance */
        -:27062:    int n_doc;
        -:27063:    xmlNodePtr elem; /* an element instance */
        -:27064:    int n_elem;
        -:27065:    xmlChar * qname; /* the qualified name as appearing in the serialization */
        -:27066:    int n_qname;
        -:27067:
    #####:27068:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    #####:27069:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:27070:    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    #####:27071:    for (n_qname = 0;n_qname < gen_nb_const_xmlChar_ptr;n_qname++) {
    #####:27072:        mem_base = xmlMemBlocks();
    #####:27073:        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
    #####:27074:        doc = gen_xmlDocPtr(n_doc, 1);
    #####:27075:        elem = gen_xmlNodePtr(n_elem, 2);
    #####:27076:        qname = gen_const_xmlChar_ptr(n_qname, 3);
        -:27077:
    #####:27078:        ret_val = xmlValidatePopElement(ctxt, doc, elem, (const xmlChar *)qname);
    #####:27079:        desret_int(ret_val);
    #####:27080:        call_tests++;
    #####:27081:        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:27082:        des_xmlDocPtr(n_doc, doc, 1);
    #####:27083:        des_xmlNodePtr(n_elem, elem, 2);
    #####:27084:        des_const_xmlChar_ptr(n_qname, (const xmlChar *)qname, 3);
    #####:27085:        xmlResetLastError();
    #####:27086:        if (mem_base != xmlMemBlocks()) {
    #####:27087:            printf("Leak of %d blocks found in xmlValidatePopElement",
    #####:27088:	           xmlMemBlocks() - mem_base);
    #####:27089:	    test_ret++;
    #####:27090:            printf(" %d", n_ctxt);
    #####:27091:            printf(" %d", n_doc);
    #####:27092:            printf(" %d", n_elem);
    #####:27093:            printf(" %d", n_qname);
    #####:27094:            printf("\n");
        -:27095:        }
        -:27096:    }
        -:27097:    }
        -:27098:    }
        -:27099:    }
    #####:27100:    function_tests++;
        -:27101:#endif
        -:27102:
    #####:27103:    return(test_ret);
        -:27104:}
        -:27105:
        -:27106:
        -:27107:static int
    #####:27108:test_xmlValidatePushCData(void) {
    #####:27109:    int test_ret = 0;
        -:27110:
        -:27111:#if defined(LIBXML_VALID_ENABLED) && defined(LIBXML_REGEXP_ENABLED)
        -:27112:    int mem_base;
        -:27113:    int ret_val;
        -:27114:    xmlValidCtxtPtr ctxt; /* the validation context */
        -:27115:    int n_ctxt;
        -:27116:    xmlChar * data; /* some character data read */
        -:27117:    int n_data;
        -:27118:    int len; /* the length of the data */
        -:27119:    int n_len;
        -:27120:
    #####:27121:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    #####:27122:    for (n_data = 0;n_data < gen_nb_const_xmlChar_ptr;n_data++) {
    #####:27123:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:27124:        mem_base = xmlMemBlocks();
    #####:27125:        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
    #####:27126:        data = gen_const_xmlChar_ptr(n_data, 1);
    #####:27127:        len = gen_int(n_len, 2);
        -:27128:
    #####:27129:        ret_val = xmlValidatePushCData(ctxt, (const xmlChar *)data, len);
    #####:27130:        desret_int(ret_val);
    #####:27131:        call_tests++;
    #####:27132:        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:27133:        des_const_xmlChar_ptr(n_data, (const xmlChar *)data, 1);
    #####:27134:        des_int(n_len, len, 2);
    #####:27135:        xmlResetLastError();
    #####:27136:        if (mem_base != xmlMemBlocks()) {
    #####:27137:            printf("Leak of %d blocks found in xmlValidatePushCData",
    #####:27138:	           xmlMemBlocks() - mem_base);
    #####:27139:	    test_ret++;
    #####:27140:            printf(" %d", n_ctxt);
    #####:27141:            printf(" %d", n_data);
    #####:27142:            printf(" %d", n_len);
    #####:27143:            printf("\n");
        -:27144:        }
        -:27145:    }
        -:27146:    }
        -:27147:    }
    #####:27148:    function_tests++;
        -:27149:#endif
        -:27150:
    #####:27151:    return(test_ret);
        -:27152:}
        -:27153:
        -:27154:
        -:27155:static int
    #####:27156:test_xmlValidatePushElement(void) {
    #####:27157:    int test_ret = 0;
        -:27158:
        -:27159:#if defined(LIBXML_VALID_ENABLED) && defined(LIBXML_REGEXP_ENABLED)
        -:27160:    int mem_base;
        -:27161:    int ret_val;
        -:27162:    xmlValidCtxtPtr ctxt; /* the validation context */
        -:27163:    int n_ctxt;
        -:27164:    xmlDocPtr doc; /* a document instance */
        -:27165:    int n_doc;
        -:27166:    xmlNodePtr elem; /* an element instance */
        -:27167:    int n_elem;
        -:27168:    xmlChar * qname; /* the qualified name as appearing in the serialization */
        -:27169:    int n_qname;
        -:27170:
    #####:27171:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    #####:27172:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:27173:    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    #####:27174:    for (n_qname = 0;n_qname < gen_nb_const_xmlChar_ptr;n_qname++) {
    #####:27175:        mem_base = xmlMemBlocks();
    #####:27176:        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
    #####:27177:        doc = gen_xmlDocPtr(n_doc, 1);
    #####:27178:        elem = gen_xmlNodePtr(n_elem, 2);
    #####:27179:        qname = gen_const_xmlChar_ptr(n_qname, 3);
        -:27180:
    #####:27181:        ret_val = xmlValidatePushElement(ctxt, doc, elem, (const xmlChar *)qname);
    #####:27182:        desret_int(ret_val);
    #####:27183:        call_tests++;
    #####:27184:        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:27185:        des_xmlDocPtr(n_doc, doc, 1);
    #####:27186:        des_xmlNodePtr(n_elem, elem, 2);
    #####:27187:        des_const_xmlChar_ptr(n_qname, (const xmlChar *)qname, 3);
    #####:27188:        xmlResetLastError();
    #####:27189:        if (mem_base != xmlMemBlocks()) {
    #####:27190:            printf("Leak of %d blocks found in xmlValidatePushElement",
    #####:27191:	           xmlMemBlocks() - mem_base);
    #####:27192:	    test_ret++;
    #####:27193:            printf(" %d", n_ctxt);
    #####:27194:            printf(" %d", n_doc);
    #####:27195:            printf(" %d", n_elem);
    #####:27196:            printf(" %d", n_qname);
    #####:27197:            printf("\n");
        -:27198:        }
        -:27199:    }
        -:27200:    }
        -:27201:    }
        -:27202:    }
    #####:27203:    function_tests++;
        -:27204:#endif
        -:27205:
    #####:27206:    return(test_ret);
        -:27207:}
        -:27208:
        -:27209:
        -:27210:static int
    #####:27211:test_xmlValidateRoot(void) {
    #####:27212:    int test_ret = 0;
        -:27213:
        -:27214:#if defined(LIBXML_VALID_ENABLED)
        -:27215:    int mem_base;
        -:27216:    int ret_val;
        -:27217:    xmlValidCtxtPtr ctxt; /* the validation context */
        -:27218:    int n_ctxt;
        -:27219:    xmlDocPtr doc; /* a document instance */
        -:27220:    int n_doc;
        -:27221:
    #####:27222:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlValidCtxtPtr;n_ctxt++) {
    #####:27223:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:27224:        mem_base = xmlMemBlocks();
    #####:27225:        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
    #####:27226:        doc = gen_xmlDocPtr(n_doc, 1);
        -:27227:
    #####:27228:        ret_val = xmlValidateRoot(ctxt, doc);
    #####:27229:        desret_int(ret_val);
    #####:27230:        call_tests++;
    #####:27231:        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:27232:        des_xmlDocPtr(n_doc, doc, 1);
    #####:27233:        xmlResetLastError();
    #####:27234:        if (mem_base != xmlMemBlocks()) {
    #####:27235:            printf("Leak of %d blocks found in xmlValidateRoot",
    #####:27236:	           xmlMemBlocks() - mem_base);
    #####:27237:	    test_ret++;
    #####:27238:            printf(" %d", n_ctxt);
    #####:27239:            printf(" %d", n_doc);
    #####:27240:            printf("\n");
        -:27241:        }
        -:27242:    }
        -:27243:    }
    #####:27244:    function_tests++;
        -:27245:#endif
        -:27246:
    #####:27247:    return(test_ret);
        -:27248:}
        -:27249:
        -:27250:static int
    #####:27251:test_valid(void) {
    #####:27252:    int test_ret = 0;
        -:27253:
    #####:27254:    if (quiet == 0) printf("Testing valid : 50 of 70 functions ...\n");
    #####:27255:    test_ret += test_xmlAddAttributeDecl();
    #####:27256:    test_ret += test_xmlAddElementDecl();
    #####:27257:    test_ret += test_xmlAddID();
    #####:27258:    test_ret += test_xmlAddNotationDecl();
    #####:27259:    test_ret += test_xmlAddRef();
    #####:27260:    test_ret += test_xmlCopyAttributeTable();
    #####:27261:    test_ret += test_xmlCopyDocElementContent();
    #####:27262:    test_ret += test_xmlCopyElementContent();
    #####:27263:    test_ret += test_xmlCopyElementTable();
    #####:27264:    test_ret += test_xmlCopyEnumeration();
    #####:27265:    test_ret += test_xmlCopyNotationTable();
    #####:27266:    test_ret += test_xmlCreateEnumeration();
    #####:27267:    test_ret += test_xmlDumpAttributeDecl();
    #####:27268:    test_ret += test_xmlDumpAttributeTable();
    #####:27269:    test_ret += test_xmlDumpElementDecl();
    #####:27270:    test_ret += test_xmlDumpElementTable();
    #####:27271:    test_ret += test_xmlDumpNotationDecl();
    #####:27272:    test_ret += test_xmlDumpNotationTable();
    #####:27273:    test_ret += test_xmlGetDtdAttrDesc();
    #####:27274:    test_ret += test_xmlGetDtdElementDesc();
    #####:27275:    test_ret += test_xmlGetDtdNotationDesc();
    #####:27276:    test_ret += test_xmlGetDtdQAttrDesc();
    #####:27277:    test_ret += test_xmlGetDtdQElementDesc();
    #####:27278:    test_ret += test_xmlGetID();
    #####:27279:    test_ret += test_xmlGetRefs();
    #####:27280:    test_ret += test_xmlIsID();
    #####:27281:    test_ret += test_xmlIsMixedElement();
    #####:27282:    test_ret += test_xmlIsRef();
    #####:27283:    test_ret += test_xmlNewDocElementContent();
    #####:27284:    test_ret += test_xmlNewElementContent();
    #####:27285:    test_ret += test_xmlNewValidCtxt();
    #####:27286:    test_ret += test_xmlRemoveID();
    #####:27287:    test_ret += test_xmlRemoveRef();
    #####:27288:    test_ret += test_xmlSnprintfElementContent();
    #####:27289:    test_ret += test_xmlSprintfElementContent();
    #####:27290:    test_ret += test_xmlValidBuildContentModel();
    #####:27291:    test_ret += test_xmlValidCtxtNormalizeAttributeValue();
    #####:27292:    test_ret += test_xmlValidGetPotentialChildren();
    #####:27293:    test_ret += test_xmlValidGetValidElements();
    #####:27294:    test_ret += test_xmlValidNormalizeAttributeValue();
    #####:27295:    test_ret += test_xmlValidateAttributeDecl();
    #####:27296:    test_ret += test_xmlValidateAttributeValue();
    #####:27297:    test_ret += test_xmlValidateDocument();
    #####:27298:    test_ret += test_xmlValidateDocumentFinal();
    #####:27299:    test_ret += test_xmlValidateDtd();
    #####:27300:    test_ret += test_xmlValidateDtdFinal();
    #####:27301:    test_ret += test_xmlValidateElement();
    #####:27302:    test_ret += test_xmlValidateElementDecl();
    #####:27303:    test_ret += test_xmlValidateNameValue();
    #####:27304:    test_ret += test_xmlValidateNamesValue();
    #####:27305:    test_ret += test_xmlValidateNmtokenValue();
    #####:27306:    test_ret += test_xmlValidateNmtokensValue();
    #####:27307:    test_ret += test_xmlValidateNotationDecl();
    #####:27308:    test_ret += test_xmlValidateNotationUse();
    #####:27309:    test_ret += test_xmlValidateOneAttribute();
    #####:27310:    test_ret += test_xmlValidateOneElement();
    #####:27311:    test_ret += test_xmlValidateOneNamespace();
    #####:27312:    test_ret += test_xmlValidatePopElement();
    #####:27313:    test_ret += test_xmlValidatePushCData();
    #####:27314:    test_ret += test_xmlValidatePushElement();
    #####:27315:    test_ret += test_xmlValidateRoot();
        -:27316:
    #####:27317:    if (test_ret != 0)
    #####:27318:	printf("Module valid: %d errors\n", test_ret);
    #####:27319:    return(test_ret);
        -:27320:}
        -:27321:
        -:27322:static int
    #####:27323:test_xmlXIncludeNewContext(void) {
    #####:27324:    int test_ret = 0;
        -:27325:
        -:27326:
        -:27327:    /* missing type support */
    #####:27328:    return(test_ret);
        -:27329:}
        -:27330:
        -:27331:
        -:27332:static int
    #####:27333:test_xmlXIncludeProcess(void) {
    #####:27334:    int test_ret = 0;
        -:27335:
        -:27336:#if defined(LIBXML_XINCLUDE_ENABLED)
        -:27337:    int mem_base;
        -:27338:    int ret_val;
        -:27339:    xmlDocPtr doc; /* an XML document */
        -:27340:    int n_doc;
        -:27341:
    #####:27342:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:27343:        mem_base = xmlMemBlocks();
    #####:27344:        doc = gen_xmlDocPtr(n_doc, 0);
        -:27345:
    #####:27346:        ret_val = xmlXIncludeProcess(doc);
    #####:27347:        desret_int(ret_val);
    #####:27348:        call_tests++;
    #####:27349:        des_xmlDocPtr(n_doc, doc, 0);
    #####:27350:        xmlResetLastError();
    #####:27351:        if (mem_base != xmlMemBlocks()) {
    #####:27352:            printf("Leak of %d blocks found in xmlXIncludeProcess",
    #####:27353:	           xmlMemBlocks() - mem_base);
    #####:27354:	    test_ret++;
    #####:27355:            printf(" %d", n_doc);
    #####:27356:            printf("\n");
        -:27357:        }
        -:27358:    }
    #####:27359:    function_tests++;
        -:27360:#endif
        -:27361:
    #####:27362:    return(test_ret);
        -:27363:}
        -:27364:
        -:27365:
        -:27366:static int
    #####:27367:test_xmlXIncludeProcessFlags(void) {
    #####:27368:    int test_ret = 0;
        -:27369:
        -:27370:#if defined(LIBXML_XINCLUDE_ENABLED)
        -:27371:    int mem_base;
        -:27372:    int ret_val;
        -:27373:    xmlDocPtr doc; /* an XML document */
        -:27374:    int n_doc;
        -:27375:    int flags; /* a set of xmlParserOption used for parsing XML includes */
        -:27376:    int n_flags;
        -:27377:
    #####:27378:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:27379:    for (n_flags = 0;n_flags < gen_nb_int;n_flags++) {
    #####:27380:        mem_base = xmlMemBlocks();
    #####:27381:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:27382:        flags = gen_int(n_flags, 1);
        -:27383:
    #####:27384:        ret_val = xmlXIncludeProcessFlags(doc, flags);
    #####:27385:        desret_int(ret_val);
    #####:27386:        call_tests++;
    #####:27387:        des_xmlDocPtr(n_doc, doc, 0);
    #####:27388:        des_int(n_flags, flags, 1);
    #####:27389:        xmlResetLastError();
    #####:27390:        if (mem_base != xmlMemBlocks()) {
    #####:27391:            printf("Leak of %d blocks found in xmlXIncludeProcessFlags",
    #####:27392:	           xmlMemBlocks() - mem_base);
    #####:27393:	    test_ret++;
    #####:27394:            printf(" %d", n_doc);
    #####:27395:            printf(" %d", n_flags);
    #####:27396:            printf("\n");
        -:27397:        }
        -:27398:    }
        -:27399:    }
    #####:27400:    function_tests++;
        -:27401:#endif
        -:27402:
    #####:27403:    return(test_ret);
        -:27404:}
        -:27405:
        -:27406:
        -:27407:static int
    #####:27408:test_xmlXIncludeProcessFlagsData(void) {
    #####:27409:    int test_ret = 0;
        -:27410:
        -:27411:#if defined(LIBXML_XINCLUDE_ENABLED)
        -:27412:    int mem_base;
        -:27413:    int ret_val;
        -:27414:    xmlDocPtr doc; /* an XML document */
        -:27415:    int n_doc;
        -:27416:    int flags; /* a set of xmlParserOption used for parsing XML includes */
        -:27417:    int n_flags;
        -:27418:    void * data; /* application data that will be passed to the parser context in the _private field of the parser context(s) */
        -:27419:    int n_data;
        -:27420:
    #####:27421:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:27422:    for (n_flags = 0;n_flags < gen_nb_int;n_flags++) {
    #####:27423:    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
    #####:27424:        mem_base = xmlMemBlocks();
    #####:27425:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:27426:        flags = gen_int(n_flags, 1);
    #####:27427:        data = gen_userdata(n_data, 2);
        -:27428:
    #####:27429:        ret_val = xmlXIncludeProcessFlagsData(doc, flags, data);
    #####:27430:        desret_int(ret_val);
    #####:27431:        call_tests++;
    #####:27432:        des_xmlDocPtr(n_doc, doc, 0);
    #####:27433:        des_int(n_flags, flags, 1);
    #####:27434:        des_userdata(n_data, data, 2);
    #####:27435:        xmlResetLastError();
    #####:27436:        if (mem_base != xmlMemBlocks()) {
    #####:27437:            printf("Leak of %d blocks found in xmlXIncludeProcessFlagsData",
    #####:27438:	           xmlMemBlocks() - mem_base);
    #####:27439:	    test_ret++;
    #####:27440:            printf(" %d", n_doc);
    #####:27441:            printf(" %d", n_flags);
    #####:27442:            printf(" %d", n_data);
    #####:27443:            printf("\n");
        -:27444:        }
        -:27445:    }
        -:27446:    }
        -:27447:    }
    #####:27448:    function_tests++;
        -:27449:#endif
        -:27450:
    #####:27451:    return(test_ret);
        -:27452:}
        -:27453:
        -:27454:#ifdef LIBXML_XINCLUDE_ENABLED
        -:27455:
        -:27456:#define gen_nb_xmlXIncludeCtxtPtr 1
    #####:27457:static xmlXIncludeCtxtPtr gen_xmlXIncludeCtxtPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:27458:    return(NULL);
        -:27459:}
    #####:27460:static void des_xmlXIncludeCtxtPtr(int no ATTRIBUTE_UNUSED, xmlXIncludeCtxtPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:27461:}
        -:27462:#endif
        -:27463:
        -:27464:
        -:27465:static int
    #####:27466:test_xmlXIncludeProcessNode(void) {
    #####:27467:    int test_ret = 0;
        -:27468:
        -:27469:#if defined(LIBXML_XINCLUDE_ENABLED)
        -:27470:    int mem_base;
        -:27471:    int ret_val;
        -:27472:    xmlXIncludeCtxtPtr ctxt; /* an existing XInclude context */
        -:27473:    int n_ctxt;
        -:27474:    xmlNodePtr node; /* a node in an XML document */
        -:27475:    int n_node;
        -:27476:
    #####:27477:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXIncludeCtxtPtr;n_ctxt++) {
    #####:27478:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:27479:        mem_base = xmlMemBlocks();
    #####:27480:        ctxt = gen_xmlXIncludeCtxtPtr(n_ctxt, 0);
    #####:27481:        node = gen_xmlNodePtr(n_node, 1);
        -:27482:
    #####:27483:        ret_val = xmlXIncludeProcessNode(ctxt, node);
    #####:27484:        desret_int(ret_val);
    #####:27485:        call_tests++;
    #####:27486:        des_xmlXIncludeCtxtPtr(n_ctxt, ctxt, 0);
    #####:27487:        des_xmlNodePtr(n_node, node, 1);
    #####:27488:        xmlResetLastError();
    #####:27489:        if (mem_base != xmlMemBlocks()) {
    #####:27490:            printf("Leak of %d blocks found in xmlXIncludeProcessNode",
    #####:27491:	           xmlMemBlocks() - mem_base);
    #####:27492:	    test_ret++;
    #####:27493:            printf(" %d", n_ctxt);
    #####:27494:            printf(" %d", n_node);
    #####:27495:            printf("\n");
        -:27496:        }
        -:27497:    }
        -:27498:    }
    #####:27499:    function_tests++;
        -:27500:#endif
        -:27501:
    #####:27502:    return(test_ret);
        -:27503:}
        -:27504:
        -:27505:
        -:27506:static int
    #####:27507:test_xmlXIncludeProcessTree(void) {
    #####:27508:    int test_ret = 0;
        -:27509:
        -:27510:#if defined(LIBXML_XINCLUDE_ENABLED)
        -:27511:    int mem_base;
        -:27512:    int ret_val;
        -:27513:    xmlNodePtr tree; /* a node in an XML document */
        -:27514:    int n_tree;
        -:27515:
    #####:27516:    for (n_tree = 0;n_tree < gen_nb_xmlNodePtr;n_tree++) {
    #####:27517:        mem_base = xmlMemBlocks();
    #####:27518:        tree = gen_xmlNodePtr(n_tree, 0);
        -:27519:
    #####:27520:        ret_val = xmlXIncludeProcessTree(tree);
    #####:27521:        desret_int(ret_val);
    #####:27522:        call_tests++;
    #####:27523:        des_xmlNodePtr(n_tree, tree, 0);
    #####:27524:        xmlResetLastError();
    #####:27525:        if (mem_base != xmlMemBlocks()) {
    #####:27526:            printf("Leak of %d blocks found in xmlXIncludeProcessTree",
    #####:27527:	           xmlMemBlocks() - mem_base);
    #####:27528:	    test_ret++;
    #####:27529:            printf(" %d", n_tree);
    #####:27530:            printf("\n");
        -:27531:        }
        -:27532:    }
    #####:27533:    function_tests++;
        -:27534:#endif
        -:27535:
    #####:27536:    return(test_ret);
        -:27537:}
        -:27538:
        -:27539:
        -:27540:static int
    #####:27541:test_xmlXIncludeProcessTreeFlags(void) {
    #####:27542:    int test_ret = 0;
        -:27543:
        -:27544:#if defined(LIBXML_XINCLUDE_ENABLED)
        -:27545:    int mem_base;
        -:27546:    int ret_val;
        -:27547:    xmlNodePtr tree; /* a node in an XML document */
        -:27548:    int n_tree;
        -:27549:    int flags; /* a set of xmlParserOption used for parsing XML includes */
        -:27550:    int n_flags;
        -:27551:
    #####:27552:    for (n_tree = 0;n_tree < gen_nb_xmlNodePtr;n_tree++) {
    #####:27553:    for (n_flags = 0;n_flags < gen_nb_int;n_flags++) {
    #####:27554:        mem_base = xmlMemBlocks();
    #####:27555:        tree = gen_xmlNodePtr(n_tree, 0);
    #####:27556:        flags = gen_int(n_flags, 1);
        -:27557:
    #####:27558:        ret_val = xmlXIncludeProcessTreeFlags(tree, flags);
    #####:27559:        desret_int(ret_val);
    #####:27560:        call_tests++;
    #####:27561:        des_xmlNodePtr(n_tree, tree, 0);
    #####:27562:        des_int(n_flags, flags, 1);
    #####:27563:        xmlResetLastError();
    #####:27564:        if (mem_base != xmlMemBlocks()) {
    #####:27565:            printf("Leak of %d blocks found in xmlXIncludeProcessTreeFlags",
    #####:27566:	           xmlMemBlocks() - mem_base);
    #####:27567:	    test_ret++;
    #####:27568:            printf(" %d", n_tree);
    #####:27569:            printf(" %d", n_flags);
    #####:27570:            printf("\n");
        -:27571:        }
        -:27572:    }
        -:27573:    }
    #####:27574:    function_tests++;
        -:27575:#endif
        -:27576:
    #####:27577:    return(test_ret);
        -:27578:}
        -:27579:
        -:27580:
        -:27581:static int
    #####:27582:test_xmlXIncludeProcessTreeFlagsData(void) {
    #####:27583:    int test_ret = 0;
        -:27584:
        -:27585:#if defined(LIBXML_XINCLUDE_ENABLED)
        -:27586:    int mem_base;
        -:27587:    int ret_val;
        -:27588:    xmlNodePtr tree; /* an XML node */
        -:27589:    int n_tree;
        -:27590:    int flags; /* a set of xmlParserOption used for parsing XML includes */
        -:27591:    int n_flags;
        -:27592:    void * data; /* application data that will be passed to the parser context in the _private field of the parser context(s) */
        -:27593:    int n_data;
        -:27594:
    #####:27595:    for (n_tree = 0;n_tree < gen_nb_xmlNodePtr;n_tree++) {
    #####:27596:    for (n_flags = 0;n_flags < gen_nb_int;n_flags++) {
    #####:27597:    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
    #####:27598:        mem_base = xmlMemBlocks();
    #####:27599:        tree = gen_xmlNodePtr(n_tree, 0);
    #####:27600:        flags = gen_int(n_flags, 1);
    #####:27601:        data = gen_userdata(n_data, 2);
        -:27602:
    #####:27603:        ret_val = xmlXIncludeProcessTreeFlagsData(tree, flags, data);
    #####:27604:        desret_int(ret_val);
    #####:27605:        call_tests++;
    #####:27606:        des_xmlNodePtr(n_tree, tree, 0);
    #####:27607:        des_int(n_flags, flags, 1);
    #####:27608:        des_userdata(n_data, data, 2);
    #####:27609:        xmlResetLastError();
    #####:27610:        if (mem_base != xmlMemBlocks()) {
    #####:27611:            printf("Leak of %d blocks found in xmlXIncludeProcessTreeFlagsData",
    #####:27612:	           xmlMemBlocks() - mem_base);
    #####:27613:	    test_ret++;
    #####:27614:            printf(" %d", n_tree);
    #####:27615:            printf(" %d", n_flags);
    #####:27616:            printf(" %d", n_data);
    #####:27617:            printf("\n");
        -:27618:        }
        -:27619:    }
        -:27620:    }
        -:27621:    }
    #####:27622:    function_tests++;
        -:27623:#endif
        -:27624:
    #####:27625:    return(test_ret);
        -:27626:}
        -:27627:
        -:27628:
        -:27629:static int
    #####:27630:test_xmlXIncludeSetFlags(void) {
    #####:27631:    int test_ret = 0;
        -:27632:
        -:27633:#if defined(LIBXML_XINCLUDE_ENABLED)
        -:27634:    int mem_base;
        -:27635:    int ret_val;
        -:27636:    xmlXIncludeCtxtPtr ctxt; /* an XInclude processing context */
        -:27637:    int n_ctxt;
        -:27638:    int flags; /* a set of xmlParserOption used for parsing XML includes */
        -:27639:    int n_flags;
        -:27640:
    #####:27641:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXIncludeCtxtPtr;n_ctxt++) {
    #####:27642:    for (n_flags = 0;n_flags < gen_nb_int;n_flags++) {
    #####:27643:        mem_base = xmlMemBlocks();
    #####:27644:        ctxt = gen_xmlXIncludeCtxtPtr(n_ctxt, 0);
    #####:27645:        flags = gen_int(n_flags, 1);
        -:27646:
    #####:27647:        ret_val = xmlXIncludeSetFlags(ctxt, flags);
    #####:27648:        desret_int(ret_val);
    #####:27649:        call_tests++;
    #####:27650:        des_xmlXIncludeCtxtPtr(n_ctxt, ctxt, 0);
    #####:27651:        des_int(n_flags, flags, 1);
    #####:27652:        xmlResetLastError();
    #####:27653:        if (mem_base != xmlMemBlocks()) {
    #####:27654:            printf("Leak of %d blocks found in xmlXIncludeSetFlags",
    #####:27655:	           xmlMemBlocks() - mem_base);
    #####:27656:	    test_ret++;
    #####:27657:            printf(" %d", n_ctxt);
    #####:27658:            printf(" %d", n_flags);
    #####:27659:            printf("\n");
        -:27660:        }
        -:27661:    }
        -:27662:    }
    #####:27663:    function_tests++;
        -:27664:#endif
        -:27665:
    #####:27666:    return(test_ret);
        -:27667:}
        -:27668:
        -:27669:static int
    #####:27670:test_xinclude(void) {
    #####:27671:    int test_ret = 0;
        -:27672:
    #####:27673:    if (quiet == 0) printf("Testing xinclude : 8 of 10 functions ...\n");
    #####:27674:    test_ret += test_xmlXIncludeNewContext();
    #####:27675:    test_ret += test_xmlXIncludeProcess();
    #####:27676:    test_ret += test_xmlXIncludeProcessFlags();
    #####:27677:    test_ret += test_xmlXIncludeProcessFlagsData();
    #####:27678:    test_ret += test_xmlXIncludeProcessNode();
    #####:27679:    test_ret += test_xmlXIncludeProcessTree();
    #####:27680:    test_ret += test_xmlXIncludeProcessTreeFlags();
    #####:27681:    test_ret += test_xmlXIncludeProcessTreeFlagsData();
    #####:27682:    test_ret += test_xmlXIncludeSetFlags();
        -:27683:
    #####:27684:    if (test_ret != 0)
    #####:27685:	printf("Module xinclude: %d errors\n", test_ret);
    #####:27686:    return(test_ret);
        -:27687:}
        -:27688:
        -:27689:static int
    #####:27690:test_xmlAllocOutputBuffer(void) {
    #####:27691:    int test_ret = 0;
        -:27692:
        -:27693:#if defined(LIBXML_OUTPUT_ENABLED)
        -:27694:    int mem_base;
        -:27695:    xmlOutputBufferPtr ret_val;
        -:27696:    xmlCharEncodingHandlerPtr encoder; /* the encoding converter or NULL */
        -:27697:    int n_encoder;
        -:27698:
    #####:27699:    for (n_encoder = 0;n_encoder < gen_nb_xmlCharEncodingHandlerPtr;n_encoder++) {
    #####:27700:        mem_base = xmlMemBlocks();
    #####:27701:        encoder = gen_xmlCharEncodingHandlerPtr(n_encoder, 0);
        -:27702:
    #####:27703:        ret_val = xmlAllocOutputBuffer(encoder);
    #####:27704:        desret_xmlOutputBufferPtr(ret_val);
    #####:27705:        call_tests++;
    #####:27706:        des_xmlCharEncodingHandlerPtr(n_encoder, encoder, 0);
    #####:27707:        xmlResetLastError();
    #####:27708:        if (mem_base != xmlMemBlocks()) {
    #####:27709:            printf("Leak of %d blocks found in xmlAllocOutputBuffer",
    #####:27710:	           xmlMemBlocks() - mem_base);
    #####:27711:	    test_ret++;
    #####:27712:            printf(" %d", n_encoder);
    #####:27713:            printf("\n");
        -:27714:        }
        -:27715:    }
    #####:27716:    function_tests++;
        -:27717:#endif
        -:27718:
    #####:27719:    return(test_ret);
        -:27720:}
        -:27721:
        -:27722:
        -:27723:static int
    #####:27724:test_xmlAllocParserInputBuffer(void) {
    #####:27725:    int test_ret = 0;
        -:27726:
        -:27727:    int mem_base;
        -:27728:    xmlParserInputBufferPtr ret_val;
        -:27729:    xmlCharEncoding enc; /* the charset encoding if known */
        -:27730:    int n_enc;
        -:27731:
    #####:27732:    for (n_enc = 0;n_enc < gen_nb_xmlCharEncoding;n_enc++) {
    #####:27733:        mem_base = xmlMemBlocks();
    #####:27734:        enc = gen_xmlCharEncoding(n_enc, 0);
        -:27735:
    #####:27736:        ret_val = xmlAllocParserInputBuffer(enc);
    #####:27737:        desret_xmlParserInputBufferPtr(ret_val);
    #####:27738:        call_tests++;
    #####:27739:        des_xmlCharEncoding(n_enc, enc, 0);
    #####:27740:        xmlResetLastError();
    #####:27741:        if (mem_base != xmlMemBlocks()) {
    #####:27742:            printf("Leak of %d blocks found in xmlAllocParserInputBuffer",
    #####:27743:	           xmlMemBlocks() - mem_base);
    #####:27744:	    test_ret++;
    #####:27745:            printf(" %d", n_enc);
    #####:27746:            printf("\n");
        -:27747:        }
        -:27748:    }
    #####:27749:    function_tests++;
        -:27750:
    #####:27751:    return(test_ret);
        -:27752:}
        -:27753:
        -:27754:
        -:27755:static int
    #####:27756:test_xmlCheckFilename(void) {
    #####:27757:    int test_ret = 0;
        -:27758:
        -:27759:    int mem_base;
        -:27760:    int ret_val;
        -:27761:    char * path; /* the path to check */
        -:27762:    int n_path;
        -:27763:
    #####:27764:    for (n_path = 0;n_path < gen_nb_const_char_ptr;n_path++) {
    #####:27765:        mem_base = xmlMemBlocks();
    #####:27766:        path = gen_const_char_ptr(n_path, 0);
        -:27767:
    #####:27768:        ret_val = xmlCheckFilename((const char *)path);
    #####:27769:        desret_int(ret_val);
    #####:27770:        call_tests++;
    #####:27771:        des_const_char_ptr(n_path, (const char *)path, 0);
    #####:27772:        xmlResetLastError();
    #####:27773:        if (mem_base != xmlMemBlocks()) {
    #####:27774:            printf("Leak of %d blocks found in xmlCheckFilename",
    #####:27775:	           xmlMemBlocks() - mem_base);
    #####:27776:	    test_ret++;
    #####:27777:            printf(" %d", n_path);
    #####:27778:            printf("\n");
        -:27779:        }
        -:27780:    }
    #####:27781:    function_tests++;
        -:27782:
    #####:27783:    return(test_ret);
        -:27784:}
        -:27785:
        -:27786:
        -:27787:static int
    #####:27788:test_xmlCheckHTTPInput(void) {
    #####:27789:    int test_ret = 0;
        -:27790:
        -:27791:    int mem_base;
        -:27792:    xmlParserInputPtr ret_val;
        -:27793:    xmlParserCtxtPtr ctxt; /* an XML parser context */
        -:27794:    int n_ctxt;
        -:27795:    xmlParserInputPtr ret; /* an XML parser input */
        -:27796:    int n_ret;
        -:27797:
    #####:27798:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:27799:    for (n_ret = 0;n_ret < gen_nb_xmlParserInputPtr;n_ret++) {
    #####:27800:        mem_base = xmlMemBlocks();
    #####:27801:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
    #####:27802:        ret = gen_xmlParserInputPtr(n_ret, 1);
        -:27803:
    #####:27804:        ret_val = xmlCheckHTTPInput(ctxt, ret);
    #####:27805:        desret_xmlParserInputPtr(ret_val);
    #####:27806:        call_tests++;
    #####:27807:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:27808:        des_xmlParserInputPtr(n_ret, ret, 1);
    #####:27809:        xmlResetLastError();
    #####:27810:        if (mem_base != xmlMemBlocks()) {
    #####:27811:            printf("Leak of %d blocks found in xmlCheckHTTPInput",
    #####:27812:	           xmlMemBlocks() - mem_base);
    #####:27813:	    test_ret++;
    #####:27814:            printf(" %d", n_ctxt);
    #####:27815:            printf(" %d", n_ret);
    #####:27816:            printf("\n");
        -:27817:        }
        -:27818:    }
        -:27819:    }
    #####:27820:    function_tests++;
        -:27821:
    #####:27822:    return(test_ret);
        -:27823:}
        -:27824:
        -:27825:
        -:27826:static int
    #####:27827:test_xmlCleanupInputCallbacks(void) {
    #####:27828:    int test_ret = 0;
        -:27829:
        -:27830:    int mem_base;
        -:27831:
    #####:27832:        mem_base = xmlMemBlocks();
        -:27833:
    #####:27834:        xmlCleanupInputCallbacks();
    #####:27835:        call_tests++;
    #####:27836:        xmlResetLastError();
    #####:27837:        if (mem_base != xmlMemBlocks()) {
    #####:27838:            printf("Leak of %d blocks found in xmlCleanupInputCallbacks",
    #####:27839:	           xmlMemBlocks() - mem_base);
    #####:27840:	    test_ret++;
    #####:27841:            printf("\n");
        -:27842:        }
    #####:27843:    function_tests++;
        -:27844:
    #####:27845:    return(test_ret);
        -:27846:}
        -:27847:
        -:27848:
        -:27849:static int
    #####:27850:test_xmlCleanupOutputCallbacks(void) {
    #####:27851:    int test_ret = 0;
        -:27852:
        -:27853:#if defined(LIBXML_OUTPUT_ENABLED)
        -:27854:    int mem_base;
        -:27855:
    #####:27856:        mem_base = xmlMemBlocks();
        -:27857:
    #####:27858:        xmlCleanupOutputCallbacks();
    #####:27859:        call_tests++;
    #####:27860:        xmlResetLastError();
    #####:27861:        if (mem_base != xmlMemBlocks()) {
    #####:27862:            printf("Leak of %d blocks found in xmlCleanupOutputCallbacks",
    #####:27863:	           xmlMemBlocks() - mem_base);
    #####:27864:	    test_ret++;
    #####:27865:            printf("\n");
        -:27866:        }
    #####:27867:    function_tests++;
        -:27868:#endif
        -:27869:
    #####:27870:    return(test_ret);
        -:27871:}
        -:27872:
        -:27873:
        -:27874:static int
    #####:27875:test_xmlFileClose(void) {
    #####:27876:    int test_ret = 0;
        -:27877:
        -:27878:    int mem_base;
        -:27879:    int ret_val;
        -:27880:    void * context; /* the I/O context */
        -:27881:    int n_context;
        -:27882:
    #####:27883:    for (n_context = 0;n_context < gen_nb_void_ptr;n_context++) {
    #####:27884:        mem_base = xmlMemBlocks();
    #####:27885:        context = gen_void_ptr(n_context, 0);
        -:27886:
    #####:27887:        ret_val = xmlFileClose(context);
    #####:27888:        desret_int(ret_val);
    #####:27889:        call_tests++;
    #####:27890:        des_void_ptr(n_context, context, 0);
    #####:27891:        xmlResetLastError();
    #####:27892:        if (mem_base != xmlMemBlocks()) {
    #####:27893:            printf("Leak of %d blocks found in xmlFileClose",
    #####:27894:	           xmlMemBlocks() - mem_base);
    #####:27895:	    test_ret++;
    #####:27896:            printf(" %d", n_context);
    #####:27897:            printf("\n");
        -:27898:        }
        -:27899:    }
    #####:27900:    function_tests++;
        -:27901:
    #####:27902:    return(test_ret);
        -:27903:}
        -:27904:
        -:27905:
        -:27906:static int
    #####:27907:test_xmlFileMatch(void) {
    #####:27908:    int test_ret = 0;
        -:27909:
        -:27910:    int mem_base;
        -:27911:    int ret_val;
        -:27912:    const char * filename; /* the URI for matching */
        -:27913:    int n_filename;
        -:27914:
    #####:27915:    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    #####:27916:        mem_base = xmlMemBlocks();
    #####:27917:        filename = gen_filepath(n_filename, 0);
        -:27918:
    #####:27919:        ret_val = xmlFileMatch(filename);
    #####:27920:        desret_int(ret_val);
    #####:27921:        call_tests++;
    #####:27922:        des_filepath(n_filename, filename, 0);
    #####:27923:        xmlResetLastError();
    #####:27924:        if (mem_base != xmlMemBlocks()) {
    #####:27925:            printf("Leak of %d blocks found in xmlFileMatch",
    #####:27926:	           xmlMemBlocks() - mem_base);
    #####:27927:	    test_ret++;
    #####:27928:            printf(" %d", n_filename);
    #####:27929:            printf("\n");
        -:27930:        }
        -:27931:    }
    #####:27932:    function_tests++;
        -:27933:
    #####:27934:    return(test_ret);
        -:27935:}
        -:27936:
        -:27937:
        -:27938:static int
    #####:27939:test_xmlFileOpen(void) {
    #####:27940:    int test_ret = 0;
        -:27941:
        -:27942:    int mem_base;
        -:27943:    void * ret_val;
        -:27944:    const char * filename; /* the URI for matching */
        -:27945:    int n_filename;
        -:27946:
    #####:27947:    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    #####:27948:        mem_base = xmlMemBlocks();
    #####:27949:        filename = gen_filepath(n_filename, 0);
        -:27950:
    #####:27951:        ret_val = xmlFileOpen(filename);
    #####:27952:        desret_void_ptr(ret_val);
    #####:27953:        call_tests++;
    #####:27954:        des_filepath(n_filename, filename, 0);
    #####:27955:        xmlResetLastError();
    #####:27956:        if (mem_base != xmlMemBlocks()) {
    #####:27957:            printf("Leak of %d blocks found in xmlFileOpen",
    #####:27958:	           xmlMemBlocks() - mem_base);
    #####:27959:	    test_ret++;
    #####:27960:            printf(" %d", n_filename);
    #####:27961:            printf("\n");
        -:27962:        }
        -:27963:    }
    #####:27964:    function_tests++;
        -:27965:
    #####:27966:    return(test_ret);
        -:27967:}
        -:27968:
        -:27969:
        -:27970:static int
    #####:27971:test_xmlFileRead(void) {
    #####:27972:    int test_ret = 0;
        -:27973:
        -:27974:    int mem_base;
        -:27975:    int ret_val;
        -:27976:    void * context; /* the I/O context */
        -:27977:    int n_context;
        -:27978:    char * buffer; /* where to drop data */
        -:27979:    int n_buffer;
        -:27980:    int len; /* number of bytes to write */
        -:27981:    int n_len;
        -:27982:
    #####:27983:    for (n_context = 0;n_context < gen_nb_void_ptr;n_context++) {
    #####:27984:    for (n_buffer = 0;n_buffer < gen_nb_char_ptr;n_buffer++) {
    #####:27985:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:27986:        mem_base = xmlMemBlocks();
    #####:27987:        context = gen_void_ptr(n_context, 0);
    #####:27988:        buffer = gen_char_ptr(n_buffer, 1);
    #####:27989:        len = gen_int(n_len, 2);
        -:27990:
    #####:27991:        ret_val = xmlFileRead(context, buffer, len);
    #####:27992:        desret_int(ret_val);
    #####:27993:        call_tests++;
    #####:27994:        des_void_ptr(n_context, context, 0);
    #####:27995:        des_char_ptr(n_buffer, buffer, 1);
    #####:27996:        des_int(n_len, len, 2);
    #####:27997:        xmlResetLastError();
    #####:27998:        if (mem_base != xmlMemBlocks()) {
    #####:27999:            printf("Leak of %d blocks found in xmlFileRead",
    #####:28000:	           xmlMemBlocks() - mem_base);
    #####:28001:	    test_ret++;
    #####:28002:            printf(" %d", n_context);
    #####:28003:            printf(" %d", n_buffer);
    #####:28004:            printf(" %d", n_len);
    #####:28005:            printf("\n");
        -:28006:        }
        -:28007:    }
        -:28008:    }
        -:28009:    }
    #####:28010:    function_tests++;
        -:28011:
    #####:28012:    return(test_ret);
        -:28013:}
        -:28014:
        -:28015:
        -:28016:static int
    #####:28017:test_xmlIOFTPClose(void) {
    #####:28018:    int test_ret = 0;
        -:28019:
        -:28020:#if defined(LIBXML_FTP_ENABLED)
        -:28021:    int mem_base;
        -:28022:    int ret_val;
        -:28023:    void * context; /* the I/O context */
        -:28024:    int n_context;
        -:28025:
    #####:28026:    for (n_context = 0;n_context < gen_nb_void_ptr;n_context++) {
    #####:28027:        mem_base = xmlMemBlocks();
    #####:28028:        context = gen_void_ptr(n_context, 0);
        -:28029:
    #####:28030:        ret_val = xmlIOFTPClose(context);
    #####:28031:        desret_int(ret_val);
    #####:28032:        call_tests++;
    #####:28033:        des_void_ptr(n_context, context, 0);
    #####:28034:        xmlResetLastError();
    #####:28035:        if (mem_base != xmlMemBlocks()) {
    #####:28036:            printf("Leak of %d blocks found in xmlIOFTPClose",
    #####:28037:	           xmlMemBlocks() - mem_base);
    #####:28038:	    test_ret++;
    #####:28039:            printf(" %d", n_context);
    #####:28040:            printf("\n");
        -:28041:        }
        -:28042:    }
    #####:28043:    function_tests++;
        -:28044:#endif
        -:28045:
    #####:28046:    return(test_ret);
        -:28047:}
        -:28048:
        -:28049:
        -:28050:static int
    #####:28051:test_xmlIOFTPMatch(void) {
    #####:28052:    int test_ret = 0;
        -:28053:
        -:28054:#if defined(LIBXML_FTP_ENABLED)
        -:28055:    int mem_base;
        -:28056:    int ret_val;
        -:28057:    const char * filename; /* the URI for matching */
        -:28058:    int n_filename;
        -:28059:
    #####:28060:    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    #####:28061:        mem_base = xmlMemBlocks();
    #####:28062:        filename = gen_filepath(n_filename, 0);
        -:28063:
    #####:28064:        ret_val = xmlIOFTPMatch(filename);
    #####:28065:        desret_int(ret_val);
    #####:28066:        call_tests++;
    #####:28067:        des_filepath(n_filename, filename, 0);
    #####:28068:        xmlResetLastError();
    #####:28069:        if (mem_base != xmlMemBlocks()) {
    #####:28070:            printf("Leak of %d blocks found in xmlIOFTPMatch",
    #####:28071:	           xmlMemBlocks() - mem_base);
    #####:28072:	    test_ret++;
    #####:28073:            printf(" %d", n_filename);
    #####:28074:            printf("\n");
        -:28075:        }
        -:28076:    }
    #####:28077:    function_tests++;
        -:28078:#endif
        -:28079:
    #####:28080:    return(test_ret);
        -:28081:}
        -:28082:
        -:28083:
        -:28084:static int
    #####:28085:test_xmlIOFTPOpen(void) {
    #####:28086:    int test_ret = 0;
        -:28087:
        -:28088:#if defined(LIBXML_FTP_ENABLED)
        -:28089:    int mem_base;
        -:28090:    void * ret_val;
        -:28091:    const char * filename; /* the URI for matching */
        -:28092:    int n_filename;
        -:28093:
    #####:28094:    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    #####:28095:        mem_base = xmlMemBlocks();
    #####:28096:        filename = gen_filepath(n_filename, 0);
        -:28097:
    #####:28098:        ret_val = xmlIOFTPOpen(filename);
    #####:28099:        desret_void_ptr(ret_val);
    #####:28100:        call_tests++;
    #####:28101:        des_filepath(n_filename, filename, 0);
    #####:28102:        xmlResetLastError();
    #####:28103:        if (mem_base != xmlMemBlocks()) {
    #####:28104:            printf("Leak of %d blocks found in xmlIOFTPOpen",
    #####:28105:	           xmlMemBlocks() - mem_base);
    #####:28106:	    test_ret++;
    #####:28107:            printf(" %d", n_filename);
    #####:28108:            printf("\n");
        -:28109:        }
        -:28110:    }
    #####:28111:    function_tests++;
        -:28112:#endif
        -:28113:
    #####:28114:    return(test_ret);
        -:28115:}
        -:28116:
        -:28117:
        -:28118:static int
    #####:28119:test_xmlIOFTPRead(void) {
    #####:28120:    int test_ret = 0;
        -:28121:
        -:28122:#if defined(LIBXML_FTP_ENABLED)
        -:28123:    int mem_base;
        -:28124:    int ret_val;
        -:28125:    void * context; /* the I/O context */
        -:28126:    int n_context;
        -:28127:    char * buffer; /* where to drop data */
        -:28128:    int n_buffer;
        -:28129:    int len; /* number of bytes to write */
        -:28130:    int n_len;
        -:28131:
    #####:28132:    for (n_context = 0;n_context < gen_nb_void_ptr;n_context++) {
    #####:28133:    for (n_buffer = 0;n_buffer < gen_nb_char_ptr;n_buffer++) {
    #####:28134:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:28135:        mem_base = xmlMemBlocks();
    #####:28136:        context = gen_void_ptr(n_context, 0);
    #####:28137:        buffer = gen_char_ptr(n_buffer, 1);
    #####:28138:        len = gen_int(n_len, 2);
        -:28139:
    #####:28140:        ret_val = xmlIOFTPRead(context, buffer, len);
    #####:28141:        desret_int(ret_val);
    #####:28142:        call_tests++;
    #####:28143:        des_void_ptr(n_context, context, 0);
    #####:28144:        des_char_ptr(n_buffer, buffer, 1);
    #####:28145:        des_int(n_len, len, 2);
    #####:28146:        xmlResetLastError();
    #####:28147:        if (mem_base != xmlMemBlocks()) {
    #####:28148:            printf("Leak of %d blocks found in xmlIOFTPRead",
    #####:28149:	           xmlMemBlocks() - mem_base);
    #####:28150:	    test_ret++;
    #####:28151:            printf(" %d", n_context);
    #####:28152:            printf(" %d", n_buffer);
    #####:28153:            printf(" %d", n_len);
    #####:28154:            printf("\n");
        -:28155:        }
        -:28156:    }
        -:28157:    }
        -:28158:    }
    #####:28159:    function_tests++;
        -:28160:#endif
        -:28161:
    #####:28162:    return(test_ret);
        -:28163:}
        -:28164:
        -:28165:
        -:28166:static int
    #####:28167:test_xmlIOHTTPClose(void) {
    #####:28168:    int test_ret = 0;
        -:28169:
        -:28170:#if defined(LIBXML_HTTP_ENABLED)
        -:28171:    int mem_base;
        -:28172:    int ret_val;
        -:28173:    void * context; /* the I/O context */
        -:28174:    int n_context;
        -:28175:
    #####:28176:    for (n_context = 0;n_context < gen_nb_void_ptr;n_context++) {
    #####:28177:        mem_base = xmlMemBlocks();
    #####:28178:        context = gen_void_ptr(n_context, 0);
        -:28179:
    #####:28180:        ret_val = xmlIOHTTPClose(context);
    #####:28181:        desret_int(ret_val);
    #####:28182:        call_tests++;
    #####:28183:        des_void_ptr(n_context, context, 0);
    #####:28184:        xmlResetLastError();
    #####:28185:        if (mem_base != xmlMemBlocks()) {
    #####:28186:            printf("Leak of %d blocks found in xmlIOHTTPClose",
    #####:28187:	           xmlMemBlocks() - mem_base);
    #####:28188:	    test_ret++;
    #####:28189:            printf(" %d", n_context);
    #####:28190:            printf("\n");
        -:28191:        }
        -:28192:    }
    #####:28193:    function_tests++;
        -:28194:#endif
        -:28195:
    #####:28196:    return(test_ret);
        -:28197:}
        -:28198:
        -:28199:
        -:28200:static int
    #####:28201:test_xmlIOHTTPMatch(void) {
    #####:28202:    int test_ret = 0;
        -:28203:
        -:28204:#if defined(LIBXML_HTTP_ENABLED)
        -:28205:    int mem_base;
        -:28206:    int ret_val;
        -:28207:    const char * filename; /* the URI for matching */
        -:28208:    int n_filename;
        -:28209:
    #####:28210:    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    #####:28211:        mem_base = xmlMemBlocks();
    #####:28212:        filename = gen_filepath(n_filename, 0);
        -:28213:
    #####:28214:        ret_val = xmlIOHTTPMatch(filename);
    #####:28215:        desret_int(ret_val);
    #####:28216:        call_tests++;
    #####:28217:        des_filepath(n_filename, filename, 0);
    #####:28218:        xmlResetLastError();
    #####:28219:        if (mem_base != xmlMemBlocks()) {
    #####:28220:            printf("Leak of %d blocks found in xmlIOHTTPMatch",
    #####:28221:	           xmlMemBlocks() - mem_base);
    #####:28222:	    test_ret++;
    #####:28223:            printf(" %d", n_filename);
    #####:28224:            printf("\n");
        -:28225:        }
        -:28226:    }
    #####:28227:    function_tests++;
        -:28228:#endif
        -:28229:
    #####:28230:    return(test_ret);
        -:28231:}
        -:28232:
        -:28233:
        -:28234:static int
    #####:28235:test_xmlIOHTTPOpen(void) {
    #####:28236:    int test_ret = 0;
        -:28237:
        -:28238:#if defined(LIBXML_HTTP_ENABLED)
        -:28239:    int mem_base;
        -:28240:    void * ret_val;
        -:28241:    const char * filename; /* the URI for matching */
        -:28242:    int n_filename;
        -:28243:
    #####:28244:    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    #####:28245:        mem_base = xmlMemBlocks();
    #####:28246:        filename = gen_filepath(n_filename, 0);
        -:28247:
    #####:28248:        ret_val = xmlIOHTTPOpen(filename);
    #####:28249:        desret_xmlNanoHTTPCtxtPtr(ret_val);
    #####:28250:        call_tests++;
    #####:28251:        des_filepath(n_filename, filename, 0);
    #####:28252:        xmlResetLastError();
    #####:28253:        if (mem_base != xmlMemBlocks()) {
    #####:28254:            printf("Leak of %d blocks found in xmlIOHTTPOpen",
    #####:28255:	           xmlMemBlocks() - mem_base);
    #####:28256:	    test_ret++;
    #####:28257:            printf(" %d", n_filename);
    #####:28258:            printf("\n");
        -:28259:        }
        -:28260:    }
    #####:28261:    function_tests++;
        -:28262:#endif
        -:28263:
    #####:28264:    return(test_ret);
        -:28265:}
        -:28266:
        -:28267:
        -:28268:static int
    #####:28269:test_xmlIOHTTPRead(void) {
    #####:28270:    int test_ret = 0;
        -:28271:
        -:28272:#if defined(LIBXML_HTTP_ENABLED)
        -:28273:    int mem_base;
        -:28274:    int ret_val;
        -:28275:    void * context; /* the I/O context */
        -:28276:    int n_context;
        -:28277:    char * buffer; /* where to drop data */
        -:28278:    int n_buffer;
        -:28279:    int len; /* number of bytes to write */
        -:28280:    int n_len;
        -:28281:
    #####:28282:    for (n_context = 0;n_context < gen_nb_void_ptr;n_context++) {
    #####:28283:    for (n_buffer = 0;n_buffer < gen_nb_char_ptr;n_buffer++) {
    #####:28284:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:28285:        mem_base = xmlMemBlocks();
    #####:28286:        context = gen_void_ptr(n_context, 0);
    #####:28287:        buffer = gen_char_ptr(n_buffer, 1);
    #####:28288:        len = gen_int(n_len, 2);
        -:28289:
    #####:28290:        ret_val = xmlIOHTTPRead(context, buffer, len);
    #####:28291:        desret_int(ret_val);
    #####:28292:        call_tests++;
    #####:28293:        des_void_ptr(n_context, context, 0);
    #####:28294:        des_char_ptr(n_buffer, buffer, 1);
    #####:28295:        des_int(n_len, len, 2);
    #####:28296:        xmlResetLastError();
    #####:28297:        if (mem_base != xmlMemBlocks()) {
    #####:28298:            printf("Leak of %d blocks found in xmlIOHTTPRead",
    #####:28299:	           xmlMemBlocks() - mem_base);
    #####:28300:	    test_ret++;
    #####:28301:            printf(" %d", n_context);
    #####:28302:            printf(" %d", n_buffer);
    #####:28303:            printf(" %d", n_len);
    #####:28304:            printf("\n");
        -:28305:        }
        -:28306:    }
        -:28307:    }
        -:28308:    }
    #####:28309:    function_tests++;
        -:28310:#endif
        -:28311:
    #####:28312:    return(test_ret);
        -:28313:}
        -:28314:
        -:28315:
        -:28316:static int
    #####:28317:test_xmlNoNetExternalEntityLoader(void) {
    #####:28318:    int test_ret = 0;
        -:28319:
        -:28320:    int mem_base;
        -:28321:    xmlParserInputPtr ret_val;
        -:28322:    const char * URL; /* the URL for the entity to load */
        -:28323:    int n_URL;
        -:28324:    char * ID; /* the System ID for the entity to load */
        -:28325:    int n_ID;
        -:28326:    xmlParserCtxtPtr ctxt; /* the context in which the entity is called or NULL */
        -:28327:    int n_ctxt;
        -:28328:
    #####:28329:    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    #####:28330:    for (n_ID = 0;n_ID < gen_nb_const_char_ptr;n_ID++) {
    #####:28331:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:28332:        mem_base = xmlMemBlocks();
    #####:28333:        URL = gen_filepath(n_URL, 0);
    #####:28334:        ID = gen_const_char_ptr(n_ID, 1);
    #####:28335:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 2);
        -:28336:
    #####:28337:        ret_val = xmlNoNetExternalEntityLoader(URL, (const char *)ID, ctxt);
    #####:28338:        desret_xmlParserInputPtr(ret_val);
    #####:28339:        call_tests++;
    #####:28340:        des_filepath(n_URL, URL, 0);
    #####:28341:        des_const_char_ptr(n_ID, (const char *)ID, 1);
    #####:28342:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 2);
    #####:28343:        xmlResetLastError();
    #####:28344:        if (mem_base != xmlMemBlocks()) {
    #####:28345:            printf("Leak of %d blocks found in xmlNoNetExternalEntityLoader",
    #####:28346:	           xmlMemBlocks() - mem_base);
    #####:28347:	    test_ret++;
    #####:28348:            printf(" %d", n_URL);
    #####:28349:            printf(" %d", n_ID);
    #####:28350:            printf(" %d", n_ctxt);
    #####:28351:            printf("\n");
        -:28352:        }
        -:28353:    }
        -:28354:    }
        -:28355:    }
    #####:28356:    function_tests++;
        -:28357:
    #####:28358:    return(test_ret);
        -:28359:}
        -:28360:
        -:28361:
        -:28362:static int
    #####:28363:test_xmlNormalizeWindowsPath(void) {
    #####:28364:    int test_ret = 0;
        -:28365:
        -:28366:    int mem_base;
        -:28367:    xmlChar * ret_val;
        -:28368:    xmlChar * path; /* the input file path */
        -:28369:    int n_path;
        -:28370:
    #####:28371:    for (n_path = 0;n_path < gen_nb_const_xmlChar_ptr;n_path++) {
    #####:28372:        mem_base = xmlMemBlocks();
    #####:28373:        path = gen_const_xmlChar_ptr(n_path, 0);
        -:28374:
    #####:28375:        ret_val = xmlNormalizeWindowsPath((const xmlChar *)path);
    #####:28376:        desret_xmlChar_ptr(ret_val);
    #####:28377:        call_tests++;
    #####:28378:        des_const_xmlChar_ptr(n_path, (const xmlChar *)path, 0);
    #####:28379:        xmlResetLastError();
    #####:28380:        if (mem_base != xmlMemBlocks()) {
    #####:28381:            printf("Leak of %d blocks found in xmlNormalizeWindowsPath",
    #####:28382:	           xmlMemBlocks() - mem_base);
    #####:28383:	    test_ret++;
    #####:28384:            printf(" %d", n_path);
    #####:28385:            printf("\n");
        -:28386:        }
        -:28387:    }
    #####:28388:    function_tests++;
        -:28389:
    #####:28390:    return(test_ret);
        -:28391:}
        -:28392:
        -:28393:
        -:28394:static int
    #####:28395:test_xmlOutputBufferCreateBuffer(void) {
    #####:28396:    int test_ret = 0;
        -:28397:
        -:28398:#if defined(LIBXML_OUTPUT_ENABLED)
        -:28399:    int mem_base;
        -:28400:    xmlOutputBufferPtr ret_val;
        -:28401:    xmlBufferPtr buffer; /* a xmlBufferPtr */
        -:28402:    int n_buffer;
        -:28403:    xmlCharEncodingHandlerPtr encoder; /* the encoding converter or NULL */
        -:28404:    int n_encoder;
        -:28405:
    #####:28406:    for (n_buffer = 0;n_buffer < gen_nb_xmlBufferPtr;n_buffer++) {
    #####:28407:    for (n_encoder = 0;n_encoder < gen_nb_xmlCharEncodingHandlerPtr;n_encoder++) {
    #####:28408:        mem_base = xmlMemBlocks();
    #####:28409:        buffer = gen_xmlBufferPtr(n_buffer, 0);
    #####:28410:        encoder = gen_xmlCharEncodingHandlerPtr(n_encoder, 1);
        -:28411:
    #####:28412:        ret_val = xmlOutputBufferCreateBuffer(buffer, encoder);
    #####:28413:        desret_xmlOutputBufferPtr(ret_val);
    #####:28414:        call_tests++;
    #####:28415:        des_xmlBufferPtr(n_buffer, buffer, 0);
    #####:28416:        des_xmlCharEncodingHandlerPtr(n_encoder, encoder, 1);
    #####:28417:        xmlResetLastError();
    #####:28418:        if (mem_base != xmlMemBlocks()) {
    #####:28419:            printf("Leak of %d blocks found in xmlOutputBufferCreateBuffer",
    #####:28420:	           xmlMemBlocks() - mem_base);
    #####:28421:	    test_ret++;
    #####:28422:            printf(" %d", n_buffer);
    #####:28423:            printf(" %d", n_encoder);
    #####:28424:            printf("\n");
        -:28425:        }
        -:28426:    }
        -:28427:    }
    #####:28428:    function_tests++;
        -:28429:#endif
        -:28430:
    #####:28431:    return(test_ret);
        -:28432:}
        -:28433:
        -:28434:
        -:28435:static int
    #####:28436:test_xmlOutputBufferCreateFd(void) {
    #####:28437:    int test_ret = 0;
        -:28438:
        -:28439:#if defined(LIBXML_OUTPUT_ENABLED)
        -:28440:    int mem_base;
        -:28441:    xmlOutputBufferPtr ret_val;
        -:28442:    int fd; /* a file descriptor number */
        -:28443:    int n_fd;
        -:28444:    xmlCharEncodingHandlerPtr encoder; /* the encoding converter or NULL */
        -:28445:    int n_encoder;
        -:28446:
    #####:28447:    for (n_fd = 0;n_fd < gen_nb_int;n_fd++) {
    #####:28448:    for (n_encoder = 0;n_encoder < gen_nb_xmlCharEncodingHandlerPtr;n_encoder++) {
    #####:28449:        mem_base = xmlMemBlocks();
    #####:28450:        fd = gen_int(n_fd, 0);
    #####:28451:        encoder = gen_xmlCharEncodingHandlerPtr(n_encoder, 1);
        -:28452:
    #####:28453:        ret_val = xmlOutputBufferCreateFd(fd, encoder);
    #####:28454:        desret_xmlOutputBufferPtr(ret_val);
    #####:28455:        call_tests++;
    #####:28456:        des_int(n_fd, fd, 0);
    #####:28457:        des_xmlCharEncodingHandlerPtr(n_encoder, encoder, 1);
    #####:28458:        xmlResetLastError();
    #####:28459:        if (mem_base != xmlMemBlocks()) {
    #####:28460:            printf("Leak of %d blocks found in xmlOutputBufferCreateFd",
    #####:28461:	           xmlMemBlocks() - mem_base);
    #####:28462:	    test_ret++;
    #####:28463:            printf(" %d", n_fd);
    #####:28464:            printf(" %d", n_encoder);
    #####:28465:            printf("\n");
        -:28466:        }
        -:28467:    }
        -:28468:    }
    #####:28469:    function_tests++;
        -:28470:#endif
        -:28471:
    #####:28472:    return(test_ret);
        -:28473:}
        -:28474:
        -:28475:
        -:28476:static int
    #####:28477:test_xmlOutputBufferCreateFile(void) {
    #####:28478:    int test_ret = 0;
        -:28479:
        -:28480:#if defined(LIBXML_OUTPUT_ENABLED)
        -:28481:    int mem_base;
        -:28482:    xmlOutputBufferPtr ret_val;
        -:28483:    FILE * file; /* a FILE* */
        -:28484:    int n_file;
        -:28485:    xmlCharEncodingHandlerPtr encoder; /* the encoding converter or NULL */
        -:28486:    int n_encoder;
        -:28487:
    #####:28488:    for (n_file = 0;n_file < gen_nb_FILE_ptr;n_file++) {
    #####:28489:    for (n_encoder = 0;n_encoder < gen_nb_xmlCharEncodingHandlerPtr;n_encoder++) {
    #####:28490:        mem_base = xmlMemBlocks();
    #####:28491:        file = gen_FILE_ptr(n_file, 0);
    #####:28492:        encoder = gen_xmlCharEncodingHandlerPtr(n_encoder, 1);
        -:28493:
    #####:28494:        ret_val = xmlOutputBufferCreateFile(file, encoder);
    #####:28495:        desret_xmlOutputBufferPtr(ret_val);
    #####:28496:        call_tests++;
    #####:28497:        des_FILE_ptr(n_file, file, 0);
    #####:28498:        des_xmlCharEncodingHandlerPtr(n_encoder, encoder, 1);
    #####:28499:        xmlResetLastError();
    #####:28500:        if (mem_base != xmlMemBlocks()) {
    #####:28501:            printf("Leak of %d blocks found in xmlOutputBufferCreateFile",
    #####:28502:	           xmlMemBlocks() - mem_base);
    #####:28503:	    test_ret++;
    #####:28504:            printf(" %d", n_file);
    #####:28505:            printf(" %d", n_encoder);
    #####:28506:            printf("\n");
        -:28507:        }
        -:28508:    }
        -:28509:    }
    #####:28510:    function_tests++;
        -:28511:#endif
        -:28512:
    #####:28513:    return(test_ret);
        -:28514:}
        -:28515:
        -:28516:
        -:28517:static int
    #####:28518:test_xmlOutputBufferCreateFilename(void) {
    #####:28519:    int test_ret = 0;
        -:28520:
        -:28521:#if defined(LIBXML_OUTPUT_ENABLED)
        -:28522:    int mem_base;
        -:28523:    xmlOutputBufferPtr ret_val;
        -:28524:    const char * URI; /* a C string containing the URI or filename */
        -:28525:    int n_URI;
        -:28526:    xmlCharEncodingHandlerPtr encoder; /* the encoding converter or NULL */
        -:28527:    int n_encoder;
        -:28528:    int compression; /* the compression ration (0 none, 9 max). */
        -:28529:    int n_compression;
        -:28530:
    #####:28531:    for (n_URI = 0;n_URI < gen_nb_fileoutput;n_URI++) {
    #####:28532:    for (n_encoder = 0;n_encoder < gen_nb_xmlCharEncodingHandlerPtr;n_encoder++) {
    #####:28533:    for (n_compression = 0;n_compression < gen_nb_int;n_compression++) {
    #####:28534:        mem_base = xmlMemBlocks();
    #####:28535:        URI = gen_fileoutput(n_URI, 0);
    #####:28536:        encoder = gen_xmlCharEncodingHandlerPtr(n_encoder, 1);
    #####:28537:        compression = gen_int(n_compression, 2);
        -:28538:
    #####:28539:        ret_val = xmlOutputBufferCreateFilename(URI, encoder, compression);
    #####:28540:        desret_xmlOutputBufferPtr(ret_val);
    #####:28541:        call_tests++;
    #####:28542:        des_fileoutput(n_URI, URI, 0);
    #####:28543:        des_xmlCharEncodingHandlerPtr(n_encoder, encoder, 1);
    #####:28544:        des_int(n_compression, compression, 2);
    #####:28545:        xmlResetLastError();
    #####:28546:        if (mem_base != xmlMemBlocks()) {
    #####:28547:            printf("Leak of %d blocks found in xmlOutputBufferCreateFilename",
    #####:28548:	           xmlMemBlocks() - mem_base);
    #####:28549:	    test_ret++;
    #####:28550:            printf(" %d", n_URI);
    #####:28551:            printf(" %d", n_encoder);
    #####:28552:            printf(" %d", n_compression);
    #####:28553:            printf("\n");
        -:28554:        }
        -:28555:    }
        -:28556:    }
        -:28557:    }
    #####:28558:    function_tests++;
        -:28559:#endif
        -:28560:
    #####:28561:    return(test_ret);
        -:28562:}
        -:28563:
        -:28564:
        -:28565:static int
    #####:28566:test_xmlOutputBufferFlush(void) {
    #####:28567:    int test_ret = 0;
        -:28568:
        -:28569:#if defined(LIBXML_OUTPUT_ENABLED)
        -:28570:    int mem_base;
        -:28571:    int ret_val;
        -:28572:    xmlOutputBufferPtr out; /* a buffered output */
        -:28573:    int n_out;
        -:28574:
    #####:28575:    for (n_out = 0;n_out < gen_nb_xmlOutputBufferPtr;n_out++) {
    #####:28576:        mem_base = xmlMemBlocks();
    #####:28577:        out = gen_xmlOutputBufferPtr(n_out, 0);
        -:28578:
    #####:28579:        ret_val = xmlOutputBufferFlush(out);
    #####:28580:        desret_int(ret_val);
    #####:28581:        call_tests++;
    #####:28582:        des_xmlOutputBufferPtr(n_out, out, 0);
    #####:28583:        xmlResetLastError();
    #####:28584:        if (mem_base != xmlMemBlocks()) {
    #####:28585:            printf("Leak of %d blocks found in xmlOutputBufferFlush",
    #####:28586:	           xmlMemBlocks() - mem_base);
    #####:28587:	    test_ret++;
    #####:28588:            printf(" %d", n_out);
    #####:28589:            printf("\n");
        -:28590:        }
        -:28591:    }
    #####:28592:    function_tests++;
        -:28593:#endif
        -:28594:
    #####:28595:    return(test_ret);
        -:28596:}
        -:28597:
        -:28598:
        -:28599:static int
    #####:28600:test_xmlOutputBufferGetContent(void) {
    #####:28601:    int test_ret = 0;
        -:28602:
        -:28603:#if defined(LIBXML_OUTPUT_ENABLED)
        -:28604:    int mem_base;
        -:28605:    const xmlChar * ret_val;
        -:28606:    xmlOutputBufferPtr out; /* an xmlOutputBufferPtr */
        -:28607:    int n_out;
        -:28608:
    #####:28609:    for (n_out = 0;n_out < gen_nb_xmlOutputBufferPtr;n_out++) {
    #####:28610:        mem_base = xmlMemBlocks();
    #####:28611:        out = gen_xmlOutputBufferPtr(n_out, 0);
        -:28612:
    #####:28613:        ret_val = xmlOutputBufferGetContent(out);
    #####:28614:        desret_const_xmlChar_ptr(ret_val);
    #####:28615:        call_tests++;
    #####:28616:        des_xmlOutputBufferPtr(n_out, out, 0);
    #####:28617:        xmlResetLastError();
    #####:28618:        if (mem_base != xmlMemBlocks()) {
    #####:28619:            printf("Leak of %d blocks found in xmlOutputBufferGetContent",
    #####:28620:	           xmlMemBlocks() - mem_base);
    #####:28621:	    test_ret++;
    #####:28622:            printf(" %d", n_out);
    #####:28623:            printf("\n");
        -:28624:        }
        -:28625:    }
    #####:28626:    function_tests++;
        -:28627:#endif
        -:28628:
    #####:28629:    return(test_ret);
        -:28630:}
        -:28631:
        -:28632:
        -:28633:static int
    #####:28634:test_xmlOutputBufferGetSize(void) {
    #####:28635:    int test_ret = 0;
        -:28636:
        -:28637:
        -:28638:    /* missing type support */
    #####:28639:    return(test_ret);
        -:28640:}
        -:28641:
        -:28642:
        -:28643:static int
    #####:28644:test_xmlOutputBufferWrite(void) {
    #####:28645:    int test_ret = 0;
        -:28646:
        -:28647:#if defined(LIBXML_OUTPUT_ENABLED)
        -:28648:    int mem_base;
        -:28649:    int ret_val;
        -:28650:    xmlOutputBufferPtr out; /* a buffered parser output */
        -:28651:    int n_out;
        -:28652:    int len; /* the size in bytes of the array. */
        -:28653:    int n_len;
        -:28654:    char * buf; /* an char array */
        -:28655:    int n_buf;
        -:28656:
    #####:28657:    for (n_out = 0;n_out < gen_nb_xmlOutputBufferPtr;n_out++) {
    #####:28658:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:28659:    for (n_buf = 0;n_buf < gen_nb_const_char_ptr;n_buf++) {
    #####:28660:        mem_base = xmlMemBlocks();
    #####:28661:        out = gen_xmlOutputBufferPtr(n_out, 0);
    #####:28662:        len = gen_int(n_len, 1);
    #####:28663:        buf = gen_const_char_ptr(n_buf, 2);
        -:28664:
    #####:28665:        ret_val = xmlOutputBufferWrite(out, len, (const char *)buf);
    #####:28666:        desret_int(ret_val);
    #####:28667:        call_tests++;
    #####:28668:        des_xmlOutputBufferPtr(n_out, out, 0);
    #####:28669:        des_int(n_len, len, 1);
    #####:28670:        des_const_char_ptr(n_buf, (const char *)buf, 2);
    #####:28671:        xmlResetLastError();
    #####:28672:        if (mem_base != xmlMemBlocks()) {
    #####:28673:            printf("Leak of %d blocks found in xmlOutputBufferWrite",
    #####:28674:	           xmlMemBlocks() - mem_base);
    #####:28675:	    test_ret++;
    #####:28676:            printf(" %d", n_out);
    #####:28677:            printf(" %d", n_len);
    #####:28678:            printf(" %d", n_buf);
    #####:28679:            printf("\n");
        -:28680:        }
        -:28681:    }
        -:28682:    }
        -:28683:    }
    #####:28684:    function_tests++;
        -:28685:#endif
        -:28686:
    #####:28687:    return(test_ret);
        -:28688:}
        -:28689:
        -:28690:
        -:28691:static int
    #####:28692:test_xmlOutputBufferWriteEscape(void) {
    #####:28693:    int test_ret = 0;
        -:28694:
        -:28695:
        -:28696:    /* missing type support */
    #####:28697:    return(test_ret);
        -:28698:}
        -:28699:
        -:28700:
        -:28701:static int
    #####:28702:test_xmlOutputBufferWriteString(void) {
    #####:28703:    int test_ret = 0;
        -:28704:
        -:28705:#if defined(LIBXML_OUTPUT_ENABLED)
        -:28706:    int mem_base;
        -:28707:    int ret_val;
        -:28708:    xmlOutputBufferPtr out; /* a buffered parser output */
        -:28709:    int n_out;
        -:28710:    char * str; /* a zero terminated C string */
        -:28711:    int n_str;
        -:28712:
    #####:28713:    for (n_out = 0;n_out < gen_nb_xmlOutputBufferPtr;n_out++) {
    #####:28714:    for (n_str = 0;n_str < gen_nb_const_char_ptr;n_str++) {
    #####:28715:        mem_base = xmlMemBlocks();
    #####:28716:        out = gen_xmlOutputBufferPtr(n_out, 0);
    #####:28717:        str = gen_const_char_ptr(n_str, 1);
        -:28718:
    #####:28719:        ret_val = xmlOutputBufferWriteString(out, (const char *)str);
    #####:28720:        desret_int(ret_val);
    #####:28721:        call_tests++;
    #####:28722:        des_xmlOutputBufferPtr(n_out, out, 0);
    #####:28723:        des_const_char_ptr(n_str, (const char *)str, 1);
    #####:28724:        xmlResetLastError();
    #####:28725:        if (mem_base != xmlMemBlocks()) {
    #####:28726:            printf("Leak of %d blocks found in xmlOutputBufferWriteString",
    #####:28727:	           xmlMemBlocks() - mem_base);
    #####:28728:	    test_ret++;
    #####:28729:            printf(" %d", n_out);
    #####:28730:            printf(" %d", n_str);
    #####:28731:            printf("\n");
        -:28732:        }
        -:28733:    }
        -:28734:    }
    #####:28735:    function_tests++;
        -:28736:#endif
        -:28737:
    #####:28738:    return(test_ret);
        -:28739:}
        -:28740:
        -:28741:
        -:28742:static int
    #####:28743:test_xmlParserGetDirectory(void) {
    #####:28744:    int test_ret = 0;
        -:28745:
        -:28746:
        -:28747:    /* missing type support */
    #####:28748:    return(test_ret);
        -:28749:}
        -:28750:
        -:28751:
        -:28752:static int
    #####:28753:test_xmlParserInputBufferCreateFd(void) {
    #####:28754:    int test_ret = 0;
        -:28755:
        -:28756:    int mem_base;
        -:28757:    xmlParserInputBufferPtr ret_val;
        -:28758:    int fd; /* a file descriptor number */
        -:28759:    int n_fd;
        -:28760:    xmlCharEncoding enc; /* the charset encoding if known */
        -:28761:    int n_enc;
        -:28762:
    #####:28763:    for (n_fd = 0;n_fd < gen_nb_int;n_fd++) {
    #####:28764:    for (n_enc = 0;n_enc < gen_nb_xmlCharEncoding;n_enc++) {
    #####:28765:        mem_base = xmlMemBlocks();
    #####:28766:        fd = gen_int(n_fd, 0);
    #####:28767:        enc = gen_xmlCharEncoding(n_enc, 1);
    #####:28768:        if (fd >= 0) fd = -1;
        -:28769:
    #####:28770:        ret_val = xmlParserInputBufferCreateFd(fd, enc);
    #####:28771:        desret_xmlParserInputBufferPtr(ret_val);
    #####:28772:        call_tests++;
    #####:28773:        des_int(n_fd, fd, 0);
    #####:28774:        des_xmlCharEncoding(n_enc, enc, 1);
    #####:28775:        xmlResetLastError();
    #####:28776:        if (mem_base != xmlMemBlocks()) {
    #####:28777:            printf("Leak of %d blocks found in xmlParserInputBufferCreateFd",
    #####:28778:	           xmlMemBlocks() - mem_base);
    #####:28779:	    test_ret++;
    #####:28780:            printf(" %d", n_fd);
    #####:28781:            printf(" %d", n_enc);
    #####:28782:            printf("\n");
        -:28783:        }
        -:28784:    }
        -:28785:    }
    #####:28786:    function_tests++;
        -:28787:
    #####:28788:    return(test_ret);
        -:28789:}
        -:28790:
        -:28791:
        -:28792:static int
    #####:28793:test_xmlParserInputBufferCreateFile(void) {
    #####:28794:    int test_ret = 0;
        -:28795:
        -:28796:    int mem_base;
        -:28797:    xmlParserInputBufferPtr ret_val;
        -:28798:    FILE * file; /* a FILE* */
        -:28799:    int n_file;
        -:28800:    xmlCharEncoding enc; /* the charset encoding if known */
        -:28801:    int n_enc;
        -:28802:
    #####:28803:    for (n_file = 0;n_file < gen_nb_FILE_ptr;n_file++) {
    #####:28804:    for (n_enc = 0;n_enc < gen_nb_xmlCharEncoding;n_enc++) {
    #####:28805:        mem_base = xmlMemBlocks();
    #####:28806:        file = gen_FILE_ptr(n_file, 0);
    #####:28807:        enc = gen_xmlCharEncoding(n_enc, 1);
        -:28808:
    #####:28809:        ret_val = xmlParserInputBufferCreateFile(file, enc);
    #####:28810:        desret_xmlParserInputBufferPtr(ret_val);
    #####:28811:        call_tests++;
    #####:28812:        des_FILE_ptr(n_file, file, 0);
    #####:28813:        des_xmlCharEncoding(n_enc, enc, 1);
    #####:28814:        xmlResetLastError();
    #####:28815:        if (mem_base != xmlMemBlocks()) {
    #####:28816:            printf("Leak of %d blocks found in xmlParserInputBufferCreateFile",
    #####:28817:	           xmlMemBlocks() - mem_base);
    #####:28818:	    test_ret++;
    #####:28819:            printf(" %d", n_file);
    #####:28820:            printf(" %d", n_enc);
    #####:28821:            printf("\n");
        -:28822:        }
        -:28823:    }
        -:28824:    }
    #####:28825:    function_tests++;
        -:28826:
    #####:28827:    return(test_ret);
        -:28828:}
        -:28829:
        -:28830:
        -:28831:static int
    #####:28832:test_xmlParserInputBufferCreateFilename(void) {
    #####:28833:    int test_ret = 0;
        -:28834:
        -:28835:    int mem_base;
        -:28836:    xmlParserInputBufferPtr ret_val;
        -:28837:    const char * URI; /* a C string containing the URI or filename */
        -:28838:    int n_URI;
        -:28839:    xmlCharEncoding enc; /* the charset encoding if known */
        -:28840:    int n_enc;
        -:28841:
    #####:28842:    for (n_URI = 0;n_URI < gen_nb_fileoutput;n_URI++) {
    #####:28843:    for (n_enc = 0;n_enc < gen_nb_xmlCharEncoding;n_enc++) {
    #####:28844:        mem_base = xmlMemBlocks();
    #####:28845:        URI = gen_fileoutput(n_URI, 0);
    #####:28846:        enc = gen_xmlCharEncoding(n_enc, 1);
        -:28847:
    #####:28848:        ret_val = xmlParserInputBufferCreateFilename(URI, enc);
    #####:28849:        desret_xmlParserInputBufferPtr(ret_val);
    #####:28850:        call_tests++;
    #####:28851:        des_fileoutput(n_URI, URI, 0);
    #####:28852:        des_xmlCharEncoding(n_enc, enc, 1);
    #####:28853:        xmlResetLastError();
    #####:28854:        if (mem_base != xmlMemBlocks()) {
    #####:28855:            printf("Leak of %d blocks found in xmlParserInputBufferCreateFilename",
    #####:28856:	           xmlMemBlocks() - mem_base);
    #####:28857:	    test_ret++;
    #####:28858:            printf(" %d", n_URI);
    #####:28859:            printf(" %d", n_enc);
    #####:28860:            printf("\n");
        -:28861:        }
        -:28862:    }
        -:28863:    }
    #####:28864:    function_tests++;
        -:28865:
    #####:28866:    return(test_ret);
        -:28867:}
        -:28868:
        -:28869:
        -:28870:static int
    #####:28871:test_xmlParserInputBufferCreateMem(void) {
    #####:28872:    int test_ret = 0;
        -:28873:
        -:28874:    int mem_base;
        -:28875:    xmlParserInputBufferPtr ret_val;
        -:28876:    char * mem; /* the memory input */
        -:28877:    int n_mem;
        -:28878:    int size; /* the length of the memory block */
        -:28879:    int n_size;
        -:28880:    xmlCharEncoding enc; /* the charset encoding if known */
        -:28881:    int n_enc;
        -:28882:
    #####:28883:    for (n_mem = 0;n_mem < gen_nb_const_char_ptr;n_mem++) {
    #####:28884:    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    #####:28885:    for (n_enc = 0;n_enc < gen_nb_xmlCharEncoding;n_enc++) {
    #####:28886:        mem_base = xmlMemBlocks();
    #####:28887:        mem = gen_const_char_ptr(n_mem, 0);
    #####:28888:        size = gen_int(n_size, 1);
    #####:28889:        enc = gen_xmlCharEncoding(n_enc, 2);
        -:28890:
    #####:28891:        ret_val = xmlParserInputBufferCreateMem((const char *)mem, size, enc);
    #####:28892:        desret_xmlParserInputBufferPtr(ret_val);
    #####:28893:        call_tests++;
    #####:28894:        des_const_char_ptr(n_mem, (const char *)mem, 0);
    #####:28895:        des_int(n_size, size, 1);
    #####:28896:        des_xmlCharEncoding(n_enc, enc, 2);
    #####:28897:        xmlResetLastError();
    #####:28898:        if (mem_base != xmlMemBlocks()) {
    #####:28899:            printf("Leak of %d blocks found in xmlParserInputBufferCreateMem",
    #####:28900:	           xmlMemBlocks() - mem_base);
    #####:28901:	    test_ret++;
    #####:28902:            printf(" %d", n_mem);
    #####:28903:            printf(" %d", n_size);
    #####:28904:            printf(" %d", n_enc);
    #####:28905:            printf("\n");
        -:28906:        }
        -:28907:    }
        -:28908:    }
        -:28909:    }
    #####:28910:    function_tests++;
        -:28911:
    #####:28912:    return(test_ret);
        -:28913:}
        -:28914:
        -:28915:
        -:28916:static int
    #####:28917:test_xmlParserInputBufferCreateStatic(void) {
    #####:28918:    int test_ret = 0;
        -:28919:
        -:28920:    int mem_base;
        -:28921:    xmlParserInputBufferPtr ret_val;
        -:28922:    char * mem; /* the memory input */
        -:28923:    int n_mem;
        -:28924:    int size; /* the length of the memory block */
        -:28925:    int n_size;
        -:28926:    xmlCharEncoding enc; /* the charset encoding if known */
        -:28927:    int n_enc;
        -:28928:
    #####:28929:    for (n_mem = 0;n_mem < gen_nb_const_char_ptr;n_mem++) {
    #####:28930:    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    #####:28931:    for (n_enc = 0;n_enc < gen_nb_xmlCharEncoding;n_enc++) {
    #####:28932:        mem_base = xmlMemBlocks();
    #####:28933:        mem = gen_const_char_ptr(n_mem, 0);
    #####:28934:        size = gen_int(n_size, 1);
    #####:28935:        enc = gen_xmlCharEncoding(n_enc, 2);
        -:28936:
    #####:28937:        ret_val = xmlParserInputBufferCreateStatic((const char *)mem, size, enc);
    #####:28938:        desret_xmlParserInputBufferPtr(ret_val);
    #####:28939:        call_tests++;
    #####:28940:        des_const_char_ptr(n_mem, (const char *)mem, 0);
    #####:28941:        des_int(n_size, size, 1);
    #####:28942:        des_xmlCharEncoding(n_enc, enc, 2);
    #####:28943:        xmlResetLastError();
    #####:28944:        if (mem_base != xmlMemBlocks()) {
    #####:28945:            printf("Leak of %d blocks found in xmlParserInputBufferCreateStatic",
    #####:28946:	           xmlMemBlocks() - mem_base);
    #####:28947:	    test_ret++;
    #####:28948:            printf(" %d", n_mem);
    #####:28949:            printf(" %d", n_size);
    #####:28950:            printf(" %d", n_enc);
    #####:28951:            printf("\n");
        -:28952:        }
        -:28953:    }
        -:28954:    }
        -:28955:    }
    #####:28956:    function_tests++;
        -:28957:
    #####:28958:    return(test_ret);
        -:28959:}
        -:28960:
        -:28961:
        -:28962:static int
    #####:28963:test_xmlParserInputBufferGrow(void) {
    #####:28964:    int test_ret = 0;
        -:28965:
        -:28966:    int mem_base;
        -:28967:    int ret_val;
        -:28968:    xmlParserInputBufferPtr in; /* a buffered parser input */
        -:28969:    int n_in;
        -:28970:    int len; /* indicative value of the amount of chars to read */
        -:28971:    int n_len;
        -:28972:
    #####:28973:    for (n_in = 0;n_in < gen_nb_xmlParserInputBufferPtr;n_in++) {
    #####:28974:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:28975:        mem_base = xmlMemBlocks();
    #####:28976:        in = gen_xmlParserInputBufferPtr(n_in, 0);
    #####:28977:        len = gen_int(n_len, 1);
        -:28978:
    #####:28979:        ret_val = xmlParserInputBufferGrow(in, len);
    #####:28980:        desret_int(ret_val);
    #####:28981:        call_tests++;
    #####:28982:        des_xmlParserInputBufferPtr(n_in, in, 0);
    #####:28983:        des_int(n_len, len, 1);
    #####:28984:        xmlResetLastError();
    #####:28985:        if (mem_base != xmlMemBlocks()) {
    #####:28986:            printf("Leak of %d blocks found in xmlParserInputBufferGrow",
    #####:28987:	           xmlMemBlocks() - mem_base);
    #####:28988:	    test_ret++;
    #####:28989:            printf(" %d", n_in);
    #####:28990:            printf(" %d", n_len);
    #####:28991:            printf("\n");
        -:28992:        }
        -:28993:    }
        -:28994:    }
    #####:28995:    function_tests++;
        -:28996:
    #####:28997:    return(test_ret);
        -:28998:}
        -:28999:
        -:29000:
        -:29001:static int
    #####:29002:test_xmlParserInputBufferPush(void) {
    #####:29003:    int test_ret = 0;
        -:29004:
        -:29005:    int mem_base;
        -:29006:    int ret_val;
        -:29007:    xmlParserInputBufferPtr in; /* a buffered parser input */
        -:29008:    int n_in;
        -:29009:    int len; /* the size in bytes of the array. */
        -:29010:    int n_len;
        -:29011:    char * buf; /* an char array */
        -:29012:    int n_buf;
        -:29013:
    #####:29014:    for (n_in = 0;n_in < gen_nb_xmlParserInputBufferPtr;n_in++) {
    #####:29015:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:29016:    for (n_buf = 0;n_buf < gen_nb_const_char_ptr;n_buf++) {
    #####:29017:        mem_base = xmlMemBlocks();
    #####:29018:        in = gen_xmlParserInputBufferPtr(n_in, 0);
    #####:29019:        len = gen_int(n_len, 1);
    #####:29020:        buf = gen_const_char_ptr(n_buf, 2);
        -:29021:
    #####:29022:        ret_val = xmlParserInputBufferPush(in, len, (const char *)buf);
    #####:29023:        desret_int(ret_val);
    #####:29024:        call_tests++;
    #####:29025:        des_xmlParserInputBufferPtr(n_in, in, 0);
    #####:29026:        des_int(n_len, len, 1);
    #####:29027:        des_const_char_ptr(n_buf, (const char *)buf, 2);
    #####:29028:        xmlResetLastError();
    #####:29029:        if (mem_base != xmlMemBlocks()) {
    #####:29030:            printf("Leak of %d blocks found in xmlParserInputBufferPush",
    #####:29031:	           xmlMemBlocks() - mem_base);
    #####:29032:	    test_ret++;
    #####:29033:            printf(" %d", n_in);
    #####:29034:            printf(" %d", n_len);
    #####:29035:            printf(" %d", n_buf);
    #####:29036:            printf("\n");
        -:29037:        }
        -:29038:    }
        -:29039:    }
        -:29040:    }
    #####:29041:    function_tests++;
        -:29042:
    #####:29043:    return(test_ret);
        -:29044:}
        -:29045:
        -:29046:
        -:29047:static int
    #####:29048:test_xmlParserInputBufferRead(void) {
    #####:29049:    int test_ret = 0;
        -:29050:
        -:29051:    int mem_base;
        -:29052:    int ret_val;
        -:29053:    xmlParserInputBufferPtr in; /* a buffered parser input */
        -:29054:    int n_in;
        -:29055:    int len; /* indicative value of the amount of chars to read */
        -:29056:    int n_len;
        -:29057:
    #####:29058:    for (n_in = 0;n_in < gen_nb_xmlParserInputBufferPtr;n_in++) {
    #####:29059:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:29060:        mem_base = xmlMemBlocks();
    #####:29061:        in = gen_xmlParserInputBufferPtr(n_in, 0);
    #####:29062:        len = gen_int(n_len, 1);
        -:29063:
    #####:29064:        ret_val = xmlParserInputBufferRead(in, len);
    #####:29065:        desret_int(ret_val);
    #####:29066:        call_tests++;
    #####:29067:        des_xmlParserInputBufferPtr(n_in, in, 0);
    #####:29068:        des_int(n_len, len, 1);
    #####:29069:        xmlResetLastError();
    #####:29070:        if (mem_base != xmlMemBlocks()) {
    #####:29071:            printf("Leak of %d blocks found in xmlParserInputBufferRead",
    #####:29072:	           xmlMemBlocks() - mem_base);
    #####:29073:	    test_ret++;
    #####:29074:            printf(" %d", n_in);
    #####:29075:            printf(" %d", n_len);
    #####:29076:            printf("\n");
        -:29077:        }
        -:29078:    }
        -:29079:    }
    #####:29080:    function_tests++;
        -:29081:
    #####:29082:    return(test_ret);
        -:29083:}
        -:29084:
        -:29085:
        -:29086:static int
    #####:29087:test_xmlPopInputCallbacks(void) {
    #####:29088:    int test_ret = 0;
        -:29089:
        -:29090:    int mem_base;
        -:29091:    int ret_val;
        -:29092:
    #####:29093:        mem_base = xmlMemBlocks();
        -:29094:
    #####:29095:        ret_val = xmlPopInputCallbacks();
    #####:29096:        desret_int(ret_val);
    #####:29097:        call_tests++;
    #####:29098:        xmlResetLastError();
    #####:29099:        if (mem_base != xmlMemBlocks()) {
    #####:29100:            printf("Leak of %d blocks found in xmlPopInputCallbacks",
    #####:29101:	           xmlMemBlocks() - mem_base);
    #####:29102:	    test_ret++;
    #####:29103:            printf("\n");
        -:29104:        }
    #####:29105:    function_tests++;
        -:29106:
    #####:29107:    return(test_ret);
        -:29108:}
        -:29109:
        -:29110:
        -:29111:static int
    #####:29112:test_xmlRegisterDefaultInputCallbacks(void) {
    #####:29113:    int test_ret = 0;
        -:29114:
        -:29115:    int mem_base;
        -:29116:
    #####:29117:        mem_base = xmlMemBlocks();
        -:29118:
    #####:29119:        xmlRegisterDefaultInputCallbacks();
    #####:29120:        call_tests++;
    #####:29121:        xmlResetLastError();
    #####:29122:        if (mem_base != xmlMemBlocks()) {
    #####:29123:            printf("Leak of %d blocks found in xmlRegisterDefaultInputCallbacks",
    #####:29124:	           xmlMemBlocks() - mem_base);
    #####:29125:	    test_ret++;
    #####:29126:            printf("\n");
        -:29127:        }
    #####:29128:    function_tests++;
        -:29129:
    #####:29130:    return(test_ret);
        -:29131:}
        -:29132:
        -:29133:
        -:29134:static int
    #####:29135:test_xmlRegisterDefaultOutputCallbacks(void) {
    #####:29136:    int test_ret = 0;
        -:29137:
        -:29138:#if defined(LIBXML_OUTPUT_ENABLED)
        -:29139:    int mem_base;
        -:29140:
    #####:29141:        mem_base = xmlMemBlocks();
        -:29142:
    #####:29143:        xmlRegisterDefaultOutputCallbacks();
    #####:29144:        call_tests++;
    #####:29145:        xmlResetLastError();
    #####:29146:        if (mem_base != xmlMemBlocks()) {
    #####:29147:            printf("Leak of %d blocks found in xmlRegisterDefaultOutputCallbacks",
    #####:29148:	           xmlMemBlocks() - mem_base);
    #####:29149:	    test_ret++;
    #####:29150:            printf("\n");
        -:29151:        }
    #####:29152:    function_tests++;
        -:29153:#endif
        -:29154:
    #####:29155:    return(test_ret);
        -:29156:}
        -:29157:
        -:29158:
        -:29159:static int
    #####:29160:test_xmlRegisterHTTPPostCallbacks(void) {
    #####:29161:    int test_ret = 0;
        -:29162:
        -:29163:#if defined(LIBXML_OUTPUT_ENABLED) && defined(LIBXML_HTTP_ENABLED)
        -:29164:    int mem_base;
        -:29165:
    #####:29166:        mem_base = xmlMemBlocks();
        -:29167:
    #####:29168:        xmlRegisterHTTPPostCallbacks();
    #####:29169:        call_tests++;
    #####:29170:        xmlResetLastError();
    #####:29171:        if (mem_base != xmlMemBlocks()) {
    #####:29172:            printf("Leak of %d blocks found in xmlRegisterHTTPPostCallbacks",
    #####:29173:	           xmlMemBlocks() - mem_base);
    #####:29174:	    test_ret++;
    #####:29175:            printf("\n");
        -:29176:        }
    #####:29177:    function_tests++;
        -:29178:#endif
        -:29179:
    #####:29180:    return(test_ret);
        -:29181:}
        -:29182:
        -:29183:static int
    #####:29184:test_xmlIO(void) {
    #####:29185:    int test_ret = 0;
        -:29186:
    #####:29187:    if (quiet == 0) printf("Testing xmlIO : 40 of 50 functions ...\n");
    #####:29188:    test_ret += test_xmlAllocOutputBuffer();
    #####:29189:    test_ret += test_xmlAllocParserInputBuffer();
    #####:29190:    test_ret += test_xmlCheckFilename();
    #####:29191:    test_ret += test_xmlCheckHTTPInput();
    #####:29192:    test_ret += test_xmlCleanupInputCallbacks();
    #####:29193:    test_ret += test_xmlCleanupOutputCallbacks();
    #####:29194:    test_ret += test_xmlFileClose();
    #####:29195:    test_ret += test_xmlFileMatch();
    #####:29196:    test_ret += test_xmlFileOpen();
    #####:29197:    test_ret += test_xmlFileRead();
    #####:29198:    test_ret += test_xmlIOFTPClose();
    #####:29199:    test_ret += test_xmlIOFTPMatch();
    #####:29200:    test_ret += test_xmlIOFTPOpen();
    #####:29201:    test_ret += test_xmlIOFTPRead();
    #####:29202:    test_ret += test_xmlIOHTTPClose();
    #####:29203:    test_ret += test_xmlIOHTTPMatch();
    #####:29204:    test_ret += test_xmlIOHTTPOpen();
    #####:29205:    test_ret += test_xmlIOHTTPRead();
    #####:29206:    test_ret += test_xmlNoNetExternalEntityLoader();
    #####:29207:    test_ret += test_xmlNormalizeWindowsPath();
    #####:29208:    test_ret += test_xmlOutputBufferCreateBuffer();
    #####:29209:    test_ret += test_xmlOutputBufferCreateFd();
    #####:29210:    test_ret += test_xmlOutputBufferCreateFile();
    #####:29211:    test_ret += test_xmlOutputBufferCreateFilename();
    #####:29212:    test_ret += test_xmlOutputBufferFlush();
    #####:29213:    test_ret += test_xmlOutputBufferGetContent();
    #####:29214:    test_ret += test_xmlOutputBufferGetSize();
    #####:29215:    test_ret += test_xmlOutputBufferWrite();
    #####:29216:    test_ret += test_xmlOutputBufferWriteEscape();
    #####:29217:    test_ret += test_xmlOutputBufferWriteString();
    #####:29218:    test_ret += test_xmlParserGetDirectory();
    #####:29219:    test_ret += test_xmlParserInputBufferCreateFd();
    #####:29220:    test_ret += test_xmlParserInputBufferCreateFile();
    #####:29221:    test_ret += test_xmlParserInputBufferCreateFilename();
    #####:29222:    test_ret += test_xmlParserInputBufferCreateMem();
    #####:29223:    test_ret += test_xmlParserInputBufferCreateStatic();
    #####:29224:    test_ret += test_xmlParserInputBufferGrow();
    #####:29225:    test_ret += test_xmlParserInputBufferPush();
    #####:29226:    test_ret += test_xmlParserInputBufferRead();
    #####:29227:    test_ret += test_xmlPopInputCallbacks();
    #####:29228:    test_ret += test_xmlRegisterDefaultInputCallbacks();
    #####:29229:    test_ret += test_xmlRegisterDefaultOutputCallbacks();
    #####:29230:    test_ret += test_xmlRegisterHTTPPostCallbacks();
        -:29231:
    #####:29232:    if (test_ret != 0)
    #####:29233:	printf("Module xmlIO: %d errors\n", test_ret);
    #####:29234:    return(test_ret);
        -:29235:}
        -:29236:#ifdef LIBXML_AUTOMATA_ENABLED
        -:29237:
        -:29238:#define gen_nb_xmlAutomataPtr 1
    #####:29239:static xmlAutomataPtr gen_xmlAutomataPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:29240:    return(NULL);
        -:29241:}
    #####:29242:static void des_xmlAutomataPtr(int no ATTRIBUTE_UNUSED, xmlAutomataPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:29243:}
        -:29244:#endif
        -:29245:
        -:29246:
        -:29247:static int
    #####:29248:test_xmlAutomataCompile(void) {
    #####:29249:    int test_ret = 0;
        -:29250:
        -:29251:
        -:29252:    /* missing type support */
    #####:29253:    return(test_ret);
        -:29254:}
        -:29255:
        -:29256:
        -:29257:static int
    #####:29258:test_xmlAutomataGetInitState(void) {
    #####:29259:    int test_ret = 0;
        -:29260:
        -:29261:
        -:29262:    /* missing type support */
    #####:29263:    return(test_ret);
        -:29264:}
        -:29265:
        -:29266:
        -:29267:static int
    #####:29268:test_xmlAutomataIsDeterminist(void) {
    #####:29269:    int test_ret = 0;
        -:29270:
        -:29271:#if defined(LIBXML_REGEXP_ENABLED) && defined(LIBXML_AUTOMATA_ENABLED)
        -:29272:    int mem_base;
        -:29273:    int ret_val;
        -:29274:    xmlAutomataPtr am; /* an automata */
        -:29275:    int n_am;
        -:29276:
    #####:29277:    for (n_am = 0;n_am < gen_nb_xmlAutomataPtr;n_am++) {
    #####:29278:        mem_base = xmlMemBlocks();
    #####:29279:        am = gen_xmlAutomataPtr(n_am, 0);
        -:29280:
    #####:29281:        ret_val = xmlAutomataIsDeterminist(am);
    #####:29282:        desret_int(ret_val);
    #####:29283:        call_tests++;
    #####:29284:        des_xmlAutomataPtr(n_am, am, 0);
    #####:29285:        xmlResetLastError();
    #####:29286:        if (mem_base != xmlMemBlocks()) {
    #####:29287:            printf("Leak of %d blocks found in xmlAutomataIsDeterminist",
    #####:29288:	           xmlMemBlocks() - mem_base);
    #####:29289:	    test_ret++;
    #####:29290:            printf(" %d", n_am);
    #####:29291:            printf("\n");
        -:29292:        }
        -:29293:    }
    #####:29294:    function_tests++;
        -:29295:#endif
        -:29296:
    #####:29297:    return(test_ret);
        -:29298:}
        -:29299:
        -:29300:#ifdef LIBXML_AUTOMATA_ENABLED
        -:29301:
        -:29302:#define gen_nb_xmlAutomataStatePtr 1
    #####:29303:static xmlAutomataStatePtr gen_xmlAutomataStatePtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:29304:    return(NULL);
        -:29305:}
    #####:29306:static void des_xmlAutomataStatePtr(int no ATTRIBUTE_UNUSED, xmlAutomataStatePtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:29307:}
        -:29308:#endif
        -:29309:
        -:29310:
        -:29311:static int
    #####:29312:test_xmlAutomataNewAllTrans(void) {
    #####:29313:    int test_ret = 0;
        -:29314:
        -:29315:
        -:29316:    /* missing type support */
    #####:29317:    return(test_ret);
        -:29318:}
        -:29319:
        -:29320:
        -:29321:static int
    #####:29322:test_xmlAutomataNewCountTrans(void) {
    #####:29323:    int test_ret = 0;
        -:29324:
        -:29325:
        -:29326:    /* missing type support */
    #####:29327:    return(test_ret);
        -:29328:}
        -:29329:
        -:29330:
        -:29331:static int
    #####:29332:test_xmlAutomataNewCountTrans2(void) {
    #####:29333:    int test_ret = 0;
        -:29334:
        -:29335:
        -:29336:    /* missing type support */
    #####:29337:    return(test_ret);
        -:29338:}
        -:29339:
        -:29340:
        -:29341:static int
    #####:29342:test_xmlAutomataNewCountedTrans(void) {
    #####:29343:    int test_ret = 0;
        -:29344:
        -:29345:
        -:29346:    /* missing type support */
    #####:29347:    return(test_ret);
        -:29348:}
        -:29349:
        -:29350:
        -:29351:static int
    #####:29352:test_xmlAutomataNewCounter(void) {
    #####:29353:    int test_ret = 0;
        -:29354:
        -:29355:#if defined(LIBXML_REGEXP_ENABLED) && defined(LIBXML_AUTOMATA_ENABLED)
        -:29356:    int mem_base;
        -:29357:    int ret_val;
        -:29358:    xmlAutomataPtr am; /* an automata */
        -:29359:    int n_am;
        -:29360:    int min; /* the minimal value on the counter */
        -:29361:    int n_min;
        -:29362:    int max; /* the maximal value on the counter */
        -:29363:    int n_max;
        -:29364:
    #####:29365:    for (n_am = 0;n_am < gen_nb_xmlAutomataPtr;n_am++) {
    #####:29366:    for (n_min = 0;n_min < gen_nb_int;n_min++) {
    #####:29367:    for (n_max = 0;n_max < gen_nb_int;n_max++) {
    #####:29368:        mem_base = xmlMemBlocks();
    #####:29369:        am = gen_xmlAutomataPtr(n_am, 0);
    #####:29370:        min = gen_int(n_min, 1);
    #####:29371:        max = gen_int(n_max, 2);
        -:29372:
    #####:29373:        ret_val = xmlAutomataNewCounter(am, min, max);
    #####:29374:        desret_int(ret_val);
    #####:29375:        call_tests++;
    #####:29376:        des_xmlAutomataPtr(n_am, am, 0);
    #####:29377:        des_int(n_min, min, 1);
    #####:29378:        des_int(n_max, max, 2);
    #####:29379:        xmlResetLastError();
    #####:29380:        if (mem_base != xmlMemBlocks()) {
    #####:29381:            printf("Leak of %d blocks found in xmlAutomataNewCounter",
    #####:29382:	           xmlMemBlocks() - mem_base);
    #####:29383:	    test_ret++;
    #####:29384:            printf(" %d", n_am);
    #####:29385:            printf(" %d", n_min);
    #####:29386:            printf(" %d", n_max);
    #####:29387:            printf("\n");
        -:29388:        }
        -:29389:    }
        -:29390:    }
        -:29391:    }
    #####:29392:    function_tests++;
        -:29393:#endif
        -:29394:
    #####:29395:    return(test_ret);
        -:29396:}
        -:29397:
        -:29398:
        -:29399:static int
    #####:29400:test_xmlAutomataNewCounterTrans(void) {
    #####:29401:    int test_ret = 0;
        -:29402:
        -:29403:
        -:29404:    /* missing type support */
    #####:29405:    return(test_ret);
        -:29406:}
        -:29407:
        -:29408:
        -:29409:static int
    #####:29410:test_xmlAutomataNewEpsilon(void) {
    #####:29411:    int test_ret = 0;
        -:29412:
        -:29413:
        -:29414:    /* missing type support */
    #####:29415:    return(test_ret);
        -:29416:}
        -:29417:
        -:29418:
        -:29419:static int
    #####:29420:test_xmlAutomataNewNegTrans(void) {
    #####:29421:    int test_ret = 0;
        -:29422:
        -:29423:
        -:29424:    /* missing type support */
    #####:29425:    return(test_ret);
        -:29426:}
        -:29427:
        -:29428:
        -:29429:static int
    #####:29430:test_xmlAutomataNewOnceTrans(void) {
    #####:29431:    int test_ret = 0;
        -:29432:
        -:29433:
        -:29434:    /* missing type support */
    #####:29435:    return(test_ret);
        -:29436:}
        -:29437:
        -:29438:
        -:29439:static int
    #####:29440:test_xmlAutomataNewOnceTrans2(void) {
    #####:29441:    int test_ret = 0;
        -:29442:
        -:29443:
        -:29444:    /* missing type support */
    #####:29445:    return(test_ret);
        -:29446:}
        -:29447:
        -:29448:
        -:29449:static int
    #####:29450:test_xmlAutomataNewState(void) {
    #####:29451:    int test_ret = 0;
        -:29452:
        -:29453:
        -:29454:    /* missing type support */
    #####:29455:    return(test_ret);
        -:29456:}
        -:29457:
        -:29458:
        -:29459:static int
    #####:29460:test_xmlAutomataNewTransition(void) {
    #####:29461:    int test_ret = 0;
        -:29462:
        -:29463:
        -:29464:    /* missing type support */
    #####:29465:    return(test_ret);
        -:29466:}
        -:29467:
        -:29468:
        -:29469:static int
    #####:29470:test_xmlAutomataNewTransition2(void) {
    #####:29471:    int test_ret = 0;
        -:29472:
        -:29473:
        -:29474:    /* missing type support */
    #####:29475:    return(test_ret);
        -:29476:}
        -:29477:
        -:29478:
        -:29479:static int
    #####:29480:test_xmlAutomataSetFinalState(void) {
    #####:29481:    int test_ret = 0;
        -:29482:
        -:29483:#if defined(LIBXML_REGEXP_ENABLED) && defined(LIBXML_AUTOMATA_ENABLED)
        -:29484:    int mem_base;
        -:29485:    int ret_val;
        -:29486:    xmlAutomataPtr am; /* an automata */
        -:29487:    int n_am;
        -:29488:    xmlAutomataStatePtr state; /* a state in this automata */
        -:29489:    int n_state;
        -:29490:
    #####:29491:    for (n_am = 0;n_am < gen_nb_xmlAutomataPtr;n_am++) {
    #####:29492:    for (n_state = 0;n_state < gen_nb_xmlAutomataStatePtr;n_state++) {
    #####:29493:        mem_base = xmlMemBlocks();
    #####:29494:        am = gen_xmlAutomataPtr(n_am, 0);
    #####:29495:        state = gen_xmlAutomataStatePtr(n_state, 1);
        -:29496:
    #####:29497:        ret_val = xmlAutomataSetFinalState(am, state);
    #####:29498:        desret_int(ret_val);
    #####:29499:        call_tests++;
    #####:29500:        des_xmlAutomataPtr(n_am, am, 0);
    #####:29501:        des_xmlAutomataStatePtr(n_state, state, 1);
    #####:29502:        xmlResetLastError();
    #####:29503:        if (mem_base != xmlMemBlocks()) {
    #####:29504:            printf("Leak of %d blocks found in xmlAutomataSetFinalState",
    #####:29505:	           xmlMemBlocks() - mem_base);
    #####:29506:	    test_ret++;
    #####:29507:            printf(" %d", n_am);
    #####:29508:            printf(" %d", n_state);
    #####:29509:            printf("\n");
        -:29510:        }
        -:29511:    }
        -:29512:    }
    #####:29513:    function_tests++;
        -:29514:#endif
        -:29515:
    #####:29516:    return(test_ret);
        -:29517:}
        -:29518:
        -:29519:
        -:29520:static int
    #####:29521:test_xmlNewAutomata(void) {
    #####:29522:    int test_ret = 0;
        -:29523:
        -:29524:
        -:29525:    /* missing type support */
    #####:29526:    return(test_ret);
        -:29527:}
        -:29528:
        -:29529:static int
    #####:29530:test_xmlautomata(void) {
    #####:29531:    int test_ret = 0;
        -:29532:
    #####:29533:    if (quiet == 0) printf("Testing xmlautomata : 3 of 19 functions ...\n");
    #####:29534:    test_ret += test_xmlAutomataCompile();
    #####:29535:    test_ret += test_xmlAutomataGetInitState();
    #####:29536:    test_ret += test_xmlAutomataIsDeterminist();
    #####:29537:    test_ret += test_xmlAutomataNewAllTrans();
    #####:29538:    test_ret += test_xmlAutomataNewCountTrans();
    #####:29539:    test_ret += test_xmlAutomataNewCountTrans2();
    #####:29540:    test_ret += test_xmlAutomataNewCountedTrans();
    #####:29541:    test_ret += test_xmlAutomataNewCounter();
    #####:29542:    test_ret += test_xmlAutomataNewCounterTrans();
    #####:29543:    test_ret += test_xmlAutomataNewEpsilon();
    #####:29544:    test_ret += test_xmlAutomataNewNegTrans();
    #####:29545:    test_ret += test_xmlAutomataNewOnceTrans();
    #####:29546:    test_ret += test_xmlAutomataNewOnceTrans2();
    #####:29547:    test_ret += test_xmlAutomataNewState();
    #####:29548:    test_ret += test_xmlAutomataNewTransition();
    #####:29549:    test_ret += test_xmlAutomataNewTransition2();
    #####:29550:    test_ret += test_xmlAutomataSetFinalState();
    #####:29551:    test_ret += test_xmlNewAutomata();
        -:29552:
    #####:29553:    if (test_ret != 0)
    #####:29554:	printf("Module xmlautomata: %d errors\n", test_ret);
    #####:29555:    return(test_ret);
        -:29556:}
        -:29557:
        -:29558:#define gen_nb_xmlGenericErrorFunc_ptr 1
    #####:29559:static xmlGenericErrorFunc * gen_xmlGenericErrorFunc_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:29560:    return(NULL);
        -:29561:}
    #####:29562:static void des_xmlGenericErrorFunc_ptr(int no ATTRIBUTE_UNUSED, xmlGenericErrorFunc * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:29563:}
        -:29564:
        -:29565:static int
    #####:29566:test_initGenericErrorDefaultFunc(void) {
    #####:29567:    int test_ret = 0;
        -:29568:
        -:29569:    int mem_base;
        -:29570:    xmlGenericErrorFunc * handler; /* the handler */
        -:29571:    int n_handler;
        -:29572:
    #####:29573:    for (n_handler = 0;n_handler < gen_nb_xmlGenericErrorFunc_ptr;n_handler++) {
    #####:29574:        mem_base = xmlMemBlocks();
    #####:29575:        handler = gen_xmlGenericErrorFunc_ptr(n_handler, 0);
        -:29576:
    #####:29577:        initGenericErrorDefaultFunc(handler);
    #####:29578:        call_tests++;
    #####:29579:        des_xmlGenericErrorFunc_ptr(n_handler, handler, 0);
    #####:29580:        xmlResetLastError();
    #####:29581:        if (mem_base != xmlMemBlocks()) {
    #####:29582:            printf("Leak of %d blocks found in initGenericErrorDefaultFunc",
    #####:29583:	           xmlMemBlocks() - mem_base);
    #####:29584:	    test_ret++;
    #####:29585:            printf(" %d", n_handler);
    #####:29586:            printf("\n");
        -:29587:        }
        -:29588:    }
    #####:29589:    function_tests++;
        -:29590:
    #####:29591:    return(test_ret);
        -:29592:}
        -:29593:
        -:29594:
        -:29595:#define gen_nb_xmlErrorPtr 1
    #####:29596:static xmlErrorPtr gen_xmlErrorPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:29597:    return(NULL);
        -:29598:}
    #####:29599:static void des_xmlErrorPtr(int no ATTRIBUTE_UNUSED, xmlErrorPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:29600:}
        -:29601:
        -:29602:static int
    #####:29603:test_xmlCopyError(void) {
    #####:29604:    int test_ret = 0;
        -:29605:
        -:29606:    int mem_base;
        -:29607:    int ret_val;
        -:29608:    xmlErrorPtr from; /* a source error */
        -:29609:    int n_from;
        -:29610:    xmlErrorPtr to; /* a target error */
        -:29611:    int n_to;
        -:29612:
    #####:29613:    for (n_from = 0;n_from < gen_nb_xmlErrorPtr;n_from++) {
    #####:29614:    for (n_to = 0;n_to < gen_nb_xmlErrorPtr;n_to++) {
    #####:29615:        mem_base = xmlMemBlocks();
    #####:29616:        from = gen_xmlErrorPtr(n_from, 0);
    #####:29617:        to = gen_xmlErrorPtr(n_to, 1);
        -:29618:
    #####:29619:        ret_val = xmlCopyError(from, to);
    #####:29620:        desret_int(ret_val);
    #####:29621:        call_tests++;
    #####:29622:        des_xmlErrorPtr(n_from, from, 0);
    #####:29623:        des_xmlErrorPtr(n_to, to, 1);
    #####:29624:        xmlResetLastError();
    #####:29625:        if (mem_base != xmlMemBlocks()) {
    #####:29626:            printf("Leak of %d blocks found in xmlCopyError",
    #####:29627:	           xmlMemBlocks() - mem_base);
    #####:29628:	    test_ret++;
    #####:29629:            printf(" %d", n_from);
    #####:29630:            printf(" %d", n_to);
    #####:29631:            printf("\n");
        -:29632:        }
        -:29633:    }
        -:29634:    }
    #####:29635:    function_tests++;
        -:29636:
    #####:29637:    return(test_ret);
        -:29638:}
        -:29639:
        -:29640:
        -:29641:static int
    #####:29642:test_xmlCtxtGetLastError(void) {
    #####:29643:    int test_ret = 0;
        -:29644:
        -:29645:
        -:29646:    /* missing type support */
    #####:29647:    return(test_ret);
        -:29648:}
        -:29649:
        -:29650:
        -:29651:static int
    #####:29652:test_xmlCtxtResetLastError(void) {
    #####:29653:    int test_ret = 0;
        -:29654:
        -:29655:    int mem_base;
        -:29656:    void * ctx; /* an XML parser context */
        -:29657:    int n_ctx;
        -:29658:
    #####:29659:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr;n_ctx++) {
    #####:29660:        mem_base = xmlMemBlocks();
    #####:29661:        ctx = gen_void_ptr(n_ctx, 0);
        -:29662:
    #####:29663:        xmlCtxtResetLastError(ctx);
    #####:29664:        call_tests++;
    #####:29665:        des_void_ptr(n_ctx, ctx, 0);
    #####:29666:        xmlResetLastError();
    #####:29667:        if (mem_base != xmlMemBlocks()) {
    #####:29668:            printf("Leak of %d blocks found in xmlCtxtResetLastError",
    #####:29669:	           xmlMemBlocks() - mem_base);
    #####:29670:	    test_ret++;
    #####:29671:            printf(" %d", n_ctx);
    #####:29672:            printf("\n");
        -:29673:        }
        -:29674:    }
    #####:29675:    function_tests++;
        -:29676:
    #####:29677:    return(test_ret);
        -:29678:}
        -:29679:
        -:29680:
        -:29681:static int
    #####:29682:test_xmlGetLastError(void) {
    #####:29683:    int test_ret = 0;
        -:29684:
        -:29685:
        -:29686:    /* missing type support */
    #####:29687:    return(test_ret);
        -:29688:}
        -:29689:
        -:29690:
        -:29691:static int
    #####:29692:test_xmlParserError(void) {
    #####:29693:    int test_ret = 0;
        -:29694:
        -:29695:
        -:29696:    /* missing type support */
    #####:29697:    return(test_ret);
        -:29698:}
        -:29699:
        -:29700:
        -:29701:static int
    #####:29702:test_xmlParserPrintFileContext(void) {
    #####:29703:    int test_ret = 0;
        -:29704:
        -:29705:    int mem_base;
        -:29706:    xmlParserInputPtr input; /* an xmlParserInputPtr input */
        -:29707:    int n_input;
        -:29708:
    #####:29709:    for (n_input = 0;n_input < gen_nb_xmlParserInputPtr;n_input++) {
    #####:29710:        mem_base = xmlMemBlocks();
    #####:29711:        input = gen_xmlParserInputPtr(n_input, 0);
        -:29712:
    #####:29713:        xmlParserPrintFileContext(input);
    #####:29714:        call_tests++;
    #####:29715:        des_xmlParserInputPtr(n_input, input, 0);
    #####:29716:        xmlResetLastError();
    #####:29717:        if (mem_base != xmlMemBlocks()) {
    #####:29718:            printf("Leak of %d blocks found in xmlParserPrintFileContext",
    #####:29719:	           xmlMemBlocks() - mem_base);
    #####:29720:	    test_ret++;
    #####:29721:            printf(" %d", n_input);
    #####:29722:            printf("\n");
        -:29723:        }
        -:29724:    }
    #####:29725:    function_tests++;
        -:29726:
    #####:29727:    return(test_ret);
        -:29728:}
        -:29729:
        -:29730:
        -:29731:static int
    #####:29732:test_xmlParserPrintFileInfo(void) {
    #####:29733:    int test_ret = 0;
        -:29734:
        -:29735:    int mem_base;
        -:29736:    xmlParserInputPtr input; /* an xmlParserInputPtr input */
        -:29737:    int n_input;
        -:29738:
    #####:29739:    for (n_input = 0;n_input < gen_nb_xmlParserInputPtr;n_input++) {
    #####:29740:        mem_base = xmlMemBlocks();
    #####:29741:        input = gen_xmlParserInputPtr(n_input, 0);
        -:29742:
    #####:29743:        xmlParserPrintFileInfo(input);
    #####:29744:        call_tests++;
    #####:29745:        des_xmlParserInputPtr(n_input, input, 0);
    #####:29746:        xmlResetLastError();
    #####:29747:        if (mem_base != xmlMemBlocks()) {
    #####:29748:            printf("Leak of %d blocks found in xmlParserPrintFileInfo",
    #####:29749:	           xmlMemBlocks() - mem_base);
    #####:29750:	    test_ret++;
    #####:29751:            printf(" %d", n_input);
    #####:29752:            printf("\n");
        -:29753:        }
        -:29754:    }
    #####:29755:    function_tests++;
        -:29756:
    #####:29757:    return(test_ret);
        -:29758:}
        -:29759:
        -:29760:
        -:29761:static int
    #####:29762:test_xmlParserValidityError(void) {
    #####:29763:    int test_ret = 0;
        -:29764:
        -:29765:
        -:29766:    /* missing type support */
    #####:29767:    return(test_ret);
        -:29768:}
        -:29769:
        -:29770:
        -:29771:static int
    #####:29772:test_xmlParserValidityWarning(void) {
    #####:29773:    int test_ret = 0;
        -:29774:
        -:29775:
        -:29776:    /* missing type support */
    #####:29777:    return(test_ret);
        -:29778:}
        -:29779:
        -:29780:
        -:29781:static int
    #####:29782:test_xmlParserWarning(void) {
    #####:29783:    int test_ret = 0;
        -:29784:
        -:29785:
        -:29786:    /* missing type support */
    #####:29787:    return(test_ret);
        -:29788:}
        -:29789:
        -:29790:
        -:29791:static int
    #####:29792:test_xmlResetError(void) {
    #####:29793:    int test_ret = 0;
        -:29794:
        -:29795:    int mem_base;
        -:29796:    xmlErrorPtr err; /* pointer to the error. */
        -:29797:    int n_err;
        -:29798:
    #####:29799:    for (n_err = 0;n_err < gen_nb_xmlErrorPtr;n_err++) {
    #####:29800:        mem_base = xmlMemBlocks();
    #####:29801:        err = gen_xmlErrorPtr(n_err, 0);
        -:29802:
    #####:29803:        xmlResetError(err);
    #####:29804:        call_tests++;
    #####:29805:        des_xmlErrorPtr(n_err, err, 0);
    #####:29806:        xmlResetLastError();
    #####:29807:        if (mem_base != xmlMemBlocks()) {
    #####:29808:            printf("Leak of %d blocks found in xmlResetError",
    #####:29809:	           xmlMemBlocks() - mem_base);
    #####:29810:	    test_ret++;
    #####:29811:            printf(" %d", n_err);
    #####:29812:            printf("\n");
        -:29813:        }
        -:29814:    }
    #####:29815:    function_tests++;
        -:29816:
    #####:29817:    return(test_ret);
        -:29818:}
        -:29819:
        -:29820:
        -:29821:static int
    #####:29822:test_xmlResetLastError(void) {
    #####:29823:    int test_ret = 0;
        -:29824:
        -:29825:
        -:29826:
    #####:29827:        xmlResetLastError();
    #####:29828:        call_tests++;
    #####:29829:        xmlResetLastError();
    #####:29830:    function_tests++;
        -:29831:
    #####:29832:    return(test_ret);
        -:29833:}
        -:29834:
        -:29835:
        -:29836:static int
    #####:29837:test_xmlSetGenericErrorFunc(void) {
    #####:29838:    int test_ret = 0;
        -:29839:
        -:29840:
        -:29841:    /* missing type support */
    #####:29842:    return(test_ret);
        -:29843:}
        -:29844:
        -:29845:
        -:29846:static int
    #####:29847:test_xmlSetStructuredErrorFunc(void) {
    #####:29848:    int test_ret = 0;
        -:29849:
        -:29850:
        -:29851:    /* missing type support */
    #####:29852:    return(test_ret);
        -:29853:}
        -:29854:
        -:29855:static int
    #####:29856:test_xmlerror(void) {
    #####:29857:    int test_ret = 0;
        -:29858:
    #####:29859:    if (quiet == 0) printf("Testing xmlerror : 7 of 15 functions ...\n");
    #####:29860:    test_ret += test_initGenericErrorDefaultFunc();
    #####:29861:    test_ret += test_xmlCopyError();
    #####:29862:    test_ret += test_xmlCtxtGetLastError();
    #####:29863:    test_ret += test_xmlCtxtResetLastError();
    #####:29864:    test_ret += test_xmlGetLastError();
    #####:29865:    test_ret += test_xmlParserError();
    #####:29866:    test_ret += test_xmlParserPrintFileContext();
    #####:29867:    test_ret += test_xmlParserPrintFileInfo();
    #####:29868:    test_ret += test_xmlParserValidityError();
    #####:29869:    test_ret += test_xmlParserValidityWarning();
    #####:29870:    test_ret += test_xmlParserWarning();
    #####:29871:    test_ret += test_xmlResetError();
    #####:29872:    test_ret += test_xmlResetLastError();
    #####:29873:    test_ret += test_xmlSetGenericErrorFunc();
    #####:29874:    test_ret += test_xmlSetStructuredErrorFunc();
        -:29875:
    #####:29876:    if (test_ret != 0)
    #####:29877:	printf("Module xmlerror: %d errors\n", test_ret);
    #####:29878:    return(test_ret);
        -:29879:}
        -:29880:#ifdef LIBXML_MODULES_ENABLED
        -:29881:
        -:29882:#define gen_nb_xmlModulePtr 1
    #####:29883:static xmlModulePtr gen_xmlModulePtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:29884:    return(NULL);
        -:29885:}
    #####:29886:static void des_xmlModulePtr(int no ATTRIBUTE_UNUSED, xmlModulePtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:29887:}
        -:29888:#endif
        -:29889:
        -:29890:
        -:29891:static int
    #####:29892:test_xmlModuleClose(void) {
    #####:29893:    int test_ret = 0;
        -:29894:
        -:29895:#if defined(LIBXML_MODULES_ENABLED)
        -:29896:    int mem_base;
        -:29897:    int ret_val;
        -:29898:    xmlModulePtr module; /* the module handle */
        -:29899:    int n_module;
        -:29900:
    #####:29901:    for (n_module = 0;n_module < gen_nb_xmlModulePtr;n_module++) {
    #####:29902:        mem_base = xmlMemBlocks();
    #####:29903:        module = gen_xmlModulePtr(n_module, 0);
        -:29904:
    #####:29905:        ret_val = xmlModuleClose(module);
    #####:29906:        desret_int(ret_val);
    #####:29907:        call_tests++;
    #####:29908:        des_xmlModulePtr(n_module, module, 0);
    #####:29909:        xmlResetLastError();
    #####:29910:        if (mem_base != xmlMemBlocks()) {
    #####:29911:            printf("Leak of %d blocks found in xmlModuleClose",
    #####:29912:	           xmlMemBlocks() - mem_base);
    #####:29913:	    test_ret++;
    #####:29914:            printf(" %d", n_module);
    #####:29915:            printf("\n");
        -:29916:        }
        -:29917:    }
    #####:29918:    function_tests++;
        -:29919:#endif
        -:29920:
    #####:29921:    return(test_ret);
        -:29922:}
        -:29923:
        -:29924:
        -:29925:static int
    #####:29926:test_xmlModuleOpen(void) {
    #####:29927:    int test_ret = 0;
        -:29928:
        -:29929:
        -:29930:    /* missing type support */
    #####:29931:    return(test_ret);
        -:29932:}
        -:29933:
        -:29934:
        -:29935:static int
    #####:29936:test_xmlModuleSymbol(void) {
    #####:29937:    int test_ret = 0;
        -:29938:
        -:29939:#if defined(LIBXML_MODULES_ENABLED)
        -:29940:    int mem_base;
        -:29941:    int ret_val;
        -:29942:    xmlModulePtr module; /* the module */
        -:29943:    int n_module;
        -:29944:    char * name; /* the name of the symbol */
        -:29945:    int n_name;
        -:29946:    void ** symbol; /* the resulting symbol address */
        -:29947:    int n_symbol;
        -:29948:
    #####:29949:    for (n_module = 0;n_module < gen_nb_xmlModulePtr;n_module++) {
    #####:29950:    for (n_name = 0;n_name < gen_nb_const_char_ptr;n_name++) {
    #####:29951:    for (n_symbol = 0;n_symbol < gen_nb_void_ptr_ptr;n_symbol++) {
    #####:29952:        mem_base = xmlMemBlocks();
    #####:29953:        module = gen_xmlModulePtr(n_module, 0);
    #####:29954:        name = gen_const_char_ptr(n_name, 1);
    #####:29955:        symbol = gen_void_ptr_ptr(n_symbol, 2);
        -:29956:
    #####:29957:        ret_val = xmlModuleSymbol(module, (const char *)name, symbol);
    #####:29958:        desret_int(ret_val);
    #####:29959:        call_tests++;
    #####:29960:        des_xmlModulePtr(n_module, module, 0);
    #####:29961:        des_const_char_ptr(n_name, (const char *)name, 1);
    #####:29962:        des_void_ptr_ptr(n_symbol, symbol, 2);
    #####:29963:        xmlResetLastError();
    #####:29964:        if (mem_base != xmlMemBlocks()) {
    #####:29965:            printf("Leak of %d blocks found in xmlModuleSymbol",
    #####:29966:	           xmlMemBlocks() - mem_base);
    #####:29967:	    test_ret++;
    #####:29968:            printf(" %d", n_module);
    #####:29969:            printf(" %d", n_name);
    #####:29970:            printf(" %d", n_symbol);
    #####:29971:            printf("\n");
        -:29972:        }
        -:29973:    }
        -:29974:    }
        -:29975:    }
    #####:29976:    function_tests++;
        -:29977:#endif
        -:29978:
    #####:29979:    return(test_ret);
        -:29980:}
        -:29981:
        -:29982:static int
    #####:29983:test_xmlmodule(void) {
    #####:29984:    int test_ret = 0;
        -:29985:
    #####:29986:    if (quiet == 0) printf("Testing xmlmodule : 2 of 4 functions ...\n");
    #####:29987:    test_ret += test_xmlModuleClose();
    #####:29988:    test_ret += test_xmlModuleOpen();
    #####:29989:    test_ret += test_xmlModuleSymbol();
        -:29990:
    #####:29991:    if (test_ret != 0)
    #####:29992:	printf("Module xmlmodule: %d errors\n", test_ret);
    #####:29993:    return(test_ret);
        -:29994:}
        -:29995:
        -:29996:static int
    #####:29997:test_xmlNewTextReader(void) {
    #####:29998:    int test_ret = 0;
        -:29999:
        -:30000:#if defined(LIBXML_READER_ENABLED)
        -:30001:    int mem_base;
        -:30002:    xmlTextReaderPtr ret_val;
        -:30003:    xmlParserInputBufferPtr input; /* the xmlParserInputBufferPtr used to read data */
        -:30004:    int n_input;
        -:30005:    const char * URI; /* the URI information for the source if available */
        -:30006:    int n_URI;
        -:30007:
    #####:30008:    for (n_input = 0;n_input < gen_nb_xmlParserInputBufferPtr;n_input++) {
    #####:30009:    for (n_URI = 0;n_URI < gen_nb_filepath;n_URI++) {
    #####:30010:        mem_base = xmlMemBlocks();
    #####:30011:        input = gen_xmlParserInputBufferPtr(n_input, 0);
    #####:30012:        URI = gen_filepath(n_URI, 1);
        -:30013:
    #####:30014:        ret_val = xmlNewTextReader(input, URI);
    #####:30015:        desret_xmlTextReaderPtr(ret_val);
    #####:30016:        call_tests++;
    #####:30017:        des_xmlParserInputBufferPtr(n_input, input, 0);
    #####:30018:        des_filepath(n_URI, URI, 1);
    #####:30019:        xmlResetLastError();
    #####:30020:        if (mem_base != xmlMemBlocks()) {
    #####:30021:            printf("Leak of %d blocks found in xmlNewTextReader",
    #####:30022:	           xmlMemBlocks() - mem_base);
    #####:30023:	    test_ret++;
    #####:30024:            printf(" %d", n_input);
    #####:30025:            printf(" %d", n_URI);
    #####:30026:            printf("\n");
        -:30027:        }
        -:30028:    }
        -:30029:    }
    #####:30030:    function_tests++;
        -:30031:#endif
        -:30032:
    #####:30033:    return(test_ret);
        -:30034:}
        -:30035:
        -:30036:
        -:30037:static int
    #####:30038:test_xmlNewTextReaderFilename(void) {
    #####:30039:    int test_ret = 0;
        -:30040:
        -:30041:#if defined(LIBXML_READER_ENABLED)
        -:30042:    int mem_base;
        -:30043:    xmlTextReaderPtr ret_val;
        -:30044:    const char * URI; /* the URI of the resource to process */
        -:30045:    int n_URI;
        -:30046:
    #####:30047:    for (n_URI = 0;n_URI < gen_nb_filepath;n_URI++) {
    #####:30048:        mem_base = xmlMemBlocks();
    #####:30049:        URI = gen_filepath(n_URI, 0);
        -:30050:
    #####:30051:        ret_val = xmlNewTextReaderFilename(URI);
    #####:30052:        desret_xmlTextReaderPtr(ret_val);
    #####:30053:        call_tests++;
    #####:30054:        des_filepath(n_URI, URI, 0);
    #####:30055:        xmlResetLastError();
    #####:30056:        if (mem_base != xmlMemBlocks()) {
    #####:30057:            printf("Leak of %d blocks found in xmlNewTextReaderFilename",
    #####:30058:	           xmlMemBlocks() - mem_base);
    #####:30059:	    test_ret++;
    #####:30060:            printf(" %d", n_URI);
    #####:30061:            printf("\n");
        -:30062:        }
        -:30063:    }
    #####:30064:    function_tests++;
        -:30065:#endif
        -:30066:
    #####:30067:    return(test_ret);
        -:30068:}
        -:30069:
        -:30070:
        -:30071:static int
    #####:30072:test_xmlReaderForDoc(void) {
    #####:30073:    int test_ret = 0;
        -:30074:
        -:30075:#if defined(LIBXML_READER_ENABLED)
        -:30076:    int mem_base;
        -:30077:    xmlTextReaderPtr ret_val;
        -:30078:    xmlChar * cur; /* a pointer to a zero terminated string */
        -:30079:    int n_cur;
        -:30080:    const char * URL; /* the base URL to use for the document */
        -:30081:    int n_URL;
        -:30082:    char * encoding; /* the document encoding, or NULL */
        -:30083:    int n_encoding;
        -:30084:    int options; /* a combination of xmlParserOption */
        -:30085:    int n_options;
        -:30086:
    #####:30087:    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    #####:30088:    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    #####:30089:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####:30090:    for (n_options = 0;n_options < gen_nb_parseroptions;n_options++) {
    #####:30091:        mem_base = xmlMemBlocks();
    #####:30092:        cur = gen_const_xmlChar_ptr(n_cur, 0);
    #####:30093:        URL = gen_filepath(n_URL, 1);
    #####:30094:        encoding = gen_const_char_ptr(n_encoding, 2);
    #####:30095:        options = gen_parseroptions(n_options, 3);
        -:30096:
    #####:30097:        ret_val = xmlReaderForDoc((const xmlChar *)cur, URL, (const char *)encoding, options);
    #####:30098:        desret_xmlTextReaderPtr(ret_val);
    #####:30099:        call_tests++;
    #####:30100:        des_const_xmlChar_ptr(n_cur, (const xmlChar *)cur, 0);
    #####:30101:        des_filepath(n_URL, URL, 1);
    #####:30102:        des_const_char_ptr(n_encoding, (const char *)encoding, 2);
    #####:30103:        des_parseroptions(n_options, options, 3);
    #####:30104:        xmlResetLastError();
    #####:30105:        if (mem_base != xmlMemBlocks()) {
    #####:30106:            printf("Leak of %d blocks found in xmlReaderForDoc",
    #####:30107:	           xmlMemBlocks() - mem_base);
    #####:30108:	    test_ret++;
    #####:30109:            printf(" %d", n_cur);
    #####:30110:            printf(" %d", n_URL);
    #####:30111:            printf(" %d", n_encoding);
    #####:30112:            printf(" %d", n_options);
    #####:30113:            printf("\n");
        -:30114:        }
        -:30115:    }
        -:30116:    }
        -:30117:    }
        -:30118:    }
    #####:30119:    function_tests++;
        -:30120:#endif
        -:30121:
    #####:30122:    return(test_ret);
        -:30123:}
        -:30124:
        -:30125:
        -:30126:static int
    #####:30127:test_xmlReaderForFile(void) {
    #####:30128:    int test_ret = 0;
        -:30129:
        -:30130:#if defined(LIBXML_READER_ENABLED)
        -:30131:    int mem_base;
        -:30132:    xmlTextReaderPtr ret_val;
        -:30133:    const char * filename; /* a file or URL */
        -:30134:    int n_filename;
        -:30135:    char * encoding; /* the document encoding, or NULL */
        -:30136:    int n_encoding;
        -:30137:    int options; /* a combination of xmlParserOption */
        -:30138:    int n_options;
        -:30139:
    #####:30140:    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    #####:30141:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####:30142:    for (n_options = 0;n_options < gen_nb_parseroptions;n_options++) {
    #####:30143:        mem_base = xmlMemBlocks();
    #####:30144:        filename = gen_filepath(n_filename, 0);
    #####:30145:        encoding = gen_const_char_ptr(n_encoding, 1);
    #####:30146:        options = gen_parseroptions(n_options, 2);
        -:30147:
    #####:30148:        ret_val = xmlReaderForFile(filename, (const char *)encoding, options);
    #####:30149:        desret_xmlTextReaderPtr(ret_val);
    #####:30150:        call_tests++;
    #####:30151:        des_filepath(n_filename, filename, 0);
    #####:30152:        des_const_char_ptr(n_encoding, (const char *)encoding, 1);
    #####:30153:        des_parseroptions(n_options, options, 2);
    #####:30154:        xmlResetLastError();
    #####:30155:        if (mem_base != xmlMemBlocks()) {
    #####:30156:            printf("Leak of %d blocks found in xmlReaderForFile",
    #####:30157:	           xmlMemBlocks() - mem_base);
    #####:30158:	    test_ret++;
    #####:30159:            printf(" %d", n_filename);
    #####:30160:            printf(" %d", n_encoding);
    #####:30161:            printf(" %d", n_options);
    #####:30162:            printf("\n");
        -:30163:        }
        -:30164:    }
        -:30165:    }
        -:30166:    }
    #####:30167:    function_tests++;
        -:30168:#endif
        -:30169:
    #####:30170:    return(test_ret);
        -:30171:}
        -:30172:
        -:30173:
        -:30174:static int
    #####:30175:test_xmlReaderForMemory(void) {
    #####:30176:    int test_ret = 0;
        -:30177:
        -:30178:#if defined(LIBXML_READER_ENABLED)
        -:30179:    int mem_base;
        -:30180:    xmlTextReaderPtr ret_val;
        -:30181:    char * buffer; /* a pointer to a char array */
        -:30182:    int n_buffer;
        -:30183:    int size; /* the size of the array */
        -:30184:    int n_size;
        -:30185:    const char * URL; /* the base URL to use for the document */
        -:30186:    int n_URL;
        -:30187:    char * encoding; /* the document encoding, or NULL */
        -:30188:    int n_encoding;
        -:30189:    int options; /* a combination of xmlParserOption */
        -:30190:    int n_options;
        -:30191:
    #####:30192:    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    #####:30193:    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    #####:30194:    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    #####:30195:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####:30196:    for (n_options = 0;n_options < gen_nb_parseroptions;n_options++) {
    #####:30197:        mem_base = xmlMemBlocks();
    #####:30198:        buffer = gen_const_char_ptr(n_buffer, 0);
    #####:30199:        size = gen_int(n_size, 1);
    #####:30200:        URL = gen_filepath(n_URL, 2);
    #####:30201:        encoding = gen_const_char_ptr(n_encoding, 3);
    #####:30202:        options = gen_parseroptions(n_options, 4);
        -:30203:
    #####:30204:        ret_val = xmlReaderForMemory((const char *)buffer, size, URL, (const char *)encoding, options);
    #####:30205:        desret_xmlTextReaderPtr(ret_val);
    #####:30206:        call_tests++;
    #####:30207:        des_const_char_ptr(n_buffer, (const char *)buffer, 0);
    #####:30208:        des_int(n_size, size, 1);
    #####:30209:        des_filepath(n_URL, URL, 2);
    #####:30210:        des_const_char_ptr(n_encoding, (const char *)encoding, 3);
    #####:30211:        des_parseroptions(n_options, options, 4);
    #####:30212:        xmlResetLastError();
    #####:30213:        if (mem_base != xmlMemBlocks()) {
    #####:30214:            printf("Leak of %d blocks found in xmlReaderForMemory",
    #####:30215:	           xmlMemBlocks() - mem_base);
    #####:30216:	    test_ret++;
    #####:30217:            printf(" %d", n_buffer);
    #####:30218:            printf(" %d", n_size);
    #####:30219:            printf(" %d", n_URL);
    #####:30220:            printf(" %d", n_encoding);
    #####:30221:            printf(" %d", n_options);
    #####:30222:            printf("\n");
        -:30223:        }
        -:30224:    }
        -:30225:    }
        -:30226:    }
        -:30227:    }
        -:30228:    }
    #####:30229:    function_tests++;
        -:30230:#endif
        -:30231:
    #####:30232:    return(test_ret);
        -:30233:}
        -:30234:
        -:30235:
        -:30236:static int
    #####:30237:test_xmlReaderNewDoc(void) {
    #####:30238:    int test_ret = 0;
        -:30239:
        -:30240:#if defined(LIBXML_READER_ENABLED)
        -:30241:    int mem_base;
        -:30242:    int ret_val;
        -:30243:    xmlTextReaderPtr reader; /* an XML reader */
        -:30244:    int n_reader;
        -:30245:    xmlChar * cur; /* a pointer to a zero terminated string */
        -:30246:    int n_cur;
        -:30247:    const char * URL; /* the base URL to use for the document */
        -:30248:    int n_URL;
        -:30249:    char * encoding; /* the document encoding, or NULL */
        -:30250:    int n_encoding;
        -:30251:    int options; /* a combination of xmlParserOption */
        -:30252:    int n_options;
        -:30253:
    #####:30254:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:30255:    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    #####:30256:    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    #####:30257:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####:30258:    for (n_options = 0;n_options < gen_nb_parseroptions;n_options++) {
    #####:30259:        mem_base = xmlMemBlocks();
    #####:30260:        reader = gen_xmlTextReaderPtr(n_reader, 0);
    #####:30261:        cur = gen_const_xmlChar_ptr(n_cur, 1);
    #####:30262:        URL = gen_filepath(n_URL, 2);
    #####:30263:        encoding = gen_const_char_ptr(n_encoding, 3);
    #####:30264:        options = gen_parseroptions(n_options, 4);
        -:30265:
    #####:30266:        ret_val = xmlReaderNewDoc(reader, (const xmlChar *)cur, URL, (const char *)encoding, options);
    #####:30267:        desret_int(ret_val);
    #####:30268:        call_tests++;
    #####:30269:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:30270:        des_const_xmlChar_ptr(n_cur, (const xmlChar *)cur, 1);
    #####:30271:        des_filepath(n_URL, URL, 2);
    #####:30272:        des_const_char_ptr(n_encoding, (const char *)encoding, 3);
    #####:30273:        des_parseroptions(n_options, options, 4);
    #####:30274:        xmlResetLastError();
    #####:30275:        if (mem_base != xmlMemBlocks()) {
    #####:30276:            printf("Leak of %d blocks found in xmlReaderNewDoc",
    #####:30277:	           xmlMemBlocks() - mem_base);
    #####:30278:	    test_ret++;
    #####:30279:            printf(" %d", n_reader);
    #####:30280:            printf(" %d", n_cur);
    #####:30281:            printf(" %d", n_URL);
    #####:30282:            printf(" %d", n_encoding);
    #####:30283:            printf(" %d", n_options);
    #####:30284:            printf("\n");
        -:30285:        }
        -:30286:    }
        -:30287:    }
        -:30288:    }
        -:30289:    }
        -:30290:    }
    #####:30291:    function_tests++;
        -:30292:#endif
        -:30293:
    #####:30294:    return(test_ret);
        -:30295:}
        -:30296:
        -:30297:
        -:30298:static int
    #####:30299:test_xmlReaderNewFile(void) {
    #####:30300:    int test_ret = 0;
        -:30301:
        -:30302:#if defined(LIBXML_READER_ENABLED)
        -:30303:    int mem_base;
        -:30304:    int ret_val;
        -:30305:    xmlTextReaderPtr reader; /* an XML reader */
        -:30306:    int n_reader;
        -:30307:    const char * filename; /* a file or URL */
        -:30308:    int n_filename;
        -:30309:    char * encoding; /* the document encoding, or NULL */
        -:30310:    int n_encoding;
        -:30311:    int options; /* a combination of xmlParserOption */
        -:30312:    int n_options;
        -:30313:
    #####:30314:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:30315:    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    #####:30316:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####:30317:    for (n_options = 0;n_options < gen_nb_parseroptions;n_options++) {
    #####:30318:        mem_base = xmlMemBlocks();
    #####:30319:        reader = gen_xmlTextReaderPtr(n_reader, 0);
    #####:30320:        filename = gen_filepath(n_filename, 1);
    #####:30321:        encoding = gen_const_char_ptr(n_encoding, 2);
    #####:30322:        options = gen_parseroptions(n_options, 3);
        -:30323:
    #####:30324:        ret_val = xmlReaderNewFile(reader, filename, (const char *)encoding, options);
    #####:30325:        desret_int(ret_val);
    #####:30326:        call_tests++;
    #####:30327:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:30328:        des_filepath(n_filename, filename, 1);
    #####:30329:        des_const_char_ptr(n_encoding, (const char *)encoding, 2);
    #####:30330:        des_parseroptions(n_options, options, 3);
    #####:30331:        xmlResetLastError();
    #####:30332:        if (mem_base != xmlMemBlocks()) {
    #####:30333:            printf("Leak of %d blocks found in xmlReaderNewFile",
    #####:30334:	           xmlMemBlocks() - mem_base);
    #####:30335:	    test_ret++;
    #####:30336:            printf(" %d", n_reader);
    #####:30337:            printf(" %d", n_filename);
    #####:30338:            printf(" %d", n_encoding);
    #####:30339:            printf(" %d", n_options);
    #####:30340:            printf("\n");
        -:30341:        }
        -:30342:    }
        -:30343:    }
        -:30344:    }
        -:30345:    }
    #####:30346:    function_tests++;
        -:30347:#endif
        -:30348:
    #####:30349:    return(test_ret);
        -:30350:}
        -:30351:
        -:30352:
        -:30353:static int
    #####:30354:test_xmlReaderNewMemory(void) {
    #####:30355:    int test_ret = 0;
        -:30356:
        -:30357:#if defined(LIBXML_READER_ENABLED)
        -:30358:    int mem_base;
        -:30359:    int ret_val;
        -:30360:    xmlTextReaderPtr reader; /* an XML reader */
        -:30361:    int n_reader;
        -:30362:    char * buffer; /* a pointer to a char array */
        -:30363:    int n_buffer;
        -:30364:    int size; /* the size of the array */
        -:30365:    int n_size;
        -:30366:    const char * URL; /* the base URL to use for the document */
        -:30367:    int n_URL;
        -:30368:    char * encoding; /* the document encoding, or NULL */
        -:30369:    int n_encoding;
        -:30370:    int options; /* a combination of xmlParserOption */
        -:30371:    int n_options;
        -:30372:
    #####:30373:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:30374:    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    #####:30375:    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    #####:30376:    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    #####:30377:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####:30378:    for (n_options = 0;n_options < gen_nb_parseroptions;n_options++) {
    #####:30379:        mem_base = xmlMemBlocks();
    #####:30380:        reader = gen_xmlTextReaderPtr(n_reader, 0);
    #####:30381:        buffer = gen_const_char_ptr(n_buffer, 1);
    #####:30382:        size = gen_int(n_size, 2);
    #####:30383:        URL = gen_filepath(n_URL, 3);
    #####:30384:        encoding = gen_const_char_ptr(n_encoding, 4);
    #####:30385:        options = gen_parseroptions(n_options, 5);
        -:30386:
    #####:30387:        ret_val = xmlReaderNewMemory(reader, (const char *)buffer, size, URL, (const char *)encoding, options);
    #####:30388:        desret_int(ret_val);
    #####:30389:        call_tests++;
    #####:30390:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:30391:        des_const_char_ptr(n_buffer, (const char *)buffer, 1);
    #####:30392:        des_int(n_size, size, 2);
    #####:30393:        des_filepath(n_URL, URL, 3);
    #####:30394:        des_const_char_ptr(n_encoding, (const char *)encoding, 4);
    #####:30395:        des_parseroptions(n_options, options, 5);
    #####:30396:        xmlResetLastError();
    #####:30397:        if (mem_base != xmlMemBlocks()) {
    #####:30398:            printf("Leak of %d blocks found in xmlReaderNewMemory",
    #####:30399:	           xmlMemBlocks() - mem_base);
    #####:30400:	    test_ret++;
    #####:30401:            printf(" %d", n_reader);
    #####:30402:            printf(" %d", n_buffer);
    #####:30403:            printf(" %d", n_size);
    #####:30404:            printf(" %d", n_URL);
    #####:30405:            printf(" %d", n_encoding);
    #####:30406:            printf(" %d", n_options);
    #####:30407:            printf("\n");
        -:30408:        }
        -:30409:    }
        -:30410:    }
        -:30411:    }
        -:30412:    }
        -:30413:    }
        -:30414:    }
    #####:30415:    function_tests++;
        -:30416:#endif
        -:30417:
    #####:30418:    return(test_ret);
        -:30419:}
        -:30420:
        -:30421:
        -:30422:static int
    #####:30423:test_xmlReaderNewWalker(void) {
    #####:30424:    int test_ret = 0;
        -:30425:
        -:30426:#if defined(LIBXML_READER_ENABLED)
        -:30427:    int mem_base;
        -:30428:    int ret_val;
        -:30429:    xmlTextReaderPtr reader; /* an XML reader */
        -:30430:    int n_reader;
        -:30431:    xmlDocPtr doc; /* a preparsed document */
        -:30432:    int n_doc;
        -:30433:
    #####:30434:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:30435:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:30436:        mem_base = xmlMemBlocks();
    #####:30437:        reader = gen_xmlTextReaderPtr(n_reader, 0);
    #####:30438:        doc = gen_xmlDocPtr(n_doc, 1);
        -:30439:
    #####:30440:        ret_val = xmlReaderNewWalker(reader, doc);
    #####:30441:        desret_int(ret_val);
    #####:30442:        call_tests++;
    #####:30443:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:30444:        des_xmlDocPtr(n_doc, doc, 1);
    #####:30445:        xmlResetLastError();
    #####:30446:        if (mem_base != xmlMemBlocks()) {
    #####:30447:            printf("Leak of %d blocks found in xmlReaderNewWalker",
    #####:30448:	           xmlMemBlocks() - mem_base);
    #####:30449:	    test_ret++;
    #####:30450:            printf(" %d", n_reader);
    #####:30451:            printf(" %d", n_doc);
    #####:30452:            printf("\n");
        -:30453:        }
        -:30454:    }
        -:30455:    }
    #####:30456:    function_tests++;
        -:30457:#endif
        -:30458:
    #####:30459:    return(test_ret);
        -:30460:}
        -:30461:
        -:30462:
        -:30463:static int
    #####:30464:test_xmlReaderWalker(void) {
    #####:30465:    int test_ret = 0;
        -:30466:
        -:30467:#if defined(LIBXML_READER_ENABLED)
        -:30468:    int mem_base;
        -:30469:    xmlTextReaderPtr ret_val;
        -:30470:    xmlDocPtr doc; /* a preparsed document */
        -:30471:    int n_doc;
        -:30472:
    #####:30473:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:30474:        mem_base = xmlMemBlocks();
    #####:30475:        doc = gen_xmlDocPtr(n_doc, 0);
        -:30476:
    #####:30477:        ret_val = xmlReaderWalker(doc);
    #####:30478:        desret_xmlTextReaderPtr(ret_val);
    #####:30479:        call_tests++;
    #####:30480:        des_xmlDocPtr(n_doc, doc, 0);
    #####:30481:        xmlResetLastError();
    #####:30482:        if (mem_base != xmlMemBlocks()) {
    #####:30483:            printf("Leak of %d blocks found in xmlReaderWalker",
    #####:30484:	           xmlMemBlocks() - mem_base);
    #####:30485:	    test_ret++;
    #####:30486:            printf(" %d", n_doc);
    #####:30487:            printf("\n");
        -:30488:        }
        -:30489:    }
    #####:30490:    function_tests++;
        -:30491:#endif
        -:30492:
    #####:30493:    return(test_ret);
        -:30494:}
        -:30495:
        -:30496:
        -:30497:static int
    #####:30498:test_xmlTextReaderAttributeCount(void) {
    #####:30499:    int test_ret = 0;
        -:30500:
        -:30501:#if defined(LIBXML_READER_ENABLED)
        -:30502:    int mem_base;
        -:30503:    int ret_val;
        -:30504:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:30505:    int n_reader;
        -:30506:
    #####:30507:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:30508:        mem_base = xmlMemBlocks();
    #####:30509:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:30510:
    #####:30511:        ret_val = xmlTextReaderAttributeCount(reader);
    #####:30512:        desret_int(ret_val);
    #####:30513:        call_tests++;
    #####:30514:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:30515:        xmlResetLastError();
    #####:30516:        if (mem_base != xmlMemBlocks()) {
    #####:30517:            printf("Leak of %d blocks found in xmlTextReaderAttributeCount",
    #####:30518:	           xmlMemBlocks() - mem_base);
    #####:30519:	    test_ret++;
    #####:30520:            printf(" %d", n_reader);
    #####:30521:            printf("\n");
        -:30522:        }
        -:30523:    }
    #####:30524:    function_tests++;
        -:30525:#endif
        -:30526:
    #####:30527:    return(test_ret);
        -:30528:}
        -:30529:
        -:30530:
        -:30531:static int
    #####:30532:test_xmlTextReaderBaseUri(void) {
    #####:30533:    int test_ret = 0;
        -:30534:
        -:30535:#if defined(LIBXML_READER_ENABLED)
        -:30536:    int mem_base;
        -:30537:    xmlChar * ret_val;
        -:30538:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:30539:    int n_reader;
        -:30540:
    #####:30541:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:30542:        mem_base = xmlMemBlocks();
    #####:30543:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:30544:
    #####:30545:        ret_val = xmlTextReaderBaseUri(reader);
    #####:30546:        desret_xmlChar_ptr(ret_val);
    #####:30547:        call_tests++;
    #####:30548:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:30549:        xmlResetLastError();
    #####:30550:        if (mem_base != xmlMemBlocks()) {
    #####:30551:            printf("Leak of %d blocks found in xmlTextReaderBaseUri",
    #####:30552:	           xmlMemBlocks() - mem_base);
    #####:30553:	    test_ret++;
    #####:30554:            printf(" %d", n_reader);
    #####:30555:            printf("\n");
        -:30556:        }
        -:30557:    }
    #####:30558:    function_tests++;
        -:30559:#endif
        -:30560:
    #####:30561:    return(test_ret);
        -:30562:}
        -:30563:
        -:30564:
        -:30565:static int
    #####:30566:test_xmlTextReaderByteConsumed(void) {
    #####:30567:    int test_ret = 0;
        -:30568:
        -:30569:#if defined(LIBXML_READER_ENABLED)
        -:30570:    int mem_base;
        -:30571:    long ret_val;
        -:30572:    xmlTextReaderPtr reader; /* an XML reader */
        -:30573:    int n_reader;
        -:30574:
    #####:30575:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:30576:        mem_base = xmlMemBlocks();
    #####:30577:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:30578:
    #####:30579:        ret_val = xmlTextReaderByteConsumed(reader);
    #####:30580:        desret_long(ret_val);
    #####:30581:        call_tests++;
    #####:30582:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:30583:        xmlResetLastError();
    #####:30584:        if (mem_base != xmlMemBlocks()) {
    #####:30585:            printf("Leak of %d blocks found in xmlTextReaderByteConsumed",
    #####:30586:	           xmlMemBlocks() - mem_base);
    #####:30587:	    test_ret++;
    #####:30588:            printf(" %d", n_reader);
    #####:30589:            printf("\n");
        -:30590:        }
        -:30591:    }
    #####:30592:    function_tests++;
        -:30593:#endif
        -:30594:
    #####:30595:    return(test_ret);
        -:30596:}
        -:30597:
        -:30598:
        -:30599:static int
    #####:30600:test_xmlTextReaderClose(void) {
    #####:30601:    int test_ret = 0;
        -:30602:
        -:30603:#if defined(LIBXML_READER_ENABLED)
        -:30604:    int mem_base;
        -:30605:    int ret_val;
        -:30606:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:30607:    int n_reader;
        -:30608:
    #####:30609:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:30610:        mem_base = xmlMemBlocks();
    #####:30611:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:30612:
    #####:30613:        ret_val = xmlTextReaderClose(reader);
    #####:30614:        desret_int(ret_val);
    #####:30615:        call_tests++;
    #####:30616:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:30617:        xmlResetLastError();
    #####:30618:        if (mem_base != xmlMemBlocks()) {
    #####:30619:            printf("Leak of %d blocks found in xmlTextReaderClose",
    #####:30620:	           xmlMemBlocks() - mem_base);
    #####:30621:	    test_ret++;
    #####:30622:            printf(" %d", n_reader);
    #####:30623:            printf("\n");
        -:30624:        }
        -:30625:    }
    #####:30626:    function_tests++;
        -:30627:#endif
        -:30628:
    #####:30629:    return(test_ret);
        -:30630:}
        -:30631:
        -:30632:
        -:30633:static int
    #####:30634:test_xmlTextReaderConstBaseUri(void) {
    #####:30635:    int test_ret = 0;
        -:30636:
        -:30637:#if defined(LIBXML_READER_ENABLED)
        -:30638:    int mem_base;
        -:30639:    const xmlChar * ret_val;
        -:30640:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:30641:    int n_reader;
        -:30642:
    #####:30643:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:30644:        mem_base = xmlMemBlocks();
    #####:30645:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:30646:
    #####:30647:        ret_val = xmlTextReaderConstBaseUri(reader);
    #####:30648:        desret_const_xmlChar_ptr(ret_val);
    #####:30649:        call_tests++;
    #####:30650:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:30651:        xmlResetLastError();
    #####:30652:        if (mem_base != xmlMemBlocks()) {
    #####:30653:            printf("Leak of %d blocks found in xmlTextReaderConstBaseUri",
    #####:30654:	           xmlMemBlocks() - mem_base);
    #####:30655:	    test_ret++;
    #####:30656:            printf(" %d", n_reader);
    #####:30657:            printf("\n");
        -:30658:        }
        -:30659:    }
    #####:30660:    function_tests++;
        -:30661:#endif
        -:30662:
    #####:30663:    return(test_ret);
        -:30664:}
        -:30665:
        -:30666:
        -:30667:static int
    #####:30668:test_xmlTextReaderConstEncoding(void) {
    #####:30669:    int test_ret = 0;
        -:30670:
        -:30671:#if defined(LIBXML_READER_ENABLED)
        -:30672:    int mem_base;
        -:30673:    const xmlChar * ret_val;
        -:30674:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:30675:    int n_reader;
        -:30676:
    #####:30677:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:30678:        mem_base = xmlMemBlocks();
    #####:30679:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:30680:
    #####:30681:        ret_val = xmlTextReaderConstEncoding(reader);
    #####:30682:        desret_const_xmlChar_ptr(ret_val);
    #####:30683:        call_tests++;
    #####:30684:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:30685:        xmlResetLastError();
    #####:30686:        if (mem_base != xmlMemBlocks()) {
    #####:30687:            printf("Leak of %d blocks found in xmlTextReaderConstEncoding",
    #####:30688:	           xmlMemBlocks() - mem_base);
    #####:30689:	    test_ret++;
    #####:30690:            printf(" %d", n_reader);
    #####:30691:            printf("\n");
        -:30692:        }
        -:30693:    }
    #####:30694:    function_tests++;
        -:30695:#endif
        -:30696:
    #####:30697:    return(test_ret);
        -:30698:}
        -:30699:
        -:30700:
        -:30701:static int
    #####:30702:test_xmlTextReaderConstLocalName(void) {
    #####:30703:    int test_ret = 0;
        -:30704:
        -:30705:#if defined(LIBXML_READER_ENABLED)
        -:30706:    int mem_base;
        -:30707:    const xmlChar * ret_val;
        -:30708:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:30709:    int n_reader;
        -:30710:
    #####:30711:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:30712:        mem_base = xmlMemBlocks();
    #####:30713:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:30714:
    #####:30715:        ret_val = xmlTextReaderConstLocalName(reader);
    #####:30716:        desret_const_xmlChar_ptr(ret_val);
    #####:30717:        call_tests++;
    #####:30718:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:30719:        xmlResetLastError();
    #####:30720:        if (mem_base != xmlMemBlocks()) {
    #####:30721:            printf("Leak of %d blocks found in xmlTextReaderConstLocalName",
    #####:30722:	           xmlMemBlocks() - mem_base);
    #####:30723:	    test_ret++;
    #####:30724:            printf(" %d", n_reader);
    #####:30725:            printf("\n");
        -:30726:        }
        -:30727:    }
    #####:30728:    function_tests++;
        -:30729:#endif
        -:30730:
    #####:30731:    return(test_ret);
        -:30732:}
        -:30733:
        -:30734:
        -:30735:static int
    #####:30736:test_xmlTextReaderConstName(void) {
    #####:30737:    int test_ret = 0;
        -:30738:
        -:30739:#if defined(LIBXML_READER_ENABLED)
        -:30740:    int mem_base;
        -:30741:    const xmlChar * ret_val;
        -:30742:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:30743:    int n_reader;
        -:30744:
    #####:30745:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:30746:        mem_base = xmlMemBlocks();
    #####:30747:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:30748:
    #####:30749:        ret_val = xmlTextReaderConstName(reader);
    #####:30750:        desret_const_xmlChar_ptr(ret_val);
    #####:30751:        call_tests++;
    #####:30752:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:30753:        xmlResetLastError();
    #####:30754:        if (mem_base != xmlMemBlocks()) {
    #####:30755:            printf("Leak of %d blocks found in xmlTextReaderConstName",
    #####:30756:	           xmlMemBlocks() - mem_base);
    #####:30757:	    test_ret++;
    #####:30758:            printf(" %d", n_reader);
    #####:30759:            printf("\n");
        -:30760:        }
        -:30761:    }
    #####:30762:    function_tests++;
        -:30763:#endif
        -:30764:
    #####:30765:    return(test_ret);
        -:30766:}
        -:30767:
        -:30768:
        -:30769:static int
    #####:30770:test_xmlTextReaderConstNamespaceUri(void) {
    #####:30771:    int test_ret = 0;
        -:30772:
        -:30773:#if defined(LIBXML_READER_ENABLED)
        -:30774:    int mem_base;
        -:30775:    const xmlChar * ret_val;
        -:30776:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:30777:    int n_reader;
        -:30778:
    #####:30779:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:30780:        mem_base = xmlMemBlocks();
    #####:30781:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:30782:
    #####:30783:        ret_val = xmlTextReaderConstNamespaceUri(reader);
    #####:30784:        desret_const_xmlChar_ptr(ret_val);
    #####:30785:        call_tests++;
    #####:30786:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:30787:        xmlResetLastError();
    #####:30788:        if (mem_base != xmlMemBlocks()) {
    #####:30789:            printf("Leak of %d blocks found in xmlTextReaderConstNamespaceUri",
    #####:30790:	           xmlMemBlocks() - mem_base);
    #####:30791:	    test_ret++;
    #####:30792:            printf(" %d", n_reader);
    #####:30793:            printf("\n");
        -:30794:        }
        -:30795:    }
    #####:30796:    function_tests++;
        -:30797:#endif
        -:30798:
    #####:30799:    return(test_ret);
        -:30800:}
        -:30801:
        -:30802:
        -:30803:static int
    #####:30804:test_xmlTextReaderConstPrefix(void) {
    #####:30805:    int test_ret = 0;
        -:30806:
        -:30807:#if defined(LIBXML_READER_ENABLED)
        -:30808:    int mem_base;
        -:30809:    const xmlChar * ret_val;
        -:30810:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:30811:    int n_reader;
        -:30812:
    #####:30813:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:30814:        mem_base = xmlMemBlocks();
    #####:30815:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:30816:
    #####:30817:        ret_val = xmlTextReaderConstPrefix(reader);
    #####:30818:        desret_const_xmlChar_ptr(ret_val);
    #####:30819:        call_tests++;
    #####:30820:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:30821:        xmlResetLastError();
    #####:30822:        if (mem_base != xmlMemBlocks()) {
    #####:30823:            printf("Leak of %d blocks found in xmlTextReaderConstPrefix",
    #####:30824:	           xmlMemBlocks() - mem_base);
    #####:30825:	    test_ret++;
    #####:30826:            printf(" %d", n_reader);
    #####:30827:            printf("\n");
        -:30828:        }
        -:30829:    }
    #####:30830:    function_tests++;
        -:30831:#endif
        -:30832:
    #####:30833:    return(test_ret);
        -:30834:}
        -:30835:
        -:30836:
        -:30837:static int
    #####:30838:test_xmlTextReaderConstString(void) {
    #####:30839:    int test_ret = 0;
        -:30840:
        -:30841:#if defined(LIBXML_READER_ENABLED)
        -:30842:    int mem_base;
        -:30843:    const xmlChar * ret_val;
        -:30844:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:30845:    int n_reader;
        -:30846:    xmlChar * str; /* the string to intern. */
        -:30847:    int n_str;
        -:30848:
    #####:30849:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:30850:    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    #####:30851:        mem_base = xmlMemBlocks();
    #####:30852:        reader = gen_xmlTextReaderPtr(n_reader, 0);
    #####:30853:        str = gen_const_xmlChar_ptr(n_str, 1);
        -:30854:
    #####:30855:        ret_val = xmlTextReaderConstString(reader, (const xmlChar *)str);
    #####:30856:        desret_const_xmlChar_ptr(ret_val);
    #####:30857:        call_tests++;
    #####:30858:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:30859:        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 1);
    #####:30860:        xmlResetLastError();
    #####:30861:        if (mem_base != xmlMemBlocks()) {
    #####:30862:            printf("Leak of %d blocks found in xmlTextReaderConstString",
    #####:30863:	           xmlMemBlocks() - mem_base);
    #####:30864:	    test_ret++;
    #####:30865:            printf(" %d", n_reader);
    #####:30866:            printf(" %d", n_str);
    #####:30867:            printf("\n");
        -:30868:        }
        -:30869:    }
        -:30870:    }
    #####:30871:    function_tests++;
        -:30872:#endif
        -:30873:
    #####:30874:    return(test_ret);
        -:30875:}
        -:30876:
        -:30877:
        -:30878:static int
    #####:30879:test_xmlTextReaderConstValue(void) {
    #####:30880:    int test_ret = 0;
        -:30881:
        -:30882:#if defined(LIBXML_READER_ENABLED)
        -:30883:    int mem_base;
        -:30884:    const xmlChar * ret_val;
        -:30885:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:30886:    int n_reader;
        -:30887:
    #####:30888:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:30889:        mem_base = xmlMemBlocks();
    #####:30890:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:30891:
    #####:30892:        ret_val = xmlTextReaderConstValue(reader);
    #####:30893:        desret_const_xmlChar_ptr(ret_val);
    #####:30894:        call_tests++;
    #####:30895:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:30896:        xmlResetLastError();
    #####:30897:        if (mem_base != xmlMemBlocks()) {
    #####:30898:            printf("Leak of %d blocks found in xmlTextReaderConstValue",
    #####:30899:	           xmlMemBlocks() - mem_base);
    #####:30900:	    test_ret++;
    #####:30901:            printf(" %d", n_reader);
    #####:30902:            printf("\n");
        -:30903:        }
        -:30904:    }
    #####:30905:    function_tests++;
        -:30906:#endif
        -:30907:
    #####:30908:    return(test_ret);
        -:30909:}
        -:30910:
        -:30911:
        -:30912:static int
    #####:30913:test_xmlTextReaderConstXmlLang(void) {
    #####:30914:    int test_ret = 0;
        -:30915:
        -:30916:#if defined(LIBXML_READER_ENABLED)
        -:30917:    int mem_base;
        -:30918:    const xmlChar * ret_val;
        -:30919:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:30920:    int n_reader;
        -:30921:
    #####:30922:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:30923:        mem_base = xmlMemBlocks();
    #####:30924:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:30925:
    #####:30926:        ret_val = xmlTextReaderConstXmlLang(reader);
    #####:30927:        desret_const_xmlChar_ptr(ret_val);
    #####:30928:        call_tests++;
    #####:30929:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:30930:        xmlResetLastError();
    #####:30931:        if (mem_base != xmlMemBlocks()) {
    #####:30932:            printf("Leak of %d blocks found in xmlTextReaderConstXmlLang",
    #####:30933:	           xmlMemBlocks() - mem_base);
    #####:30934:	    test_ret++;
    #####:30935:            printf(" %d", n_reader);
    #####:30936:            printf("\n");
        -:30937:        }
        -:30938:    }
    #####:30939:    function_tests++;
        -:30940:#endif
        -:30941:
    #####:30942:    return(test_ret);
        -:30943:}
        -:30944:
        -:30945:
        -:30946:static int
    #####:30947:test_xmlTextReaderConstXmlVersion(void) {
    #####:30948:    int test_ret = 0;
        -:30949:
        -:30950:#if defined(LIBXML_READER_ENABLED)
        -:30951:    int mem_base;
        -:30952:    const xmlChar * ret_val;
        -:30953:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:30954:    int n_reader;
        -:30955:
    #####:30956:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:30957:        mem_base = xmlMemBlocks();
    #####:30958:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:30959:
    #####:30960:        ret_val = xmlTextReaderConstXmlVersion(reader);
    #####:30961:        desret_const_xmlChar_ptr(ret_val);
    #####:30962:        call_tests++;
    #####:30963:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:30964:        xmlResetLastError();
    #####:30965:        if (mem_base != xmlMemBlocks()) {
    #####:30966:            printf("Leak of %d blocks found in xmlTextReaderConstXmlVersion",
    #####:30967:	           xmlMemBlocks() - mem_base);
    #####:30968:	    test_ret++;
    #####:30969:            printf(" %d", n_reader);
    #####:30970:            printf("\n");
        -:30971:        }
        -:30972:    }
    #####:30973:    function_tests++;
        -:30974:#endif
        -:30975:
    #####:30976:    return(test_ret);
        -:30977:}
        -:30978:
        -:30979:
        -:30980:static int
    #####:30981:test_xmlTextReaderCurrentDoc(void) {
    #####:30982:    int test_ret = 0;
        -:30983:
        -:30984:#if defined(LIBXML_READER_ENABLED)
        -:30985:    int mem_base;
        -:30986:    xmlDocPtr ret_val;
        -:30987:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:30988:    int n_reader;
        -:30989:
    #####:30990:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:30991:        mem_base = xmlMemBlocks();
    #####:30992:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:30993:
    #####:30994:        ret_val = xmlTextReaderCurrentDoc(reader);
    #####:30995:        desret_xmlDocPtr(ret_val);
    #####:30996:        call_tests++;
    #####:30997:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:30998:        xmlResetLastError();
    #####:30999:        if (mem_base != xmlMemBlocks()) {
    #####:31000:            printf("Leak of %d blocks found in xmlTextReaderCurrentDoc",
    #####:31001:	           xmlMemBlocks() - mem_base);
    #####:31002:	    test_ret++;
    #####:31003:            printf(" %d", n_reader);
    #####:31004:            printf("\n");
        -:31005:        }
        -:31006:    }
    #####:31007:    function_tests++;
        -:31008:#endif
        -:31009:
    #####:31010:    return(test_ret);
        -:31011:}
        -:31012:
        -:31013:
        -:31014:static int
    #####:31015:test_xmlTextReaderCurrentNode(void) {
    #####:31016:    int test_ret = 0;
        -:31017:
        -:31018:#if defined(LIBXML_READER_ENABLED)
        -:31019:    int mem_base;
        -:31020:    xmlNodePtr ret_val;
        -:31021:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:31022:    int n_reader;
        -:31023:
    #####:31024:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:31025:        mem_base = xmlMemBlocks();
    #####:31026:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:31027:
    #####:31028:        ret_val = xmlTextReaderCurrentNode(reader);
    #####:31029:        desret_xmlNodePtr(ret_val);
    #####:31030:        call_tests++;
    #####:31031:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:31032:        xmlResetLastError();
    #####:31033:        if (mem_base != xmlMemBlocks()) {
    #####:31034:            printf("Leak of %d blocks found in xmlTextReaderCurrentNode",
    #####:31035:	           xmlMemBlocks() - mem_base);
    #####:31036:	    test_ret++;
    #####:31037:            printf(" %d", n_reader);
    #####:31038:            printf("\n");
        -:31039:        }
        -:31040:    }
    #####:31041:    function_tests++;
        -:31042:#endif
        -:31043:
    #####:31044:    return(test_ret);
        -:31045:}
        -:31046:
        -:31047:
        -:31048:static int
    #####:31049:test_xmlTextReaderDepth(void) {
    #####:31050:    int test_ret = 0;
        -:31051:
        -:31052:#if defined(LIBXML_READER_ENABLED)
        -:31053:    int mem_base;
        -:31054:    int ret_val;
        -:31055:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:31056:    int n_reader;
        -:31057:
    #####:31058:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:31059:        mem_base = xmlMemBlocks();
    #####:31060:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:31061:
    #####:31062:        ret_val = xmlTextReaderDepth(reader);
    #####:31063:        desret_int(ret_val);
    #####:31064:        call_tests++;
    #####:31065:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:31066:        xmlResetLastError();
    #####:31067:        if (mem_base != xmlMemBlocks()) {
    #####:31068:            printf("Leak of %d blocks found in xmlTextReaderDepth",
    #####:31069:	           xmlMemBlocks() - mem_base);
    #####:31070:	    test_ret++;
    #####:31071:            printf(" %d", n_reader);
    #####:31072:            printf("\n");
        -:31073:        }
        -:31074:    }
    #####:31075:    function_tests++;
        -:31076:#endif
        -:31077:
    #####:31078:    return(test_ret);
        -:31079:}
        -:31080:
        -:31081:
        -:31082:static int
    #####:31083:test_xmlTextReaderExpand(void) {
    #####:31084:    int test_ret = 0;
        -:31085:
        -:31086:#if defined(LIBXML_READER_ENABLED)
        -:31087:    int mem_base;
        -:31088:    xmlNodePtr ret_val;
        -:31089:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:31090:    int n_reader;
        -:31091:
    #####:31092:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:31093:        mem_base = xmlMemBlocks();
    #####:31094:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:31095:
    #####:31096:        ret_val = xmlTextReaderExpand(reader);
    #####:31097:        desret_xmlNodePtr(ret_val);
    #####:31098:        call_tests++;
    #####:31099:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:31100:        xmlResetLastError();
    #####:31101:        if (mem_base != xmlMemBlocks()) {
    #####:31102:            printf("Leak of %d blocks found in xmlTextReaderExpand",
    #####:31103:	           xmlMemBlocks() - mem_base);
    #####:31104:	    test_ret++;
    #####:31105:            printf(" %d", n_reader);
    #####:31106:            printf("\n");
        -:31107:        }
        -:31108:    }
    #####:31109:    function_tests++;
        -:31110:#endif
        -:31111:
    #####:31112:    return(test_ret);
        -:31113:}
        -:31114:
        -:31115:
        -:31116:static int
    #####:31117:test_xmlTextReaderGetAttribute(void) {
    #####:31118:    int test_ret = 0;
        -:31119:
        -:31120:#if defined(LIBXML_READER_ENABLED)
        -:31121:    int mem_base;
        -:31122:    xmlChar * ret_val;
        -:31123:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:31124:    int n_reader;
        -:31125:    xmlChar * name; /* the qualified name of the attribute. */
        -:31126:    int n_name;
        -:31127:
    #####:31128:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:31129:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:31130:        mem_base = xmlMemBlocks();
    #####:31131:        reader = gen_xmlTextReaderPtr(n_reader, 0);
    #####:31132:        name = gen_const_xmlChar_ptr(n_name, 1);
        -:31133:
    #####:31134:        ret_val = xmlTextReaderGetAttribute(reader, (const xmlChar *)name);
    #####:31135:        desret_xmlChar_ptr(ret_val);
    #####:31136:        call_tests++;
    #####:31137:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:31138:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:31139:        xmlResetLastError();
    #####:31140:        if (mem_base != xmlMemBlocks()) {
    #####:31141:            printf("Leak of %d blocks found in xmlTextReaderGetAttribute",
    #####:31142:	           xmlMemBlocks() - mem_base);
    #####:31143:	    test_ret++;
    #####:31144:            printf(" %d", n_reader);
    #####:31145:            printf(" %d", n_name);
    #####:31146:            printf("\n");
        -:31147:        }
        -:31148:    }
        -:31149:    }
    #####:31150:    function_tests++;
        -:31151:#endif
        -:31152:
    #####:31153:    return(test_ret);
        -:31154:}
        -:31155:
        -:31156:
        -:31157:static int
    #####:31158:test_xmlTextReaderGetAttributeNo(void) {
    #####:31159:    int test_ret = 0;
        -:31160:
        -:31161:#if defined(LIBXML_READER_ENABLED)
        -:31162:    int mem_base;
        -:31163:    xmlChar * ret_val;
        -:31164:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:31165:    int n_reader;
        -:31166:    int no; /* the zero-based index of the attribute relative to the containing element */
        -:31167:    int n_no;
        -:31168:
    #####:31169:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:31170:    for (n_no = 0;n_no < gen_nb_int;n_no++) {
    #####:31171:        mem_base = xmlMemBlocks();
    #####:31172:        reader = gen_xmlTextReaderPtr(n_reader, 0);
    #####:31173:        no = gen_int(n_no, 1);
        -:31174:
    #####:31175:        ret_val = xmlTextReaderGetAttributeNo(reader, no);
    #####:31176:        desret_xmlChar_ptr(ret_val);
    #####:31177:        call_tests++;
    #####:31178:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:31179:        des_int(n_no, no, 1);
    #####:31180:        xmlResetLastError();
    #####:31181:        if (mem_base != xmlMemBlocks()) {
    #####:31182:            printf("Leak of %d blocks found in xmlTextReaderGetAttributeNo",
    #####:31183:	           xmlMemBlocks() - mem_base);
    #####:31184:	    test_ret++;
    #####:31185:            printf(" %d", n_reader);
    #####:31186:            printf(" %d", n_no);
    #####:31187:            printf("\n");
        -:31188:        }
        -:31189:    }
        -:31190:    }
    #####:31191:    function_tests++;
        -:31192:#endif
        -:31193:
    #####:31194:    return(test_ret);
        -:31195:}
        -:31196:
        -:31197:
        -:31198:static int
    #####:31199:test_xmlTextReaderGetAttributeNs(void) {
    #####:31200:    int test_ret = 0;
        -:31201:
        -:31202:#if defined(LIBXML_READER_ENABLED)
        -:31203:    int mem_base;
        -:31204:    xmlChar * ret_val;
        -:31205:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:31206:    int n_reader;
        -:31207:    xmlChar * localName; /* the local name of the attribute. */
        -:31208:    int n_localName;
        -:31209:    xmlChar * namespaceURI; /* the namespace URI of the attribute. */
        -:31210:    int n_namespaceURI;
        -:31211:
    #####:31212:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:31213:    for (n_localName = 0;n_localName < gen_nb_const_xmlChar_ptr;n_localName++) {
    #####:31214:    for (n_namespaceURI = 0;n_namespaceURI < gen_nb_const_xmlChar_ptr;n_namespaceURI++) {
    #####:31215:        mem_base = xmlMemBlocks();
    #####:31216:        reader = gen_xmlTextReaderPtr(n_reader, 0);
    #####:31217:        localName = gen_const_xmlChar_ptr(n_localName, 1);
    #####:31218:        namespaceURI = gen_const_xmlChar_ptr(n_namespaceURI, 2);
        -:31219:
    #####:31220:        ret_val = xmlTextReaderGetAttributeNs(reader, (const xmlChar *)localName, (const xmlChar *)namespaceURI);
    #####:31221:        desret_xmlChar_ptr(ret_val);
    #####:31222:        call_tests++;
    #####:31223:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:31224:        des_const_xmlChar_ptr(n_localName, (const xmlChar *)localName, 1);
    #####:31225:        des_const_xmlChar_ptr(n_namespaceURI, (const xmlChar *)namespaceURI, 2);
    #####:31226:        xmlResetLastError();
    #####:31227:        if (mem_base != xmlMemBlocks()) {
    #####:31228:            printf("Leak of %d blocks found in xmlTextReaderGetAttributeNs",
    #####:31229:	           xmlMemBlocks() - mem_base);
    #####:31230:	    test_ret++;
    #####:31231:            printf(" %d", n_reader);
    #####:31232:            printf(" %d", n_localName);
    #####:31233:            printf(" %d", n_namespaceURI);
    #####:31234:            printf("\n");
        -:31235:        }
        -:31236:    }
        -:31237:    }
        -:31238:    }
    #####:31239:    function_tests++;
        -:31240:#endif
        -:31241:
    #####:31242:    return(test_ret);
        -:31243:}
        -:31244:
        -:31245:#ifdef LIBXML_READER_ENABLED
        -:31246:
        -:31247:#define gen_nb_xmlTextReaderErrorFunc_ptr 1
    #####:31248:static xmlTextReaderErrorFunc * gen_xmlTextReaderErrorFunc_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:31249:    return(NULL);
        -:31250:}
    #####:31251:static void des_xmlTextReaderErrorFunc_ptr(int no ATTRIBUTE_UNUSED, xmlTextReaderErrorFunc * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:31252:}
        -:31253:#endif
        -:31254:
        -:31255:
        -:31256:static int
    #####:31257:test_xmlTextReaderGetErrorHandler(void) {
    #####:31258:    int test_ret = 0;
        -:31259:
        -:31260:#if defined(LIBXML_READER_ENABLED)
        -:31261:    int mem_base;
        -:31262:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:31263:    int n_reader;
        -:31264:    xmlTextReaderErrorFunc * f; /* the callback function or NULL is no callback has been registered */
        -:31265:    int n_f;
        -:31266:    void ** arg; /* a user argument */
        -:31267:    int n_arg;
        -:31268:
    #####:31269:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:31270:    for (n_f = 0;n_f < gen_nb_xmlTextReaderErrorFunc_ptr;n_f++) {
    #####:31271:    for (n_arg = 0;n_arg < gen_nb_void_ptr_ptr;n_arg++) {
    #####:31272:        mem_base = xmlMemBlocks();
    #####:31273:        reader = gen_xmlTextReaderPtr(n_reader, 0);
    #####:31274:        f = gen_xmlTextReaderErrorFunc_ptr(n_f, 1);
    #####:31275:        arg = gen_void_ptr_ptr(n_arg, 2);
        -:31276:
    #####:31277:        xmlTextReaderGetErrorHandler(reader, f, arg);
    #####:31278:        call_tests++;
    #####:31279:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:31280:        des_xmlTextReaderErrorFunc_ptr(n_f, f, 1);
    #####:31281:        des_void_ptr_ptr(n_arg, arg, 2);
    #####:31282:        xmlResetLastError();
    #####:31283:        if (mem_base != xmlMemBlocks()) {
    #####:31284:            printf("Leak of %d blocks found in xmlTextReaderGetErrorHandler",
    #####:31285:	           xmlMemBlocks() - mem_base);
    #####:31286:	    test_ret++;
    #####:31287:            printf(" %d", n_reader);
    #####:31288:            printf(" %d", n_f);
    #####:31289:            printf(" %d", n_arg);
    #####:31290:            printf("\n");
        -:31291:        }
        -:31292:    }
        -:31293:    }
        -:31294:    }
    #####:31295:    function_tests++;
        -:31296:#endif
        -:31297:
    #####:31298:    return(test_ret);
        -:31299:}
        -:31300:
        -:31301:
        -:31302:static int
    #####:31303:test_xmlTextReaderGetParserColumnNumber(void) {
    #####:31304:    int test_ret = 0;
        -:31305:
        -:31306:#if defined(LIBXML_READER_ENABLED)
        -:31307:    int mem_base;
        -:31308:    int ret_val;
        -:31309:    xmlTextReaderPtr reader; /* the user data (XML reader context) */
        -:31310:    int n_reader;
        -:31311:
    #####:31312:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:31313:        mem_base = xmlMemBlocks();
    #####:31314:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:31315:
    #####:31316:        ret_val = xmlTextReaderGetParserColumnNumber(reader);
    #####:31317:        desret_int(ret_val);
    #####:31318:        call_tests++;
    #####:31319:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:31320:        xmlResetLastError();
    #####:31321:        if (mem_base != xmlMemBlocks()) {
    #####:31322:            printf("Leak of %d blocks found in xmlTextReaderGetParserColumnNumber",
    #####:31323:	           xmlMemBlocks() - mem_base);
    #####:31324:	    test_ret++;
    #####:31325:            printf(" %d", n_reader);
    #####:31326:            printf("\n");
        -:31327:        }
        -:31328:    }
    #####:31329:    function_tests++;
        -:31330:#endif
        -:31331:
    #####:31332:    return(test_ret);
        -:31333:}
        -:31334:
        -:31335:
        -:31336:static int
    #####:31337:test_xmlTextReaderGetParserLineNumber(void) {
    #####:31338:    int test_ret = 0;
        -:31339:
        -:31340:#if defined(LIBXML_READER_ENABLED)
        -:31341:    int mem_base;
        -:31342:    int ret_val;
        -:31343:    xmlTextReaderPtr reader; /* the user data (XML reader context) */
        -:31344:    int n_reader;
        -:31345:
    #####:31346:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:31347:        mem_base = xmlMemBlocks();
    #####:31348:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:31349:
    #####:31350:        ret_val = xmlTextReaderGetParserLineNumber(reader);
    #####:31351:        desret_int(ret_val);
    #####:31352:        call_tests++;
    #####:31353:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:31354:        xmlResetLastError();
    #####:31355:        if (mem_base != xmlMemBlocks()) {
    #####:31356:            printf("Leak of %d blocks found in xmlTextReaderGetParserLineNumber",
    #####:31357:	           xmlMemBlocks() - mem_base);
    #####:31358:	    test_ret++;
    #####:31359:            printf(" %d", n_reader);
    #####:31360:            printf("\n");
        -:31361:        }
        -:31362:    }
    #####:31363:    function_tests++;
        -:31364:#endif
        -:31365:
    #####:31366:    return(test_ret);
        -:31367:}
        -:31368:
        -:31369:
        -:31370:static int
    #####:31371:test_xmlTextReaderGetParserProp(void) {
    #####:31372:    int test_ret = 0;
        -:31373:
        -:31374:#if defined(LIBXML_READER_ENABLED)
        -:31375:    int mem_base;
        -:31376:    int ret_val;
        -:31377:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:31378:    int n_reader;
        -:31379:    int prop; /* the xmlParserProperties to get */
        -:31380:    int n_prop;
        -:31381:
    #####:31382:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:31383:    for (n_prop = 0;n_prop < gen_nb_int;n_prop++) {
    #####:31384:        mem_base = xmlMemBlocks();
    #####:31385:        reader = gen_xmlTextReaderPtr(n_reader, 0);
    #####:31386:        prop = gen_int(n_prop, 1);
        -:31387:
    #####:31388:        ret_val = xmlTextReaderGetParserProp(reader, prop);
    #####:31389:        desret_int(ret_val);
    #####:31390:        call_tests++;
    #####:31391:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:31392:        des_int(n_prop, prop, 1);
    #####:31393:        xmlResetLastError();
    #####:31394:        if (mem_base != xmlMemBlocks()) {
    #####:31395:            printf("Leak of %d blocks found in xmlTextReaderGetParserProp",
    #####:31396:	           xmlMemBlocks() - mem_base);
    #####:31397:	    test_ret++;
    #####:31398:            printf(" %d", n_reader);
    #####:31399:            printf(" %d", n_prop);
    #####:31400:            printf("\n");
        -:31401:        }
        -:31402:    }
        -:31403:    }
    #####:31404:    function_tests++;
        -:31405:#endif
        -:31406:
    #####:31407:    return(test_ret);
        -:31408:}
        -:31409:
        -:31410:
        -:31411:static int
    #####:31412:test_xmlTextReaderGetRemainder(void) {
    #####:31413:    int test_ret = 0;
        -:31414:
        -:31415:#if defined(LIBXML_READER_ENABLED)
        -:31416:    int mem_base;
        -:31417:    xmlParserInputBufferPtr ret_val;
        -:31418:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:31419:    int n_reader;
        -:31420:
    #####:31421:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:31422:        mem_base = xmlMemBlocks();
    #####:31423:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:31424:
    #####:31425:        ret_val = xmlTextReaderGetRemainder(reader);
    #####:31426:        desret_xmlParserInputBufferPtr(ret_val);
    #####:31427:        call_tests++;
    #####:31428:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:31429:        xmlResetLastError();
    #####:31430:        if (mem_base != xmlMemBlocks()) {
    #####:31431:            printf("Leak of %d blocks found in xmlTextReaderGetRemainder",
    #####:31432:	           xmlMemBlocks() - mem_base);
    #####:31433:	    test_ret++;
    #####:31434:            printf(" %d", n_reader);
    #####:31435:            printf("\n");
        -:31436:        }
        -:31437:    }
    #####:31438:    function_tests++;
        -:31439:#endif
        -:31440:
    #####:31441:    return(test_ret);
        -:31442:}
        -:31443:
        -:31444:
        -:31445:static int
    #####:31446:test_xmlTextReaderHasAttributes(void) {
    #####:31447:    int test_ret = 0;
        -:31448:
        -:31449:#if defined(LIBXML_READER_ENABLED)
        -:31450:    int mem_base;
        -:31451:    int ret_val;
        -:31452:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:31453:    int n_reader;
        -:31454:
    #####:31455:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:31456:        mem_base = xmlMemBlocks();
    #####:31457:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:31458:
    #####:31459:        ret_val = xmlTextReaderHasAttributes(reader);
    #####:31460:        desret_int(ret_val);
    #####:31461:        call_tests++;
    #####:31462:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:31463:        xmlResetLastError();
    #####:31464:        if (mem_base != xmlMemBlocks()) {
    #####:31465:            printf("Leak of %d blocks found in xmlTextReaderHasAttributes",
    #####:31466:	           xmlMemBlocks() - mem_base);
    #####:31467:	    test_ret++;
    #####:31468:            printf(" %d", n_reader);
    #####:31469:            printf("\n");
        -:31470:        }
        -:31471:    }
    #####:31472:    function_tests++;
        -:31473:#endif
        -:31474:
    #####:31475:    return(test_ret);
        -:31476:}
        -:31477:
        -:31478:
        -:31479:static int
    #####:31480:test_xmlTextReaderHasValue(void) {
    #####:31481:    int test_ret = 0;
        -:31482:
        -:31483:#if defined(LIBXML_READER_ENABLED)
        -:31484:    int mem_base;
        -:31485:    int ret_val;
        -:31486:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:31487:    int n_reader;
        -:31488:
    #####:31489:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:31490:        mem_base = xmlMemBlocks();
    #####:31491:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:31492:
    #####:31493:        ret_val = xmlTextReaderHasValue(reader);
    #####:31494:        desret_int(ret_val);
    #####:31495:        call_tests++;
    #####:31496:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:31497:        xmlResetLastError();
    #####:31498:        if (mem_base != xmlMemBlocks()) {
    #####:31499:            printf("Leak of %d blocks found in xmlTextReaderHasValue",
    #####:31500:	           xmlMemBlocks() - mem_base);
    #####:31501:	    test_ret++;
    #####:31502:            printf(" %d", n_reader);
    #####:31503:            printf("\n");
        -:31504:        }
        -:31505:    }
    #####:31506:    function_tests++;
        -:31507:#endif
        -:31508:
    #####:31509:    return(test_ret);
        -:31510:}
        -:31511:
        -:31512:
        -:31513:static int
    #####:31514:test_xmlTextReaderIsDefault(void) {
    #####:31515:    int test_ret = 0;
        -:31516:
        -:31517:#if defined(LIBXML_READER_ENABLED)
        -:31518:    int mem_base;
        -:31519:    int ret_val;
        -:31520:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:31521:    int n_reader;
        -:31522:
    #####:31523:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:31524:        mem_base = xmlMemBlocks();
    #####:31525:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:31526:
    #####:31527:        ret_val = xmlTextReaderIsDefault(reader);
    #####:31528:        desret_int(ret_val);
    #####:31529:        call_tests++;
    #####:31530:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:31531:        xmlResetLastError();
    #####:31532:        if (mem_base != xmlMemBlocks()) {
    #####:31533:            printf("Leak of %d blocks found in xmlTextReaderIsDefault",
    #####:31534:	           xmlMemBlocks() - mem_base);
    #####:31535:	    test_ret++;
    #####:31536:            printf(" %d", n_reader);
    #####:31537:            printf("\n");
        -:31538:        }
        -:31539:    }
    #####:31540:    function_tests++;
        -:31541:#endif
        -:31542:
    #####:31543:    return(test_ret);
        -:31544:}
        -:31545:
        -:31546:
        -:31547:static int
    #####:31548:test_xmlTextReaderIsEmptyElement(void) {
    #####:31549:    int test_ret = 0;
        -:31550:
        -:31551:#if defined(LIBXML_READER_ENABLED)
        -:31552:    int mem_base;
        -:31553:    int ret_val;
        -:31554:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:31555:    int n_reader;
        -:31556:
    #####:31557:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:31558:        mem_base = xmlMemBlocks();
    #####:31559:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:31560:
    #####:31561:        ret_val = xmlTextReaderIsEmptyElement(reader);
    #####:31562:        desret_int(ret_val);
    #####:31563:        call_tests++;
    #####:31564:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:31565:        xmlResetLastError();
    #####:31566:        if (mem_base != xmlMemBlocks()) {
    #####:31567:            printf("Leak of %d blocks found in xmlTextReaderIsEmptyElement",
    #####:31568:	           xmlMemBlocks() - mem_base);
    #####:31569:	    test_ret++;
    #####:31570:            printf(" %d", n_reader);
    #####:31571:            printf("\n");
        -:31572:        }
        -:31573:    }
    #####:31574:    function_tests++;
        -:31575:#endif
        -:31576:
    #####:31577:    return(test_ret);
        -:31578:}
        -:31579:
        -:31580:
        -:31581:static int
    #####:31582:test_xmlTextReaderIsNamespaceDecl(void) {
    #####:31583:    int test_ret = 0;
        -:31584:
        -:31585:#if defined(LIBXML_READER_ENABLED)
        -:31586:    int mem_base;
        -:31587:    int ret_val;
        -:31588:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:31589:    int n_reader;
        -:31590:
    #####:31591:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:31592:        mem_base = xmlMemBlocks();
    #####:31593:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:31594:
    #####:31595:        ret_val = xmlTextReaderIsNamespaceDecl(reader);
    #####:31596:        desret_int(ret_val);
    #####:31597:        call_tests++;
    #####:31598:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:31599:        xmlResetLastError();
    #####:31600:        if (mem_base != xmlMemBlocks()) {
    #####:31601:            printf("Leak of %d blocks found in xmlTextReaderIsNamespaceDecl",
    #####:31602:	           xmlMemBlocks() - mem_base);
    #####:31603:	    test_ret++;
    #####:31604:            printf(" %d", n_reader);
    #####:31605:            printf("\n");
        -:31606:        }
        -:31607:    }
    #####:31608:    function_tests++;
        -:31609:#endif
        -:31610:
    #####:31611:    return(test_ret);
        -:31612:}
        -:31613:
        -:31614:
        -:31615:static int
    #####:31616:test_xmlTextReaderIsValid(void) {
    #####:31617:    int test_ret = 0;
        -:31618:
        -:31619:#if defined(LIBXML_READER_ENABLED)
        -:31620:    int mem_base;
        -:31621:    int ret_val;
        -:31622:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:31623:    int n_reader;
        -:31624:
    #####:31625:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:31626:        mem_base = xmlMemBlocks();
    #####:31627:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:31628:
    #####:31629:        ret_val = xmlTextReaderIsValid(reader);
    #####:31630:        desret_int(ret_val);
    #####:31631:        call_tests++;
    #####:31632:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:31633:        xmlResetLastError();
    #####:31634:        if (mem_base != xmlMemBlocks()) {
    #####:31635:            printf("Leak of %d blocks found in xmlTextReaderIsValid",
    #####:31636:	           xmlMemBlocks() - mem_base);
    #####:31637:	    test_ret++;
    #####:31638:            printf(" %d", n_reader);
    #####:31639:            printf("\n");
        -:31640:        }
        -:31641:    }
    #####:31642:    function_tests++;
        -:31643:#endif
        -:31644:
    #####:31645:    return(test_ret);
        -:31646:}
        -:31647:
        -:31648:
        -:31649:static int
    #####:31650:test_xmlTextReaderLocalName(void) {
    #####:31651:    int test_ret = 0;
        -:31652:
        -:31653:#if defined(LIBXML_READER_ENABLED)
        -:31654:    int mem_base;
        -:31655:    xmlChar * ret_val;
        -:31656:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:31657:    int n_reader;
        -:31658:
    #####:31659:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:31660:        mem_base = xmlMemBlocks();
    #####:31661:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:31662:
    #####:31663:        ret_val = xmlTextReaderLocalName(reader);
    #####:31664:        desret_xmlChar_ptr(ret_val);
    #####:31665:        call_tests++;
    #####:31666:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:31667:        xmlResetLastError();
    #####:31668:        if (mem_base != xmlMemBlocks()) {
    #####:31669:            printf("Leak of %d blocks found in xmlTextReaderLocalName",
    #####:31670:	           xmlMemBlocks() - mem_base);
    #####:31671:	    test_ret++;
    #####:31672:            printf(" %d", n_reader);
    #####:31673:            printf("\n");
        -:31674:        }
        -:31675:    }
    #####:31676:    function_tests++;
        -:31677:#endif
        -:31678:
    #####:31679:    return(test_ret);
        -:31680:}
        -:31681:
        -:31682:#ifdef LIBXML_READER_ENABLED
        -:31683:
        -:31684:#define gen_nb_xmlTextReaderLocatorPtr 1
    #####:31685:static xmlTextReaderLocatorPtr gen_xmlTextReaderLocatorPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:31686:    return(NULL);
        -:31687:}
    #####:31688:static void des_xmlTextReaderLocatorPtr(int no ATTRIBUTE_UNUSED, xmlTextReaderLocatorPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:31689:}
        -:31690:#endif
        -:31691:
        -:31692:
        -:31693:static int
    #####:31694:test_xmlTextReaderLocatorBaseURI(void) {
    #####:31695:    int test_ret = 0;
        -:31696:
        -:31697:#if defined(LIBXML_READER_ENABLED)
        -:31698:    int mem_base;
        -:31699:    xmlChar * ret_val;
        -:31700:    xmlTextReaderLocatorPtr locator; /* the xmlTextReaderLocatorPtr used */
        -:31701:    int n_locator;
        -:31702:
    #####:31703:    for (n_locator = 0;n_locator < gen_nb_xmlTextReaderLocatorPtr;n_locator++) {
    #####:31704:        mem_base = xmlMemBlocks();
    #####:31705:        locator = gen_xmlTextReaderLocatorPtr(n_locator, 0);
        -:31706:
    #####:31707:        ret_val = xmlTextReaderLocatorBaseURI(locator);
    #####:31708:        desret_xmlChar_ptr(ret_val);
    #####:31709:        call_tests++;
    #####:31710:        des_xmlTextReaderLocatorPtr(n_locator, locator, 0);
    #####:31711:        xmlResetLastError();
    #####:31712:        if (mem_base != xmlMemBlocks()) {
    #####:31713:            printf("Leak of %d blocks found in xmlTextReaderLocatorBaseURI",
    #####:31714:	           xmlMemBlocks() - mem_base);
    #####:31715:	    test_ret++;
    #####:31716:            printf(" %d", n_locator);
    #####:31717:            printf("\n");
        -:31718:        }
        -:31719:    }
    #####:31720:    function_tests++;
        -:31721:#endif
        -:31722:
    #####:31723:    return(test_ret);
        -:31724:}
        -:31725:
        -:31726:
        -:31727:static int
    #####:31728:test_xmlTextReaderLocatorLineNumber(void) {
    #####:31729:    int test_ret = 0;
        -:31730:
        -:31731:#if defined(LIBXML_READER_ENABLED)
        -:31732:    int mem_base;
        -:31733:    int ret_val;
        -:31734:    xmlTextReaderLocatorPtr locator; /* the xmlTextReaderLocatorPtr used */
        -:31735:    int n_locator;
        -:31736:
    #####:31737:    for (n_locator = 0;n_locator < gen_nb_xmlTextReaderLocatorPtr;n_locator++) {
    #####:31738:        mem_base = xmlMemBlocks();
    #####:31739:        locator = gen_xmlTextReaderLocatorPtr(n_locator, 0);
        -:31740:
    #####:31741:        ret_val = xmlTextReaderLocatorLineNumber(locator);
    #####:31742:        desret_int(ret_val);
    #####:31743:        call_tests++;
    #####:31744:        des_xmlTextReaderLocatorPtr(n_locator, locator, 0);
    #####:31745:        xmlResetLastError();
    #####:31746:        if (mem_base != xmlMemBlocks()) {
    #####:31747:            printf("Leak of %d blocks found in xmlTextReaderLocatorLineNumber",
    #####:31748:	           xmlMemBlocks() - mem_base);
    #####:31749:	    test_ret++;
    #####:31750:            printf(" %d", n_locator);
    #####:31751:            printf("\n");
        -:31752:        }
        -:31753:    }
    #####:31754:    function_tests++;
        -:31755:#endif
        -:31756:
    #####:31757:    return(test_ret);
        -:31758:}
        -:31759:
        -:31760:
        -:31761:static int
    #####:31762:test_xmlTextReaderLookupNamespace(void) {
    #####:31763:    int test_ret = 0;
        -:31764:
        -:31765:#if defined(LIBXML_READER_ENABLED)
        -:31766:    int mem_base;
        -:31767:    xmlChar * ret_val;
        -:31768:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:31769:    int n_reader;
        -:31770:    xmlChar * prefix; /* the prefix whose namespace URI is to be resolved. To return the default namespace, specify NULL */
        -:31771:    int n_prefix;
        -:31772:
    #####:31773:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:31774:    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    #####:31775:        mem_base = xmlMemBlocks();
    #####:31776:        reader = gen_xmlTextReaderPtr(n_reader, 0);
    #####:31777:        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
        -:31778:
    #####:31779:        ret_val = xmlTextReaderLookupNamespace(reader, (const xmlChar *)prefix);
    #####:31780:        desret_xmlChar_ptr(ret_val);
    #####:31781:        call_tests++;
    #####:31782:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:31783:        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 1);
    #####:31784:        xmlResetLastError();
    #####:31785:        if (mem_base != xmlMemBlocks()) {
    #####:31786:            printf("Leak of %d blocks found in xmlTextReaderLookupNamespace",
    #####:31787:	           xmlMemBlocks() - mem_base);
    #####:31788:	    test_ret++;
    #####:31789:            printf(" %d", n_reader);
    #####:31790:            printf(" %d", n_prefix);
    #####:31791:            printf("\n");
        -:31792:        }
        -:31793:    }
        -:31794:    }
    #####:31795:    function_tests++;
        -:31796:#endif
        -:31797:
    #####:31798:    return(test_ret);
        -:31799:}
        -:31800:
        -:31801:
        -:31802:static int
    #####:31803:test_xmlTextReaderMoveToAttribute(void) {
    #####:31804:    int test_ret = 0;
        -:31805:
        -:31806:#if defined(LIBXML_READER_ENABLED)
        -:31807:    int mem_base;
        -:31808:    int ret_val;
        -:31809:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:31810:    int n_reader;
        -:31811:    xmlChar * name; /* the qualified name of the attribute. */
        -:31812:    int n_name;
        -:31813:
    #####:31814:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:31815:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:31816:        mem_base = xmlMemBlocks();
    #####:31817:        reader = gen_xmlTextReaderPtr(n_reader, 0);
    #####:31818:        name = gen_const_xmlChar_ptr(n_name, 1);
        -:31819:
    #####:31820:        ret_val = xmlTextReaderMoveToAttribute(reader, (const xmlChar *)name);
    #####:31821:        desret_int(ret_val);
    #####:31822:        call_tests++;
    #####:31823:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:31824:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:31825:        xmlResetLastError();
    #####:31826:        if (mem_base != xmlMemBlocks()) {
    #####:31827:            printf("Leak of %d blocks found in xmlTextReaderMoveToAttribute",
    #####:31828:	           xmlMemBlocks() - mem_base);
    #####:31829:	    test_ret++;
    #####:31830:            printf(" %d", n_reader);
    #####:31831:            printf(" %d", n_name);
    #####:31832:            printf("\n");
        -:31833:        }
        -:31834:    }
        -:31835:    }
    #####:31836:    function_tests++;
        -:31837:#endif
        -:31838:
    #####:31839:    return(test_ret);
        -:31840:}
        -:31841:
        -:31842:
        -:31843:static int
    #####:31844:test_xmlTextReaderMoveToAttributeNo(void) {
    #####:31845:    int test_ret = 0;
        -:31846:
        -:31847:#if defined(LIBXML_READER_ENABLED)
        -:31848:    int mem_base;
        -:31849:    int ret_val;
        -:31850:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:31851:    int n_reader;
        -:31852:    int no; /* the zero-based index of the attribute relative to the containing element. */
        -:31853:    int n_no;
        -:31854:
    #####:31855:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:31856:    for (n_no = 0;n_no < gen_nb_int;n_no++) {
    #####:31857:        mem_base = xmlMemBlocks();
    #####:31858:        reader = gen_xmlTextReaderPtr(n_reader, 0);
    #####:31859:        no = gen_int(n_no, 1);
        -:31860:
    #####:31861:        ret_val = xmlTextReaderMoveToAttributeNo(reader, no);
    #####:31862:        desret_int(ret_val);
    #####:31863:        call_tests++;
    #####:31864:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:31865:        des_int(n_no, no, 1);
    #####:31866:        xmlResetLastError();
    #####:31867:        if (mem_base != xmlMemBlocks()) {
    #####:31868:            printf("Leak of %d blocks found in xmlTextReaderMoveToAttributeNo",
    #####:31869:	           xmlMemBlocks() - mem_base);
    #####:31870:	    test_ret++;
    #####:31871:            printf(" %d", n_reader);
    #####:31872:            printf(" %d", n_no);
    #####:31873:            printf("\n");
        -:31874:        }
        -:31875:    }
        -:31876:    }
    #####:31877:    function_tests++;
        -:31878:#endif
        -:31879:
    #####:31880:    return(test_ret);
        -:31881:}
        -:31882:
        -:31883:
        -:31884:static int
    #####:31885:test_xmlTextReaderMoveToAttributeNs(void) {
    #####:31886:    int test_ret = 0;
        -:31887:
        -:31888:#if defined(LIBXML_READER_ENABLED)
        -:31889:    int mem_base;
        -:31890:    int ret_val;
        -:31891:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:31892:    int n_reader;
        -:31893:    xmlChar * localName; /* the local name of the attribute. */
        -:31894:    int n_localName;
        -:31895:    xmlChar * namespaceURI; /* the namespace URI of the attribute. */
        -:31896:    int n_namespaceURI;
        -:31897:
    #####:31898:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:31899:    for (n_localName = 0;n_localName < gen_nb_const_xmlChar_ptr;n_localName++) {
    #####:31900:    for (n_namespaceURI = 0;n_namespaceURI < gen_nb_const_xmlChar_ptr;n_namespaceURI++) {
    #####:31901:        mem_base = xmlMemBlocks();
    #####:31902:        reader = gen_xmlTextReaderPtr(n_reader, 0);
    #####:31903:        localName = gen_const_xmlChar_ptr(n_localName, 1);
    #####:31904:        namespaceURI = gen_const_xmlChar_ptr(n_namespaceURI, 2);
        -:31905:
    #####:31906:        ret_val = xmlTextReaderMoveToAttributeNs(reader, (const xmlChar *)localName, (const xmlChar *)namespaceURI);
    #####:31907:        desret_int(ret_val);
    #####:31908:        call_tests++;
    #####:31909:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:31910:        des_const_xmlChar_ptr(n_localName, (const xmlChar *)localName, 1);
    #####:31911:        des_const_xmlChar_ptr(n_namespaceURI, (const xmlChar *)namespaceURI, 2);
    #####:31912:        xmlResetLastError();
    #####:31913:        if (mem_base != xmlMemBlocks()) {
    #####:31914:            printf("Leak of %d blocks found in xmlTextReaderMoveToAttributeNs",
    #####:31915:	           xmlMemBlocks() - mem_base);
    #####:31916:	    test_ret++;
    #####:31917:            printf(" %d", n_reader);
    #####:31918:            printf(" %d", n_localName);
    #####:31919:            printf(" %d", n_namespaceURI);
    #####:31920:            printf("\n");
        -:31921:        }
        -:31922:    }
        -:31923:    }
        -:31924:    }
    #####:31925:    function_tests++;
        -:31926:#endif
        -:31927:
    #####:31928:    return(test_ret);
        -:31929:}
        -:31930:
        -:31931:
        -:31932:static int
    #####:31933:test_xmlTextReaderMoveToElement(void) {
    #####:31934:    int test_ret = 0;
        -:31935:
        -:31936:#if defined(LIBXML_READER_ENABLED)
        -:31937:    int mem_base;
        -:31938:    int ret_val;
        -:31939:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:31940:    int n_reader;
        -:31941:
    #####:31942:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:31943:        mem_base = xmlMemBlocks();
    #####:31944:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:31945:
    #####:31946:        ret_val = xmlTextReaderMoveToElement(reader);
    #####:31947:        desret_int(ret_val);
    #####:31948:        call_tests++;
    #####:31949:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:31950:        xmlResetLastError();
    #####:31951:        if (mem_base != xmlMemBlocks()) {
    #####:31952:            printf("Leak of %d blocks found in xmlTextReaderMoveToElement",
    #####:31953:	           xmlMemBlocks() - mem_base);
    #####:31954:	    test_ret++;
    #####:31955:            printf(" %d", n_reader);
    #####:31956:            printf("\n");
        -:31957:        }
        -:31958:    }
    #####:31959:    function_tests++;
        -:31960:#endif
        -:31961:
    #####:31962:    return(test_ret);
        -:31963:}
        -:31964:
        -:31965:
        -:31966:static int
    #####:31967:test_xmlTextReaderMoveToFirstAttribute(void) {
    #####:31968:    int test_ret = 0;
        -:31969:
        -:31970:#if defined(LIBXML_READER_ENABLED)
        -:31971:    int mem_base;
        -:31972:    int ret_val;
        -:31973:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:31974:    int n_reader;
        -:31975:
    #####:31976:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:31977:        mem_base = xmlMemBlocks();
    #####:31978:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:31979:
    #####:31980:        ret_val = xmlTextReaderMoveToFirstAttribute(reader);
    #####:31981:        desret_int(ret_val);
    #####:31982:        call_tests++;
    #####:31983:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:31984:        xmlResetLastError();
    #####:31985:        if (mem_base != xmlMemBlocks()) {
    #####:31986:            printf("Leak of %d blocks found in xmlTextReaderMoveToFirstAttribute",
    #####:31987:	           xmlMemBlocks() - mem_base);
    #####:31988:	    test_ret++;
    #####:31989:            printf(" %d", n_reader);
    #####:31990:            printf("\n");
        -:31991:        }
        -:31992:    }
    #####:31993:    function_tests++;
        -:31994:#endif
        -:31995:
    #####:31996:    return(test_ret);
        -:31997:}
        -:31998:
        -:31999:
        -:32000:static int
    #####:32001:test_xmlTextReaderMoveToNextAttribute(void) {
    #####:32002:    int test_ret = 0;
        -:32003:
        -:32004:#if defined(LIBXML_READER_ENABLED)
        -:32005:    int mem_base;
        -:32006:    int ret_val;
        -:32007:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:32008:    int n_reader;
        -:32009:
    #####:32010:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:32011:        mem_base = xmlMemBlocks();
    #####:32012:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:32013:
    #####:32014:        ret_val = xmlTextReaderMoveToNextAttribute(reader);
    #####:32015:        desret_int(ret_val);
    #####:32016:        call_tests++;
    #####:32017:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:32018:        xmlResetLastError();
    #####:32019:        if (mem_base != xmlMemBlocks()) {
    #####:32020:            printf("Leak of %d blocks found in xmlTextReaderMoveToNextAttribute",
    #####:32021:	           xmlMemBlocks() - mem_base);
    #####:32022:	    test_ret++;
    #####:32023:            printf(" %d", n_reader);
    #####:32024:            printf("\n");
        -:32025:        }
        -:32026:    }
    #####:32027:    function_tests++;
        -:32028:#endif
        -:32029:
    #####:32030:    return(test_ret);
        -:32031:}
        -:32032:
        -:32033:
        -:32034:static int
    #####:32035:test_xmlTextReaderName(void) {
    #####:32036:    int test_ret = 0;
        -:32037:
        -:32038:#if defined(LIBXML_READER_ENABLED)
        -:32039:    int mem_base;
        -:32040:    xmlChar * ret_val;
        -:32041:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:32042:    int n_reader;
        -:32043:
    #####:32044:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:32045:        mem_base = xmlMemBlocks();
    #####:32046:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:32047:
    #####:32048:        ret_val = xmlTextReaderName(reader);
    #####:32049:        desret_xmlChar_ptr(ret_val);
    #####:32050:        call_tests++;
    #####:32051:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:32052:        xmlResetLastError();
    #####:32053:        if (mem_base != xmlMemBlocks()) {
    #####:32054:            printf("Leak of %d blocks found in xmlTextReaderName",
    #####:32055:	           xmlMemBlocks() - mem_base);
    #####:32056:	    test_ret++;
    #####:32057:            printf(" %d", n_reader);
    #####:32058:            printf("\n");
        -:32059:        }
        -:32060:    }
    #####:32061:    function_tests++;
        -:32062:#endif
        -:32063:
    #####:32064:    return(test_ret);
        -:32065:}
        -:32066:
        -:32067:
        -:32068:static int
    #####:32069:test_xmlTextReaderNamespaceUri(void) {
    #####:32070:    int test_ret = 0;
        -:32071:
        -:32072:#if defined(LIBXML_READER_ENABLED)
        -:32073:    int mem_base;
        -:32074:    xmlChar * ret_val;
        -:32075:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:32076:    int n_reader;
        -:32077:
    #####:32078:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:32079:        mem_base = xmlMemBlocks();
    #####:32080:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:32081:
    #####:32082:        ret_val = xmlTextReaderNamespaceUri(reader);
    #####:32083:        desret_xmlChar_ptr(ret_val);
    #####:32084:        call_tests++;
    #####:32085:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:32086:        xmlResetLastError();
    #####:32087:        if (mem_base != xmlMemBlocks()) {
    #####:32088:            printf("Leak of %d blocks found in xmlTextReaderNamespaceUri",
    #####:32089:	           xmlMemBlocks() - mem_base);
    #####:32090:	    test_ret++;
    #####:32091:            printf(" %d", n_reader);
    #####:32092:            printf("\n");
        -:32093:        }
        -:32094:    }
    #####:32095:    function_tests++;
        -:32096:#endif
        -:32097:
    #####:32098:    return(test_ret);
        -:32099:}
        -:32100:
        -:32101:
        -:32102:static int
    #####:32103:test_xmlTextReaderNext(void) {
    #####:32104:    int test_ret = 0;
        -:32105:
        -:32106:#if defined(LIBXML_READER_ENABLED)
        -:32107:    int mem_base;
        -:32108:    int ret_val;
        -:32109:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:32110:    int n_reader;
        -:32111:
    #####:32112:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:32113:        mem_base = xmlMemBlocks();
    #####:32114:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:32115:
    #####:32116:        ret_val = xmlTextReaderNext(reader);
    #####:32117:        desret_int(ret_val);
    #####:32118:        call_tests++;
    #####:32119:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:32120:        xmlResetLastError();
    #####:32121:        if (mem_base != xmlMemBlocks()) {
    #####:32122:            printf("Leak of %d blocks found in xmlTextReaderNext",
    #####:32123:	           xmlMemBlocks() - mem_base);
    #####:32124:	    test_ret++;
    #####:32125:            printf(" %d", n_reader);
    #####:32126:            printf("\n");
        -:32127:        }
        -:32128:    }
    #####:32129:    function_tests++;
        -:32130:#endif
        -:32131:
    #####:32132:    return(test_ret);
        -:32133:}
        -:32134:
        -:32135:
        -:32136:static int
    #####:32137:test_xmlTextReaderNextSibling(void) {
    #####:32138:    int test_ret = 0;
        -:32139:
        -:32140:#if defined(LIBXML_READER_ENABLED)
        -:32141:    int mem_base;
        -:32142:    int ret_val;
        -:32143:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:32144:    int n_reader;
        -:32145:
    #####:32146:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:32147:        mem_base = xmlMemBlocks();
    #####:32148:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:32149:
    #####:32150:        ret_val = xmlTextReaderNextSibling(reader);
    #####:32151:        desret_int(ret_val);
    #####:32152:        call_tests++;
    #####:32153:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:32154:        xmlResetLastError();
    #####:32155:        if (mem_base != xmlMemBlocks()) {
    #####:32156:            printf("Leak of %d blocks found in xmlTextReaderNextSibling",
    #####:32157:	           xmlMemBlocks() - mem_base);
    #####:32158:	    test_ret++;
    #####:32159:            printf(" %d", n_reader);
    #####:32160:            printf("\n");
        -:32161:        }
        -:32162:    }
    #####:32163:    function_tests++;
        -:32164:#endif
        -:32165:
    #####:32166:    return(test_ret);
        -:32167:}
        -:32168:
        -:32169:
        -:32170:static int
    #####:32171:test_xmlTextReaderNodeType(void) {
    #####:32172:    int test_ret = 0;
        -:32173:
        -:32174:#if defined(LIBXML_READER_ENABLED)
        -:32175:    int mem_base;
        -:32176:    int ret_val;
        -:32177:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:32178:    int n_reader;
        -:32179:
    #####:32180:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:32181:        mem_base = xmlMemBlocks();
    #####:32182:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:32183:
    #####:32184:        ret_val = xmlTextReaderNodeType(reader);
    #####:32185:        desret_int(ret_val);
    #####:32186:        call_tests++;
    #####:32187:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:32188:        xmlResetLastError();
    #####:32189:        if (mem_base != xmlMemBlocks()) {
    #####:32190:            printf("Leak of %d blocks found in xmlTextReaderNodeType",
    #####:32191:	           xmlMemBlocks() - mem_base);
    #####:32192:	    test_ret++;
    #####:32193:            printf(" %d", n_reader);
    #####:32194:            printf("\n");
        -:32195:        }
        -:32196:    }
    #####:32197:    function_tests++;
        -:32198:#endif
        -:32199:
    #####:32200:    return(test_ret);
        -:32201:}
        -:32202:
        -:32203:
        -:32204:static int
    #####:32205:test_xmlTextReaderNormalization(void) {
    #####:32206:    int test_ret = 0;
        -:32207:
        -:32208:#if defined(LIBXML_READER_ENABLED)
        -:32209:    int mem_base;
        -:32210:    int ret_val;
        -:32211:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:32212:    int n_reader;
        -:32213:
    #####:32214:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:32215:        mem_base = xmlMemBlocks();
    #####:32216:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:32217:
    #####:32218:        ret_val = xmlTextReaderNormalization(reader);
    #####:32219:        desret_int(ret_val);
    #####:32220:        call_tests++;
    #####:32221:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:32222:        xmlResetLastError();
    #####:32223:        if (mem_base != xmlMemBlocks()) {
    #####:32224:            printf("Leak of %d blocks found in xmlTextReaderNormalization",
    #####:32225:	           xmlMemBlocks() - mem_base);
    #####:32226:	    test_ret++;
    #####:32227:            printf(" %d", n_reader);
    #####:32228:            printf("\n");
        -:32229:        }
        -:32230:    }
    #####:32231:    function_tests++;
        -:32232:#endif
        -:32233:
    #####:32234:    return(test_ret);
        -:32235:}
        -:32236:
        -:32237:
        -:32238:static int
    #####:32239:test_xmlTextReaderPrefix(void) {
    #####:32240:    int test_ret = 0;
        -:32241:
        -:32242:#if defined(LIBXML_READER_ENABLED)
        -:32243:    int mem_base;
        -:32244:    xmlChar * ret_val;
        -:32245:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:32246:    int n_reader;
        -:32247:
    #####:32248:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:32249:        mem_base = xmlMemBlocks();
    #####:32250:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:32251:
    #####:32252:        ret_val = xmlTextReaderPrefix(reader);
    #####:32253:        desret_xmlChar_ptr(ret_val);
    #####:32254:        call_tests++;
    #####:32255:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:32256:        xmlResetLastError();
    #####:32257:        if (mem_base != xmlMemBlocks()) {
    #####:32258:            printf("Leak of %d blocks found in xmlTextReaderPrefix",
    #####:32259:	           xmlMemBlocks() - mem_base);
    #####:32260:	    test_ret++;
    #####:32261:            printf(" %d", n_reader);
    #####:32262:            printf("\n");
        -:32263:        }
        -:32264:    }
    #####:32265:    function_tests++;
        -:32266:#endif
        -:32267:
    #####:32268:    return(test_ret);
        -:32269:}
        -:32270:
        -:32271:
        -:32272:static int
    #####:32273:test_xmlTextReaderPreserve(void) {
    #####:32274:    int test_ret = 0;
        -:32275:
        -:32276:#if defined(LIBXML_READER_ENABLED)
        -:32277:    int mem_base;
        -:32278:    xmlNodePtr ret_val;
        -:32279:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:32280:    int n_reader;
        -:32281:
    #####:32282:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:32283:        mem_base = xmlMemBlocks();
    #####:32284:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:32285:
    #####:32286:        ret_val = xmlTextReaderPreserve(reader);
    #####:32287:        desret_xmlNodePtr(ret_val);
    #####:32288:        call_tests++;
    #####:32289:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:32290:        xmlResetLastError();
    #####:32291:        if (mem_base != xmlMemBlocks()) {
    #####:32292:            printf("Leak of %d blocks found in xmlTextReaderPreserve",
    #####:32293:	           xmlMemBlocks() - mem_base);
    #####:32294:	    test_ret++;
    #####:32295:            printf(" %d", n_reader);
    #####:32296:            printf("\n");
        -:32297:        }
        -:32298:    }
    #####:32299:    function_tests++;
        -:32300:#endif
        -:32301:
    #####:32302:    return(test_ret);
        -:32303:}
        -:32304:
        -:32305:
        -:32306:static int
    #####:32307:test_xmlTextReaderPreservePattern(void) {
    #####:32308:    int test_ret = 0;
        -:32309:
        -:32310:#if defined(LIBXML_READER_ENABLED) && defined(LIBXML_PATTERN_ENABLED)
        -:32311:#ifdef LIBXML_PATTERN_ENABLED
        -:32312:    int mem_base;
        -:32313:    int ret_val;
        -:32314:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:32315:    int n_reader;
        -:32316:    xmlChar * pattern; /* an XPath subset pattern */
        -:32317:    int n_pattern;
        -:32318:    xmlChar ** namespaces; /* the prefix definitions, array of [URI, prefix] or NULL */
        -:32319:    int n_namespaces;
        -:32320:
    #####:32321:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:32322:    for (n_pattern = 0;n_pattern < gen_nb_const_xmlChar_ptr;n_pattern++) {
    #####:32323:    for (n_namespaces = 0;n_namespaces < gen_nb_const_xmlChar_ptr_ptr;n_namespaces++) {
    #####:32324:        mem_base = xmlMemBlocks();
    #####:32325:        reader = gen_xmlTextReaderPtr(n_reader, 0);
    #####:32326:        pattern = gen_const_xmlChar_ptr(n_pattern, 1);
    #####:32327:        namespaces = gen_const_xmlChar_ptr_ptr(n_namespaces, 2);
        -:32328:
    #####:32329:        ret_val = xmlTextReaderPreservePattern(reader, (const xmlChar *)pattern, (const xmlChar **)namespaces);
    #####:32330:        desret_int(ret_val);
    #####:32331:        call_tests++;
    #####:32332:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:32333:        des_const_xmlChar_ptr(n_pattern, (const xmlChar *)pattern, 1);
    #####:32334:        des_const_xmlChar_ptr_ptr(n_namespaces, (const xmlChar **)namespaces, 2);
    #####:32335:        xmlResetLastError();
    #####:32336:        if (mem_base != xmlMemBlocks()) {
    #####:32337:            printf("Leak of %d blocks found in xmlTextReaderPreservePattern",
    #####:32338:	           xmlMemBlocks() - mem_base);
    #####:32339:	    test_ret++;
    #####:32340:            printf(" %d", n_reader);
    #####:32341:            printf(" %d", n_pattern);
    #####:32342:            printf(" %d", n_namespaces);
    #####:32343:            printf("\n");
        -:32344:        }
        -:32345:    }
        -:32346:    }
        -:32347:    }
    #####:32348:    function_tests++;
        -:32349:#endif
        -:32350:#endif
        -:32351:
    #####:32352:    return(test_ret);
        -:32353:}
        -:32354:
        -:32355:
        -:32356:static int
    #####:32357:test_xmlTextReaderQuoteChar(void) {
    #####:32358:    int test_ret = 0;
        -:32359:
        -:32360:#if defined(LIBXML_READER_ENABLED)
        -:32361:    int mem_base;
        -:32362:    int ret_val;
        -:32363:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:32364:    int n_reader;
        -:32365:
    #####:32366:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:32367:        mem_base = xmlMemBlocks();
    #####:32368:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:32369:
    #####:32370:        ret_val = xmlTextReaderQuoteChar(reader);
    #####:32371:        desret_int(ret_val);
    #####:32372:        call_tests++;
    #####:32373:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:32374:        xmlResetLastError();
    #####:32375:        if (mem_base != xmlMemBlocks()) {
    #####:32376:            printf("Leak of %d blocks found in xmlTextReaderQuoteChar",
    #####:32377:	           xmlMemBlocks() - mem_base);
    #####:32378:	    test_ret++;
    #####:32379:            printf(" %d", n_reader);
    #####:32380:            printf("\n");
        -:32381:        }
        -:32382:    }
    #####:32383:    function_tests++;
        -:32384:#endif
        -:32385:
    #####:32386:    return(test_ret);
        -:32387:}
        -:32388:
        -:32389:
        -:32390:static int
    #####:32391:test_xmlTextReaderRead(void) {
    #####:32392:    int test_ret = 0;
        -:32393:
        -:32394:#if defined(LIBXML_READER_ENABLED)
        -:32395:    int mem_base;
        -:32396:    int ret_val;
        -:32397:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:32398:    int n_reader;
        -:32399:
    #####:32400:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:32401:        mem_base = xmlMemBlocks();
    #####:32402:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:32403:
    #####:32404:        ret_val = xmlTextReaderRead(reader);
    #####:32405:        desret_int(ret_val);
    #####:32406:        call_tests++;
    #####:32407:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:32408:        xmlResetLastError();
    #####:32409:        if (mem_base != xmlMemBlocks()) {
    #####:32410:            printf("Leak of %d blocks found in xmlTextReaderRead",
    #####:32411:	           xmlMemBlocks() - mem_base);
    #####:32412:	    test_ret++;
    #####:32413:            printf(" %d", n_reader);
    #####:32414:            printf("\n");
        -:32415:        }
        -:32416:    }
    #####:32417:    function_tests++;
        -:32418:#endif
        -:32419:
    #####:32420:    return(test_ret);
        -:32421:}
        -:32422:
        -:32423:
        -:32424:static int
    #####:32425:test_xmlTextReaderReadAttributeValue(void) {
    #####:32426:    int test_ret = 0;
        -:32427:
        -:32428:#if defined(LIBXML_READER_ENABLED)
        -:32429:    int mem_base;
        -:32430:    int ret_val;
        -:32431:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:32432:    int n_reader;
        -:32433:
    #####:32434:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:32435:        mem_base = xmlMemBlocks();
    #####:32436:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:32437:
    #####:32438:        ret_val = xmlTextReaderReadAttributeValue(reader);
    #####:32439:        desret_int(ret_val);
    #####:32440:        call_tests++;
    #####:32441:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:32442:        xmlResetLastError();
    #####:32443:        if (mem_base != xmlMemBlocks()) {
    #####:32444:            printf("Leak of %d blocks found in xmlTextReaderReadAttributeValue",
    #####:32445:	           xmlMemBlocks() - mem_base);
    #####:32446:	    test_ret++;
    #####:32447:            printf(" %d", n_reader);
    #####:32448:            printf("\n");
        -:32449:        }
        -:32450:    }
    #####:32451:    function_tests++;
        -:32452:#endif
        -:32453:
    #####:32454:    return(test_ret);
        -:32455:}
        -:32456:
        -:32457:
        -:32458:static int
    #####:32459:test_xmlTextReaderReadState(void) {
    #####:32460:    int test_ret = 0;
        -:32461:
        -:32462:#if defined(LIBXML_READER_ENABLED)
        -:32463:    int mem_base;
        -:32464:    int ret_val;
        -:32465:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:32466:    int n_reader;
        -:32467:
    #####:32468:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:32469:        mem_base = xmlMemBlocks();
    #####:32470:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:32471:
    #####:32472:        ret_val = xmlTextReaderReadState(reader);
    #####:32473:        desret_int(ret_val);
    #####:32474:        call_tests++;
    #####:32475:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:32476:        xmlResetLastError();
    #####:32477:        if (mem_base != xmlMemBlocks()) {
    #####:32478:            printf("Leak of %d blocks found in xmlTextReaderReadState",
    #####:32479:	           xmlMemBlocks() - mem_base);
    #####:32480:	    test_ret++;
    #####:32481:            printf(" %d", n_reader);
    #####:32482:            printf("\n");
        -:32483:        }
        -:32484:    }
    #####:32485:    function_tests++;
        -:32486:#endif
        -:32487:
    #####:32488:    return(test_ret);
        -:32489:}
        -:32490:
        -:32491:
        -:32492:static int
    #####:32493:test_xmlTextReaderRelaxNGSetSchema(void) {
    #####:32494:    int test_ret = 0;
        -:32495:
        -:32496:#if defined(LIBXML_READER_ENABLED) && defined(LIBXML_SCHEMAS_ENABLED)
        -:32497:    int mem_base;
        -:32498:    int ret_val;
        -:32499:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:32500:    int n_reader;
        -:32501:    xmlRelaxNGPtr schema; /* a precompiled RelaxNG schema */
        -:32502:    int n_schema;
        -:32503:
    #####:32504:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:32505:    for (n_schema = 0;n_schema < gen_nb_xmlRelaxNGPtr;n_schema++) {
    #####:32506:        mem_base = xmlMemBlocks();
    #####:32507:        reader = gen_xmlTextReaderPtr(n_reader, 0);
    #####:32508:        schema = gen_xmlRelaxNGPtr(n_schema, 1);
        -:32509:
    #####:32510:        ret_val = xmlTextReaderRelaxNGSetSchema(reader, schema);
    #####:32511:        desret_int(ret_val);
    #####:32512:        call_tests++;
    #####:32513:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:32514:        des_xmlRelaxNGPtr(n_schema, schema, 1);
    #####:32515:        xmlResetLastError();
    #####:32516:        if (mem_base != xmlMemBlocks()) {
    #####:32517:            printf("Leak of %d blocks found in xmlTextReaderRelaxNGSetSchema",
    #####:32518:	           xmlMemBlocks() - mem_base);
    #####:32519:	    test_ret++;
    #####:32520:            printf(" %d", n_reader);
    #####:32521:            printf(" %d", n_schema);
    #####:32522:            printf("\n");
        -:32523:        }
        -:32524:    }
        -:32525:    }
    #####:32526:    function_tests++;
        -:32527:#endif
        -:32528:
    #####:32529:    return(test_ret);
        -:32530:}
        -:32531:
        -:32532:
        -:32533:static int
    #####:32534:test_xmlTextReaderRelaxNGValidate(void) {
    #####:32535:    int test_ret = 0;
        -:32536:
        -:32537:#if defined(LIBXML_READER_ENABLED) && defined(LIBXML_SCHEMAS_ENABLED)
        -:32538:    int mem_base;
        -:32539:    int ret_val;
        -:32540:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:32541:    int n_reader;
        -:32542:    char * rng; /* the path to a RelaxNG schema or NULL */
        -:32543:    int n_rng;
        -:32544:
    #####:32545:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:32546:    for (n_rng = 0;n_rng < gen_nb_const_char_ptr;n_rng++) {
    #####:32547:        mem_base = xmlMemBlocks();
    #####:32548:        reader = gen_xmlTextReaderPtr(n_reader, 0);
    #####:32549:        rng = gen_const_char_ptr(n_rng, 1);
        -:32550:
    #####:32551:        ret_val = xmlTextReaderRelaxNGValidate(reader, (const char *)rng);
    #####:32552:        desret_int(ret_val);
    #####:32553:        call_tests++;
    #####:32554:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:32555:        des_const_char_ptr(n_rng, (const char *)rng, 1);
    #####:32556:        xmlResetLastError();
    #####:32557:        if (mem_base != xmlMemBlocks()) {
    #####:32558:            printf("Leak of %d blocks found in xmlTextReaderRelaxNGValidate",
    #####:32559:	           xmlMemBlocks() - mem_base);
    #####:32560:	    test_ret++;
    #####:32561:            printf(" %d", n_reader);
    #####:32562:            printf(" %d", n_rng);
    #####:32563:            printf("\n");
        -:32564:        }
        -:32565:    }
        -:32566:    }
    #####:32567:    function_tests++;
        -:32568:#endif
        -:32569:
    #####:32570:    return(test_ret);
        -:32571:}
        -:32572:
        -:32573:
        -:32574:static int
    #####:32575:test_xmlTextReaderRelaxNGValidateCtxt(void) {
    #####:32576:    int test_ret = 0;
        -:32577:
        -:32578:#if defined(LIBXML_READER_ENABLED) && defined(LIBXML_SCHEMAS_ENABLED)
        -:32579:    int mem_base;
        -:32580:    int ret_val;
        -:32581:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:32582:    int n_reader;
        -:32583:    xmlRelaxNGValidCtxtPtr ctxt; /* the RelaxNG schema validation context or NULL */
        -:32584:    int n_ctxt;
        -:32585:    int options; /* options (not used yet) */
        -:32586:    int n_options;
        -:32587:
    #####:32588:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:32589:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlRelaxNGValidCtxtPtr;n_ctxt++) {
    #####:32590:    for (n_options = 0;n_options < gen_nb_parseroptions;n_options++) {
    #####:32591:        mem_base = xmlMemBlocks();
    #####:32592:        reader = gen_xmlTextReaderPtr(n_reader, 0);
    #####:32593:        ctxt = gen_xmlRelaxNGValidCtxtPtr(n_ctxt, 1);
    #####:32594:        options = gen_parseroptions(n_options, 2);
        -:32595:
    #####:32596:        ret_val = xmlTextReaderRelaxNGValidateCtxt(reader, ctxt, options);
    #####:32597:        desret_int(ret_val);
    #####:32598:        call_tests++;
    #####:32599:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:32600:        des_xmlRelaxNGValidCtxtPtr(n_ctxt, ctxt, 1);
    #####:32601:        des_parseroptions(n_options, options, 2);
    #####:32602:        xmlResetLastError();
    #####:32603:        if (mem_base != xmlMemBlocks()) {
    #####:32604:            printf("Leak of %d blocks found in xmlTextReaderRelaxNGValidateCtxt",
    #####:32605:	           xmlMemBlocks() - mem_base);
    #####:32606:	    test_ret++;
    #####:32607:            printf(" %d", n_reader);
    #####:32608:            printf(" %d", n_ctxt);
    #####:32609:            printf(" %d", n_options);
    #####:32610:            printf("\n");
        -:32611:        }
        -:32612:    }
        -:32613:    }
        -:32614:    }
    #####:32615:    function_tests++;
        -:32616:#endif
        -:32617:
    #####:32618:    return(test_ret);
        -:32619:}
        -:32620:
        -:32621:
        -:32622:static int
    #####:32623:test_xmlTextReaderSchemaValidate(void) {
    #####:32624:    int test_ret = 0;
        -:32625:
        -:32626:#if defined(LIBXML_READER_ENABLED) && defined(LIBXML_SCHEMAS_ENABLED)
        -:32627:    int ret_val;
        -:32628:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:32629:    int n_reader;
        -:32630:    char * xsd; /* the path to a W3C XSD schema or NULL */
        -:32631:    int n_xsd;
        -:32632:
    #####:32633:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:32634:    for (n_xsd = 0;n_xsd < gen_nb_const_char_ptr;n_xsd++) {
    #####:32635:        reader = gen_xmlTextReaderPtr(n_reader, 0);
    #####:32636:        xsd = gen_const_char_ptr(n_xsd, 1);
        -:32637:
    #####:32638:        ret_val = xmlTextReaderSchemaValidate(reader, (const char *)xsd);
    #####:32639:        desret_int(ret_val);
    #####:32640:        call_tests++;
    #####:32641:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:32642:        des_const_char_ptr(n_xsd, (const char *)xsd, 1);
    #####:32643:        xmlResetLastError();
        -:32644:    }
        -:32645:    }
    #####:32646:    function_tests++;
        -:32647:#endif
        -:32648:
    #####:32649:    return(test_ret);
        -:32650:}
        -:32651:
        -:32652:
        -:32653:static int
    #####:32654:test_xmlTextReaderSchemaValidateCtxt(void) {
    #####:32655:    int test_ret = 0;
        -:32656:
        -:32657:#if defined(LIBXML_READER_ENABLED) && defined(LIBXML_SCHEMAS_ENABLED)
        -:32658:    int mem_base;
        -:32659:    int ret_val;
        -:32660:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:32661:    int n_reader;
        -:32662:    xmlSchemaValidCtxtPtr ctxt; /* the XML Schema validation context or NULL */
        -:32663:    int n_ctxt;
        -:32664:    int options; /* options (not used yet) */
        -:32665:    int n_options;
        -:32666:
    #####:32667:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:32668:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
    #####:32669:    for (n_options = 0;n_options < gen_nb_parseroptions;n_options++) {
    #####:32670:        mem_base = xmlMemBlocks();
    #####:32671:        reader = gen_xmlTextReaderPtr(n_reader, 0);
    #####:32672:        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 1);
    #####:32673:        options = gen_parseroptions(n_options, 2);
        -:32674:
    #####:32675:        ret_val = xmlTextReaderSchemaValidateCtxt(reader, ctxt, options);
    #####:32676:        desret_int(ret_val);
    #####:32677:        call_tests++;
    #####:32678:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:32679:        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 1);
    #####:32680:        des_parseroptions(n_options, options, 2);
    #####:32681:        xmlResetLastError();
    #####:32682:        if (mem_base != xmlMemBlocks()) {
    #####:32683:            printf("Leak of %d blocks found in xmlTextReaderSchemaValidateCtxt",
    #####:32684:	           xmlMemBlocks() - mem_base);
    #####:32685:	    test_ret++;
    #####:32686:            printf(" %d", n_reader);
    #####:32687:            printf(" %d", n_ctxt);
    #####:32688:            printf(" %d", n_options);
    #####:32689:            printf("\n");
        -:32690:        }
        -:32691:    }
        -:32692:    }
        -:32693:    }
    #####:32694:    function_tests++;
        -:32695:#endif
        -:32696:
    #####:32697:    return(test_ret);
        -:32698:}
        -:32699:
        -:32700:
        -:32701:static int
    #####:32702:test_xmlTextReaderSetErrorHandler(void) {
    #####:32703:    int test_ret = 0;
        -:32704:
        -:32705:
        -:32706:    /* missing type support */
    #####:32707:    return(test_ret);
        -:32708:}
        -:32709:
        -:32710:
        -:32711:static int
    #####:32712:test_xmlTextReaderSetParserProp(void) {
    #####:32713:    int test_ret = 0;
        -:32714:
        -:32715:#if defined(LIBXML_READER_ENABLED)
        -:32716:    int mem_base;
        -:32717:    int ret_val;
        -:32718:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:32719:    int n_reader;
        -:32720:    int prop; /* the xmlParserProperties to set */
        -:32721:    int n_prop;
        -:32722:    int value; /* usually 0 or 1 to (de)activate it */
        -:32723:    int n_value;
        -:32724:
    #####:32725:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:32726:    for (n_prop = 0;n_prop < gen_nb_int;n_prop++) {
    #####:32727:    for (n_value = 0;n_value < gen_nb_int;n_value++) {
    #####:32728:        mem_base = xmlMemBlocks();
    #####:32729:        reader = gen_xmlTextReaderPtr(n_reader, 0);
    #####:32730:        prop = gen_int(n_prop, 1);
    #####:32731:        value = gen_int(n_value, 2);
        -:32732:
    #####:32733:        ret_val = xmlTextReaderSetParserProp(reader, prop, value);
    #####:32734:        desret_int(ret_val);
    #####:32735:        call_tests++;
    #####:32736:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:32737:        des_int(n_prop, prop, 1);
    #####:32738:        des_int(n_value, value, 2);
    #####:32739:        xmlResetLastError();
    #####:32740:        if (mem_base != xmlMemBlocks()) {
    #####:32741:            printf("Leak of %d blocks found in xmlTextReaderSetParserProp",
    #####:32742:	           xmlMemBlocks() - mem_base);
    #####:32743:	    test_ret++;
    #####:32744:            printf(" %d", n_reader);
    #####:32745:            printf(" %d", n_prop);
    #####:32746:            printf(" %d", n_value);
    #####:32747:            printf("\n");
        -:32748:        }
        -:32749:    }
        -:32750:    }
        -:32751:    }
    #####:32752:    function_tests++;
        -:32753:#endif
        -:32754:
    #####:32755:    return(test_ret);
        -:32756:}
        -:32757:
        -:32758:
        -:32759:static int
    #####:32760:test_xmlTextReaderSetSchema(void) {
    #####:32761:    int test_ret = 0;
        -:32762:
        -:32763:#if defined(LIBXML_READER_ENABLED) && defined(LIBXML_SCHEMAS_ENABLED)
        -:32764:    int mem_base;
        -:32765:    int ret_val;
        -:32766:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:32767:    int n_reader;
        -:32768:    xmlSchemaPtr schema; /* a precompiled Schema schema */
        -:32769:    int n_schema;
        -:32770:
    #####:32771:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:32772:    for (n_schema = 0;n_schema < gen_nb_xmlSchemaPtr;n_schema++) {
    #####:32773:        mem_base = xmlMemBlocks();
    #####:32774:        reader = gen_xmlTextReaderPtr(n_reader, 0);
    #####:32775:        schema = gen_xmlSchemaPtr(n_schema, 1);
        -:32776:
    #####:32777:        ret_val = xmlTextReaderSetSchema(reader, schema);
    #####:32778:        desret_int(ret_val);
    #####:32779:        call_tests++;
    #####:32780:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:32781:        des_xmlSchemaPtr(n_schema, schema, 1);
    #####:32782:        xmlResetLastError();
    #####:32783:        if (mem_base != xmlMemBlocks()) {
    #####:32784:            printf("Leak of %d blocks found in xmlTextReaderSetSchema",
    #####:32785:	           xmlMemBlocks() - mem_base);
    #####:32786:	    test_ret++;
    #####:32787:            printf(" %d", n_reader);
    #####:32788:            printf(" %d", n_schema);
    #####:32789:            printf("\n");
        -:32790:        }
        -:32791:    }
        -:32792:    }
    #####:32793:    function_tests++;
        -:32794:#endif
        -:32795:
    #####:32796:    return(test_ret);
        -:32797:}
        -:32798:
        -:32799:
        -:32800:static int
    #####:32801:test_xmlTextReaderSetStructuredErrorHandler(void) {
    #####:32802:    int test_ret = 0;
        -:32803:
        -:32804:
        -:32805:    /* missing type support */
    #####:32806:    return(test_ret);
        -:32807:}
        -:32808:
        -:32809:
        -:32810:static int
    #####:32811:test_xmlTextReaderSetup(void) {
    #####:32812:    int test_ret = 0;
        -:32813:
        -:32814:#if defined(LIBXML_READER_ENABLED)
        -:32815:    int mem_base;
        -:32816:    int ret_val;
        -:32817:    xmlTextReaderPtr reader; /* an XML reader */
        -:32818:    int n_reader;
        -:32819:    xmlParserInputBufferPtr input; /* xmlParserInputBufferPtr used to feed the reader, will be destroyed with it. */
        -:32820:    int n_input;
        -:32821:    const char * URL; /* the base URL to use for the document */
        -:32822:    int n_URL;
        -:32823:    char * encoding; /* the document encoding, or NULL */
        -:32824:    int n_encoding;
        -:32825:    int options; /* a combination of xmlParserOption */
        -:32826:    int n_options;
        -:32827:
    #####:32828:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:32829:    for (n_input = 0;n_input < gen_nb_xmlParserInputBufferPtr;n_input++) {
    #####:32830:    for (n_URL = 0;n_URL < gen_nb_filepath;n_URL++) {
    #####:32831:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####:32832:    for (n_options = 0;n_options < gen_nb_parseroptions;n_options++) {
    #####:32833:        mem_base = xmlMemBlocks();
    #####:32834:        reader = gen_xmlTextReaderPtr(n_reader, 0);
    #####:32835:        input = gen_xmlParserInputBufferPtr(n_input, 1);
    #####:32836:        URL = gen_filepath(n_URL, 2);
    #####:32837:        encoding = gen_const_char_ptr(n_encoding, 3);
    #####:32838:        options = gen_parseroptions(n_options, 4);
        -:32839:
    #####:32840:        ret_val = xmlTextReaderSetup(reader, input, URL, (const char *)encoding, options);
    #####:32841:        desret_int(ret_val);
    #####:32842:        call_tests++;
    #####:32843:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:32844:        des_filepath(n_URL, URL, 2);
    #####:32845:        des_const_char_ptr(n_encoding, (const char *)encoding, 3);
    #####:32846:        des_parseroptions(n_options, options, 4);
    #####:32847:        xmlResetLastError();
    #####:32848:        if (mem_base != xmlMemBlocks()) {
    #####:32849:            printf("Leak of %d blocks found in xmlTextReaderSetup",
    #####:32850:	           xmlMemBlocks() - mem_base);
    #####:32851:	    test_ret++;
    #####:32852:            printf(" %d", n_reader);
    #####:32853:            printf(" %d", n_input);
    #####:32854:            printf(" %d", n_URL);
    #####:32855:            printf(" %d", n_encoding);
    #####:32856:            printf(" %d", n_options);
    #####:32857:            printf("\n");
        -:32858:        }
        -:32859:    }
        -:32860:    }
        -:32861:    }
        -:32862:    }
        -:32863:    }
    #####:32864:    function_tests++;
        -:32865:#endif
        -:32866:
    #####:32867:    return(test_ret);
        -:32868:}
        -:32869:
        -:32870:
        -:32871:static int
    #####:32872:test_xmlTextReaderStandalone(void) {
    #####:32873:    int test_ret = 0;
        -:32874:
        -:32875:#if defined(LIBXML_READER_ENABLED)
        -:32876:    int mem_base;
        -:32877:    int ret_val;
        -:32878:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:32879:    int n_reader;
        -:32880:
    #####:32881:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:32882:        mem_base = xmlMemBlocks();
    #####:32883:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:32884:
    #####:32885:        ret_val = xmlTextReaderStandalone(reader);
    #####:32886:        desret_int(ret_val);
    #####:32887:        call_tests++;
    #####:32888:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:32889:        xmlResetLastError();
    #####:32890:        if (mem_base != xmlMemBlocks()) {
    #####:32891:            printf("Leak of %d blocks found in xmlTextReaderStandalone",
    #####:32892:	           xmlMemBlocks() - mem_base);
    #####:32893:	    test_ret++;
    #####:32894:            printf(" %d", n_reader);
    #####:32895:            printf("\n");
        -:32896:        }
        -:32897:    }
    #####:32898:    function_tests++;
        -:32899:#endif
        -:32900:
    #####:32901:    return(test_ret);
        -:32902:}
        -:32903:
        -:32904:
        -:32905:static int
    #####:32906:test_xmlTextReaderValue(void) {
    #####:32907:    int test_ret = 0;
        -:32908:
        -:32909:#if defined(LIBXML_READER_ENABLED)
        -:32910:    int mem_base;
        -:32911:    xmlChar * ret_val;
        -:32912:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:32913:    int n_reader;
        -:32914:
    #####:32915:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:32916:        mem_base = xmlMemBlocks();
    #####:32917:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:32918:
    #####:32919:        ret_val = xmlTextReaderValue(reader);
    #####:32920:        desret_xmlChar_ptr(ret_val);
    #####:32921:        call_tests++;
    #####:32922:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:32923:        xmlResetLastError();
    #####:32924:        if (mem_base != xmlMemBlocks()) {
    #####:32925:            printf("Leak of %d blocks found in xmlTextReaderValue",
    #####:32926:	           xmlMemBlocks() - mem_base);
    #####:32927:	    test_ret++;
    #####:32928:            printf(" %d", n_reader);
    #####:32929:            printf("\n");
        -:32930:        }
        -:32931:    }
    #####:32932:    function_tests++;
        -:32933:#endif
        -:32934:
    #####:32935:    return(test_ret);
        -:32936:}
        -:32937:
        -:32938:
        -:32939:static int
    #####:32940:test_xmlTextReaderXmlLang(void) {
    #####:32941:    int test_ret = 0;
        -:32942:
        -:32943:#if defined(LIBXML_READER_ENABLED)
        -:32944:    int mem_base;
        -:32945:    xmlChar * ret_val;
        -:32946:    xmlTextReaderPtr reader; /* the xmlTextReaderPtr used */
        -:32947:    int n_reader;
        -:32948:
    #####:32949:    for (n_reader = 0;n_reader < gen_nb_xmlTextReaderPtr;n_reader++) {
    #####:32950:        mem_base = xmlMemBlocks();
    #####:32951:        reader = gen_xmlTextReaderPtr(n_reader, 0);
        -:32952:
    #####:32953:        ret_val = xmlTextReaderXmlLang(reader);
    #####:32954:        desret_xmlChar_ptr(ret_val);
    #####:32955:        call_tests++;
    #####:32956:        des_xmlTextReaderPtr(n_reader, reader, 0);
    #####:32957:        xmlResetLastError();
    #####:32958:        if (mem_base != xmlMemBlocks()) {
    #####:32959:            printf("Leak of %d blocks found in xmlTextReaderXmlLang",
    #####:32960:	           xmlMemBlocks() - mem_base);
    #####:32961:	    test_ret++;
    #####:32962:            printf(" %d", n_reader);
    #####:32963:            printf("\n");
        -:32964:        }
        -:32965:    }
    #####:32966:    function_tests++;
        -:32967:#endif
        -:32968:
    #####:32969:    return(test_ret);
        -:32970:}
        -:32971:
        -:32972:static int
    #####:32973:test_xmlreader(void) {
    #####:32974:    int test_ret = 0;
        -:32975:
    #####:32976:    if (quiet == 0) printf("Testing xmlreader : 76 of 86 functions ...\n");
    #####:32977:    test_ret += test_xmlNewTextReader();
    #####:32978:    test_ret += test_xmlNewTextReaderFilename();
    #####:32979:    test_ret += test_xmlReaderForDoc();
    #####:32980:    test_ret += test_xmlReaderForFile();
    #####:32981:    test_ret += test_xmlReaderForMemory();
    #####:32982:    test_ret += test_xmlReaderNewDoc();
    #####:32983:    test_ret += test_xmlReaderNewFile();
    #####:32984:    test_ret += test_xmlReaderNewMemory();
    #####:32985:    test_ret += test_xmlReaderNewWalker();
    #####:32986:    test_ret += test_xmlReaderWalker();
    #####:32987:    test_ret += test_xmlTextReaderAttributeCount();
    #####:32988:    test_ret += test_xmlTextReaderBaseUri();
    #####:32989:    test_ret += test_xmlTextReaderByteConsumed();
    #####:32990:    test_ret += test_xmlTextReaderClose();
    #####:32991:    test_ret += test_xmlTextReaderConstBaseUri();
    #####:32992:    test_ret += test_xmlTextReaderConstEncoding();
    #####:32993:    test_ret += test_xmlTextReaderConstLocalName();
    #####:32994:    test_ret += test_xmlTextReaderConstName();
    #####:32995:    test_ret += test_xmlTextReaderConstNamespaceUri();
    #####:32996:    test_ret += test_xmlTextReaderConstPrefix();
    #####:32997:    test_ret += test_xmlTextReaderConstString();
    #####:32998:    test_ret += test_xmlTextReaderConstValue();
    #####:32999:    test_ret += test_xmlTextReaderConstXmlLang();
    #####:33000:    test_ret += test_xmlTextReaderConstXmlVersion();
    #####:33001:    test_ret += test_xmlTextReaderCurrentDoc();
    #####:33002:    test_ret += test_xmlTextReaderCurrentNode();
    #####:33003:    test_ret += test_xmlTextReaderDepth();
    #####:33004:    test_ret += test_xmlTextReaderExpand();
    #####:33005:    test_ret += test_xmlTextReaderGetAttribute();
    #####:33006:    test_ret += test_xmlTextReaderGetAttributeNo();
    #####:33007:    test_ret += test_xmlTextReaderGetAttributeNs();
    #####:33008:    test_ret += test_xmlTextReaderGetErrorHandler();
    #####:33009:    test_ret += test_xmlTextReaderGetParserColumnNumber();
    #####:33010:    test_ret += test_xmlTextReaderGetParserLineNumber();
    #####:33011:    test_ret += test_xmlTextReaderGetParserProp();
    #####:33012:    test_ret += test_xmlTextReaderGetRemainder();
    #####:33013:    test_ret += test_xmlTextReaderHasAttributes();
    #####:33014:    test_ret += test_xmlTextReaderHasValue();
    #####:33015:    test_ret += test_xmlTextReaderIsDefault();
    #####:33016:    test_ret += test_xmlTextReaderIsEmptyElement();
    #####:33017:    test_ret += test_xmlTextReaderIsNamespaceDecl();
    #####:33018:    test_ret += test_xmlTextReaderIsValid();
    #####:33019:    test_ret += test_xmlTextReaderLocalName();
    #####:33020:    test_ret += test_xmlTextReaderLocatorBaseURI();
    #####:33021:    test_ret += test_xmlTextReaderLocatorLineNumber();
    #####:33022:    test_ret += test_xmlTextReaderLookupNamespace();
    #####:33023:    test_ret += test_xmlTextReaderMoveToAttribute();
    #####:33024:    test_ret += test_xmlTextReaderMoveToAttributeNo();
    #####:33025:    test_ret += test_xmlTextReaderMoveToAttributeNs();
    #####:33026:    test_ret += test_xmlTextReaderMoveToElement();
    #####:33027:    test_ret += test_xmlTextReaderMoveToFirstAttribute();
    #####:33028:    test_ret += test_xmlTextReaderMoveToNextAttribute();
    #####:33029:    test_ret += test_xmlTextReaderName();
    #####:33030:    test_ret += test_xmlTextReaderNamespaceUri();
    #####:33031:    test_ret += test_xmlTextReaderNext();
    #####:33032:    test_ret += test_xmlTextReaderNextSibling();
    #####:33033:    test_ret += test_xmlTextReaderNodeType();
    #####:33034:    test_ret += test_xmlTextReaderNormalization();
    #####:33035:    test_ret += test_xmlTextReaderPrefix();
    #####:33036:    test_ret += test_xmlTextReaderPreserve();
    #####:33037:    test_ret += test_xmlTextReaderPreservePattern();
    #####:33038:    test_ret += test_xmlTextReaderQuoteChar();
    #####:33039:    test_ret += test_xmlTextReaderRead();
    #####:33040:    test_ret += test_xmlTextReaderReadAttributeValue();
    #####:33041:    test_ret += test_xmlTextReaderReadState();
    #####:33042:    test_ret += test_xmlTextReaderRelaxNGSetSchema();
    #####:33043:    test_ret += test_xmlTextReaderRelaxNGValidate();
    #####:33044:    test_ret += test_xmlTextReaderRelaxNGValidateCtxt();
    #####:33045:    test_ret += test_xmlTextReaderSchemaValidate();
    #####:33046:    test_ret += test_xmlTextReaderSchemaValidateCtxt();
    #####:33047:    test_ret += test_xmlTextReaderSetErrorHandler();
    #####:33048:    test_ret += test_xmlTextReaderSetParserProp();
    #####:33049:    test_ret += test_xmlTextReaderSetSchema();
    #####:33050:    test_ret += test_xmlTextReaderSetStructuredErrorHandler();
    #####:33051:    test_ret += test_xmlTextReaderSetup();
    #####:33052:    test_ret += test_xmlTextReaderStandalone();
    #####:33053:    test_ret += test_xmlTextReaderValue();
    #####:33054:    test_ret += test_xmlTextReaderXmlLang();
        -:33055:
    #####:33056:    if (test_ret != 0)
    #####:33057:	printf("Module xmlreader: %d errors\n", test_ret);
    #####:33058:    return(test_ret);
        -:33059:}
        -:33060:
        -:33061:static int
    #####:33062:test_xmlExpCtxtNbCons(void) {
    #####:33063:    int test_ret = 0;
        -:33064:
        -:33065:#if defined(LIBXML_REGEXP_ENABLED) && defined(LIBXML_EXPR_ENABLED)
        -:33066:    int mem_base;
        -:33067:    int ret_val;
        -:33068:    xmlExpCtxtPtr ctxt; /* an expression context */
        -:33069:    int n_ctxt;
        -:33070:
    #####:33071:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlExpCtxtPtr;n_ctxt++) {
    #####:33072:        mem_base = xmlMemBlocks();
    #####:33073:        ctxt = gen_xmlExpCtxtPtr(n_ctxt, 0);
        -:33074:
    #####:33075:        ret_val = xmlExpCtxtNbCons(ctxt);
    #####:33076:        desret_int(ret_val);
    #####:33077:        call_tests++;
    #####:33078:        des_xmlExpCtxtPtr(n_ctxt, ctxt, 0);
    #####:33079:        xmlResetLastError();
    #####:33080:        if (mem_base != xmlMemBlocks()) {
    #####:33081:            printf("Leak of %d blocks found in xmlExpCtxtNbCons",
    #####:33082:	           xmlMemBlocks() - mem_base);
    #####:33083:	    test_ret++;
    #####:33084:            printf(" %d", n_ctxt);
    #####:33085:            printf("\n");
        -:33086:        }
        -:33087:    }
    #####:33088:    function_tests++;
        -:33089:#endif
        -:33090:
    #####:33091:    return(test_ret);
        -:33092:}
        -:33093:
        -:33094:
        -:33095:static int
    #####:33096:test_xmlExpCtxtNbNodes(void) {
    #####:33097:    int test_ret = 0;
        -:33098:
        -:33099:#if defined(LIBXML_REGEXP_ENABLED) && defined(LIBXML_EXPR_ENABLED)
        -:33100:    int mem_base;
        -:33101:    int ret_val;
        -:33102:    xmlExpCtxtPtr ctxt; /* an expression context */
        -:33103:    int n_ctxt;
        -:33104:
    #####:33105:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlExpCtxtPtr;n_ctxt++) {
    #####:33106:        mem_base = xmlMemBlocks();
    #####:33107:        ctxt = gen_xmlExpCtxtPtr(n_ctxt, 0);
        -:33108:
    #####:33109:        ret_val = xmlExpCtxtNbNodes(ctxt);
    #####:33110:        desret_int(ret_val);
    #####:33111:        call_tests++;
    #####:33112:        des_xmlExpCtxtPtr(n_ctxt, ctxt, 0);
    #####:33113:        xmlResetLastError();
    #####:33114:        if (mem_base != xmlMemBlocks()) {
    #####:33115:            printf("Leak of %d blocks found in xmlExpCtxtNbNodes",
    #####:33116:	           xmlMemBlocks() - mem_base);
    #####:33117:	    test_ret++;
    #####:33118:            printf(" %d", n_ctxt);
    #####:33119:            printf("\n");
        -:33120:        }
        -:33121:    }
    #####:33122:    function_tests++;
        -:33123:#endif
        -:33124:
    #####:33125:    return(test_ret);
        -:33126:}
        -:33127:
        -:33128:
        -:33129:static int
    #####:33130:test_xmlExpDump(void) {
    #####:33131:    int test_ret = 0;
        -:33132:
        -:33133:#if defined(LIBXML_REGEXP_ENABLED) && defined(LIBXML_EXPR_ENABLED)
        -:33134:    int mem_base;
        -:33135:    xmlBufferPtr buf; /* a buffer to receive the output */
        -:33136:    int n_buf;
        -:33137:    xmlExpNodePtr expr; /* the compiled expression */
        -:33138:    int n_expr;
        -:33139:
    #####:33140:    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    #####:33141:    for (n_expr = 0;n_expr < gen_nb_xmlExpNodePtr;n_expr++) {
    #####:33142:        mem_base = xmlMemBlocks();
    #####:33143:        buf = gen_xmlBufferPtr(n_buf, 0);
    #####:33144:        expr = gen_xmlExpNodePtr(n_expr, 1);
        -:33145:
    #####:33146:        xmlExpDump(buf, expr);
    #####:33147:        call_tests++;
    #####:33148:        des_xmlBufferPtr(n_buf, buf, 0);
    #####:33149:        des_xmlExpNodePtr(n_expr, expr, 1);
    #####:33150:        xmlResetLastError();
    #####:33151:        if (mem_base != xmlMemBlocks()) {
    #####:33152:            printf("Leak of %d blocks found in xmlExpDump",
    #####:33153:	           xmlMemBlocks() - mem_base);
    #####:33154:	    test_ret++;
    #####:33155:            printf(" %d", n_buf);
    #####:33156:            printf(" %d", n_expr);
    #####:33157:            printf("\n");
        -:33158:        }
        -:33159:    }
        -:33160:    }
    #####:33161:    function_tests++;
        -:33162:#endif
        -:33163:
    #####:33164:    return(test_ret);
        -:33165:}
        -:33166:
        -:33167:
        -:33168:static int
    #####:33169:test_xmlExpExpDerive(void) {
    #####:33170:    int test_ret = 0;
        -:33171:
        -:33172:
        -:33173:    /* missing type support */
    #####:33174:    return(test_ret);
        -:33175:}
        -:33176:
        -:33177:
        -:33178:static int
    #####:33179:test_xmlExpGetLanguage(void) {
    #####:33180:    int test_ret = 0;
        -:33181:
        -:33182:#if defined(LIBXML_REGEXP_ENABLED) && defined(LIBXML_EXPR_ENABLED)
        -:33183:    int mem_base;
        -:33184:    int ret_val;
        -:33185:    xmlExpCtxtPtr ctxt; /* the expression context */
        -:33186:    int n_ctxt;
        -:33187:    xmlExpNodePtr exp; /* the expression */
        -:33188:    int n_exp;
        -:33189:    xmlChar ** langList; /* where to store the tokens */
        -:33190:    int n_langList;
        -:33191:    int len; /* the allocated length of @list */
        -:33192:    int n_len;
        -:33193:
    #####:33194:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlExpCtxtPtr;n_ctxt++) {
    #####:33195:    for (n_exp = 0;n_exp < gen_nb_xmlExpNodePtr;n_exp++) {
    #####:33196:    for (n_langList = 0;n_langList < gen_nb_const_xmlChar_ptr_ptr;n_langList++) {
    #####:33197:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:33198:        mem_base = xmlMemBlocks();
    #####:33199:        ctxt = gen_xmlExpCtxtPtr(n_ctxt, 0);
    #####:33200:        exp = gen_xmlExpNodePtr(n_exp, 1);
    #####:33201:        langList = gen_const_xmlChar_ptr_ptr(n_langList, 2);
    #####:33202:        len = gen_int(n_len, 3);
        -:33203:
    #####:33204:        ret_val = xmlExpGetLanguage(ctxt, exp, (const xmlChar **)langList, len);
    #####:33205:        desret_int(ret_val);
    #####:33206:        call_tests++;
    #####:33207:        des_xmlExpCtxtPtr(n_ctxt, ctxt, 0);
    #####:33208:        des_xmlExpNodePtr(n_exp, exp, 1);
    #####:33209:        des_const_xmlChar_ptr_ptr(n_langList, (const xmlChar **)langList, 2);
    #####:33210:        des_int(n_len, len, 3);
    #####:33211:        xmlResetLastError();
    #####:33212:        if (mem_base != xmlMemBlocks()) {
    #####:33213:            printf("Leak of %d blocks found in xmlExpGetLanguage",
    #####:33214:	           xmlMemBlocks() - mem_base);
    #####:33215:	    test_ret++;
    #####:33216:            printf(" %d", n_ctxt);
    #####:33217:            printf(" %d", n_exp);
    #####:33218:            printf(" %d", n_langList);
    #####:33219:            printf(" %d", n_len);
    #####:33220:            printf("\n");
        -:33221:        }
        -:33222:    }
        -:33223:    }
        -:33224:    }
        -:33225:    }
    #####:33226:    function_tests++;
        -:33227:#endif
        -:33228:
    #####:33229:    return(test_ret);
        -:33230:}
        -:33231:
        -:33232:
        -:33233:static int
    #####:33234:test_xmlExpGetStart(void) {
    #####:33235:    int test_ret = 0;
        -:33236:
        -:33237:#if defined(LIBXML_REGEXP_ENABLED) && defined(LIBXML_EXPR_ENABLED)
        -:33238:    int mem_base;
        -:33239:    int ret_val;
        -:33240:    xmlExpCtxtPtr ctxt; /* the expression context */
        -:33241:    int n_ctxt;
        -:33242:    xmlExpNodePtr exp; /* the expression */
        -:33243:    int n_exp;
        -:33244:    xmlChar ** tokList; /* where to store the tokens */
        -:33245:    int n_tokList;
        -:33246:    int len; /* the allocated length of @list */
        -:33247:    int n_len;
        -:33248:
    #####:33249:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlExpCtxtPtr;n_ctxt++) {
    #####:33250:    for (n_exp = 0;n_exp < gen_nb_xmlExpNodePtr;n_exp++) {
    #####:33251:    for (n_tokList = 0;n_tokList < gen_nb_const_xmlChar_ptr_ptr;n_tokList++) {
    #####:33252:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:33253:        mem_base = xmlMemBlocks();
    #####:33254:        ctxt = gen_xmlExpCtxtPtr(n_ctxt, 0);
    #####:33255:        exp = gen_xmlExpNodePtr(n_exp, 1);
    #####:33256:        tokList = gen_const_xmlChar_ptr_ptr(n_tokList, 2);
    #####:33257:        len = gen_int(n_len, 3);
        -:33258:
    #####:33259:        ret_val = xmlExpGetStart(ctxt, exp, (const xmlChar **)tokList, len);
    #####:33260:        desret_int(ret_val);
    #####:33261:        call_tests++;
    #####:33262:        des_xmlExpCtxtPtr(n_ctxt, ctxt, 0);
    #####:33263:        des_xmlExpNodePtr(n_exp, exp, 1);
    #####:33264:        des_const_xmlChar_ptr_ptr(n_tokList, (const xmlChar **)tokList, 2);
    #####:33265:        des_int(n_len, len, 3);
    #####:33266:        xmlResetLastError();
    #####:33267:        if (mem_base != xmlMemBlocks()) {
    #####:33268:            printf("Leak of %d blocks found in xmlExpGetStart",
    #####:33269:	           xmlMemBlocks() - mem_base);
    #####:33270:	    test_ret++;
    #####:33271:            printf(" %d", n_ctxt);
    #####:33272:            printf(" %d", n_exp);
    #####:33273:            printf(" %d", n_tokList);
    #####:33274:            printf(" %d", n_len);
    #####:33275:            printf("\n");
        -:33276:        }
        -:33277:    }
        -:33278:    }
        -:33279:    }
        -:33280:    }
    #####:33281:    function_tests++;
        -:33282:#endif
        -:33283:
    #####:33284:    return(test_ret);
        -:33285:}
        -:33286:
        -:33287:
        -:33288:static int
    #####:33289:test_xmlExpIsNillable(void) {
    #####:33290:    int test_ret = 0;
        -:33291:
        -:33292:#if defined(LIBXML_REGEXP_ENABLED) && defined(LIBXML_EXPR_ENABLED)
        -:33293:    int mem_base;
        -:33294:    int ret_val;
        -:33295:    xmlExpNodePtr exp; /* the expression */
        -:33296:    int n_exp;
        -:33297:
    #####:33298:    for (n_exp = 0;n_exp < gen_nb_xmlExpNodePtr;n_exp++) {
    #####:33299:        mem_base = xmlMemBlocks();
    #####:33300:        exp = gen_xmlExpNodePtr(n_exp, 0);
        -:33301:
    #####:33302:        ret_val = xmlExpIsNillable(exp);
    #####:33303:        desret_int(ret_val);
    #####:33304:        call_tests++;
    #####:33305:        des_xmlExpNodePtr(n_exp, exp, 0);
    #####:33306:        xmlResetLastError();
    #####:33307:        if (mem_base != xmlMemBlocks()) {
    #####:33308:            printf("Leak of %d blocks found in xmlExpIsNillable",
    #####:33309:	           xmlMemBlocks() - mem_base);
    #####:33310:	    test_ret++;
    #####:33311:            printf(" %d", n_exp);
    #####:33312:            printf("\n");
        -:33313:        }
        -:33314:    }
    #####:33315:    function_tests++;
        -:33316:#endif
        -:33317:
    #####:33318:    return(test_ret);
        -:33319:}
        -:33320:
        -:33321:
        -:33322:static int
    #####:33323:test_xmlExpMaxToken(void) {
    #####:33324:    int test_ret = 0;
        -:33325:
        -:33326:#if defined(LIBXML_REGEXP_ENABLED) && defined(LIBXML_EXPR_ENABLED)
        -:33327:    int mem_base;
        -:33328:    int ret_val;
        -:33329:    xmlExpNodePtr expr; /* a compiled expression */
        -:33330:    int n_expr;
        -:33331:
    #####:33332:    for (n_expr = 0;n_expr < gen_nb_xmlExpNodePtr;n_expr++) {
    #####:33333:        mem_base = xmlMemBlocks();
    #####:33334:        expr = gen_xmlExpNodePtr(n_expr, 0);
        -:33335:
    #####:33336:        ret_val = xmlExpMaxToken(expr);
    #####:33337:        desret_int(ret_val);
    #####:33338:        call_tests++;
    #####:33339:        des_xmlExpNodePtr(n_expr, expr, 0);
    #####:33340:        xmlResetLastError();
    #####:33341:        if (mem_base != xmlMemBlocks()) {
    #####:33342:            printf("Leak of %d blocks found in xmlExpMaxToken",
    #####:33343:	           xmlMemBlocks() - mem_base);
    #####:33344:	    test_ret++;
    #####:33345:            printf(" %d", n_expr);
    #####:33346:            printf("\n");
        -:33347:        }
        -:33348:    }
    #####:33349:    function_tests++;
        -:33350:#endif
        -:33351:
    #####:33352:    return(test_ret);
        -:33353:}
        -:33354:
        -:33355:
        -:33356:static int
    #####:33357:test_xmlExpNewAtom(void) {
    #####:33358:    int test_ret = 0;
        -:33359:
        -:33360:
        -:33361:    /* missing type support */
    #####:33362:    return(test_ret);
        -:33363:}
        -:33364:
        -:33365:
        -:33366:static int
    #####:33367:test_xmlExpNewCtxt(void) {
    #####:33368:    int test_ret = 0;
        -:33369:
        -:33370:
        -:33371:    /* missing type support */
    #####:33372:    return(test_ret);
        -:33373:}
        -:33374:
        -:33375:
        -:33376:static int
    #####:33377:test_xmlExpNewOr(void) {
    #####:33378:    int test_ret = 0;
        -:33379:
        -:33380:
        -:33381:    /* missing type support */
    #####:33382:    return(test_ret);
        -:33383:}
        -:33384:
        -:33385:
        -:33386:static int
    #####:33387:test_xmlExpNewRange(void) {
    #####:33388:    int test_ret = 0;
        -:33389:
        -:33390:
        -:33391:    /* missing type support */
    #####:33392:    return(test_ret);
        -:33393:}
        -:33394:
        -:33395:
        -:33396:static int
    #####:33397:test_xmlExpNewSeq(void) {
    #####:33398:    int test_ret = 0;
        -:33399:
        -:33400:
        -:33401:    /* missing type support */
    #####:33402:    return(test_ret);
        -:33403:}
        -:33404:
        -:33405:
        -:33406:static int
    #####:33407:test_xmlExpParse(void) {
    #####:33408:    int test_ret = 0;
        -:33409:
        -:33410:
        -:33411:    /* missing type support */
    #####:33412:    return(test_ret);
        -:33413:}
        -:33414:
        -:33415:
        -:33416:static int
    #####:33417:test_xmlExpRef(void) {
    #####:33418:    int test_ret = 0;
        -:33419:
        -:33420:#if defined(LIBXML_REGEXP_ENABLED) && defined(LIBXML_EXPR_ENABLED)
        -:33421:    int mem_base;
        -:33422:    xmlExpNodePtr exp; /* the expression */
        -:33423:    int n_exp;
        -:33424:
    #####:33425:    for (n_exp = 0;n_exp < gen_nb_xmlExpNodePtr;n_exp++) {
    #####:33426:        mem_base = xmlMemBlocks();
    #####:33427:        exp = gen_xmlExpNodePtr(n_exp, 0);
        -:33428:
    #####:33429:        xmlExpRef(exp);
    #####:33430:        call_tests++;
    #####:33431:        des_xmlExpNodePtr(n_exp, exp, 0);
    #####:33432:        xmlResetLastError();
    #####:33433:        if (mem_base != xmlMemBlocks()) {
    #####:33434:            printf("Leak of %d blocks found in xmlExpRef",
    #####:33435:	           xmlMemBlocks() - mem_base);
    #####:33436:	    test_ret++;
    #####:33437:            printf(" %d", n_exp);
    #####:33438:            printf("\n");
        -:33439:        }
        -:33440:    }
    #####:33441:    function_tests++;
        -:33442:#endif
        -:33443:
    #####:33444:    return(test_ret);
        -:33445:}
        -:33446:
        -:33447:
        -:33448:static int
    #####:33449:test_xmlExpStringDerive(void) {
    #####:33450:    int test_ret = 0;
        -:33451:
        -:33452:
        -:33453:    /* missing type support */
    #####:33454:    return(test_ret);
        -:33455:}
        -:33456:
        -:33457:
        -:33458:static int
    #####:33459:test_xmlExpSubsume(void) {
    #####:33460:    int test_ret = 0;
        -:33461:
        -:33462:#if defined(LIBXML_REGEXP_ENABLED) && defined(LIBXML_EXPR_ENABLED)
        -:33463:    int mem_base;
        -:33464:    int ret_val;
        -:33465:    xmlExpCtxtPtr ctxt; /* the expressions context */
        -:33466:    int n_ctxt;
        -:33467:    xmlExpNodePtr exp; /* the englobing expression */
        -:33468:    int n_exp;
        -:33469:    xmlExpNodePtr sub; /* the subexpression */
        -:33470:    int n_sub;
        -:33471:
    #####:33472:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlExpCtxtPtr;n_ctxt++) {
    #####:33473:    for (n_exp = 0;n_exp < gen_nb_xmlExpNodePtr;n_exp++) {
    #####:33474:    for (n_sub = 0;n_sub < gen_nb_xmlExpNodePtr;n_sub++) {
    #####:33475:        mem_base = xmlMemBlocks();
    #####:33476:        ctxt = gen_xmlExpCtxtPtr(n_ctxt, 0);
    #####:33477:        exp = gen_xmlExpNodePtr(n_exp, 1);
    #####:33478:        sub = gen_xmlExpNodePtr(n_sub, 2);
        -:33479:
    #####:33480:        ret_val = xmlExpSubsume(ctxt, exp, sub);
    #####:33481:        desret_int(ret_val);
    #####:33482:        call_tests++;
    #####:33483:        des_xmlExpCtxtPtr(n_ctxt, ctxt, 0);
    #####:33484:        des_xmlExpNodePtr(n_exp, exp, 1);
    #####:33485:        des_xmlExpNodePtr(n_sub, sub, 2);
    #####:33486:        xmlResetLastError();
    #####:33487:        if (mem_base != xmlMemBlocks()) {
    #####:33488:            printf("Leak of %d blocks found in xmlExpSubsume",
    #####:33489:	           xmlMemBlocks() - mem_base);
    #####:33490:	    test_ret++;
    #####:33491:            printf(" %d", n_ctxt);
    #####:33492:            printf(" %d", n_exp);
    #####:33493:            printf(" %d", n_sub);
    #####:33494:            printf("\n");
        -:33495:        }
        -:33496:    }
        -:33497:    }
        -:33498:    }
    #####:33499:    function_tests++;
        -:33500:#endif
        -:33501:
    #####:33502:    return(test_ret);
        -:33503:}
        -:33504:
        -:33505:#ifdef LIBXML_REGEXP_ENABLED
        -:33506:
        -:33507:#define gen_nb_xmlRegExecCtxtPtr 1
    #####:33508:static xmlRegExecCtxtPtr gen_xmlRegExecCtxtPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:33509:    return(NULL);
        -:33510:}
    #####:33511:static void des_xmlRegExecCtxtPtr(int no ATTRIBUTE_UNUSED, xmlRegExecCtxtPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:33512:}
        -:33513:#endif
        -:33514:
        -:33515:
        -:33516:static int
    #####:33517:test_xmlRegExecErrInfo(void) {
    #####:33518:    int test_ret = 0;
        -:33519:
        -:33520:#if defined(LIBXML_REGEXP_ENABLED)
        -:33521:    int mem_base;
        -:33522:    int ret_val;
        -:33523:    xmlRegExecCtxtPtr exec; /* a regexp execution context generating an error */
        -:33524:    int n_exec;
        -:33525:    xmlChar ** string; /* return value for the error string */
        -:33526:    int n_string;
        -:33527:    int * nbval; /* pointer to the number of accepted values IN/OUT */
        -:33528:    int n_nbval;
        -:33529:    int * nbneg; /* return number of negative transitions */
        -:33530:    int n_nbneg;
        -:33531:    xmlChar ** values; /* pointer to the array of acceptable values */
        -:33532:    int n_values;
        -:33533:    int * terminal; /* return value if this was a terminal state */
        -:33534:    int n_terminal;
        -:33535:
    #####:33536:    for (n_exec = 0;n_exec < gen_nb_xmlRegExecCtxtPtr;n_exec++) {
    #####:33537:    for (n_string = 0;n_string < gen_nb_const_xmlChar_ptr_ptr;n_string++) {
    #####:33538:    for (n_nbval = 0;n_nbval < gen_nb_int_ptr;n_nbval++) {
    #####:33539:    for (n_nbneg = 0;n_nbneg < gen_nb_int_ptr;n_nbneg++) {
    #####:33540:    for (n_values = 0;n_values < gen_nb_xmlChar_ptr_ptr;n_values++) {
    #####:33541:    for (n_terminal = 0;n_terminal < gen_nb_int_ptr;n_terminal++) {
    #####:33542:        mem_base = xmlMemBlocks();
    #####:33543:        exec = gen_xmlRegExecCtxtPtr(n_exec, 0);
    #####:33544:        string = gen_const_xmlChar_ptr_ptr(n_string, 1);
    #####:33545:        nbval = gen_int_ptr(n_nbval, 2);
    #####:33546:        nbneg = gen_int_ptr(n_nbneg, 3);
    #####:33547:        values = gen_xmlChar_ptr_ptr(n_values, 4);
    #####:33548:        terminal = gen_int_ptr(n_terminal, 5);
        -:33549:
    #####:33550:        ret_val = xmlRegExecErrInfo(exec, (const xmlChar **)string, nbval, nbneg, values, terminal);
    #####:33551:        desret_int(ret_val);
    #####:33552:        call_tests++;
    #####:33553:        des_xmlRegExecCtxtPtr(n_exec, exec, 0);
    #####:33554:        des_const_xmlChar_ptr_ptr(n_string, (const xmlChar **)string, 1);
    #####:33555:        des_int_ptr(n_nbval, nbval, 2);
    #####:33556:        des_int_ptr(n_nbneg, nbneg, 3);
    #####:33557:        des_xmlChar_ptr_ptr(n_values, values, 4);
    #####:33558:        des_int_ptr(n_terminal, terminal, 5);
    #####:33559:        xmlResetLastError();
    #####:33560:        if (mem_base != xmlMemBlocks()) {
    #####:33561:            printf("Leak of %d blocks found in xmlRegExecErrInfo",
    #####:33562:	           xmlMemBlocks() - mem_base);
    #####:33563:	    test_ret++;
    #####:33564:            printf(" %d", n_exec);
    #####:33565:            printf(" %d", n_string);
    #####:33566:            printf(" %d", n_nbval);
    #####:33567:            printf(" %d", n_nbneg);
    #####:33568:            printf(" %d", n_values);
    #####:33569:            printf(" %d", n_terminal);
    #####:33570:            printf("\n");
        -:33571:        }
        -:33572:    }
        -:33573:    }
        -:33574:    }
        -:33575:    }
        -:33576:    }
        -:33577:    }
    #####:33578:    function_tests++;
        -:33579:#endif
        -:33580:
    #####:33581:    return(test_ret);
        -:33582:}
        -:33583:
        -:33584:
        -:33585:static int
    #####:33586:test_xmlRegExecNextValues(void) {
    #####:33587:    int test_ret = 0;
        -:33588:
        -:33589:#if defined(LIBXML_REGEXP_ENABLED)
        -:33590:    int mem_base;
        -:33591:    int ret_val;
        -:33592:    xmlRegExecCtxtPtr exec; /* a regexp execution context */
        -:33593:    int n_exec;
        -:33594:    int * nbval; /* pointer to the number of accepted values IN/OUT */
        -:33595:    int n_nbval;
        -:33596:    int * nbneg; /* return number of negative transitions */
        -:33597:    int n_nbneg;
        -:33598:    xmlChar ** values; /* pointer to the array of acceptable values */
        -:33599:    int n_values;
        -:33600:    int * terminal; /* return value if this was a terminal state */
        -:33601:    int n_terminal;
        -:33602:
    #####:33603:    for (n_exec = 0;n_exec < gen_nb_xmlRegExecCtxtPtr;n_exec++) {
    #####:33604:    for (n_nbval = 0;n_nbval < gen_nb_int_ptr;n_nbval++) {
    #####:33605:    for (n_nbneg = 0;n_nbneg < gen_nb_int_ptr;n_nbneg++) {
    #####:33606:    for (n_values = 0;n_values < gen_nb_xmlChar_ptr_ptr;n_values++) {
    #####:33607:    for (n_terminal = 0;n_terminal < gen_nb_int_ptr;n_terminal++) {
    #####:33608:        mem_base = xmlMemBlocks();
    #####:33609:        exec = gen_xmlRegExecCtxtPtr(n_exec, 0);
    #####:33610:        nbval = gen_int_ptr(n_nbval, 1);
    #####:33611:        nbneg = gen_int_ptr(n_nbneg, 2);
    #####:33612:        values = gen_xmlChar_ptr_ptr(n_values, 3);
    #####:33613:        terminal = gen_int_ptr(n_terminal, 4);
        -:33614:
    #####:33615:        ret_val = xmlRegExecNextValues(exec, nbval, nbneg, values, terminal);
    #####:33616:        desret_int(ret_val);
    #####:33617:        call_tests++;
    #####:33618:        des_xmlRegExecCtxtPtr(n_exec, exec, 0);
    #####:33619:        des_int_ptr(n_nbval, nbval, 1);
    #####:33620:        des_int_ptr(n_nbneg, nbneg, 2);
    #####:33621:        des_xmlChar_ptr_ptr(n_values, values, 3);
    #####:33622:        des_int_ptr(n_terminal, terminal, 4);
    #####:33623:        xmlResetLastError();
    #####:33624:        if (mem_base != xmlMemBlocks()) {
    #####:33625:            printf("Leak of %d blocks found in xmlRegExecNextValues",
    #####:33626:	           xmlMemBlocks() - mem_base);
    #####:33627:	    test_ret++;
    #####:33628:            printf(" %d", n_exec);
    #####:33629:            printf(" %d", n_nbval);
    #####:33630:            printf(" %d", n_nbneg);
    #####:33631:            printf(" %d", n_values);
    #####:33632:            printf(" %d", n_terminal);
    #####:33633:            printf("\n");
        -:33634:        }
        -:33635:    }
        -:33636:    }
        -:33637:    }
        -:33638:    }
        -:33639:    }
    #####:33640:    function_tests++;
        -:33641:#endif
        -:33642:
    #####:33643:    return(test_ret);
        -:33644:}
        -:33645:
        -:33646:
        -:33647:static int
    #####:33648:test_xmlRegExecPushString(void) {
    #####:33649:    int test_ret = 0;
        -:33650:
        -:33651:#if defined(LIBXML_REGEXP_ENABLED)
        -:33652:    int mem_base;
        -:33653:    int ret_val;
        -:33654:    xmlRegExecCtxtPtr exec; /* a regexp execution context or NULL to indicate the end */
        -:33655:    int n_exec;
        -:33656:    xmlChar * value; /* a string token input */
        -:33657:    int n_value;
        -:33658:    void * data; /* data associated to the token to reuse in callbacks */
        -:33659:    int n_data;
        -:33660:
    #####:33661:    for (n_exec = 0;n_exec < gen_nb_xmlRegExecCtxtPtr;n_exec++) {
    #####:33662:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:33663:    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
    #####:33664:        mem_base = xmlMemBlocks();
    #####:33665:        exec = gen_xmlRegExecCtxtPtr(n_exec, 0);
    #####:33666:        value = gen_const_xmlChar_ptr(n_value, 1);
    #####:33667:        data = gen_userdata(n_data, 2);
        -:33668:
    #####:33669:        ret_val = xmlRegExecPushString(exec, (const xmlChar *)value, data);
    #####:33670:        desret_int(ret_val);
    #####:33671:        call_tests++;
    #####:33672:        des_xmlRegExecCtxtPtr(n_exec, exec, 0);
    #####:33673:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 1);
    #####:33674:        des_userdata(n_data, data, 2);
    #####:33675:        xmlResetLastError();
    #####:33676:        if (mem_base != xmlMemBlocks()) {
    #####:33677:            printf("Leak of %d blocks found in xmlRegExecPushString",
    #####:33678:	           xmlMemBlocks() - mem_base);
    #####:33679:	    test_ret++;
    #####:33680:            printf(" %d", n_exec);
    #####:33681:            printf(" %d", n_value);
    #####:33682:            printf(" %d", n_data);
    #####:33683:            printf("\n");
        -:33684:        }
        -:33685:    }
        -:33686:    }
        -:33687:    }
    #####:33688:    function_tests++;
        -:33689:#endif
        -:33690:
    #####:33691:    return(test_ret);
        -:33692:}
        -:33693:
        -:33694:
        -:33695:static int
    #####:33696:test_xmlRegExecPushString2(void) {
    #####:33697:    int test_ret = 0;
        -:33698:
        -:33699:#if defined(LIBXML_REGEXP_ENABLED)
        -:33700:    int mem_base;
        -:33701:    int ret_val;
        -:33702:    xmlRegExecCtxtPtr exec; /* a regexp execution context or NULL to indicate the end */
        -:33703:    int n_exec;
        -:33704:    xmlChar * value; /* the first string token input */
        -:33705:    int n_value;
        -:33706:    xmlChar * value2; /* the second string token input */
        -:33707:    int n_value2;
        -:33708:    void * data; /* data associated to the token to reuse in callbacks */
        -:33709:    int n_data;
        -:33710:
    #####:33711:    for (n_exec = 0;n_exec < gen_nb_xmlRegExecCtxtPtr;n_exec++) {
    #####:33712:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:33713:    for (n_value2 = 0;n_value2 < gen_nb_const_xmlChar_ptr;n_value2++) {
    #####:33714:    for (n_data = 0;n_data < gen_nb_userdata;n_data++) {
    #####:33715:        mem_base = xmlMemBlocks();
    #####:33716:        exec = gen_xmlRegExecCtxtPtr(n_exec, 0);
    #####:33717:        value = gen_const_xmlChar_ptr(n_value, 1);
    #####:33718:        value2 = gen_const_xmlChar_ptr(n_value2, 2);
    #####:33719:        data = gen_userdata(n_data, 3);
        -:33720:
    #####:33721:        ret_val = xmlRegExecPushString2(exec, (const xmlChar *)value, (const xmlChar *)value2, data);
    #####:33722:        desret_int(ret_val);
    #####:33723:        call_tests++;
    #####:33724:        des_xmlRegExecCtxtPtr(n_exec, exec, 0);
    #####:33725:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 1);
    #####:33726:        des_const_xmlChar_ptr(n_value2, (const xmlChar *)value2, 2);
    #####:33727:        des_userdata(n_data, data, 3);
    #####:33728:        xmlResetLastError();
    #####:33729:        if (mem_base != xmlMemBlocks()) {
    #####:33730:            printf("Leak of %d blocks found in xmlRegExecPushString2",
    #####:33731:	           xmlMemBlocks() - mem_base);
    #####:33732:	    test_ret++;
    #####:33733:            printf(" %d", n_exec);
    #####:33734:            printf(" %d", n_value);
    #####:33735:            printf(" %d", n_value2);
    #####:33736:            printf(" %d", n_data);
    #####:33737:            printf("\n");
        -:33738:        }
        -:33739:    }
        -:33740:    }
        -:33741:    }
        -:33742:    }
    #####:33743:    function_tests++;
        -:33744:#endif
        -:33745:
    #####:33746:    return(test_ret);
        -:33747:}
        -:33748:
        -:33749:#ifdef LIBXML_REGEXP_ENABLED
        -:33750:
        -:33751:#define gen_nb_xmlRegexpPtr 1
    #####:33752:static xmlRegexpPtr gen_xmlRegexpPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:33753:    return(NULL);
        -:33754:}
    #####:33755:static void des_xmlRegexpPtr(int no ATTRIBUTE_UNUSED, xmlRegexpPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:33756:}
        -:33757:#endif
        -:33758:
        -:33759:
        -:33760:static int
    #####:33761:test_xmlRegNewExecCtxt(void) {
    #####:33762:    int test_ret = 0;
        -:33763:
        -:33764:
        -:33765:    /* missing type support */
    #####:33766:    return(test_ret);
        -:33767:}
        -:33768:
        -:33769:
        -:33770:static int
    #####:33771:test_xmlRegexpCompile(void) {
    #####:33772:    int test_ret = 0;
        -:33773:
        -:33774:
        -:33775:    /* missing type support */
    #####:33776:    return(test_ret);
        -:33777:}
        -:33778:
        -:33779:
        -:33780:static int
    #####:33781:test_xmlRegexpExec(void) {
    #####:33782:    int test_ret = 0;
        -:33783:
        -:33784:#if defined(LIBXML_REGEXP_ENABLED)
        -:33785:    int mem_base;
        -:33786:    int ret_val;
        -:33787:    xmlRegexpPtr comp; /* the compiled regular expression */
        -:33788:    int n_comp;
        -:33789:    xmlChar * content; /* the value to check against the regular expression */
        -:33790:    int n_content;
        -:33791:
    #####:33792:    for (n_comp = 0;n_comp < gen_nb_xmlRegexpPtr;n_comp++) {
    #####:33793:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:33794:        mem_base = xmlMemBlocks();
    #####:33795:        comp = gen_xmlRegexpPtr(n_comp, 0);
    #####:33796:        content = gen_const_xmlChar_ptr(n_content, 1);
        -:33797:
    #####:33798:        ret_val = xmlRegexpExec(comp, (const xmlChar *)content);
    #####:33799:        desret_int(ret_val);
    #####:33800:        call_tests++;
    #####:33801:        des_xmlRegexpPtr(n_comp, comp, 0);
    #####:33802:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
    #####:33803:        xmlResetLastError();
    #####:33804:        if (mem_base != xmlMemBlocks()) {
    #####:33805:            printf("Leak of %d blocks found in xmlRegexpExec",
    #####:33806:	           xmlMemBlocks() - mem_base);
    #####:33807:	    test_ret++;
    #####:33808:            printf(" %d", n_comp);
    #####:33809:            printf(" %d", n_content);
    #####:33810:            printf("\n");
        -:33811:        }
        -:33812:    }
        -:33813:    }
    #####:33814:    function_tests++;
        -:33815:#endif
        -:33816:
    #####:33817:    return(test_ret);
        -:33818:}
        -:33819:
        -:33820:
        -:33821:static int
    #####:33822:test_xmlRegexpIsDeterminist(void) {
    #####:33823:    int test_ret = 0;
        -:33824:
        -:33825:#if defined(LIBXML_REGEXP_ENABLED)
        -:33826:    int mem_base;
        -:33827:    int ret_val;
        -:33828:    xmlRegexpPtr comp; /* the compiled regular expression */
        -:33829:    int n_comp;
        -:33830:
    #####:33831:    for (n_comp = 0;n_comp < gen_nb_xmlRegexpPtr;n_comp++) {
    #####:33832:        mem_base = xmlMemBlocks();
    #####:33833:        comp = gen_xmlRegexpPtr(n_comp, 0);
        -:33834:
    #####:33835:        ret_val = xmlRegexpIsDeterminist(comp);
    #####:33836:        desret_int(ret_val);
    #####:33837:        call_tests++;
    #####:33838:        des_xmlRegexpPtr(n_comp, comp, 0);
    #####:33839:        xmlResetLastError();
    #####:33840:        if (mem_base != xmlMemBlocks()) {
    #####:33841:            printf("Leak of %d blocks found in xmlRegexpIsDeterminist",
    #####:33842:	           xmlMemBlocks() - mem_base);
    #####:33843:	    test_ret++;
    #####:33844:            printf(" %d", n_comp);
    #####:33845:            printf("\n");
        -:33846:        }
        -:33847:    }
    #####:33848:    function_tests++;
        -:33849:#endif
        -:33850:
    #####:33851:    return(test_ret);
        -:33852:}
        -:33853:
        -:33854:
        -:33855:static int
    #####:33856:test_xmlRegexpPrint(void) {
    #####:33857:    int test_ret = 0;
        -:33858:
        -:33859:#if defined(LIBXML_REGEXP_ENABLED)
        -:33860:    int mem_base;
        -:33861:    FILE * output; /* the file for the output debug */
        -:33862:    int n_output;
        -:33863:    xmlRegexpPtr regexp; /* the compiled regexp */
        -:33864:    int n_regexp;
        -:33865:
    #####:33866:    for (n_output = 0;n_output < gen_nb_FILE_ptr;n_output++) {
    #####:33867:    for (n_regexp = 0;n_regexp < gen_nb_xmlRegexpPtr;n_regexp++) {
    #####:33868:        mem_base = xmlMemBlocks();
    #####:33869:        output = gen_FILE_ptr(n_output, 0);
    #####:33870:        regexp = gen_xmlRegexpPtr(n_regexp, 1);
        -:33871:
    #####:33872:        xmlRegexpPrint(output, regexp);
    #####:33873:        call_tests++;
    #####:33874:        des_FILE_ptr(n_output, output, 0);
    #####:33875:        des_xmlRegexpPtr(n_regexp, regexp, 1);
    #####:33876:        xmlResetLastError();
    #####:33877:        if (mem_base != xmlMemBlocks()) {
    #####:33878:            printf("Leak of %d blocks found in xmlRegexpPrint",
    #####:33879:	           xmlMemBlocks() - mem_base);
    #####:33880:	    test_ret++;
    #####:33881:            printf(" %d", n_output);
    #####:33882:            printf(" %d", n_regexp);
    #####:33883:            printf("\n");
        -:33884:        }
        -:33885:    }
        -:33886:    }
    #####:33887:    function_tests++;
        -:33888:#endif
        -:33889:
    #####:33890:    return(test_ret);
        -:33891:}
        -:33892:
        -:33893:static int
    #####:33894:test_xmlregexp(void) {
    #####:33895:    int test_ret = 0;
        -:33896:
    #####:33897:    if (quiet == 0) printf("Testing xmlregexp : 16 of 30 functions ...\n");
    #####:33898:    test_ret += test_xmlExpCtxtNbCons();
    #####:33899:    test_ret += test_xmlExpCtxtNbNodes();
    #####:33900:    test_ret += test_xmlExpDump();
    #####:33901:    test_ret += test_xmlExpExpDerive();
    #####:33902:    test_ret += test_xmlExpGetLanguage();
    #####:33903:    test_ret += test_xmlExpGetStart();
    #####:33904:    test_ret += test_xmlExpIsNillable();
    #####:33905:    test_ret += test_xmlExpMaxToken();
    #####:33906:    test_ret += test_xmlExpNewAtom();
    #####:33907:    test_ret += test_xmlExpNewCtxt();
    #####:33908:    test_ret += test_xmlExpNewOr();
    #####:33909:    test_ret += test_xmlExpNewRange();
    #####:33910:    test_ret += test_xmlExpNewSeq();
    #####:33911:    test_ret += test_xmlExpParse();
    #####:33912:    test_ret += test_xmlExpRef();
    #####:33913:    test_ret += test_xmlExpStringDerive();
    #####:33914:    test_ret += test_xmlExpSubsume();
    #####:33915:    test_ret += test_xmlRegExecErrInfo();
    #####:33916:    test_ret += test_xmlRegExecNextValues();
    #####:33917:    test_ret += test_xmlRegExecPushString();
    #####:33918:    test_ret += test_xmlRegExecPushString2();
    #####:33919:    test_ret += test_xmlRegNewExecCtxt();
    #####:33920:    test_ret += test_xmlRegexpCompile();
    #####:33921:    test_ret += test_xmlRegexpExec();
    #####:33922:    test_ret += test_xmlRegexpIsDeterminist();
    #####:33923:    test_ret += test_xmlRegexpPrint();
        -:33924:
    #####:33925:    if (test_ret != 0)
    #####:33926:	printf("Module xmlregexp: %d errors\n", test_ret);
    #####:33927:    return(test_ret);
        -:33928:}
        -:33929:#ifdef LIBXML_OUTPUT_ENABLED
        -:33930:
        -:33931:#define gen_nb_xmlSaveCtxtPtr 1
    #####:33932:static xmlSaveCtxtPtr gen_xmlSaveCtxtPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:33933:    return(NULL);
        -:33934:}
    #####:33935:static void des_xmlSaveCtxtPtr(int no ATTRIBUTE_UNUSED, xmlSaveCtxtPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:33936:}
        -:33937:#endif
        -:33938:
        -:33939:
        -:33940:static int
    #####:33941:test_xmlSaveClose(void) {
    #####:33942:    int test_ret = 0;
        -:33943:
        -:33944:#if defined(LIBXML_OUTPUT_ENABLED)
        -:33945:    int mem_base;
        -:33946:    int ret_val;
        -:33947:    xmlSaveCtxtPtr ctxt; /* a document saving context */
        -:33948:    int n_ctxt;
        -:33949:
    #####:33950:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSaveCtxtPtr;n_ctxt++) {
    #####:33951:        mem_base = xmlMemBlocks();
    #####:33952:        ctxt = gen_xmlSaveCtxtPtr(n_ctxt, 0);
        -:33953:
    #####:33954:        ret_val = xmlSaveClose(ctxt);
    #####:33955:        desret_int(ret_val);
    #####:33956:        call_tests++;
    #####:33957:        des_xmlSaveCtxtPtr(n_ctxt, ctxt, 0);
    #####:33958:        xmlResetLastError();
    #####:33959:        if (mem_base != xmlMemBlocks()) {
    #####:33960:            printf("Leak of %d blocks found in xmlSaveClose",
    #####:33961:	           xmlMemBlocks() - mem_base);
    #####:33962:	    test_ret++;
    #####:33963:            printf(" %d", n_ctxt);
    #####:33964:            printf("\n");
        -:33965:        }
        -:33966:    }
    #####:33967:    function_tests++;
        -:33968:#endif
        -:33969:
    #####:33970:    return(test_ret);
        -:33971:}
        -:33972:
        -:33973:
        -:33974:static int
    #####:33975:test_xmlSaveDoc(void) {
    #####:33976:    int test_ret = 0;
        -:33977:
        -:33978:#if defined(LIBXML_OUTPUT_ENABLED)
        -:33979:    int mem_base;
        -:33980:    long ret_val;
        -:33981:    xmlSaveCtxtPtr ctxt; /* a document saving context */
        -:33982:    int n_ctxt;
        -:33983:    xmlDocPtr doc; /* a document */
        -:33984:    int n_doc;
        -:33985:
    #####:33986:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSaveCtxtPtr;n_ctxt++) {
    #####:33987:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:33988:        mem_base = xmlMemBlocks();
    #####:33989:        ctxt = gen_xmlSaveCtxtPtr(n_ctxt, 0);
    #####:33990:        doc = gen_xmlDocPtr(n_doc, 1);
        -:33991:
    #####:33992:        ret_val = xmlSaveDoc(ctxt, doc);
    #####:33993:        desret_long(ret_val);
    #####:33994:        call_tests++;
    #####:33995:        des_xmlSaveCtxtPtr(n_ctxt, ctxt, 0);
    #####:33996:        des_xmlDocPtr(n_doc, doc, 1);
    #####:33997:        xmlResetLastError();
    #####:33998:        if (mem_base != xmlMemBlocks()) {
    #####:33999:            printf("Leak of %d blocks found in xmlSaveDoc",
    #####:34000:	           xmlMemBlocks() - mem_base);
    #####:34001:	    test_ret++;
    #####:34002:            printf(" %d", n_ctxt);
    #####:34003:            printf(" %d", n_doc);
    #####:34004:            printf("\n");
        -:34005:        }
        -:34006:    }
        -:34007:    }
    #####:34008:    function_tests++;
        -:34009:#endif
        -:34010:
    #####:34011:    return(test_ret);
        -:34012:}
        -:34013:
        -:34014:
        -:34015:static int
    #####:34016:test_xmlSaveFlush(void) {
    #####:34017:    int test_ret = 0;
        -:34018:
        -:34019:#if defined(LIBXML_OUTPUT_ENABLED)
        -:34020:    int mem_base;
        -:34021:    int ret_val;
        -:34022:    xmlSaveCtxtPtr ctxt; /* a document saving context */
        -:34023:    int n_ctxt;
        -:34024:
    #####:34025:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSaveCtxtPtr;n_ctxt++) {
    #####:34026:        mem_base = xmlMemBlocks();
    #####:34027:        ctxt = gen_xmlSaveCtxtPtr(n_ctxt, 0);
        -:34028:
    #####:34029:        ret_val = xmlSaveFlush(ctxt);
    #####:34030:        desret_int(ret_val);
    #####:34031:        call_tests++;
    #####:34032:        des_xmlSaveCtxtPtr(n_ctxt, ctxt, 0);
    #####:34033:        xmlResetLastError();
    #####:34034:        if (mem_base != xmlMemBlocks()) {
    #####:34035:            printf("Leak of %d blocks found in xmlSaveFlush",
    #####:34036:	           xmlMemBlocks() - mem_base);
    #####:34037:	    test_ret++;
    #####:34038:            printf(" %d", n_ctxt);
    #####:34039:            printf("\n");
        -:34040:        }
        -:34041:    }
    #####:34042:    function_tests++;
        -:34043:#endif
        -:34044:
    #####:34045:    return(test_ret);
        -:34046:}
        -:34047:
        -:34048:
        -:34049:static int
    #####:34050:test_xmlSaveSetAttrEscape(void) {
    #####:34051:    int test_ret = 0;
        -:34052:
        -:34053:
        -:34054:    /* missing type support */
    #####:34055:    return(test_ret);
        -:34056:}
        -:34057:
        -:34058:
        -:34059:static int
    #####:34060:test_xmlSaveSetEscape(void) {
    #####:34061:    int test_ret = 0;
        -:34062:
        -:34063:
        -:34064:    /* missing type support */
    #####:34065:    return(test_ret);
        -:34066:}
        -:34067:
        -:34068:
        -:34069:static int
    #####:34070:test_xmlSaveToBuffer(void) {
    #####:34071:    int test_ret = 0;
        -:34072:
        -:34073:
        -:34074:    /* missing type support */
    #####:34075:    return(test_ret);
        -:34076:}
        -:34077:
        -:34078:
        -:34079:static int
    #####:34080:test_xmlSaveToFd(void) {
    #####:34081:    int test_ret = 0;
        -:34082:
        -:34083:
        -:34084:    /* missing type support */
    #####:34085:    return(test_ret);
        -:34086:}
        -:34087:
        -:34088:
        -:34089:static int
    #####:34090:test_xmlSaveToFilename(void) {
    #####:34091:    int test_ret = 0;
        -:34092:
        -:34093:
        -:34094:    /* missing type support */
    #####:34095:    return(test_ret);
        -:34096:}
        -:34097:
        -:34098:
        -:34099:static int
    #####:34100:test_xmlSaveTree(void) {
    #####:34101:    int test_ret = 0;
        -:34102:
        -:34103:#if defined(LIBXML_OUTPUT_ENABLED)
        -:34104:    int mem_base;
        -:34105:    long ret_val;
        -:34106:    xmlSaveCtxtPtr ctxt; /* a document saving context */
        -:34107:    int n_ctxt;
        -:34108:    xmlNodePtr node; /* the top node of the subtree to save */
        -:34109:    int n_node;
        -:34110:
    #####:34111:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSaveCtxtPtr;n_ctxt++) {
    #####:34112:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:34113:        mem_base = xmlMemBlocks();
    #####:34114:        ctxt = gen_xmlSaveCtxtPtr(n_ctxt, 0);
    #####:34115:        node = gen_xmlNodePtr(n_node, 1);
        -:34116:
    #####:34117:        ret_val = xmlSaveTree(ctxt, node);
    #####:34118:        desret_long(ret_val);
    #####:34119:        call_tests++;
    #####:34120:        des_xmlSaveCtxtPtr(n_ctxt, ctxt, 0);
    #####:34121:        des_xmlNodePtr(n_node, node, 1);
    #####:34122:        xmlResetLastError();
    #####:34123:        if (mem_base != xmlMemBlocks()) {
    #####:34124:            printf("Leak of %d blocks found in xmlSaveTree",
    #####:34125:	           xmlMemBlocks() - mem_base);
    #####:34126:	    test_ret++;
    #####:34127:            printf(" %d", n_ctxt);
    #####:34128:            printf(" %d", n_node);
    #####:34129:            printf("\n");
        -:34130:        }
        -:34131:    }
        -:34132:    }
    #####:34133:    function_tests++;
        -:34134:#endif
        -:34135:
    #####:34136:    return(test_ret);
        -:34137:}
        -:34138:
        -:34139:static int
    #####:34140:test_xmlsave(void) {
    #####:34141:    int test_ret = 0;
        -:34142:
    #####:34143:    if (quiet == 0) printf("Testing xmlsave : 4 of 10 functions ...\n");
    #####:34144:    test_ret += test_xmlSaveClose();
    #####:34145:    test_ret += test_xmlSaveDoc();
    #####:34146:    test_ret += test_xmlSaveFlush();
    #####:34147:    test_ret += test_xmlSaveSetAttrEscape();
    #####:34148:    test_ret += test_xmlSaveSetEscape();
    #####:34149:    test_ret += test_xmlSaveToBuffer();
    #####:34150:    test_ret += test_xmlSaveToFd();
    #####:34151:    test_ret += test_xmlSaveToFilename();
    #####:34152:    test_ret += test_xmlSaveTree();
        -:34153:
    #####:34154:    if (test_ret != 0)
    #####:34155:	printf("Module xmlsave: %d errors\n", test_ret);
    #####:34156:    return(test_ret);
        -:34157:}
        -:34158:
        -:34159:static int
    #####:34160:test_xmlSchemaDump(void) {
    #####:34161:    int test_ret = 0;
        -:34162:
        -:34163:#if defined(LIBXML_SCHEMAS_ENABLED) && defined(LIBXML_OUTPUT_ENABLED)
        -:34164:    int mem_base;
        -:34165:    FILE * output; /* the file output */
        -:34166:    int n_output;
        -:34167:    xmlSchemaPtr schema; /* a schema structure */
        -:34168:    int n_schema;
        -:34169:
    #####:34170:    for (n_output = 0;n_output < gen_nb_FILE_ptr;n_output++) {
    #####:34171:    for (n_schema = 0;n_schema < gen_nb_xmlSchemaPtr;n_schema++) {
    #####:34172:        mem_base = xmlMemBlocks();
    #####:34173:        output = gen_FILE_ptr(n_output, 0);
    #####:34174:        schema = gen_xmlSchemaPtr(n_schema, 1);
        -:34175:
    #####:34176:        xmlSchemaDump(output, schema);
    #####:34177:        call_tests++;
    #####:34178:        des_FILE_ptr(n_output, output, 0);
    #####:34179:        des_xmlSchemaPtr(n_schema, schema, 1);
    #####:34180:        xmlResetLastError();
    #####:34181:        if (mem_base != xmlMemBlocks()) {
    #####:34182:            printf("Leak of %d blocks found in xmlSchemaDump",
    #####:34183:	           xmlMemBlocks() - mem_base);
    #####:34184:	    test_ret++;
    #####:34185:            printf(" %d", n_output);
    #####:34186:            printf(" %d", n_schema);
    #####:34187:            printf("\n");
        -:34188:        }
        -:34189:    }
        -:34190:    }
    #####:34191:    function_tests++;
        -:34192:#endif
        -:34193:
    #####:34194:    return(test_ret);
        -:34195:}
        -:34196:
        -:34197:#ifdef LIBXML_SCHEMAS_ENABLED
        -:34198:
        -:34199:#define gen_nb_xmlSchemaParserCtxtPtr 1
    #####:34200:static xmlSchemaParserCtxtPtr gen_xmlSchemaParserCtxtPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:34201:    return(NULL);
        -:34202:}
    #####:34203:static void des_xmlSchemaParserCtxtPtr(int no ATTRIBUTE_UNUSED, xmlSchemaParserCtxtPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:34204:}
        -:34205:#endif
        -:34206:
        -:34207:#ifdef LIBXML_SCHEMAS_ENABLED
        -:34208:
        -:34209:#define gen_nb_xmlSchemaValidityErrorFunc_ptr 1
    #####:34210:static xmlSchemaValidityErrorFunc * gen_xmlSchemaValidityErrorFunc_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:34211:    return(NULL);
        -:34212:}
    #####:34213:static void des_xmlSchemaValidityErrorFunc_ptr(int no ATTRIBUTE_UNUSED, xmlSchemaValidityErrorFunc * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:34214:}
        -:34215:#endif
        -:34216:
        -:34217:#ifdef LIBXML_SCHEMAS_ENABLED
        -:34218:
        -:34219:#define gen_nb_xmlSchemaValidityWarningFunc_ptr 1
    #####:34220:static xmlSchemaValidityWarningFunc * gen_xmlSchemaValidityWarningFunc_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:34221:    return(NULL);
        -:34222:}
    #####:34223:static void des_xmlSchemaValidityWarningFunc_ptr(int no ATTRIBUTE_UNUSED, xmlSchemaValidityWarningFunc * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:34224:}
        -:34225:#endif
        -:34226:
        -:34227:
        -:34228:static int
    #####:34229:test_xmlSchemaGetParserErrors(void) {
    #####:34230:    int test_ret = 0;
        -:34231:
        -:34232:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:34233:    int mem_base;
        -:34234:    int ret_val;
        -:34235:    xmlSchemaParserCtxtPtr ctxt; /* a XMl-Schema parser context */
        -:34236:    int n_ctxt;
        -:34237:    xmlSchemaValidityErrorFunc * err; /* the error callback result */
        -:34238:    int n_err;
        -:34239:    xmlSchemaValidityWarningFunc * warn; /* the warning callback result */
        -:34240:    int n_warn;
        -:34241:    void ** ctx; /* contextual data for the callbacks result */
        -:34242:    int n_ctx;
        -:34243:
    #####:34244:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaParserCtxtPtr;n_ctxt++) {
    #####:34245:    for (n_err = 0;n_err < gen_nb_xmlSchemaValidityErrorFunc_ptr;n_err++) {
    #####:34246:    for (n_warn = 0;n_warn < gen_nb_xmlSchemaValidityWarningFunc_ptr;n_warn++) {
    #####:34247:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr_ptr;n_ctx++) {
    #####:34248:        mem_base = xmlMemBlocks();
    #####:34249:        ctxt = gen_xmlSchemaParserCtxtPtr(n_ctxt, 0);
    #####:34250:        err = gen_xmlSchemaValidityErrorFunc_ptr(n_err, 1);
    #####:34251:        warn = gen_xmlSchemaValidityWarningFunc_ptr(n_warn, 2);
    #####:34252:        ctx = gen_void_ptr_ptr(n_ctx, 3);
        -:34253:
    #####:34254:        ret_val = xmlSchemaGetParserErrors(ctxt, err, warn, ctx);
    #####:34255:        desret_int(ret_val);
    #####:34256:        call_tests++;
    #####:34257:        des_xmlSchemaParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:34258:        des_xmlSchemaValidityErrorFunc_ptr(n_err, err, 1);
    #####:34259:        des_xmlSchemaValidityWarningFunc_ptr(n_warn, warn, 2);
    #####:34260:        des_void_ptr_ptr(n_ctx, ctx, 3);
    #####:34261:        xmlResetLastError();
    #####:34262:        if (mem_base != xmlMemBlocks()) {
    #####:34263:            printf("Leak of %d blocks found in xmlSchemaGetParserErrors",
    #####:34264:	           xmlMemBlocks() - mem_base);
    #####:34265:	    test_ret++;
    #####:34266:            printf(" %d", n_ctxt);
    #####:34267:            printf(" %d", n_err);
    #####:34268:            printf(" %d", n_warn);
    #####:34269:            printf(" %d", n_ctx);
    #####:34270:            printf("\n");
        -:34271:        }
        -:34272:    }
        -:34273:    }
        -:34274:    }
        -:34275:    }
    #####:34276:    function_tests++;
        -:34277:#endif
        -:34278:
    #####:34279:    return(test_ret);
        -:34280:}
        -:34281:
        -:34282:
        -:34283:static int
    #####:34284:test_xmlSchemaGetValidErrors(void) {
    #####:34285:    int test_ret = 0;
        -:34286:
        -:34287:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:34288:    int mem_base;
        -:34289:    int ret_val;
        -:34290:    xmlSchemaValidCtxtPtr ctxt; /* a XML-Schema validation context */
        -:34291:    int n_ctxt;
        -:34292:    xmlSchemaValidityErrorFunc * err; /* the error function result */
        -:34293:    int n_err;
        -:34294:    xmlSchemaValidityWarningFunc * warn; /* the warning function result */
        -:34295:    int n_warn;
        -:34296:    void ** ctx; /* the functions context result */
        -:34297:    int n_ctx;
        -:34298:
    #####:34299:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
    #####:34300:    for (n_err = 0;n_err < gen_nb_xmlSchemaValidityErrorFunc_ptr;n_err++) {
    #####:34301:    for (n_warn = 0;n_warn < gen_nb_xmlSchemaValidityWarningFunc_ptr;n_warn++) {
    #####:34302:    for (n_ctx = 0;n_ctx < gen_nb_void_ptr_ptr;n_ctx++) {
    #####:34303:        mem_base = xmlMemBlocks();
    #####:34304:        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
    #####:34305:        err = gen_xmlSchemaValidityErrorFunc_ptr(n_err, 1);
    #####:34306:        warn = gen_xmlSchemaValidityWarningFunc_ptr(n_warn, 2);
    #####:34307:        ctx = gen_void_ptr_ptr(n_ctx, 3);
        -:34308:
    #####:34309:        ret_val = xmlSchemaGetValidErrors(ctxt, err, warn, ctx);
    #####:34310:        desret_int(ret_val);
    #####:34311:        call_tests++;
    #####:34312:        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:34313:        des_xmlSchemaValidityErrorFunc_ptr(n_err, err, 1);
    #####:34314:        des_xmlSchemaValidityWarningFunc_ptr(n_warn, warn, 2);
    #####:34315:        des_void_ptr_ptr(n_ctx, ctx, 3);
    #####:34316:        xmlResetLastError();
    #####:34317:        if (mem_base != xmlMemBlocks()) {
    #####:34318:            printf("Leak of %d blocks found in xmlSchemaGetValidErrors",
    #####:34319:	           xmlMemBlocks() - mem_base);
    #####:34320:	    test_ret++;
    #####:34321:            printf(" %d", n_ctxt);
    #####:34322:            printf(" %d", n_err);
    #####:34323:            printf(" %d", n_warn);
    #####:34324:            printf(" %d", n_ctx);
    #####:34325:            printf("\n");
        -:34326:        }
        -:34327:    }
        -:34328:    }
        -:34329:    }
        -:34330:    }
    #####:34331:    function_tests++;
        -:34332:#endif
        -:34333:
    #####:34334:    return(test_ret);
        -:34335:}
        -:34336:
        -:34337:
        -:34338:static int
    #####:34339:test_xmlSchemaIsValid(void) {
    #####:34340:    int test_ret = 0;
        -:34341:
        -:34342:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:34343:    int mem_base;
        -:34344:    int ret_val;
        -:34345:    xmlSchemaValidCtxtPtr ctxt; /* the schema validation context */
        -:34346:    int n_ctxt;
        -:34347:
    #####:34348:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
    #####:34349:        mem_base = xmlMemBlocks();
    #####:34350:        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
        -:34351:
    #####:34352:        ret_val = xmlSchemaIsValid(ctxt);
    #####:34353:        desret_int(ret_val);
    #####:34354:        call_tests++;
    #####:34355:        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:34356:        xmlResetLastError();
    #####:34357:        if (mem_base != xmlMemBlocks()) {
    #####:34358:            printf("Leak of %d blocks found in xmlSchemaIsValid",
    #####:34359:	           xmlMemBlocks() - mem_base);
    #####:34360:	    test_ret++;
    #####:34361:            printf(" %d", n_ctxt);
    #####:34362:            printf("\n");
        -:34363:        }
        -:34364:    }
    #####:34365:    function_tests++;
        -:34366:#endif
        -:34367:
    #####:34368:    return(test_ret);
        -:34369:}
        -:34370:
        -:34371:
        -:34372:static int
    #####:34373:test_xmlSchemaNewDocParserCtxt(void) {
    #####:34374:    int test_ret = 0;
        -:34375:
        -:34376:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:34377:    int mem_base;
        -:34378:    xmlSchemaParserCtxtPtr ret_val;
        -:34379:    xmlDocPtr doc; /* a preparsed document tree */
        -:34380:    int n_doc;
        -:34381:
    #####:34382:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:34383:        mem_base = xmlMemBlocks();
    #####:34384:        doc = gen_xmlDocPtr(n_doc, 0);
        -:34385:
    #####:34386:        ret_val = xmlSchemaNewDocParserCtxt(doc);
    #####:34387:        desret_xmlSchemaParserCtxtPtr(ret_val);
    #####:34388:        call_tests++;
    #####:34389:        des_xmlDocPtr(n_doc, doc, 0);
    #####:34390:        xmlResetLastError();
    #####:34391:        if (mem_base != xmlMemBlocks()) {
    #####:34392:            printf("Leak of %d blocks found in xmlSchemaNewDocParserCtxt",
    #####:34393:	           xmlMemBlocks() - mem_base);
    #####:34394:	    test_ret++;
    #####:34395:            printf(" %d", n_doc);
    #####:34396:            printf("\n");
        -:34397:        }
        -:34398:    }
    #####:34399:    function_tests++;
        -:34400:#endif
        -:34401:
    #####:34402:    return(test_ret);
        -:34403:}
        -:34404:
        -:34405:
        -:34406:static int
    #####:34407:test_xmlSchemaNewMemParserCtxt(void) {
    #####:34408:    int test_ret = 0;
        -:34409:
        -:34410:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:34411:    int mem_base;
        -:34412:    xmlSchemaParserCtxtPtr ret_val;
        -:34413:    char * buffer; /* a pointer to a char array containing the schemas */
        -:34414:    int n_buffer;
        -:34415:    int size; /* the size of the array */
        -:34416:    int n_size;
        -:34417:
    #####:34418:    for (n_buffer = 0;n_buffer < gen_nb_const_char_ptr;n_buffer++) {
    #####:34419:    for (n_size = 0;n_size < gen_nb_int;n_size++) {
    #####:34420:        mem_base = xmlMemBlocks();
    #####:34421:        buffer = gen_const_char_ptr(n_buffer, 0);
    #####:34422:        size = gen_int(n_size, 1);
        -:34423:
    #####:34424:        ret_val = xmlSchemaNewMemParserCtxt((const char *)buffer, size);
    #####:34425:        desret_xmlSchemaParserCtxtPtr(ret_val);
    #####:34426:        call_tests++;
    #####:34427:        des_const_char_ptr(n_buffer, (const char *)buffer, 0);
    #####:34428:        des_int(n_size, size, 1);
    #####:34429:        xmlResetLastError();
    #####:34430:        if (mem_base != xmlMemBlocks()) {
    #####:34431:            printf("Leak of %d blocks found in xmlSchemaNewMemParserCtxt",
    #####:34432:	           xmlMemBlocks() - mem_base);
    #####:34433:	    test_ret++;
    #####:34434:            printf(" %d", n_buffer);
    #####:34435:            printf(" %d", n_size);
    #####:34436:            printf("\n");
        -:34437:        }
        -:34438:    }
        -:34439:    }
    #####:34440:    function_tests++;
        -:34441:#endif
        -:34442:
    #####:34443:    return(test_ret);
        -:34444:}
        -:34445:
        -:34446:
        -:34447:static int
    #####:34448:test_xmlSchemaNewParserCtxt(void) {
    #####:34449:    int test_ret = 0;
        -:34450:
        -:34451:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:34452:    int mem_base;
        -:34453:    xmlSchemaParserCtxtPtr ret_val;
        -:34454:    char * URL; /* the location of the schema */
        -:34455:    int n_URL;
        -:34456:
    #####:34457:    for (n_URL = 0;n_URL < gen_nb_const_char_ptr;n_URL++) {
    #####:34458:        mem_base = xmlMemBlocks();
    #####:34459:        URL = gen_const_char_ptr(n_URL, 0);
        -:34460:
    #####:34461:        ret_val = xmlSchemaNewParserCtxt((const char *)URL);
    #####:34462:        desret_xmlSchemaParserCtxtPtr(ret_val);
    #####:34463:        call_tests++;
    #####:34464:        des_const_char_ptr(n_URL, (const char *)URL, 0);
    #####:34465:        xmlResetLastError();
    #####:34466:        if (mem_base != xmlMemBlocks()) {
    #####:34467:            printf("Leak of %d blocks found in xmlSchemaNewParserCtxt",
    #####:34468:	           xmlMemBlocks() - mem_base);
    #####:34469:	    test_ret++;
    #####:34470:            printf(" %d", n_URL);
    #####:34471:            printf("\n");
        -:34472:        }
        -:34473:    }
    #####:34474:    function_tests++;
        -:34475:#endif
        -:34476:
    #####:34477:    return(test_ret);
        -:34478:}
        -:34479:
        -:34480:
        -:34481:static int
    #####:34482:test_xmlSchemaNewValidCtxt(void) {
    #####:34483:    int test_ret = 0;
        -:34484:
        -:34485:
        -:34486:    /* missing type support */
    #####:34487:    return(test_ret);
        -:34488:}
        -:34489:
        -:34490:
        -:34491:static int
    #####:34492:test_xmlSchemaParse(void) {
    #####:34493:    int test_ret = 0;
        -:34494:
        -:34495:
        -:34496:    /* missing type support */
    #####:34497:    return(test_ret);
        -:34498:}
        -:34499:
        -:34500:#ifdef LIBXML_SCHEMAS_ENABLED
        -:34501:
        -:34502:#define gen_nb_xmlSAXHandlerPtr_ptr 1
    #####:34503:static xmlSAXHandlerPtr * gen_xmlSAXHandlerPtr_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:34504:    return(NULL);
        -:34505:}
    #####:34506:static void des_xmlSAXHandlerPtr_ptr(int no ATTRIBUTE_UNUSED, xmlSAXHandlerPtr * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:34507:}
        -:34508:#endif
        -:34509:
        -:34510:
        -:34511:static int
    #####:34512:test_xmlSchemaSAXPlug(void) {
    #####:34513:    int test_ret = 0;
        -:34514:
        -:34515:
        -:34516:    /* missing type support */
    #####:34517:    return(test_ret);
        -:34518:}
        -:34519:
        -:34520:#ifdef LIBXML_SCHEMAS_ENABLED
        -:34521:
        -:34522:#define gen_nb_xmlSchemaSAXPlugPtr 1
    #####:34523:static xmlSchemaSAXPlugPtr gen_xmlSchemaSAXPlugPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:34524:    return(NULL);
        -:34525:}
    #####:34526:static void des_xmlSchemaSAXPlugPtr(int no ATTRIBUTE_UNUSED, xmlSchemaSAXPlugPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:34527:}
        -:34528:#endif
        -:34529:
        -:34530:
        -:34531:static int
    #####:34532:test_xmlSchemaSAXUnplug(void) {
    #####:34533:    int test_ret = 0;
        -:34534:
        -:34535:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:34536:    int mem_base;
        -:34537:    int ret_val;
        -:34538:    xmlSchemaSAXPlugPtr plug; /* a data structure returned by xmlSchemaSAXPlug */
        -:34539:    int n_plug;
        -:34540:
    #####:34541:    for (n_plug = 0;n_plug < gen_nb_xmlSchemaSAXPlugPtr;n_plug++) {
    #####:34542:        mem_base = xmlMemBlocks();
    #####:34543:        plug = gen_xmlSchemaSAXPlugPtr(n_plug, 0);
        -:34544:
    #####:34545:        ret_val = xmlSchemaSAXUnplug(plug);
    #####:34546:        desret_int(ret_val);
    #####:34547:        call_tests++;
    #####:34548:        des_xmlSchemaSAXPlugPtr(n_plug, plug, 0);
    #####:34549:        xmlResetLastError();
    #####:34550:        if (mem_base != xmlMemBlocks()) {
    #####:34551:            printf("Leak of %d blocks found in xmlSchemaSAXUnplug",
    #####:34552:	           xmlMemBlocks() - mem_base);
    #####:34553:	    test_ret++;
    #####:34554:            printf(" %d", n_plug);
    #####:34555:            printf("\n");
        -:34556:        }
        -:34557:    }
    #####:34558:    function_tests++;
        -:34559:#endif
        -:34560:
    #####:34561:    return(test_ret);
        -:34562:}
        -:34563:
        -:34564:
        -:34565:static int
    #####:34566:test_xmlSchemaSetParserErrors(void) {
    #####:34567:    int test_ret = 0;
        -:34568:
        -:34569:
        -:34570:    /* missing type support */
    #####:34571:    return(test_ret);
        -:34572:}
        -:34573:
        -:34574:
        -:34575:static int
    #####:34576:test_xmlSchemaSetParserStructuredErrors(void) {
    #####:34577:    int test_ret = 0;
        -:34578:
        -:34579:
        -:34580:    /* missing type support */
    #####:34581:    return(test_ret);
        -:34582:}
        -:34583:
        -:34584:
        -:34585:static int
    #####:34586:test_xmlSchemaSetValidErrors(void) {
    #####:34587:    int test_ret = 0;
        -:34588:
        -:34589:
        -:34590:    /* missing type support */
    #####:34591:    return(test_ret);
        -:34592:}
        -:34593:
        -:34594:
        -:34595:static int
    #####:34596:test_xmlSchemaSetValidOptions(void) {
    #####:34597:    int test_ret = 0;
        -:34598:
        -:34599:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:34600:    int mem_base;
        -:34601:    int ret_val;
        -:34602:    xmlSchemaValidCtxtPtr ctxt; /* a schema validation context */
        -:34603:    int n_ctxt;
        -:34604:    int options; /* a combination of xmlSchemaValidOption */
        -:34605:    int n_options;
        -:34606:
    #####:34607:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
    #####:34608:    for (n_options = 0;n_options < gen_nb_int;n_options++) {
    #####:34609:        mem_base = xmlMemBlocks();
    #####:34610:        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
    #####:34611:        options = gen_int(n_options, 1);
        -:34612:
    #####:34613:        ret_val = xmlSchemaSetValidOptions(ctxt, options);
    #####:34614:        desret_int(ret_val);
    #####:34615:        call_tests++;
    #####:34616:        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:34617:        des_int(n_options, options, 1);
    #####:34618:        xmlResetLastError();
    #####:34619:        if (mem_base != xmlMemBlocks()) {
    #####:34620:            printf("Leak of %d blocks found in xmlSchemaSetValidOptions",
    #####:34621:	           xmlMemBlocks() - mem_base);
    #####:34622:	    test_ret++;
    #####:34623:            printf(" %d", n_ctxt);
    #####:34624:            printf(" %d", n_options);
    #####:34625:            printf("\n");
        -:34626:        }
        -:34627:    }
        -:34628:    }
    #####:34629:    function_tests++;
        -:34630:#endif
        -:34631:
    #####:34632:    return(test_ret);
        -:34633:}
        -:34634:
        -:34635:
        -:34636:static int
    #####:34637:test_xmlSchemaSetValidStructuredErrors(void) {
    #####:34638:    int test_ret = 0;
        -:34639:
        -:34640:
        -:34641:    /* missing type support */
    #####:34642:    return(test_ret);
        -:34643:}
        -:34644:
        -:34645:
        -:34646:static int
    #####:34647:test_xmlSchemaValidCtxtGetOptions(void) {
    #####:34648:    int test_ret = 0;
        -:34649:
        -:34650:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:34651:    int mem_base;
        -:34652:    int ret_val;
        -:34653:    xmlSchemaValidCtxtPtr ctxt; /* a schema validation context */
        -:34654:    int n_ctxt;
        -:34655:
    #####:34656:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
    #####:34657:        mem_base = xmlMemBlocks();
    #####:34658:        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
        -:34659:
    #####:34660:        ret_val = xmlSchemaValidCtxtGetOptions(ctxt);
    #####:34661:        desret_int(ret_val);
    #####:34662:        call_tests++;
    #####:34663:        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:34664:        xmlResetLastError();
    #####:34665:        if (mem_base != xmlMemBlocks()) {
    #####:34666:            printf("Leak of %d blocks found in xmlSchemaValidCtxtGetOptions",
    #####:34667:	           xmlMemBlocks() - mem_base);
    #####:34668:	    test_ret++;
    #####:34669:            printf(" %d", n_ctxt);
    #####:34670:            printf("\n");
        -:34671:        }
        -:34672:    }
    #####:34673:    function_tests++;
        -:34674:#endif
        -:34675:
    #####:34676:    return(test_ret);
        -:34677:}
        -:34678:
        -:34679:
        -:34680:static int
    #####:34681:test_xmlSchemaValidCtxtGetParserCtxt(void) {
    #####:34682:    int test_ret = 0;
        -:34683:
        -:34684:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:34685:    int mem_base;
        -:34686:    xmlParserCtxtPtr ret_val;
        -:34687:    xmlSchemaValidCtxtPtr ctxt; /* a schema validation context */
        -:34688:    int n_ctxt;
        -:34689:
    #####:34690:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
    #####:34691:        mem_base = xmlMemBlocks();
    #####:34692:        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
        -:34693:
    #####:34694:        ret_val = xmlSchemaValidCtxtGetParserCtxt(ctxt);
    #####:34695:        desret_xmlParserCtxtPtr(ret_val);
    #####:34696:        call_tests++;
    #####:34697:        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:34698:        xmlResetLastError();
    #####:34699:        if (mem_base != xmlMemBlocks()) {
    #####:34700:            printf("Leak of %d blocks found in xmlSchemaValidCtxtGetParserCtxt",
    #####:34701:	           xmlMemBlocks() - mem_base);
    #####:34702:	    test_ret++;
    #####:34703:            printf(" %d", n_ctxt);
    #####:34704:            printf("\n");
        -:34705:        }
        -:34706:    }
    #####:34707:    function_tests++;
        -:34708:#endif
        -:34709:
    #####:34710:    return(test_ret);
        -:34711:}
        -:34712:
        -:34713:
        -:34714:static int
    #####:34715:test_xmlSchemaValidateDoc(void) {
    #####:34716:    int test_ret = 0;
        -:34717:
        -:34718:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:34719:    int mem_base;
        -:34720:    int ret_val;
        -:34721:    xmlSchemaValidCtxtPtr ctxt; /* a schema validation context */
        -:34722:    int n_ctxt;
        -:34723:    xmlDocPtr doc; /* a parsed document tree */
        -:34724:    int n_doc;
        -:34725:
    #####:34726:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
    #####:34727:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:34728:        mem_base = xmlMemBlocks();
    #####:34729:        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
    #####:34730:        doc = gen_xmlDocPtr(n_doc, 1);
        -:34731:
    #####:34732:        ret_val = xmlSchemaValidateDoc(ctxt, doc);
    #####:34733:        desret_int(ret_val);
    #####:34734:        call_tests++;
    #####:34735:        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:34736:        des_xmlDocPtr(n_doc, doc, 1);
    #####:34737:        xmlResetLastError();
    #####:34738:        if (mem_base != xmlMemBlocks()) {
    #####:34739:            printf("Leak of %d blocks found in xmlSchemaValidateDoc",
    #####:34740:	           xmlMemBlocks() - mem_base);
    #####:34741:	    test_ret++;
    #####:34742:            printf(" %d", n_ctxt);
    #####:34743:            printf(" %d", n_doc);
    #####:34744:            printf("\n");
        -:34745:        }
        -:34746:    }
        -:34747:    }
    #####:34748:    function_tests++;
        -:34749:#endif
        -:34750:
    #####:34751:    return(test_ret);
        -:34752:}
        -:34753:
        -:34754:
        -:34755:static int
    #####:34756:test_xmlSchemaValidateFile(void) {
    #####:34757:    int test_ret = 0;
        -:34758:
        -:34759:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:34760:    int mem_base;
        -:34761:    int ret_val;
        -:34762:    xmlSchemaValidCtxtPtr ctxt; /* a schema validation context */
        -:34763:    int n_ctxt;
        -:34764:    const char * filename; /* the URI of the instance */
        -:34765:    int n_filename;
        -:34766:    int options; /* a future set of options, currently unused */
        -:34767:    int n_options;
        -:34768:
    #####:34769:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
    #####:34770:    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    #####:34771:    for (n_options = 0;n_options < gen_nb_int;n_options++) {
    #####:34772:        mem_base = xmlMemBlocks();
    #####:34773:        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
    #####:34774:        filename = gen_filepath(n_filename, 1);
    #####:34775:        options = gen_int(n_options, 2);
        -:34776:
    #####:34777:        ret_val = xmlSchemaValidateFile(ctxt, filename, options);
    #####:34778:        desret_int(ret_val);
    #####:34779:        call_tests++;
    #####:34780:        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:34781:        des_filepath(n_filename, filename, 1);
    #####:34782:        des_int(n_options, options, 2);
    #####:34783:        xmlResetLastError();
    #####:34784:        if (mem_base != xmlMemBlocks()) {
    #####:34785:            printf("Leak of %d blocks found in xmlSchemaValidateFile",
    #####:34786:	           xmlMemBlocks() - mem_base);
    #####:34787:	    test_ret++;
    #####:34788:            printf(" %d", n_ctxt);
    #####:34789:            printf(" %d", n_filename);
    #####:34790:            printf(" %d", n_options);
    #####:34791:            printf("\n");
        -:34792:        }
        -:34793:    }
        -:34794:    }
        -:34795:    }
    #####:34796:    function_tests++;
        -:34797:#endif
        -:34798:
    #####:34799:    return(test_ret);
        -:34800:}
        -:34801:
        -:34802:
        -:34803:static int
    #####:34804:test_xmlSchemaValidateOneElement(void) {
    #####:34805:    int test_ret = 0;
        -:34806:
        -:34807:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:34808:    int mem_base;
        -:34809:    int ret_val;
        -:34810:    xmlSchemaValidCtxtPtr ctxt; /* a schema validation context */
        -:34811:    int n_ctxt;
        -:34812:    xmlNodePtr elem; /* an element node */
        -:34813:    int n_elem;
        -:34814:
    #####:34815:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
    #####:34816:    for (n_elem = 0;n_elem < gen_nb_xmlNodePtr;n_elem++) {
    #####:34817:        mem_base = xmlMemBlocks();
    #####:34818:        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
    #####:34819:        elem = gen_xmlNodePtr(n_elem, 1);
        -:34820:
    #####:34821:        ret_val = xmlSchemaValidateOneElement(ctxt, elem);
    #####:34822:        desret_int(ret_val);
    #####:34823:        call_tests++;
    #####:34824:        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:34825:        des_xmlNodePtr(n_elem, elem, 1);
    #####:34826:        xmlResetLastError();
    #####:34827:        if (mem_base != xmlMemBlocks()) {
    #####:34828:            printf("Leak of %d blocks found in xmlSchemaValidateOneElement",
    #####:34829:	           xmlMemBlocks() - mem_base);
    #####:34830:	    test_ret++;
    #####:34831:            printf(" %d", n_ctxt);
    #####:34832:            printf(" %d", n_elem);
    #####:34833:            printf("\n");
        -:34834:        }
        -:34835:    }
        -:34836:    }
    #####:34837:    function_tests++;
        -:34838:#endif
        -:34839:
    #####:34840:    return(test_ret);
        -:34841:}
        -:34842:
        -:34843:
        -:34844:static int
    #####:34845:test_xmlSchemaValidateSetFilename(void) {
    #####:34846:    int test_ret = 0;
        -:34847:
        -:34848:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:34849:    int mem_base;
        -:34850:    xmlSchemaValidCtxtPtr vctxt; /* the schema validation context */
        -:34851:    int n_vctxt;
        -:34852:    const char * filename; /* the file name */
        -:34853:    int n_filename;
        -:34854:
    #####:34855:    for (n_vctxt = 0;n_vctxt < gen_nb_xmlSchemaValidCtxtPtr;n_vctxt++) {
    #####:34856:    for (n_filename = 0;n_filename < gen_nb_filepath;n_filename++) {
    #####:34857:        mem_base = xmlMemBlocks();
    #####:34858:        vctxt = gen_xmlSchemaValidCtxtPtr(n_vctxt, 0);
    #####:34859:        filename = gen_filepath(n_filename, 1);
        -:34860:
    #####:34861:        xmlSchemaValidateSetFilename(vctxt, filename);
    #####:34862:        call_tests++;
    #####:34863:        des_xmlSchemaValidCtxtPtr(n_vctxt, vctxt, 0);
    #####:34864:        des_filepath(n_filename, filename, 1);
    #####:34865:        xmlResetLastError();
    #####:34866:        if (mem_base != xmlMemBlocks()) {
    #####:34867:            printf("Leak of %d blocks found in xmlSchemaValidateSetFilename",
    #####:34868:	           xmlMemBlocks() - mem_base);
    #####:34869:	    test_ret++;
    #####:34870:            printf(" %d", n_vctxt);
    #####:34871:            printf(" %d", n_filename);
    #####:34872:            printf("\n");
        -:34873:        }
        -:34874:    }
        -:34875:    }
    #####:34876:    function_tests++;
        -:34877:#endif
        -:34878:
    #####:34879:    return(test_ret);
        -:34880:}
        -:34881:
        -:34882:
        -:34883:static int
    #####:34884:test_xmlSchemaValidateSetLocator(void) {
    #####:34885:    int test_ret = 0;
        -:34886:
        -:34887:
        -:34888:    /* missing type support */
    #####:34889:    return(test_ret);
        -:34890:}
        -:34891:
        -:34892:
        -:34893:static int
    #####:34894:test_xmlSchemaValidateStream(void) {
    #####:34895:    int test_ret = 0;
        -:34896:
        -:34897:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:34898:    int mem_base;
        -:34899:    int ret_val;
        -:34900:    xmlSchemaValidCtxtPtr ctxt; /* a schema validation context */
        -:34901:    int n_ctxt;
        -:34902:    xmlParserInputBufferPtr input; /* the input to use for reading the data */
        -:34903:    int n_input;
        -:34904:    xmlCharEncoding enc; /* an optional encoding information */
        -:34905:    int n_enc;
        -:34906:    xmlSAXHandlerPtr sax; /* a SAX handler for the resulting events */
        -:34907:    int n_sax;
        -:34908:    void * user_data; /* the context to provide to the SAX handler. */
        -:34909:    int n_user_data;
        -:34910:
    #####:34911:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlSchemaValidCtxtPtr;n_ctxt++) {
    #####:34912:    for (n_input = 0;n_input < gen_nb_xmlParserInputBufferPtr;n_input++) {
    #####:34913:    for (n_enc = 0;n_enc < gen_nb_xmlCharEncoding;n_enc++) {
    #####:34914:    for (n_sax = 0;n_sax < gen_nb_xmlSAXHandlerPtr;n_sax++) {
    #####:34915:    for (n_user_data = 0;n_user_data < gen_nb_userdata;n_user_data++) {
    #####:34916:        mem_base = xmlMemBlocks();
    #####:34917:        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
    #####:34918:        input = gen_xmlParserInputBufferPtr(n_input, 1);
    #####:34919:        enc = gen_xmlCharEncoding(n_enc, 2);
    #####:34920:        sax = gen_xmlSAXHandlerPtr(n_sax, 3);
    #####:34921:        user_data = gen_userdata(n_user_data, 4);
        -:34922:
    #####:34923:        ret_val = xmlSchemaValidateStream(ctxt, input, enc, sax, user_data);
    #####:34924:        desret_int(ret_val);
    #####:34925:        call_tests++;
    #####:34926:        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
    #####:34927:        des_xmlParserInputBufferPtr(n_input, input, 1);
    #####:34928:        des_xmlCharEncoding(n_enc, enc, 2);
    #####:34929:        des_xmlSAXHandlerPtr(n_sax, sax, 3);
    #####:34930:        des_userdata(n_user_data, user_data, 4);
    #####:34931:        xmlResetLastError();
    #####:34932:        if (mem_base != xmlMemBlocks()) {
    #####:34933:            printf("Leak of %d blocks found in xmlSchemaValidateStream",
    #####:34934:	           xmlMemBlocks() - mem_base);
    #####:34935:	    test_ret++;
    #####:34936:            printf(" %d", n_ctxt);
    #####:34937:            printf(" %d", n_input);
    #####:34938:            printf(" %d", n_enc);
    #####:34939:            printf(" %d", n_sax);
    #####:34940:            printf(" %d", n_user_data);
    #####:34941:            printf("\n");
        -:34942:        }
        -:34943:    }
        -:34944:    }
        -:34945:    }
        -:34946:    }
        -:34947:    }
    #####:34948:    function_tests++;
        -:34949:#endif
        -:34950:
    #####:34951:    return(test_ret);
        -:34952:}
        -:34953:
        -:34954:static int
    #####:34955:test_xmlschemas(void) {
    #####:34956:    int test_ret = 0;
        -:34957:
    #####:34958:    if (quiet == 0) printf("Testing xmlschemas : 16 of 27 functions ...\n");
    #####:34959:    test_ret += test_xmlSchemaDump();
    #####:34960:    test_ret += test_xmlSchemaGetParserErrors();
    #####:34961:    test_ret += test_xmlSchemaGetValidErrors();
    #####:34962:    test_ret += test_xmlSchemaIsValid();
    #####:34963:    test_ret += test_xmlSchemaNewDocParserCtxt();
    #####:34964:    test_ret += test_xmlSchemaNewMemParserCtxt();
    #####:34965:    test_ret += test_xmlSchemaNewParserCtxt();
    #####:34966:    test_ret += test_xmlSchemaNewValidCtxt();
    #####:34967:    test_ret += test_xmlSchemaParse();
    #####:34968:    test_ret += test_xmlSchemaSAXPlug();
    #####:34969:    test_ret += test_xmlSchemaSAXUnplug();
    #####:34970:    test_ret += test_xmlSchemaSetParserErrors();
    #####:34971:    test_ret += test_xmlSchemaSetParserStructuredErrors();
    #####:34972:    test_ret += test_xmlSchemaSetValidErrors();
    #####:34973:    test_ret += test_xmlSchemaSetValidOptions();
    #####:34974:    test_ret += test_xmlSchemaSetValidStructuredErrors();
    #####:34975:    test_ret += test_xmlSchemaValidCtxtGetOptions();
    #####:34976:    test_ret += test_xmlSchemaValidCtxtGetParserCtxt();
    #####:34977:    test_ret += test_xmlSchemaValidateDoc();
    #####:34978:    test_ret += test_xmlSchemaValidateFile();
    #####:34979:    test_ret += test_xmlSchemaValidateOneElement();
    #####:34980:    test_ret += test_xmlSchemaValidateSetFilename();
    #####:34981:    test_ret += test_xmlSchemaValidateSetLocator();
    #####:34982:    test_ret += test_xmlSchemaValidateStream();
        -:34983:
    #####:34984:    if (test_ret != 0)
    #####:34985:	printf("Module xmlschemas: %d errors\n", test_ret);
    #####:34986:    return(test_ret);
        -:34987:}
        -:34988:#ifdef LIBXML_SCHEMAS_ENABLED
        -:34989:
        -:34990:#define gen_nb_xmlSchemaFacetPtr 1
    #####:34991:static xmlSchemaFacetPtr gen_xmlSchemaFacetPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:34992:    return(NULL);
        -:34993:}
    #####:34994:static void des_xmlSchemaFacetPtr(int no ATTRIBUTE_UNUSED, xmlSchemaFacetPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:34995:}
        -:34996:#endif
        -:34997:
        -:34998:#ifdef LIBXML_SCHEMAS_ENABLED
        -:34999:
        -:35000:#define gen_nb_xmlSchemaTypePtr 1
    #####:35001:static xmlSchemaTypePtr gen_xmlSchemaTypePtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:35002:    return(NULL);
        -:35003:}
    #####:35004:static void des_xmlSchemaTypePtr(int no ATTRIBUTE_UNUSED, xmlSchemaTypePtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:35005:}
        -:35006:#endif
        -:35007:
        -:35008:
        -:35009:static int
    #####:35010:test_xmlSchemaCheckFacet(void) {
    #####:35011:    int test_ret = 0;
        -:35012:
        -:35013:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:35014:    int mem_base;
        -:35015:    int ret_val;
        -:35016:    xmlSchemaFacetPtr facet; /* the facet */
        -:35017:    int n_facet;
        -:35018:    xmlSchemaTypePtr typeDecl; /* the schema type definition */
        -:35019:    int n_typeDecl;
        -:35020:    xmlSchemaParserCtxtPtr pctxt; /* the schema parser context or NULL */
        -:35021:    int n_pctxt;
        -:35022:    xmlChar * name; /* the optional name of the type */
        -:35023:    int n_name;
        -:35024:
    #####:35025:    for (n_facet = 0;n_facet < gen_nb_xmlSchemaFacetPtr;n_facet++) {
    #####:35026:    for (n_typeDecl = 0;n_typeDecl < gen_nb_xmlSchemaTypePtr;n_typeDecl++) {
    #####:35027:    for (n_pctxt = 0;n_pctxt < gen_nb_xmlSchemaParserCtxtPtr;n_pctxt++) {
    #####:35028:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:35029:        mem_base = xmlMemBlocks();
    #####:35030:        facet = gen_xmlSchemaFacetPtr(n_facet, 0);
    #####:35031:        typeDecl = gen_xmlSchemaTypePtr(n_typeDecl, 1);
    #####:35032:        pctxt = gen_xmlSchemaParserCtxtPtr(n_pctxt, 2);
    #####:35033:        name = gen_const_xmlChar_ptr(n_name, 3);
        -:35034:
    #####:35035:        ret_val = xmlSchemaCheckFacet(facet, typeDecl, pctxt, (const xmlChar *)name);
    #####:35036:        desret_int(ret_val);
    #####:35037:        call_tests++;
    #####:35038:        des_xmlSchemaFacetPtr(n_facet, facet, 0);
    #####:35039:        des_xmlSchemaTypePtr(n_typeDecl, typeDecl, 1);
    #####:35040:        des_xmlSchemaParserCtxtPtr(n_pctxt, pctxt, 2);
    #####:35041:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 3);
    #####:35042:        xmlResetLastError();
    #####:35043:        if (mem_base != xmlMemBlocks()) {
    #####:35044:            printf("Leak of %d blocks found in xmlSchemaCheckFacet",
    #####:35045:	           xmlMemBlocks() - mem_base);
    #####:35046:	    test_ret++;
    #####:35047:            printf(" %d", n_facet);
    #####:35048:            printf(" %d", n_typeDecl);
    #####:35049:            printf(" %d", n_pctxt);
    #####:35050:            printf(" %d", n_name);
    #####:35051:            printf("\n");
        -:35052:        }
        -:35053:    }
        -:35054:    }
        -:35055:    }
        -:35056:    }
    #####:35057:    function_tests++;
        -:35058:#endif
        -:35059:
    #####:35060:    return(test_ret);
        -:35061:}
        -:35062:
        -:35063:
        -:35064:static int
    #####:35065:test_xmlSchemaCleanupTypes(void) {
    #####:35066:    int test_ret = 0;
        -:35067:
        -:35068:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:35069:
        -:35070:
    #####:35071:        xmlSchemaCleanupTypes();
    #####:35072:        call_tests++;
    #####:35073:        xmlResetLastError();
    #####:35074:    function_tests++;
        -:35075:#endif
        -:35076:
    #####:35077:    return(test_ret);
        -:35078:}
        -:35079:
        -:35080:
        -:35081:static int
    #####:35082:test_xmlSchemaCollapseString(void) {
    #####:35083:    int test_ret = 0;
        -:35084:
        -:35085:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:35086:    int mem_base;
        -:35087:    xmlChar * ret_val;
        -:35088:    xmlChar * value; /* a value */
        -:35089:    int n_value;
        -:35090:
    #####:35091:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:35092:        mem_base = xmlMemBlocks();
    #####:35093:        value = gen_const_xmlChar_ptr(n_value, 0);
        -:35094:
    #####:35095:        ret_val = xmlSchemaCollapseString((const xmlChar *)value);
    #####:35096:        desret_xmlChar_ptr(ret_val);
    #####:35097:        call_tests++;
    #####:35098:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 0);
    #####:35099:        xmlResetLastError();
    #####:35100:        if (mem_base != xmlMemBlocks()) {
    #####:35101:            printf("Leak of %d blocks found in xmlSchemaCollapseString",
    #####:35102:	           xmlMemBlocks() - mem_base);
    #####:35103:	    test_ret++;
    #####:35104:            printf(" %d", n_value);
    #####:35105:            printf("\n");
        -:35106:        }
        -:35107:    }
    #####:35108:    function_tests++;
        -:35109:#endif
        -:35110:
    #####:35111:    return(test_ret);
        -:35112:}
        -:35113:
        -:35114:#ifdef LIBXML_SCHEMAS_ENABLED
        -:35115:
        -:35116:#define gen_nb_xmlSchemaValPtr 1
    #####:35117:static xmlSchemaValPtr gen_xmlSchemaValPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:35118:    return(NULL);
        -:35119:}
    #####:35120:static void des_xmlSchemaValPtr(int no ATTRIBUTE_UNUSED, xmlSchemaValPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:35121:}
        -:35122:#endif
        -:35123:
        -:35124:
        -:35125:static int
    #####:35126:test_xmlSchemaCompareValues(void) {
    #####:35127:    int test_ret = 0;
        -:35128:
        -:35129:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:35130:    int mem_base;
        -:35131:    int ret_val;
        -:35132:    xmlSchemaValPtr x; /* a first value */
        -:35133:    int n_x;
        -:35134:    xmlSchemaValPtr y; /* a second value */
        -:35135:    int n_y;
        -:35136:
    #####:35137:    for (n_x = 0;n_x < gen_nb_xmlSchemaValPtr;n_x++) {
    #####:35138:    for (n_y = 0;n_y < gen_nb_xmlSchemaValPtr;n_y++) {
    #####:35139:        mem_base = xmlMemBlocks();
    #####:35140:        x = gen_xmlSchemaValPtr(n_x, 0);
    #####:35141:        y = gen_xmlSchemaValPtr(n_y, 1);
        -:35142:
    #####:35143:        ret_val = xmlSchemaCompareValues(x, y);
    #####:35144:        desret_int(ret_val);
    #####:35145:        call_tests++;
    #####:35146:        des_xmlSchemaValPtr(n_x, x, 0);
    #####:35147:        des_xmlSchemaValPtr(n_y, y, 1);
    #####:35148:        xmlResetLastError();
    #####:35149:        if (mem_base != xmlMemBlocks()) {
    #####:35150:            printf("Leak of %d blocks found in xmlSchemaCompareValues",
    #####:35151:	           xmlMemBlocks() - mem_base);
    #####:35152:	    test_ret++;
    #####:35153:            printf(" %d", n_x);
    #####:35154:            printf(" %d", n_y);
    #####:35155:            printf("\n");
        -:35156:        }
        -:35157:    }
        -:35158:    }
    #####:35159:    function_tests++;
        -:35160:#endif
        -:35161:
    #####:35162:    return(test_ret);
        -:35163:}
        -:35164:
        -:35165:
        -:35166:static int
    #####:35167:test_xmlSchemaCompareValuesWhtsp(void) {
    #####:35168:    int test_ret = 0;
        -:35169:
        -:35170:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:35171:    int mem_base;
        -:35172:    int ret_val;
        -:35173:    xmlSchemaValPtr x; /* a first value */
        -:35174:    int n_x;
        -:35175:    xmlSchemaWhitespaceValueType xws; /* the whitespace value of x */
        -:35176:    int n_xws;
        -:35177:    xmlSchemaValPtr y; /* a second value */
        -:35178:    int n_y;
        -:35179:    xmlSchemaWhitespaceValueType yws; /* the whitespace value of y */
        -:35180:    int n_yws;
        -:35181:
    #####:35182:    for (n_x = 0;n_x < gen_nb_xmlSchemaValPtr;n_x++) {
    #####:35183:    for (n_xws = 0;n_xws < gen_nb_xmlSchemaWhitespaceValueType;n_xws++) {
    #####:35184:    for (n_y = 0;n_y < gen_nb_xmlSchemaValPtr;n_y++) {
    #####:35185:    for (n_yws = 0;n_yws < gen_nb_xmlSchemaWhitespaceValueType;n_yws++) {
    #####:35186:        mem_base = xmlMemBlocks();
    #####:35187:        x = gen_xmlSchemaValPtr(n_x, 0);
    #####:35188:        xws = gen_xmlSchemaWhitespaceValueType(n_xws, 1);
    #####:35189:        y = gen_xmlSchemaValPtr(n_y, 2);
    #####:35190:        yws = gen_xmlSchemaWhitespaceValueType(n_yws, 3);
        -:35191:
    #####:35192:        ret_val = xmlSchemaCompareValuesWhtsp(x, xws, y, yws);
    #####:35193:        desret_int(ret_val);
    #####:35194:        call_tests++;
    #####:35195:        des_xmlSchemaValPtr(n_x, x, 0);
    #####:35196:        des_xmlSchemaWhitespaceValueType(n_xws, xws, 1);
    #####:35197:        des_xmlSchemaValPtr(n_y, y, 2);
    #####:35198:        des_xmlSchemaWhitespaceValueType(n_yws, yws, 3);
    #####:35199:        xmlResetLastError();
    #####:35200:        if (mem_base != xmlMemBlocks()) {
    #####:35201:            printf("Leak of %d blocks found in xmlSchemaCompareValuesWhtsp",
    #####:35202:	           xmlMemBlocks() - mem_base);
    #####:35203:	    test_ret++;
    #####:35204:            printf(" %d", n_x);
    #####:35205:            printf(" %d", n_xws);
    #####:35206:            printf(" %d", n_y);
    #####:35207:            printf(" %d", n_yws);
    #####:35208:            printf("\n");
        -:35209:        }
        -:35210:    }
        -:35211:    }
        -:35212:    }
        -:35213:    }
    #####:35214:    function_tests++;
        -:35215:#endif
        -:35216:
    #####:35217:    return(test_ret);
        -:35218:}
        -:35219:
        -:35220:
        -:35221:static int
    #####:35222:test_xmlSchemaCopyValue(void) {
    #####:35223:    int test_ret = 0;
        -:35224:
        -:35225:
        -:35226:    /* missing type support */
    #####:35227:    return(test_ret);
        -:35228:}
        -:35229:
        -:35230:
        -:35231:static int
    #####:35232:test_xmlSchemaGetBuiltInListSimpleTypeItemType(void) {
    #####:35233:    int test_ret = 0;
        -:35234:
        -:35235:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:35236:    int mem_base;
        -:35237:    xmlSchemaTypePtr ret_val;
        -:35238:    xmlSchemaTypePtr type; /* the built-in simple type. */
        -:35239:    int n_type;
        -:35240:
    #####:35241:    for (n_type = 0;n_type < gen_nb_xmlSchemaTypePtr;n_type++) {
    #####:35242:        mem_base = xmlMemBlocks();
    #####:35243:        type = gen_xmlSchemaTypePtr(n_type, 0);
        -:35244:
    #####:35245:        ret_val = xmlSchemaGetBuiltInListSimpleTypeItemType(type);
    #####:35246:        desret_xmlSchemaTypePtr(ret_val);
    #####:35247:        call_tests++;
    #####:35248:        des_xmlSchemaTypePtr(n_type, type, 0);
    #####:35249:        xmlResetLastError();
    #####:35250:        if (mem_base != xmlMemBlocks()) {
    #####:35251:            printf("Leak of %d blocks found in xmlSchemaGetBuiltInListSimpleTypeItemType",
    #####:35252:	           xmlMemBlocks() - mem_base);
    #####:35253:	    test_ret++;
    #####:35254:            printf(" %d", n_type);
    #####:35255:            printf("\n");
        -:35256:        }
        -:35257:    }
    #####:35258:    function_tests++;
        -:35259:#endif
        -:35260:
    #####:35261:    return(test_ret);
        -:35262:}
        -:35263:
        -:35264:
        -:35265:static int
    #####:35266:test_xmlSchemaGetBuiltInType(void) {
    #####:35267:    int test_ret = 0;
        -:35268:
        -:35269:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:35270:    xmlSchemaTypePtr ret_val;
        -:35271:    xmlSchemaValType type; /* the type of the built in type */
        -:35272:    int n_type;
        -:35273:
    #####:35274:    for (n_type = 0;n_type < gen_nb_xmlSchemaValType;n_type++) {
    #####:35275:        type = gen_xmlSchemaValType(n_type, 0);
        -:35276:
    #####:35277:        ret_val = xmlSchemaGetBuiltInType(type);
    #####:35278:        desret_xmlSchemaTypePtr(ret_val);
    #####:35279:        call_tests++;
    #####:35280:        des_xmlSchemaValType(n_type, type, 0);
    #####:35281:        xmlResetLastError();
        -:35282:    }
    #####:35283:    function_tests++;
        -:35284:#endif
        -:35285:
    #####:35286:    return(test_ret);
        -:35287:}
        -:35288:
        -:35289:
        -:35290:static int
    #####:35291:test_xmlSchemaGetCanonValue(void) {
    #####:35292:    int test_ret = 0;
        -:35293:
        -:35294:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:35295:    int mem_base;
        -:35296:    int ret_val;
        -:35297:    xmlSchemaValPtr val; /* the precomputed value */
        -:35298:    int n_val;
        -:35299:    xmlChar ** retValue; /* the returned value */
        -:35300:    int n_retValue;
        -:35301:
    #####:35302:    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr;n_val++) {
    #####:35303:    for (n_retValue = 0;n_retValue < gen_nb_const_xmlChar_ptr_ptr;n_retValue++) {
    #####:35304:        mem_base = xmlMemBlocks();
    #####:35305:        val = gen_xmlSchemaValPtr(n_val, 0);
    #####:35306:        retValue = gen_const_xmlChar_ptr_ptr(n_retValue, 1);
        -:35307:
    #####:35308:        ret_val = xmlSchemaGetCanonValue(val, (const xmlChar **)retValue);
    #####:35309:        desret_int(ret_val);
    #####:35310:        call_tests++;
    #####:35311:        des_xmlSchemaValPtr(n_val, val, 0);
    #####:35312:        des_const_xmlChar_ptr_ptr(n_retValue, (const xmlChar **)retValue, 1);
    #####:35313:        xmlResetLastError();
    #####:35314:        if (mem_base != xmlMemBlocks()) {
    #####:35315:            printf("Leak of %d blocks found in xmlSchemaGetCanonValue",
    #####:35316:	           xmlMemBlocks() - mem_base);
    #####:35317:	    test_ret++;
    #####:35318:            printf(" %d", n_val);
    #####:35319:            printf(" %d", n_retValue);
    #####:35320:            printf("\n");
        -:35321:        }
        -:35322:    }
        -:35323:    }
    #####:35324:    function_tests++;
        -:35325:#endif
        -:35326:
    #####:35327:    return(test_ret);
        -:35328:}
        -:35329:
        -:35330:
        -:35331:static int
    #####:35332:test_xmlSchemaGetCanonValueWhtsp(void) {
    #####:35333:    int test_ret = 0;
        -:35334:
        -:35335:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:35336:    int mem_base;
        -:35337:    int ret_val;
        -:35338:    xmlSchemaValPtr val; /* the precomputed value */
        -:35339:    int n_val;
        -:35340:    xmlChar ** retValue; /* the returned value */
        -:35341:    int n_retValue;
        -:35342:    xmlSchemaWhitespaceValueType ws; /* the whitespace type of the value */
        -:35343:    int n_ws;
        -:35344:
    #####:35345:    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr;n_val++) {
    #####:35346:    for (n_retValue = 0;n_retValue < gen_nb_const_xmlChar_ptr_ptr;n_retValue++) {
    #####:35347:    for (n_ws = 0;n_ws < gen_nb_xmlSchemaWhitespaceValueType;n_ws++) {
    #####:35348:        mem_base = xmlMemBlocks();
    #####:35349:        val = gen_xmlSchemaValPtr(n_val, 0);
    #####:35350:        retValue = gen_const_xmlChar_ptr_ptr(n_retValue, 1);
    #####:35351:        ws = gen_xmlSchemaWhitespaceValueType(n_ws, 2);
        -:35352:
    #####:35353:        ret_val = xmlSchemaGetCanonValueWhtsp(val, (const xmlChar **)retValue, ws);
    #####:35354:        desret_int(ret_val);
    #####:35355:        call_tests++;
    #####:35356:        des_xmlSchemaValPtr(n_val, val, 0);
    #####:35357:        des_const_xmlChar_ptr_ptr(n_retValue, (const xmlChar **)retValue, 1);
    #####:35358:        des_xmlSchemaWhitespaceValueType(n_ws, ws, 2);
    #####:35359:        xmlResetLastError();
    #####:35360:        if (mem_base != xmlMemBlocks()) {
    #####:35361:            printf("Leak of %d blocks found in xmlSchemaGetCanonValueWhtsp",
    #####:35362:	           xmlMemBlocks() - mem_base);
    #####:35363:	    test_ret++;
    #####:35364:            printf(" %d", n_val);
    #####:35365:            printf(" %d", n_retValue);
    #####:35366:            printf(" %d", n_ws);
    #####:35367:            printf("\n");
        -:35368:        }
        -:35369:    }
        -:35370:    }
        -:35371:    }
    #####:35372:    function_tests++;
        -:35373:#endif
        -:35374:
    #####:35375:    return(test_ret);
        -:35376:}
        -:35377:
        -:35378:
        -:35379:static int
    #####:35380:test_xmlSchemaGetFacetValueAsULong(void) {
    #####:35381:    int test_ret = 0;
        -:35382:
        -:35383:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:35384:    int mem_base;
        -:35385:    unsigned long ret_val;
        -:35386:    xmlSchemaFacetPtr facet; /* an schemas type facet */
        -:35387:    int n_facet;
        -:35388:
    #####:35389:    for (n_facet = 0;n_facet < gen_nb_xmlSchemaFacetPtr;n_facet++) {
    #####:35390:        mem_base = xmlMemBlocks();
    #####:35391:        facet = gen_xmlSchemaFacetPtr(n_facet, 0);
        -:35392:
    #####:35393:        ret_val = xmlSchemaGetFacetValueAsULong(facet);
    #####:35394:        desret_unsigned_long(ret_val);
    #####:35395:        call_tests++;
    #####:35396:        des_xmlSchemaFacetPtr(n_facet, facet, 0);
    #####:35397:        xmlResetLastError();
    #####:35398:        if (mem_base != xmlMemBlocks()) {
    #####:35399:            printf("Leak of %d blocks found in xmlSchemaGetFacetValueAsULong",
    #####:35400:	           xmlMemBlocks() - mem_base);
    #####:35401:	    test_ret++;
    #####:35402:            printf(" %d", n_facet);
    #####:35403:            printf("\n");
        -:35404:        }
        -:35405:    }
    #####:35406:    function_tests++;
        -:35407:#endif
        -:35408:
    #####:35409:    return(test_ret);
        -:35410:}
        -:35411:
        -:35412:
        -:35413:static int
    #####:35414:test_xmlSchemaGetPredefinedType(void) {
    #####:35415:    int test_ret = 0;
        -:35416:
        -:35417:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:35418:    int mem_base;
        -:35419:    xmlSchemaTypePtr ret_val;
        -:35420:    xmlChar * name; /* the type name */
        -:35421:    int n_name;
        -:35422:    xmlChar * ns; /* the URI of the namespace usually "http://www.w3.org/2001/XMLSchema" */
        -:35423:    int n_ns;
        -:35424:
    #####:35425:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:35426:    for (n_ns = 0;n_ns < gen_nb_const_xmlChar_ptr;n_ns++) {
    #####:35427:        mem_base = xmlMemBlocks();
    #####:35428:        name = gen_const_xmlChar_ptr(n_name, 0);
    #####:35429:        ns = gen_const_xmlChar_ptr(n_ns, 1);
        -:35430:
    #####:35431:        ret_val = xmlSchemaGetPredefinedType((const xmlChar *)name, (const xmlChar *)ns);
    #####:35432:        desret_xmlSchemaTypePtr(ret_val);
    #####:35433:        call_tests++;
    #####:35434:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 0);
    #####:35435:        des_const_xmlChar_ptr(n_ns, (const xmlChar *)ns, 1);
    #####:35436:        xmlResetLastError();
    #####:35437:        if (mem_base != xmlMemBlocks()) {
    #####:35438:            printf("Leak of %d blocks found in xmlSchemaGetPredefinedType",
    #####:35439:	           xmlMemBlocks() - mem_base);
    #####:35440:	    test_ret++;
    #####:35441:            printf(" %d", n_name);
    #####:35442:            printf(" %d", n_ns);
    #####:35443:            printf("\n");
        -:35444:        }
        -:35445:    }
        -:35446:    }
    #####:35447:    function_tests++;
        -:35448:#endif
        -:35449:
    #####:35450:    return(test_ret);
        -:35451:}
        -:35452:
        -:35453:
        -:35454:static int
    #####:35455:test_xmlSchemaGetValType(void) {
    #####:35456:    int test_ret = 0;
        -:35457:
        -:35458:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:35459:    int mem_base;
        -:35460:    xmlSchemaValType ret_val;
        -:35461:    xmlSchemaValPtr val; /* a schemas value */
        -:35462:    int n_val;
        -:35463:
    #####:35464:    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr;n_val++) {
    #####:35465:        mem_base = xmlMemBlocks();
    #####:35466:        val = gen_xmlSchemaValPtr(n_val, 0);
        -:35467:
    #####:35468:        ret_val = xmlSchemaGetValType(val);
    #####:35469:        desret_xmlSchemaValType(ret_val);
    #####:35470:        call_tests++;
    #####:35471:        des_xmlSchemaValPtr(n_val, val, 0);
    #####:35472:        xmlResetLastError();
    #####:35473:        if (mem_base != xmlMemBlocks()) {
    #####:35474:            printf("Leak of %d blocks found in xmlSchemaGetValType",
    #####:35475:	           xmlMemBlocks() - mem_base);
    #####:35476:	    test_ret++;
    #####:35477:            printf(" %d", n_val);
    #####:35478:            printf("\n");
        -:35479:        }
        -:35480:    }
    #####:35481:    function_tests++;
        -:35482:#endif
        -:35483:
    #####:35484:    return(test_ret);
        -:35485:}
        -:35486:
        -:35487:
        -:35488:static int
    #####:35489:test_xmlSchemaInitTypes(void) {
    #####:35490:    int test_ret = 0;
        -:35491:
        -:35492:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:35493:
        -:35494:
    #####:35495:        xmlSchemaInitTypes();
    #####:35496:        call_tests++;
    #####:35497:        xmlResetLastError();
    #####:35498:    function_tests++;
        -:35499:#endif
        -:35500:
    #####:35501:    return(test_ret);
        -:35502:}
        -:35503:
        -:35504:
        -:35505:static int
    #####:35506:test_xmlSchemaIsBuiltInTypeFacet(void) {
    #####:35507:    int test_ret = 0;
        -:35508:
        -:35509:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:35510:    int mem_base;
        -:35511:    int ret_val;
        -:35512:    xmlSchemaTypePtr type; /* the built-in type */
        -:35513:    int n_type;
        -:35514:    int facetType; /* the facet type */
        -:35515:    int n_facetType;
        -:35516:
    #####:35517:    for (n_type = 0;n_type < gen_nb_xmlSchemaTypePtr;n_type++) {
    #####:35518:    for (n_facetType = 0;n_facetType < gen_nb_int;n_facetType++) {
    #####:35519:        mem_base = xmlMemBlocks();
    #####:35520:        type = gen_xmlSchemaTypePtr(n_type, 0);
    #####:35521:        facetType = gen_int(n_facetType, 1);
        -:35522:
    #####:35523:        ret_val = xmlSchemaIsBuiltInTypeFacet(type, facetType);
    #####:35524:        desret_int(ret_val);
    #####:35525:        call_tests++;
    #####:35526:        des_xmlSchemaTypePtr(n_type, type, 0);
    #####:35527:        des_int(n_facetType, facetType, 1);
    #####:35528:        xmlResetLastError();
    #####:35529:        if (mem_base != xmlMemBlocks()) {
    #####:35530:            printf("Leak of %d blocks found in xmlSchemaIsBuiltInTypeFacet",
    #####:35531:	           xmlMemBlocks() - mem_base);
    #####:35532:	    test_ret++;
    #####:35533:            printf(" %d", n_type);
    #####:35534:            printf(" %d", n_facetType);
    #####:35535:            printf("\n");
        -:35536:        }
        -:35537:    }
        -:35538:    }
    #####:35539:    function_tests++;
        -:35540:#endif
        -:35541:
    #####:35542:    return(test_ret);
        -:35543:}
        -:35544:
        -:35545:
        -:35546:static int
    #####:35547:test_xmlSchemaNewFacet(void) {
    #####:35548:    int test_ret = 0;
        -:35549:
        -:35550:
        -:35551:    /* missing type support */
    #####:35552:    return(test_ret);
        -:35553:}
        -:35554:
        -:35555:
        -:35556:static int
    #####:35557:test_xmlSchemaNewNOTATIONValue(void) {
    #####:35558:    int test_ret = 0;
        -:35559:
        -:35560:
        -:35561:    /* missing type support */
    #####:35562:    return(test_ret);
        -:35563:}
        -:35564:
        -:35565:
        -:35566:static int
    #####:35567:test_xmlSchemaNewQNameValue(void) {
    #####:35568:    int test_ret = 0;
        -:35569:
        -:35570:
        -:35571:    /* missing type support */
    #####:35572:    return(test_ret);
        -:35573:}
        -:35574:
        -:35575:
        -:35576:static int
    #####:35577:test_xmlSchemaNewStringValue(void) {
    #####:35578:    int test_ret = 0;
        -:35579:
        -:35580:
        -:35581:    /* missing type support */
    #####:35582:    return(test_ret);
        -:35583:}
        -:35584:
        -:35585:#ifdef LIBXML_SCHEMAS_ENABLED
        -:35586:
        -:35587:#define gen_nb_xmlSchemaValPtr_ptr 1
    #####:35588:static xmlSchemaValPtr * gen_xmlSchemaValPtr_ptr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:35589:    return(NULL);
        -:35590:}
    #####:35591:static void des_xmlSchemaValPtr_ptr(int no ATTRIBUTE_UNUSED, xmlSchemaValPtr * val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:35592:}
        -:35593:#endif
        -:35594:
        -:35595:
        -:35596:static int
    #####:35597:test_xmlSchemaValPredefTypeNode(void) {
    #####:35598:    int test_ret = 0;
        -:35599:
        -:35600:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:35601:    int mem_base;
        -:35602:    int ret_val;
        -:35603:    xmlSchemaTypePtr type; /* the predefined type */
        -:35604:    int n_type;
        -:35605:    xmlChar * value; /* the value to check */
        -:35606:    int n_value;
        -:35607:    xmlSchemaValPtr * val; /* the return computed value */
        -:35608:    int n_val;
        -:35609:    xmlNodePtr node; /* the node containing the value */
        -:35610:    int n_node;
        -:35611:
    #####:35612:    for (n_type = 0;n_type < gen_nb_xmlSchemaTypePtr;n_type++) {
    #####:35613:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:35614:    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr_ptr;n_val++) {
    #####:35615:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:35616:        mem_base = xmlMemBlocks();
    #####:35617:        type = gen_xmlSchemaTypePtr(n_type, 0);
    #####:35618:        value = gen_const_xmlChar_ptr(n_value, 1);
    #####:35619:        val = gen_xmlSchemaValPtr_ptr(n_val, 2);
    #####:35620:        node = gen_xmlNodePtr(n_node, 3);
        -:35621:
    #####:35622:        ret_val = xmlSchemaValPredefTypeNode(type, (const xmlChar *)value, val, node);
    #####:35623:        desret_int(ret_val);
    #####:35624:        call_tests++;
    #####:35625:        des_xmlSchemaTypePtr(n_type, type, 0);
    #####:35626:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 1);
    #####:35627:        des_xmlSchemaValPtr_ptr(n_val, val, 2);
    #####:35628:        des_xmlNodePtr(n_node, node, 3);
    #####:35629:        xmlResetLastError();
    #####:35630:        if (mem_base != xmlMemBlocks()) {
    #####:35631:            printf("Leak of %d blocks found in xmlSchemaValPredefTypeNode",
    #####:35632:	           xmlMemBlocks() - mem_base);
    #####:35633:	    test_ret++;
    #####:35634:            printf(" %d", n_type);
    #####:35635:            printf(" %d", n_value);
    #####:35636:            printf(" %d", n_val);
    #####:35637:            printf(" %d", n_node);
    #####:35638:            printf("\n");
        -:35639:        }
        -:35640:    }
        -:35641:    }
        -:35642:    }
        -:35643:    }
    #####:35644:    function_tests++;
        -:35645:#endif
        -:35646:
    #####:35647:    return(test_ret);
        -:35648:}
        -:35649:
        -:35650:
        -:35651:static int
    #####:35652:test_xmlSchemaValPredefTypeNodeNoNorm(void) {
    #####:35653:    int test_ret = 0;
        -:35654:
        -:35655:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:35656:    int mem_base;
        -:35657:    int ret_val;
        -:35658:    xmlSchemaTypePtr type; /* the predefined type */
        -:35659:    int n_type;
        -:35660:    xmlChar * value; /* the value to check */
        -:35661:    int n_value;
        -:35662:    xmlSchemaValPtr * val; /* the return computed value */
        -:35663:    int n_val;
        -:35664:    xmlNodePtr node; /* the node containing the value */
        -:35665:    int n_node;
        -:35666:
    #####:35667:    for (n_type = 0;n_type < gen_nb_xmlSchemaTypePtr;n_type++) {
    #####:35668:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:35669:    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr_ptr;n_val++) {
    #####:35670:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:35671:        mem_base = xmlMemBlocks();
    #####:35672:        type = gen_xmlSchemaTypePtr(n_type, 0);
    #####:35673:        value = gen_const_xmlChar_ptr(n_value, 1);
    #####:35674:        val = gen_xmlSchemaValPtr_ptr(n_val, 2);
    #####:35675:        node = gen_xmlNodePtr(n_node, 3);
        -:35676:
    #####:35677:        ret_val = xmlSchemaValPredefTypeNodeNoNorm(type, (const xmlChar *)value, val, node);
    #####:35678:        desret_int(ret_val);
    #####:35679:        call_tests++;
    #####:35680:        des_xmlSchemaTypePtr(n_type, type, 0);
    #####:35681:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 1);
    #####:35682:        des_xmlSchemaValPtr_ptr(n_val, val, 2);
    #####:35683:        des_xmlNodePtr(n_node, node, 3);
    #####:35684:        xmlResetLastError();
    #####:35685:        if (mem_base != xmlMemBlocks()) {
    #####:35686:            printf("Leak of %d blocks found in xmlSchemaValPredefTypeNodeNoNorm",
    #####:35687:	           xmlMemBlocks() - mem_base);
    #####:35688:	    test_ret++;
    #####:35689:            printf(" %d", n_type);
    #####:35690:            printf(" %d", n_value);
    #####:35691:            printf(" %d", n_val);
    #####:35692:            printf(" %d", n_node);
    #####:35693:            printf("\n");
        -:35694:        }
        -:35695:    }
        -:35696:    }
        -:35697:    }
        -:35698:    }
    #####:35699:    function_tests++;
        -:35700:#endif
        -:35701:
    #####:35702:    return(test_ret);
        -:35703:}
        -:35704:
        -:35705:
        -:35706:static int
    #####:35707:test_xmlSchemaValidateFacet(void) {
    #####:35708:    int test_ret = 0;
        -:35709:
        -:35710:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:35711:    int mem_base;
        -:35712:    int ret_val;
        -:35713:    xmlSchemaTypePtr base; /* the base type */
        -:35714:    int n_base;
        -:35715:    xmlSchemaFacetPtr facet; /* the facet to check */
        -:35716:    int n_facet;
        -:35717:    xmlChar * value; /* the lexical repr of the value to validate */
        -:35718:    int n_value;
        -:35719:    xmlSchemaValPtr val; /* the precomputed value */
        -:35720:    int n_val;
        -:35721:
    #####:35722:    for (n_base = 0;n_base < gen_nb_xmlSchemaTypePtr;n_base++) {
    #####:35723:    for (n_facet = 0;n_facet < gen_nb_xmlSchemaFacetPtr;n_facet++) {
    #####:35724:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:35725:    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr;n_val++) {
    #####:35726:        mem_base = xmlMemBlocks();
    #####:35727:        base = gen_xmlSchemaTypePtr(n_base, 0);
    #####:35728:        facet = gen_xmlSchemaFacetPtr(n_facet, 1);
    #####:35729:        value = gen_const_xmlChar_ptr(n_value, 2);
    #####:35730:        val = gen_xmlSchemaValPtr(n_val, 3);
        -:35731:
    #####:35732:        ret_val = xmlSchemaValidateFacet(base, facet, (const xmlChar *)value, val);
    #####:35733:        desret_int(ret_val);
    #####:35734:        call_tests++;
    #####:35735:        des_xmlSchemaTypePtr(n_base, base, 0);
    #####:35736:        des_xmlSchemaFacetPtr(n_facet, facet, 1);
    #####:35737:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 2);
    #####:35738:        des_xmlSchemaValPtr(n_val, val, 3);
    #####:35739:        xmlResetLastError();
    #####:35740:        if (mem_base != xmlMemBlocks()) {
    #####:35741:            printf("Leak of %d blocks found in xmlSchemaValidateFacet",
    #####:35742:	           xmlMemBlocks() - mem_base);
    #####:35743:	    test_ret++;
    #####:35744:            printf(" %d", n_base);
    #####:35745:            printf(" %d", n_facet);
    #####:35746:            printf(" %d", n_value);
    #####:35747:            printf(" %d", n_val);
    #####:35748:            printf("\n");
        -:35749:        }
        -:35750:    }
        -:35751:    }
        -:35752:    }
        -:35753:    }
    #####:35754:    function_tests++;
        -:35755:#endif
        -:35756:
    #####:35757:    return(test_ret);
        -:35758:}
        -:35759:
        -:35760:
        -:35761:static int
    #####:35762:test_xmlSchemaValidateFacetWhtsp(void) {
    #####:35763:    int test_ret = 0;
        -:35764:
        -:35765:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:35766:    int mem_base;
        -:35767:    int ret_val;
        -:35768:    xmlSchemaFacetPtr facet; /* the facet to check */
        -:35769:    int n_facet;
        -:35770:    xmlSchemaWhitespaceValueType fws; /* the whitespace type of the facet's value */
        -:35771:    int n_fws;
        -:35772:    xmlSchemaValType valType; /* the built-in type of the value */
        -:35773:    int n_valType;
        -:35774:    xmlChar * value; /* the lexical (or normalized for pattern) repr of the value to validate */
        -:35775:    int n_value;
        -:35776:    xmlSchemaValPtr val; /* the precomputed value */
        -:35777:    int n_val;
        -:35778:    xmlSchemaWhitespaceValueType ws; /* the whitespace type of the value */
        -:35779:    int n_ws;
        -:35780:
    #####:35781:    for (n_facet = 0;n_facet < gen_nb_xmlSchemaFacetPtr;n_facet++) {
    #####:35782:    for (n_fws = 0;n_fws < gen_nb_xmlSchemaWhitespaceValueType;n_fws++) {
    #####:35783:    for (n_valType = 0;n_valType < gen_nb_xmlSchemaValType;n_valType++) {
    #####:35784:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:35785:    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr;n_val++) {
    #####:35786:    for (n_ws = 0;n_ws < gen_nb_xmlSchemaWhitespaceValueType;n_ws++) {
    #####:35787:        mem_base = xmlMemBlocks();
    #####:35788:        facet = gen_xmlSchemaFacetPtr(n_facet, 0);
    #####:35789:        fws = gen_xmlSchemaWhitespaceValueType(n_fws, 1);
    #####:35790:        valType = gen_xmlSchemaValType(n_valType, 2);
    #####:35791:        value = gen_const_xmlChar_ptr(n_value, 3);
    #####:35792:        val = gen_xmlSchemaValPtr(n_val, 4);
    #####:35793:        ws = gen_xmlSchemaWhitespaceValueType(n_ws, 5);
        -:35794:
    #####:35795:        ret_val = xmlSchemaValidateFacetWhtsp(facet, fws, valType, (const xmlChar *)value, val, ws);
    #####:35796:        desret_int(ret_val);
    #####:35797:        call_tests++;
    #####:35798:        des_xmlSchemaFacetPtr(n_facet, facet, 0);
    #####:35799:        des_xmlSchemaWhitespaceValueType(n_fws, fws, 1);
    #####:35800:        des_xmlSchemaValType(n_valType, valType, 2);
    #####:35801:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 3);
    #####:35802:        des_xmlSchemaValPtr(n_val, val, 4);
    #####:35803:        des_xmlSchemaWhitespaceValueType(n_ws, ws, 5);
    #####:35804:        xmlResetLastError();
    #####:35805:        if (mem_base != xmlMemBlocks()) {
    #####:35806:            printf("Leak of %d blocks found in xmlSchemaValidateFacetWhtsp",
    #####:35807:	           xmlMemBlocks() - mem_base);
    #####:35808:	    test_ret++;
    #####:35809:            printf(" %d", n_facet);
    #####:35810:            printf(" %d", n_fws);
    #####:35811:            printf(" %d", n_valType);
    #####:35812:            printf(" %d", n_value);
    #####:35813:            printf(" %d", n_val);
    #####:35814:            printf(" %d", n_ws);
    #####:35815:            printf("\n");
        -:35816:        }
        -:35817:    }
        -:35818:    }
        -:35819:    }
        -:35820:    }
        -:35821:    }
        -:35822:    }
    #####:35823:    function_tests++;
        -:35824:#endif
        -:35825:
    #####:35826:    return(test_ret);
        -:35827:}
        -:35828:
        -:35829:
        -:35830:static int
    #####:35831:test_xmlSchemaValidateLengthFacet(void) {
    #####:35832:    int test_ret = 0;
        -:35833:
        -:35834:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:35835:    int mem_base;
        -:35836:    int ret_val;
        -:35837:    xmlSchemaTypePtr type; /* the built-in type */
        -:35838:    int n_type;
        -:35839:    xmlSchemaFacetPtr facet; /* the facet to check */
        -:35840:    int n_facet;
        -:35841:    xmlChar * value; /* the lexical repr. of the value to be validated */
        -:35842:    int n_value;
        -:35843:    xmlSchemaValPtr val; /* the precomputed value */
        -:35844:    int n_val;
        -:35845:    unsigned long * length; /* the actual length of the value */
        -:35846:    int n_length;
        -:35847:
    #####:35848:    for (n_type = 0;n_type < gen_nb_xmlSchemaTypePtr;n_type++) {
    #####:35849:    for (n_facet = 0;n_facet < gen_nb_xmlSchemaFacetPtr;n_facet++) {
    #####:35850:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:35851:    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr;n_val++) {
    #####:35852:    for (n_length = 0;n_length < gen_nb_unsigned_long_ptr;n_length++) {
    #####:35853:        mem_base = xmlMemBlocks();
    #####:35854:        type = gen_xmlSchemaTypePtr(n_type, 0);
    #####:35855:        facet = gen_xmlSchemaFacetPtr(n_facet, 1);
    #####:35856:        value = gen_const_xmlChar_ptr(n_value, 2);
    #####:35857:        val = gen_xmlSchemaValPtr(n_val, 3);
    #####:35858:        length = gen_unsigned_long_ptr(n_length, 4);
        -:35859:
    #####:35860:        ret_val = xmlSchemaValidateLengthFacet(type, facet, (const xmlChar *)value, val, length);
    #####:35861:        desret_int(ret_val);
    #####:35862:        call_tests++;
    #####:35863:        des_xmlSchemaTypePtr(n_type, type, 0);
    #####:35864:        des_xmlSchemaFacetPtr(n_facet, facet, 1);
    #####:35865:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 2);
    #####:35866:        des_xmlSchemaValPtr(n_val, val, 3);
    #####:35867:        des_unsigned_long_ptr(n_length, length, 4);
    #####:35868:        xmlResetLastError();
    #####:35869:        if (mem_base != xmlMemBlocks()) {
    #####:35870:            printf("Leak of %d blocks found in xmlSchemaValidateLengthFacet",
    #####:35871:	           xmlMemBlocks() - mem_base);
    #####:35872:	    test_ret++;
    #####:35873:            printf(" %d", n_type);
    #####:35874:            printf(" %d", n_facet);
    #####:35875:            printf(" %d", n_value);
    #####:35876:            printf(" %d", n_val);
    #####:35877:            printf(" %d", n_length);
    #####:35878:            printf("\n");
        -:35879:        }
        -:35880:    }
        -:35881:    }
        -:35882:    }
        -:35883:    }
        -:35884:    }
    #####:35885:    function_tests++;
        -:35886:#endif
        -:35887:
    #####:35888:    return(test_ret);
        -:35889:}
        -:35890:
        -:35891:
        -:35892:static int
    #####:35893:test_xmlSchemaValidateLengthFacetWhtsp(void) {
    #####:35894:    int test_ret = 0;
        -:35895:
        -:35896:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:35897:    int mem_base;
        -:35898:    int ret_val;
        -:35899:    xmlSchemaFacetPtr facet; /* the facet to check */
        -:35900:    int n_facet;
        -:35901:    xmlSchemaValType valType; /* the built-in type */
        -:35902:    int n_valType;
        -:35903:    xmlChar * value; /* the lexical repr. of the value to be validated */
        -:35904:    int n_value;
        -:35905:    xmlSchemaValPtr val; /* the precomputed value */
        -:35906:    int n_val;
        -:35907:    unsigned long * length; /* the actual length of the value */
        -:35908:    int n_length;
        -:35909:    xmlSchemaWhitespaceValueType ws; /* the whitespace type of the value */
        -:35910:    int n_ws;
        -:35911:
    #####:35912:    for (n_facet = 0;n_facet < gen_nb_xmlSchemaFacetPtr;n_facet++) {
    #####:35913:    for (n_valType = 0;n_valType < gen_nb_xmlSchemaValType;n_valType++) {
    #####:35914:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:35915:    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr;n_val++) {
    #####:35916:    for (n_length = 0;n_length < gen_nb_unsigned_long_ptr;n_length++) {
    #####:35917:    for (n_ws = 0;n_ws < gen_nb_xmlSchemaWhitespaceValueType;n_ws++) {
    #####:35918:        mem_base = xmlMemBlocks();
    #####:35919:        facet = gen_xmlSchemaFacetPtr(n_facet, 0);
    #####:35920:        valType = gen_xmlSchemaValType(n_valType, 1);
    #####:35921:        value = gen_const_xmlChar_ptr(n_value, 2);
    #####:35922:        val = gen_xmlSchemaValPtr(n_val, 3);
    #####:35923:        length = gen_unsigned_long_ptr(n_length, 4);
    #####:35924:        ws = gen_xmlSchemaWhitespaceValueType(n_ws, 5);
        -:35925:
    #####:35926:        ret_val = xmlSchemaValidateLengthFacetWhtsp(facet, valType, (const xmlChar *)value, val, length, ws);
    #####:35927:        desret_int(ret_val);
    #####:35928:        call_tests++;
    #####:35929:        des_xmlSchemaFacetPtr(n_facet, facet, 0);
    #####:35930:        des_xmlSchemaValType(n_valType, valType, 1);
    #####:35931:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 2);
    #####:35932:        des_xmlSchemaValPtr(n_val, val, 3);
    #####:35933:        des_unsigned_long_ptr(n_length, length, 4);
    #####:35934:        des_xmlSchemaWhitespaceValueType(n_ws, ws, 5);
    #####:35935:        xmlResetLastError();
    #####:35936:        if (mem_base != xmlMemBlocks()) {
    #####:35937:            printf("Leak of %d blocks found in xmlSchemaValidateLengthFacetWhtsp",
    #####:35938:	           xmlMemBlocks() - mem_base);
    #####:35939:	    test_ret++;
    #####:35940:            printf(" %d", n_facet);
    #####:35941:            printf(" %d", n_valType);
    #####:35942:            printf(" %d", n_value);
    #####:35943:            printf(" %d", n_val);
    #####:35944:            printf(" %d", n_length);
    #####:35945:            printf(" %d", n_ws);
    #####:35946:            printf("\n");
        -:35947:        }
        -:35948:    }
        -:35949:    }
        -:35950:    }
        -:35951:    }
        -:35952:    }
        -:35953:    }
    #####:35954:    function_tests++;
        -:35955:#endif
        -:35956:
    #####:35957:    return(test_ret);
        -:35958:}
        -:35959:
        -:35960:
        -:35961:static int
    #####:35962:test_xmlSchemaValidateListSimpleTypeFacet(void) {
    #####:35963:    int test_ret = 0;
        -:35964:
        -:35965:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:35966:    int mem_base;
        -:35967:    int ret_val;
        -:35968:    xmlSchemaFacetPtr facet; /* the facet to check */
        -:35969:    int n_facet;
        -:35970:    xmlChar * value; /* the lexical repr of the value to validate */
        -:35971:    int n_value;
        -:35972:    unsigned long actualLen; /* the number of list items */
        -:35973:    int n_actualLen;
        -:35974:    unsigned long * expectedLen; /* the resulting expected number of list items */
        -:35975:    int n_expectedLen;
        -:35976:
    #####:35977:    for (n_facet = 0;n_facet < gen_nb_xmlSchemaFacetPtr;n_facet++) {
    #####:35978:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:35979:    for (n_actualLen = 0;n_actualLen < gen_nb_unsigned_long;n_actualLen++) {
    #####:35980:    for (n_expectedLen = 0;n_expectedLen < gen_nb_unsigned_long_ptr;n_expectedLen++) {
    #####:35981:        mem_base = xmlMemBlocks();
    #####:35982:        facet = gen_xmlSchemaFacetPtr(n_facet, 0);
    #####:35983:        value = gen_const_xmlChar_ptr(n_value, 1);
    #####:35984:        actualLen = gen_unsigned_long(n_actualLen, 2);
    #####:35985:        expectedLen = gen_unsigned_long_ptr(n_expectedLen, 3);
        -:35986:
    #####:35987:        ret_val = xmlSchemaValidateListSimpleTypeFacet(facet, (const xmlChar *)value, actualLen, expectedLen);
    #####:35988:        desret_int(ret_val);
    #####:35989:        call_tests++;
    #####:35990:        des_xmlSchemaFacetPtr(n_facet, facet, 0);
    #####:35991:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 1);
    #####:35992:        des_unsigned_long(n_actualLen, actualLen, 2);
    #####:35993:        des_unsigned_long_ptr(n_expectedLen, expectedLen, 3);
    #####:35994:        xmlResetLastError();
    #####:35995:        if (mem_base != xmlMemBlocks()) {
    #####:35996:            printf("Leak of %d blocks found in xmlSchemaValidateListSimpleTypeFacet",
    #####:35997:	           xmlMemBlocks() - mem_base);
    #####:35998:	    test_ret++;
    #####:35999:            printf(" %d", n_facet);
    #####:36000:            printf(" %d", n_value);
    #####:36001:            printf(" %d", n_actualLen);
    #####:36002:            printf(" %d", n_expectedLen);
    #####:36003:            printf("\n");
        -:36004:        }
        -:36005:    }
        -:36006:    }
        -:36007:    }
        -:36008:    }
    #####:36009:    function_tests++;
        -:36010:#endif
        -:36011:
    #####:36012:    return(test_ret);
        -:36013:}
        -:36014:
        -:36015:
        -:36016:static int
    #####:36017:test_xmlSchemaValidatePredefinedType(void) {
    #####:36018:    int test_ret = 0;
        -:36019:
        -:36020:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:36021:    int mem_base;
        -:36022:    int ret_val;
        -:36023:    xmlSchemaTypePtr type; /* the predefined type */
        -:36024:    int n_type;
        -:36025:    xmlChar * value; /* the value to check */
        -:36026:    int n_value;
        -:36027:    xmlSchemaValPtr * val; /* the return computed value */
        -:36028:    int n_val;
        -:36029:
    #####:36030:    for (n_type = 0;n_type < gen_nb_xmlSchemaTypePtr;n_type++) {
    #####:36031:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:36032:    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr_ptr;n_val++) {
    #####:36033:        mem_base = xmlMemBlocks();
    #####:36034:        type = gen_xmlSchemaTypePtr(n_type, 0);
    #####:36035:        value = gen_const_xmlChar_ptr(n_value, 1);
    #####:36036:        val = gen_xmlSchemaValPtr_ptr(n_val, 2);
        -:36037:
    #####:36038:        ret_val = xmlSchemaValidatePredefinedType(type, (const xmlChar *)value, val);
    #####:36039:        desret_int(ret_val);
    #####:36040:        call_tests++;
    #####:36041:        des_xmlSchemaTypePtr(n_type, type, 0);
    #####:36042:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 1);
    #####:36043:        des_xmlSchemaValPtr_ptr(n_val, val, 2);
    #####:36044:        xmlResetLastError();
    #####:36045:        if (mem_base != xmlMemBlocks()) {
    #####:36046:            printf("Leak of %d blocks found in xmlSchemaValidatePredefinedType",
    #####:36047:	           xmlMemBlocks() - mem_base);
    #####:36048:	    test_ret++;
    #####:36049:            printf(" %d", n_type);
    #####:36050:            printf(" %d", n_value);
    #####:36051:            printf(" %d", n_val);
    #####:36052:            printf("\n");
        -:36053:        }
        -:36054:    }
        -:36055:    }
        -:36056:    }
    #####:36057:    function_tests++;
        -:36058:#endif
        -:36059:
    #####:36060:    return(test_ret);
        -:36061:}
        -:36062:
        -:36063:
        -:36064:static int
    #####:36065:test_xmlSchemaValueAppend(void) {
    #####:36066:    int test_ret = 0;
        -:36067:
        -:36068:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:36069:    int mem_base;
        -:36070:    int ret_val;
        -:36071:    xmlSchemaValPtr prev; /* the value */
        -:36072:    int n_prev;
        -:36073:    xmlSchemaValPtr cur; /* the value to be appended */
        -:36074:    int n_cur;
        -:36075:
    #####:36076:    for (n_prev = 0;n_prev < gen_nb_xmlSchemaValPtr;n_prev++) {
    #####:36077:    for (n_cur = 0;n_cur < gen_nb_xmlSchemaValPtr;n_cur++) {
    #####:36078:        mem_base = xmlMemBlocks();
    #####:36079:        prev = gen_xmlSchemaValPtr(n_prev, 0);
    #####:36080:        cur = gen_xmlSchemaValPtr(n_cur, 1);
        -:36081:
    #####:36082:        ret_val = xmlSchemaValueAppend(prev, cur);
    #####:36083:        desret_int(ret_val);
    #####:36084:        call_tests++;
    #####:36085:        des_xmlSchemaValPtr(n_prev, prev, 0);
    #####:36086:        des_xmlSchemaValPtr(n_cur, cur, 1);
    #####:36087:        xmlResetLastError();
    #####:36088:        if (mem_base != xmlMemBlocks()) {
    #####:36089:            printf("Leak of %d blocks found in xmlSchemaValueAppend",
    #####:36090:	           xmlMemBlocks() - mem_base);
    #####:36091:	    test_ret++;
    #####:36092:            printf(" %d", n_prev);
    #####:36093:            printf(" %d", n_cur);
    #####:36094:            printf("\n");
        -:36095:        }
        -:36096:    }
        -:36097:    }
    #####:36098:    function_tests++;
        -:36099:#endif
        -:36100:
    #####:36101:    return(test_ret);
        -:36102:}
        -:36103:
        -:36104:
        -:36105:static int
    #####:36106:test_xmlSchemaValueGetAsBoolean(void) {
    #####:36107:    int test_ret = 0;
        -:36108:
        -:36109:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:36110:    int mem_base;
        -:36111:    int ret_val;
        -:36112:    xmlSchemaValPtr val; /* the value */
        -:36113:    int n_val;
        -:36114:
    #####:36115:    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr;n_val++) {
    #####:36116:        mem_base = xmlMemBlocks();
    #####:36117:        val = gen_xmlSchemaValPtr(n_val, 0);
        -:36118:
    #####:36119:        ret_val = xmlSchemaValueGetAsBoolean(val);
    #####:36120:        desret_int(ret_val);
    #####:36121:        call_tests++;
    #####:36122:        des_xmlSchemaValPtr(n_val, val, 0);
    #####:36123:        xmlResetLastError();
    #####:36124:        if (mem_base != xmlMemBlocks()) {
    #####:36125:            printf("Leak of %d blocks found in xmlSchemaValueGetAsBoolean",
    #####:36126:	           xmlMemBlocks() - mem_base);
    #####:36127:	    test_ret++;
    #####:36128:            printf(" %d", n_val);
    #####:36129:            printf("\n");
        -:36130:        }
        -:36131:    }
    #####:36132:    function_tests++;
        -:36133:#endif
        -:36134:
    #####:36135:    return(test_ret);
        -:36136:}
        -:36137:
        -:36138:
        -:36139:static int
    #####:36140:test_xmlSchemaValueGetAsString(void) {
    #####:36141:    int test_ret = 0;
        -:36142:
        -:36143:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:36144:    int mem_base;
        -:36145:    const xmlChar * ret_val;
        -:36146:    xmlSchemaValPtr val; /* the value */
        -:36147:    int n_val;
        -:36148:
    #####:36149:    for (n_val = 0;n_val < gen_nb_xmlSchemaValPtr;n_val++) {
    #####:36150:        mem_base = xmlMemBlocks();
    #####:36151:        val = gen_xmlSchemaValPtr(n_val, 0);
        -:36152:
    #####:36153:        ret_val = xmlSchemaValueGetAsString(val);
    #####:36154:        desret_const_xmlChar_ptr(ret_val);
    #####:36155:        call_tests++;
    #####:36156:        des_xmlSchemaValPtr(n_val, val, 0);
    #####:36157:        xmlResetLastError();
    #####:36158:        if (mem_base != xmlMemBlocks()) {
    #####:36159:            printf("Leak of %d blocks found in xmlSchemaValueGetAsString",
    #####:36160:	           xmlMemBlocks() - mem_base);
    #####:36161:	    test_ret++;
    #####:36162:            printf(" %d", n_val);
    #####:36163:            printf("\n");
        -:36164:        }
        -:36165:    }
    #####:36166:    function_tests++;
        -:36167:#endif
        -:36168:
    #####:36169:    return(test_ret);
        -:36170:}
        -:36171:
        -:36172:
        -:36173:static int
    #####:36174:test_xmlSchemaValueGetNext(void) {
    #####:36175:    int test_ret = 0;
        -:36176:
        -:36177:
        -:36178:    /* missing type support */
    #####:36179:    return(test_ret);
        -:36180:}
        -:36181:
        -:36182:
        -:36183:static int
    #####:36184:test_xmlSchemaWhiteSpaceReplace(void) {
    #####:36185:    int test_ret = 0;
        -:36186:
        -:36187:#if defined(LIBXML_SCHEMAS_ENABLED)
        -:36188:    int mem_base;
        -:36189:    xmlChar * ret_val;
        -:36190:    xmlChar * value; /* a value */
        -:36191:    int n_value;
        -:36192:
    #####:36193:    for (n_value = 0;n_value < gen_nb_const_xmlChar_ptr;n_value++) {
    #####:36194:        mem_base = xmlMemBlocks();
    #####:36195:        value = gen_const_xmlChar_ptr(n_value, 0);
        -:36196:
    #####:36197:        ret_val = xmlSchemaWhiteSpaceReplace((const xmlChar *)value);
    #####:36198:        desret_xmlChar_ptr(ret_val);
    #####:36199:        call_tests++;
    #####:36200:        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 0);
    #####:36201:        xmlResetLastError();
    #####:36202:        if (mem_base != xmlMemBlocks()) {
    #####:36203:            printf("Leak of %d blocks found in xmlSchemaWhiteSpaceReplace",
    #####:36204:	           xmlMemBlocks() - mem_base);
    #####:36205:	    test_ret++;
    #####:36206:            printf(" %d", n_value);
    #####:36207:            printf("\n");
        -:36208:        }
        -:36209:    }
    #####:36210:    function_tests++;
        -:36211:#endif
        -:36212:
    #####:36213:    return(test_ret);
        -:36214:}
        -:36215:
        -:36216:static int
    #####:36217:test_xmlschemastypes(void) {
    #####:36218:    int test_ret = 0;
        -:36219:
    #####:36220:    if (quiet == 0) printf("Testing xmlschemastypes : 26 of 34 functions ...\n");
    #####:36221:    test_ret += test_xmlSchemaCheckFacet();
    #####:36222:    test_ret += test_xmlSchemaCleanupTypes();
    #####:36223:    test_ret += test_xmlSchemaCollapseString();
    #####:36224:    test_ret += test_xmlSchemaCompareValues();
    #####:36225:    test_ret += test_xmlSchemaCompareValuesWhtsp();
    #####:36226:    test_ret += test_xmlSchemaCopyValue();
    #####:36227:    test_ret += test_xmlSchemaGetBuiltInListSimpleTypeItemType();
    #####:36228:    test_ret += test_xmlSchemaGetBuiltInType();
    #####:36229:    test_ret += test_xmlSchemaGetCanonValue();
    #####:36230:    test_ret += test_xmlSchemaGetCanonValueWhtsp();
    #####:36231:    test_ret += test_xmlSchemaGetFacetValueAsULong();
    #####:36232:    test_ret += test_xmlSchemaGetPredefinedType();
    #####:36233:    test_ret += test_xmlSchemaGetValType();
    #####:36234:    test_ret += test_xmlSchemaInitTypes();
    #####:36235:    test_ret += test_xmlSchemaIsBuiltInTypeFacet();
    #####:36236:    test_ret += test_xmlSchemaNewFacet();
    #####:36237:    test_ret += test_xmlSchemaNewNOTATIONValue();
    #####:36238:    test_ret += test_xmlSchemaNewQNameValue();
    #####:36239:    test_ret += test_xmlSchemaNewStringValue();
    #####:36240:    test_ret += test_xmlSchemaValPredefTypeNode();
    #####:36241:    test_ret += test_xmlSchemaValPredefTypeNodeNoNorm();
    #####:36242:    test_ret += test_xmlSchemaValidateFacet();
    #####:36243:    test_ret += test_xmlSchemaValidateFacetWhtsp();
    #####:36244:    test_ret += test_xmlSchemaValidateLengthFacet();
    #####:36245:    test_ret += test_xmlSchemaValidateLengthFacetWhtsp();
    #####:36246:    test_ret += test_xmlSchemaValidateListSimpleTypeFacet();
    #####:36247:    test_ret += test_xmlSchemaValidatePredefinedType();
    #####:36248:    test_ret += test_xmlSchemaValueAppend();
    #####:36249:    test_ret += test_xmlSchemaValueGetAsBoolean();
    #####:36250:    test_ret += test_xmlSchemaValueGetAsString();
    #####:36251:    test_ret += test_xmlSchemaValueGetNext();
    #####:36252:    test_ret += test_xmlSchemaWhiteSpaceReplace();
        -:36253:
    #####:36254:    if (test_ret != 0)
    #####:36255:	printf("Module xmlschemastypes: %d errors\n", test_ret);
    #####:36256:    return(test_ret);
        -:36257:}
        -:36258:
        -:36259:static int
    #####:36260:test_xmlCharStrdup(void) {
    #####:36261:    int test_ret = 0;
        -:36262:
        -:36263:    int mem_base;
        -:36264:    xmlChar * ret_val;
        -:36265:    char * cur; /* the input char * */
        -:36266:    int n_cur;
        -:36267:
    #####:36268:    for (n_cur = 0;n_cur < gen_nb_const_char_ptr;n_cur++) {
    #####:36269:        mem_base = xmlMemBlocks();
    #####:36270:        cur = gen_const_char_ptr(n_cur, 0);
        -:36271:
    #####:36272:        ret_val = xmlCharStrdup((const char *)cur);
    #####:36273:        desret_xmlChar_ptr(ret_val);
    #####:36274:        call_tests++;
    #####:36275:        des_const_char_ptr(n_cur, (const char *)cur, 0);
    #####:36276:        xmlResetLastError();
    #####:36277:        if (mem_base != xmlMemBlocks()) {
    #####:36278:            printf("Leak of %d blocks found in xmlCharStrdup",
    #####:36279:	           xmlMemBlocks() - mem_base);
    #####:36280:	    test_ret++;
    #####:36281:            printf(" %d", n_cur);
    #####:36282:            printf("\n");
        -:36283:        }
        -:36284:    }
    #####:36285:    function_tests++;
        -:36286:
    #####:36287:    return(test_ret);
        -:36288:}
        -:36289:
        -:36290:
        -:36291:static int
    #####:36292:test_xmlCharStrndup(void) {
    #####:36293:    int test_ret = 0;
        -:36294:
        -:36295:    int mem_base;
        -:36296:    xmlChar * ret_val;
        -:36297:    char * cur; /* the input char * */
        -:36298:    int n_cur;
        -:36299:    int len; /* the len of @cur */
        -:36300:    int n_len;
        -:36301:
    #####:36302:    for (n_cur = 0;n_cur < gen_nb_const_char_ptr;n_cur++) {
    #####:36303:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:36304:        mem_base = xmlMemBlocks();
    #####:36305:        cur = gen_const_char_ptr(n_cur, 0);
    #####:36306:        len = gen_int(n_len, 1);
        -:36307:
    #####:36308:        ret_val = xmlCharStrndup((const char *)cur, len);
    #####:36309:        desret_xmlChar_ptr(ret_val);
    #####:36310:        call_tests++;
    #####:36311:        des_const_char_ptr(n_cur, (const char *)cur, 0);
    #####:36312:        des_int(n_len, len, 1);
    #####:36313:        xmlResetLastError();
    #####:36314:        if (mem_base != xmlMemBlocks()) {
    #####:36315:            printf("Leak of %d blocks found in xmlCharStrndup",
    #####:36316:	           xmlMemBlocks() - mem_base);
    #####:36317:	    test_ret++;
    #####:36318:            printf(" %d", n_cur);
    #####:36319:            printf(" %d", n_len);
    #####:36320:            printf("\n");
        -:36321:        }
        -:36322:    }
        -:36323:    }
    #####:36324:    function_tests++;
        -:36325:
    #####:36326:    return(test_ret);
        -:36327:}
        -:36328:
        -:36329:
        -:36330:static int
    #####:36331:test_xmlCheckUTF8(void) {
    #####:36332:    int test_ret = 0;
        -:36333:
        -:36334:    int mem_base;
        -:36335:    int ret_val;
        -:36336:    unsigned char * utf; /* Pointer to putative UTF-8 encoded string. */
        -:36337:    int n_utf;
        -:36338:
    #####:36339:    for (n_utf = 0;n_utf < gen_nb_const_unsigned_char_ptr;n_utf++) {
    #####:36340:        mem_base = xmlMemBlocks();
    #####:36341:        utf = gen_const_unsigned_char_ptr(n_utf, 0);
        -:36342:
    #####:36343:        ret_val = xmlCheckUTF8((const unsigned char *)utf);
    #####:36344:        desret_int(ret_val);
    #####:36345:        call_tests++;
    #####:36346:        des_const_unsigned_char_ptr(n_utf, (const unsigned char *)utf, 0);
    #####:36347:        xmlResetLastError();
    #####:36348:        if (mem_base != xmlMemBlocks()) {
    #####:36349:            printf("Leak of %d blocks found in xmlCheckUTF8",
    #####:36350:	           xmlMemBlocks() - mem_base);
    #####:36351:	    test_ret++;
    #####:36352:            printf(" %d", n_utf);
    #####:36353:            printf("\n");
        -:36354:        }
        -:36355:    }
    #####:36356:    function_tests++;
        -:36357:
    #####:36358:    return(test_ret);
        -:36359:}
        -:36360:
        -:36361:
        -:36362:static int
    #####:36363:test_xmlGetUTF8Char(void) {
    #####:36364:    int test_ret = 0;
        -:36365:
        -:36366:    int mem_base;
        -:36367:    int ret_val;
        -:36368:    unsigned char * utf; /* a sequence of UTF-8 encoded bytes */
        -:36369:    int n_utf;
        -:36370:    int * len; /* a pointer to the minimum number of bytes present in the sequence.  This is used to assure the next character is completely contained within the sequence. */
        -:36371:    int n_len;
        -:36372:
    #####:36373:    for (n_utf = 0;n_utf < gen_nb_const_unsigned_char_ptr;n_utf++) {
    #####:36374:    for (n_len = 0;n_len < gen_nb_int_ptr;n_len++) {
    #####:36375:        mem_base = xmlMemBlocks();
    #####:36376:        utf = gen_const_unsigned_char_ptr(n_utf, 0);
    #####:36377:        len = gen_int_ptr(n_len, 1);
        -:36378:
    #####:36379:        ret_val = xmlGetUTF8Char((const unsigned char *)utf, len);
    #####:36380:        desret_int(ret_val);
    #####:36381:        call_tests++;
    #####:36382:        des_const_unsigned_char_ptr(n_utf, (const unsigned char *)utf, 0);
    #####:36383:        des_int_ptr(n_len, len, 1);
    #####:36384:        xmlResetLastError();
    #####:36385:        if (mem_base != xmlMemBlocks()) {
    #####:36386:            printf("Leak of %d blocks found in xmlGetUTF8Char",
    #####:36387:	           xmlMemBlocks() - mem_base);
    #####:36388:	    test_ret++;
    #####:36389:            printf(" %d", n_utf);
    #####:36390:            printf(" %d", n_len);
    #####:36391:            printf("\n");
        -:36392:        }
        -:36393:    }
        -:36394:    }
    #####:36395:    function_tests++;
        -:36396:
    #####:36397:    return(test_ret);
        -:36398:}
        -:36399:
        -:36400:
        -:36401:static int
    #####:36402:test_xmlStrEqual(void) {
    #####:36403:    int test_ret = 0;
        -:36404:
        -:36405:    int mem_base;
        -:36406:    int ret_val;
        -:36407:    xmlChar * str1; /* the first xmlChar * */
        -:36408:    int n_str1;
        -:36409:    xmlChar * str2; /* the second xmlChar * */
        -:36410:    int n_str2;
        -:36411:
    #####:36412:    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
    #####:36413:    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
    #####:36414:        mem_base = xmlMemBlocks();
    #####:36415:        str1 = gen_const_xmlChar_ptr(n_str1, 0);
    #####:36416:        str2 = gen_const_xmlChar_ptr(n_str2, 1);
        -:36417:
    #####:36418:        ret_val = xmlStrEqual((const xmlChar *)str1, (const xmlChar *)str2);
    #####:36419:        desret_int(ret_val);
    #####:36420:        call_tests++;
    #####:36421:        des_const_xmlChar_ptr(n_str1, (const xmlChar *)str1, 0);
    #####:36422:        des_const_xmlChar_ptr(n_str2, (const xmlChar *)str2, 1);
    #####:36423:        xmlResetLastError();
    #####:36424:        if (mem_base != xmlMemBlocks()) {
    #####:36425:            printf("Leak of %d blocks found in xmlStrEqual",
    #####:36426:	           xmlMemBlocks() - mem_base);
    #####:36427:	    test_ret++;
    #####:36428:            printf(" %d", n_str1);
    #####:36429:            printf(" %d", n_str2);
    #####:36430:            printf("\n");
        -:36431:        }
        -:36432:    }
        -:36433:    }
    #####:36434:    function_tests++;
        -:36435:
    #####:36436:    return(test_ret);
        -:36437:}
        -:36438:
        -:36439:
        -:36440:static int
    #####:36441:test_xmlStrPrintf(void) {
    #####:36442:    int test_ret = 0;
        -:36443:
        -:36444:
        -:36445:    /* missing type support */
    #####:36446:    return(test_ret);
        -:36447:}
        -:36448:
        -:36449:
        -:36450:static int
    #####:36451:test_xmlStrQEqual(void) {
    #####:36452:    int test_ret = 0;
        -:36453:
        -:36454:    int mem_base;
        -:36455:    int ret_val;
        -:36456:    xmlChar * pref; /* the prefix of the QName */
        -:36457:    int n_pref;
        -:36458:    xmlChar * name; /* the localname of the QName */
        -:36459:    int n_name;
        -:36460:    xmlChar * str; /* the second xmlChar * */
        -:36461:    int n_str;
        -:36462:
    #####:36463:    for (n_pref = 0;n_pref < gen_nb_const_xmlChar_ptr;n_pref++) {
    #####:36464:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:36465:    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    #####:36466:        mem_base = xmlMemBlocks();
    #####:36467:        pref = gen_const_xmlChar_ptr(n_pref, 0);
    #####:36468:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:36469:        str = gen_const_xmlChar_ptr(n_str, 2);
        -:36470:
    #####:36471:        ret_val = xmlStrQEqual((const xmlChar *)pref, (const xmlChar *)name, (const xmlChar *)str);
    #####:36472:        desret_int(ret_val);
    #####:36473:        call_tests++;
    #####:36474:        des_const_xmlChar_ptr(n_pref, (const xmlChar *)pref, 0);
    #####:36475:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:36476:        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 2);
    #####:36477:        xmlResetLastError();
    #####:36478:        if (mem_base != xmlMemBlocks()) {
    #####:36479:            printf("Leak of %d blocks found in xmlStrQEqual",
    #####:36480:	           xmlMemBlocks() - mem_base);
    #####:36481:	    test_ret++;
    #####:36482:            printf(" %d", n_pref);
    #####:36483:            printf(" %d", n_name);
    #####:36484:            printf(" %d", n_str);
    #####:36485:            printf("\n");
        -:36486:        }
        -:36487:    }
        -:36488:    }
        -:36489:    }
    #####:36490:    function_tests++;
        -:36491:
    #####:36492:    return(test_ret);
        -:36493:}
        -:36494:
        -:36495:
        -:36496:static int
    #####:36497:test_xmlStrVPrintf(void) {
    #####:36498:    int test_ret = 0;
        -:36499:
        -:36500:
        -:36501:    /* missing type support */
    #####:36502:    return(test_ret);
        -:36503:}
        -:36504:
        -:36505:
        -:36506:static int
    #####:36507:test_xmlStrcasecmp(void) {
    #####:36508:    int test_ret = 0;
        -:36509:
        -:36510:    int mem_base;
        -:36511:    int ret_val;
        -:36512:    xmlChar * str1; /* the first xmlChar * */
        -:36513:    int n_str1;
        -:36514:    xmlChar * str2; /* the second xmlChar * */
        -:36515:    int n_str2;
        -:36516:
    #####:36517:    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
    #####:36518:    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
    #####:36519:        mem_base = xmlMemBlocks();
    #####:36520:        str1 = gen_const_xmlChar_ptr(n_str1, 0);
    #####:36521:        str2 = gen_const_xmlChar_ptr(n_str2, 1);
        -:36522:
    #####:36523:        ret_val = xmlStrcasecmp((const xmlChar *)str1, (const xmlChar *)str2);
    #####:36524:        desret_int(ret_val);
    #####:36525:        call_tests++;
    #####:36526:        des_const_xmlChar_ptr(n_str1, (const xmlChar *)str1, 0);
    #####:36527:        des_const_xmlChar_ptr(n_str2, (const xmlChar *)str2, 1);
    #####:36528:        xmlResetLastError();
    #####:36529:        if (mem_base != xmlMemBlocks()) {
    #####:36530:            printf("Leak of %d blocks found in xmlStrcasecmp",
    #####:36531:	           xmlMemBlocks() - mem_base);
    #####:36532:	    test_ret++;
    #####:36533:            printf(" %d", n_str1);
    #####:36534:            printf(" %d", n_str2);
    #####:36535:            printf("\n");
        -:36536:        }
        -:36537:    }
        -:36538:    }
    #####:36539:    function_tests++;
        -:36540:
    #####:36541:    return(test_ret);
        -:36542:}
        -:36543:
        -:36544:
        -:36545:static int
    #####:36546:test_xmlStrcasestr(void) {
    #####:36547:    int test_ret = 0;
        -:36548:
        -:36549:    int mem_base;
        -:36550:    const xmlChar * ret_val;
        -:36551:    xmlChar * str; /* the xmlChar * array (haystack) */
        -:36552:    int n_str;
        -:36553:    xmlChar * val; /* the xmlChar to search (needle) */
        -:36554:    int n_val;
        -:36555:
    #####:36556:    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    #####:36557:    for (n_val = 0;n_val < gen_nb_const_xmlChar_ptr;n_val++) {
    #####:36558:        mem_base = xmlMemBlocks();
    #####:36559:        str = gen_const_xmlChar_ptr(n_str, 0);
    #####:36560:        val = gen_const_xmlChar_ptr(n_val, 1);
        -:36561:
    #####:36562:        ret_val = xmlStrcasestr((const xmlChar *)str, (const xmlChar *)val);
    #####:36563:        desret_const_xmlChar_ptr(ret_val);
    #####:36564:        call_tests++;
    #####:36565:        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 0);
    #####:36566:        des_const_xmlChar_ptr(n_val, (const xmlChar *)val, 1);
    #####:36567:        xmlResetLastError();
    #####:36568:        if (mem_base != xmlMemBlocks()) {
    #####:36569:            printf("Leak of %d blocks found in xmlStrcasestr",
    #####:36570:	           xmlMemBlocks() - mem_base);
    #####:36571:	    test_ret++;
    #####:36572:            printf(" %d", n_str);
    #####:36573:            printf(" %d", n_val);
    #####:36574:            printf("\n");
        -:36575:        }
        -:36576:    }
        -:36577:    }
    #####:36578:    function_tests++;
        -:36579:
    #####:36580:    return(test_ret);
        -:36581:}
        -:36582:
        -:36583:
        -:36584:static int
    #####:36585:test_xmlStrchr(void) {
    #####:36586:    int test_ret = 0;
        -:36587:
        -:36588:    int mem_base;
        -:36589:    const xmlChar * ret_val;
        -:36590:    xmlChar * str; /* the xmlChar * array */
        -:36591:    int n_str;
        -:36592:    xmlChar val; /* the xmlChar to search */
        -:36593:    int n_val;
        -:36594:
    #####:36595:    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    #####:36596:    for (n_val = 0;n_val < gen_nb_xmlChar;n_val++) {
    #####:36597:        mem_base = xmlMemBlocks();
    #####:36598:        str = gen_const_xmlChar_ptr(n_str, 0);
    #####:36599:        val = gen_xmlChar(n_val, 1);
        -:36600:
    #####:36601:        ret_val = xmlStrchr((const xmlChar *)str, val);
    #####:36602:        desret_const_xmlChar_ptr(ret_val);
    #####:36603:        call_tests++;
    #####:36604:        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 0);
    #####:36605:        des_xmlChar(n_val, val, 1);
    #####:36606:        xmlResetLastError();
    #####:36607:        if (mem_base != xmlMemBlocks()) {
    #####:36608:            printf("Leak of %d blocks found in xmlStrchr",
    #####:36609:	           xmlMemBlocks() - mem_base);
    #####:36610:	    test_ret++;
    #####:36611:            printf(" %d", n_str);
    #####:36612:            printf(" %d", n_val);
    #####:36613:            printf("\n");
        -:36614:        }
        -:36615:    }
        -:36616:    }
    #####:36617:    function_tests++;
        -:36618:
    #####:36619:    return(test_ret);
        -:36620:}
        -:36621:
        -:36622:
        -:36623:static int
    #####:36624:test_xmlStrcmp(void) {
    #####:36625:    int test_ret = 0;
        -:36626:
        -:36627:    int mem_base;
        -:36628:    int ret_val;
        -:36629:    xmlChar * str1; /* the first xmlChar * */
        -:36630:    int n_str1;
        -:36631:    xmlChar * str2; /* the second xmlChar * */
        -:36632:    int n_str2;
        -:36633:
    #####:36634:    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
    #####:36635:    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
    #####:36636:        mem_base = xmlMemBlocks();
    #####:36637:        str1 = gen_const_xmlChar_ptr(n_str1, 0);
    #####:36638:        str2 = gen_const_xmlChar_ptr(n_str2, 1);
        -:36639:
    #####:36640:        ret_val = xmlStrcmp((const xmlChar *)str1, (const xmlChar *)str2);
    #####:36641:        desret_int(ret_val);
    #####:36642:        call_tests++;
    #####:36643:        des_const_xmlChar_ptr(n_str1, (const xmlChar *)str1, 0);
    #####:36644:        des_const_xmlChar_ptr(n_str2, (const xmlChar *)str2, 1);
    #####:36645:        xmlResetLastError();
    #####:36646:        if (mem_base != xmlMemBlocks()) {
    #####:36647:            printf("Leak of %d blocks found in xmlStrcmp",
    #####:36648:	           xmlMemBlocks() - mem_base);
    #####:36649:	    test_ret++;
    #####:36650:            printf(" %d", n_str1);
    #####:36651:            printf(" %d", n_str2);
    #####:36652:            printf("\n");
        -:36653:        }
        -:36654:    }
        -:36655:    }
    #####:36656:    function_tests++;
        -:36657:
    #####:36658:    return(test_ret);
        -:36659:}
        -:36660:
        -:36661:
        -:36662:static int
    #####:36663:test_xmlStrdup(void) {
    #####:36664:    int test_ret = 0;
        -:36665:
        -:36666:    int mem_base;
        -:36667:    xmlChar * ret_val;
        -:36668:    xmlChar * cur; /* the input xmlChar * */
        -:36669:    int n_cur;
        -:36670:
    #####:36671:    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    #####:36672:        mem_base = xmlMemBlocks();
    #####:36673:        cur = gen_const_xmlChar_ptr(n_cur, 0);
        -:36674:
    #####:36675:        ret_val = xmlStrdup((const xmlChar *)cur);
    #####:36676:        desret_xmlChar_ptr(ret_val);
    #####:36677:        call_tests++;
    #####:36678:        des_const_xmlChar_ptr(n_cur, (const xmlChar *)cur, 0);
    #####:36679:        xmlResetLastError();
    #####:36680:        if (mem_base != xmlMemBlocks()) {
    #####:36681:            printf("Leak of %d blocks found in xmlStrdup",
    #####:36682:	           xmlMemBlocks() - mem_base);
    #####:36683:	    test_ret++;
    #####:36684:            printf(" %d", n_cur);
    #####:36685:            printf("\n");
        -:36686:        }
        -:36687:    }
    #####:36688:    function_tests++;
        -:36689:
    #####:36690:    return(test_ret);
        -:36691:}
        -:36692:
        -:36693:
        -:36694:static int
    #####:36695:test_xmlStrlen(void) {
    #####:36696:    int test_ret = 0;
        -:36697:
        -:36698:    int mem_base;
        -:36699:    int ret_val;
        -:36700:    xmlChar * str; /* the xmlChar * array */
        -:36701:    int n_str;
        -:36702:
    #####:36703:    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    #####:36704:        mem_base = xmlMemBlocks();
    #####:36705:        str = gen_const_xmlChar_ptr(n_str, 0);
        -:36706:
    #####:36707:        ret_val = xmlStrlen((const xmlChar *)str);
    #####:36708:        desret_int(ret_val);
    #####:36709:        call_tests++;
    #####:36710:        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 0);
    #####:36711:        xmlResetLastError();
    #####:36712:        if (mem_base != xmlMemBlocks()) {
    #####:36713:            printf("Leak of %d blocks found in xmlStrlen",
    #####:36714:	           xmlMemBlocks() - mem_base);
    #####:36715:	    test_ret++;
    #####:36716:            printf(" %d", n_str);
    #####:36717:            printf("\n");
        -:36718:        }
        -:36719:    }
    #####:36720:    function_tests++;
        -:36721:
    #####:36722:    return(test_ret);
        -:36723:}
        -:36724:
        -:36725:
        -:36726:static int
    #####:36727:test_xmlStrncasecmp(void) {
    #####:36728:    int test_ret = 0;
        -:36729:
        -:36730:    int mem_base;
        -:36731:    int ret_val;
        -:36732:    xmlChar * str1; /* the first xmlChar * */
        -:36733:    int n_str1;
        -:36734:    xmlChar * str2; /* the second xmlChar * */
        -:36735:    int n_str2;
        -:36736:    int len; /* the max comparison length */
        -:36737:    int n_len;
        -:36738:
    #####:36739:    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
    #####:36740:    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
    #####:36741:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:36742:        mem_base = xmlMemBlocks();
    #####:36743:        str1 = gen_const_xmlChar_ptr(n_str1, 0);
    #####:36744:        str2 = gen_const_xmlChar_ptr(n_str2, 1);
    #####:36745:        len = gen_int(n_len, 2);
        -:36746:
    #####:36747:        ret_val = xmlStrncasecmp((const xmlChar *)str1, (const xmlChar *)str2, len);
    #####:36748:        desret_int(ret_val);
    #####:36749:        call_tests++;
    #####:36750:        des_const_xmlChar_ptr(n_str1, (const xmlChar *)str1, 0);
    #####:36751:        des_const_xmlChar_ptr(n_str2, (const xmlChar *)str2, 1);
    #####:36752:        des_int(n_len, len, 2);
    #####:36753:        xmlResetLastError();
    #####:36754:        if (mem_base != xmlMemBlocks()) {
    #####:36755:            printf("Leak of %d blocks found in xmlStrncasecmp",
    #####:36756:	           xmlMemBlocks() - mem_base);
    #####:36757:	    test_ret++;
    #####:36758:            printf(" %d", n_str1);
    #####:36759:            printf(" %d", n_str2);
    #####:36760:            printf(" %d", n_len);
    #####:36761:            printf("\n");
        -:36762:        }
        -:36763:    }
        -:36764:    }
        -:36765:    }
    #####:36766:    function_tests++;
        -:36767:
    #####:36768:    return(test_ret);
        -:36769:}
        -:36770:
        -:36771:
        -:36772:static int
    #####:36773:test_xmlStrncatNew(void) {
    #####:36774:    int test_ret = 0;
        -:36775:
        -:36776:    int mem_base;
        -:36777:    xmlChar * ret_val;
        -:36778:    xmlChar * str1; /* first xmlChar string */
        -:36779:    int n_str1;
        -:36780:    xmlChar * str2; /* second xmlChar string */
        -:36781:    int n_str2;
        -:36782:    int len; /* the len of @str2 or < 0 */
        -:36783:    int n_len;
        -:36784:
    #####:36785:    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
    #####:36786:    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
    #####:36787:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:36788:        mem_base = xmlMemBlocks();
    #####:36789:        str1 = gen_const_xmlChar_ptr(n_str1, 0);
    #####:36790:        str2 = gen_const_xmlChar_ptr(n_str2, 1);
    #####:36791:        len = gen_int(n_len, 2);
        -:36792:
    #####:36793:        ret_val = xmlStrncatNew((const xmlChar *)str1, (const xmlChar *)str2, len);
    #####:36794:        desret_xmlChar_ptr(ret_val);
    #####:36795:        call_tests++;
    #####:36796:        des_const_xmlChar_ptr(n_str1, (const xmlChar *)str1, 0);
    #####:36797:        des_const_xmlChar_ptr(n_str2, (const xmlChar *)str2, 1);
    #####:36798:        des_int(n_len, len, 2);
    #####:36799:        xmlResetLastError();
    #####:36800:        if (mem_base != xmlMemBlocks()) {
    #####:36801:            printf("Leak of %d blocks found in xmlStrncatNew",
    #####:36802:	           xmlMemBlocks() - mem_base);
    #####:36803:	    test_ret++;
    #####:36804:            printf(" %d", n_str1);
    #####:36805:            printf(" %d", n_str2);
    #####:36806:            printf(" %d", n_len);
    #####:36807:            printf("\n");
        -:36808:        }
        -:36809:    }
        -:36810:    }
        -:36811:    }
    #####:36812:    function_tests++;
        -:36813:
    #####:36814:    return(test_ret);
        -:36815:}
        -:36816:
        -:36817:
        -:36818:static int
    #####:36819:test_xmlStrncmp(void) {
    #####:36820:    int test_ret = 0;
        -:36821:
        -:36822:    int mem_base;
        -:36823:    int ret_val;
        -:36824:    xmlChar * str1; /* the first xmlChar * */
        -:36825:    int n_str1;
        -:36826:    xmlChar * str2; /* the second xmlChar * */
        -:36827:    int n_str2;
        -:36828:    int len; /* the max comparison length */
        -:36829:    int n_len;
        -:36830:
    #####:36831:    for (n_str1 = 0;n_str1 < gen_nb_const_xmlChar_ptr;n_str1++) {
    #####:36832:    for (n_str2 = 0;n_str2 < gen_nb_const_xmlChar_ptr;n_str2++) {
    #####:36833:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:36834:        mem_base = xmlMemBlocks();
    #####:36835:        str1 = gen_const_xmlChar_ptr(n_str1, 0);
    #####:36836:        str2 = gen_const_xmlChar_ptr(n_str2, 1);
    #####:36837:        len = gen_int(n_len, 2);
        -:36838:
    #####:36839:        ret_val = xmlStrncmp((const xmlChar *)str1, (const xmlChar *)str2, len);
    #####:36840:        desret_int(ret_val);
    #####:36841:        call_tests++;
    #####:36842:        des_const_xmlChar_ptr(n_str1, (const xmlChar *)str1, 0);
    #####:36843:        des_const_xmlChar_ptr(n_str2, (const xmlChar *)str2, 1);
    #####:36844:        des_int(n_len, len, 2);
    #####:36845:        xmlResetLastError();
    #####:36846:        if (mem_base != xmlMemBlocks()) {
    #####:36847:            printf("Leak of %d blocks found in xmlStrncmp",
    #####:36848:	           xmlMemBlocks() - mem_base);
    #####:36849:	    test_ret++;
    #####:36850:            printf(" %d", n_str1);
    #####:36851:            printf(" %d", n_str2);
    #####:36852:            printf(" %d", n_len);
    #####:36853:            printf("\n");
        -:36854:        }
        -:36855:    }
        -:36856:    }
        -:36857:    }
    #####:36858:    function_tests++;
        -:36859:
    #####:36860:    return(test_ret);
        -:36861:}
        -:36862:
        -:36863:
        -:36864:static int
    #####:36865:test_xmlStrndup(void) {
    #####:36866:    int test_ret = 0;
        -:36867:
        -:36868:    int mem_base;
        -:36869:    xmlChar * ret_val;
        -:36870:    xmlChar * cur; /* the input xmlChar * */
        -:36871:    int n_cur;
        -:36872:    int len; /* the len of @cur */
        -:36873:    int n_len;
        -:36874:
    #####:36875:    for (n_cur = 0;n_cur < gen_nb_const_xmlChar_ptr;n_cur++) {
    #####:36876:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:36877:        mem_base = xmlMemBlocks();
    #####:36878:        cur = gen_const_xmlChar_ptr(n_cur, 0);
    #####:36879:        len = gen_int(n_len, 1);
        -:36880:
    #####:36881:        ret_val = xmlStrndup((const xmlChar *)cur, len);
    #####:36882:        desret_xmlChar_ptr(ret_val);
    #####:36883:        call_tests++;
    #####:36884:        des_const_xmlChar_ptr(n_cur, (const xmlChar *)cur, 0);
    #####:36885:        des_int(n_len, len, 1);
    #####:36886:        xmlResetLastError();
    #####:36887:        if (mem_base != xmlMemBlocks()) {
    #####:36888:            printf("Leak of %d blocks found in xmlStrndup",
    #####:36889:	           xmlMemBlocks() - mem_base);
    #####:36890:	    test_ret++;
    #####:36891:            printf(" %d", n_cur);
    #####:36892:            printf(" %d", n_len);
    #####:36893:            printf("\n");
        -:36894:        }
        -:36895:    }
        -:36896:    }
    #####:36897:    function_tests++;
        -:36898:
    #####:36899:    return(test_ret);
        -:36900:}
        -:36901:
        -:36902:
        -:36903:static int
    #####:36904:test_xmlStrstr(void) {
    #####:36905:    int test_ret = 0;
        -:36906:
        -:36907:    int mem_base;
        -:36908:    const xmlChar * ret_val;
        -:36909:    xmlChar * str; /* the xmlChar * array (haystack) */
        -:36910:    int n_str;
        -:36911:    xmlChar * val; /* the xmlChar to search (needle) */
        -:36912:    int n_val;
        -:36913:
    #####:36914:    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    #####:36915:    for (n_val = 0;n_val < gen_nb_const_xmlChar_ptr;n_val++) {
    #####:36916:        mem_base = xmlMemBlocks();
    #####:36917:        str = gen_const_xmlChar_ptr(n_str, 0);
    #####:36918:        val = gen_const_xmlChar_ptr(n_val, 1);
        -:36919:
    #####:36920:        ret_val = xmlStrstr((const xmlChar *)str, (const xmlChar *)val);
    #####:36921:        desret_const_xmlChar_ptr(ret_val);
    #####:36922:        call_tests++;
    #####:36923:        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 0);
    #####:36924:        des_const_xmlChar_ptr(n_val, (const xmlChar *)val, 1);
    #####:36925:        xmlResetLastError();
    #####:36926:        if (mem_base != xmlMemBlocks()) {
    #####:36927:            printf("Leak of %d blocks found in xmlStrstr",
    #####:36928:	           xmlMemBlocks() - mem_base);
    #####:36929:	    test_ret++;
    #####:36930:            printf(" %d", n_str);
    #####:36931:            printf(" %d", n_val);
    #####:36932:            printf("\n");
        -:36933:        }
        -:36934:    }
        -:36935:    }
    #####:36936:    function_tests++;
        -:36937:
    #####:36938:    return(test_ret);
        -:36939:}
        -:36940:
        -:36941:
        -:36942:static int
    #####:36943:test_xmlStrsub(void) {
    #####:36944:    int test_ret = 0;
        -:36945:
        -:36946:    int mem_base;
        -:36947:    xmlChar * ret_val;
        -:36948:    xmlChar * str; /* the xmlChar * array (haystack) */
        -:36949:    int n_str;
        -:36950:    int start; /* the index of the first char (zero based) */
        -:36951:    int n_start;
        -:36952:    int len; /* the length of the substring */
        -:36953:    int n_len;
        -:36954:
    #####:36955:    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    #####:36956:    for (n_start = 0;n_start < gen_nb_int;n_start++) {
    #####:36957:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:36958:        mem_base = xmlMemBlocks();
    #####:36959:        str = gen_const_xmlChar_ptr(n_str, 0);
    #####:36960:        start = gen_int(n_start, 1);
    #####:36961:        len = gen_int(n_len, 2);
        -:36962:
    #####:36963:        ret_val = xmlStrsub((const xmlChar *)str, start, len);
    #####:36964:        desret_xmlChar_ptr(ret_val);
    #####:36965:        call_tests++;
    #####:36966:        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 0);
    #####:36967:        des_int(n_start, start, 1);
    #####:36968:        des_int(n_len, len, 2);
    #####:36969:        xmlResetLastError();
    #####:36970:        if (mem_base != xmlMemBlocks()) {
    #####:36971:            printf("Leak of %d blocks found in xmlStrsub",
    #####:36972:	           xmlMemBlocks() - mem_base);
    #####:36973:	    test_ret++;
    #####:36974:            printf(" %d", n_str);
    #####:36975:            printf(" %d", n_start);
    #####:36976:            printf(" %d", n_len);
    #####:36977:            printf("\n");
        -:36978:        }
        -:36979:    }
        -:36980:    }
        -:36981:    }
    #####:36982:    function_tests++;
        -:36983:
    #####:36984:    return(test_ret);
        -:36985:}
        -:36986:
        -:36987:
        -:36988:static int
    #####:36989:test_xmlUTF8Charcmp(void) {
    #####:36990:    int test_ret = 0;
        -:36991:
        -:36992:    int mem_base;
        -:36993:    int ret_val;
        -:36994:    xmlChar * utf1; /* pointer to first UTF8 char */
        -:36995:    int n_utf1;
        -:36996:    xmlChar * utf2; /* pointer to second UTF8 char */
        -:36997:    int n_utf2;
        -:36998:
    #####:36999:    for (n_utf1 = 0;n_utf1 < gen_nb_const_xmlChar_ptr;n_utf1++) {
    #####:37000:    for (n_utf2 = 0;n_utf2 < gen_nb_const_xmlChar_ptr;n_utf2++) {
    #####:37001:        mem_base = xmlMemBlocks();
    #####:37002:        utf1 = gen_const_xmlChar_ptr(n_utf1, 0);
    #####:37003:        utf2 = gen_const_xmlChar_ptr(n_utf2, 1);
        -:37004:
    #####:37005:        ret_val = xmlUTF8Charcmp((const xmlChar *)utf1, (const xmlChar *)utf2);
    #####:37006:        desret_int(ret_val);
    #####:37007:        call_tests++;
    #####:37008:        des_const_xmlChar_ptr(n_utf1, (const xmlChar *)utf1, 0);
    #####:37009:        des_const_xmlChar_ptr(n_utf2, (const xmlChar *)utf2, 1);
    #####:37010:        xmlResetLastError();
    #####:37011:        if (mem_base != xmlMemBlocks()) {
    #####:37012:            printf("Leak of %d blocks found in xmlUTF8Charcmp",
    #####:37013:	           xmlMemBlocks() - mem_base);
    #####:37014:	    test_ret++;
    #####:37015:            printf(" %d", n_utf1);
    #####:37016:            printf(" %d", n_utf2);
    #####:37017:            printf("\n");
        -:37018:        }
        -:37019:    }
        -:37020:    }
    #####:37021:    function_tests++;
        -:37022:
    #####:37023:    return(test_ret);
        -:37024:}
        -:37025:
        -:37026:
        -:37027:static int
    #####:37028:test_xmlUTF8Size(void) {
    #####:37029:    int test_ret = 0;
        -:37030:
        -:37031:    int mem_base;
        -:37032:    int ret_val;
        -:37033:    xmlChar * utf; /* pointer to the UTF8 character */
        -:37034:    int n_utf;
        -:37035:
    #####:37036:    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
    #####:37037:        mem_base = xmlMemBlocks();
    #####:37038:        utf = gen_const_xmlChar_ptr(n_utf, 0);
        -:37039:
    #####:37040:        ret_val = xmlUTF8Size((const xmlChar *)utf);
    #####:37041:        desret_int(ret_val);
    #####:37042:        call_tests++;
    #####:37043:        des_const_xmlChar_ptr(n_utf, (const xmlChar *)utf, 0);
    #####:37044:        xmlResetLastError();
    #####:37045:        if (mem_base != xmlMemBlocks()) {
    #####:37046:            printf("Leak of %d blocks found in xmlUTF8Size",
    #####:37047:	           xmlMemBlocks() - mem_base);
    #####:37048:	    test_ret++;
    #####:37049:            printf(" %d", n_utf);
    #####:37050:            printf("\n");
        -:37051:        }
        -:37052:    }
    #####:37053:    function_tests++;
        -:37054:
    #####:37055:    return(test_ret);
        -:37056:}
        -:37057:
        -:37058:
        -:37059:static int
    #####:37060:test_xmlUTF8Strlen(void) {
    #####:37061:    int test_ret = 0;
        -:37062:
        -:37063:    int mem_base;
        -:37064:    int ret_val;
        -:37065:    xmlChar * utf; /* a sequence of UTF-8 encoded bytes */
        -:37066:    int n_utf;
        -:37067:
    #####:37068:    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
    #####:37069:        mem_base = xmlMemBlocks();
    #####:37070:        utf = gen_const_xmlChar_ptr(n_utf, 0);
        -:37071:
    #####:37072:        ret_val = xmlUTF8Strlen((const xmlChar *)utf);
    #####:37073:        desret_int(ret_val);
    #####:37074:        call_tests++;
    #####:37075:        des_const_xmlChar_ptr(n_utf, (const xmlChar *)utf, 0);
    #####:37076:        xmlResetLastError();
    #####:37077:        if (mem_base != xmlMemBlocks()) {
    #####:37078:            printf("Leak of %d blocks found in xmlUTF8Strlen",
    #####:37079:	           xmlMemBlocks() - mem_base);
    #####:37080:	    test_ret++;
    #####:37081:            printf(" %d", n_utf);
    #####:37082:            printf("\n");
        -:37083:        }
        -:37084:    }
    #####:37085:    function_tests++;
        -:37086:
    #####:37087:    return(test_ret);
        -:37088:}
        -:37089:
        -:37090:
        -:37091:static int
    #####:37092:test_xmlUTF8Strloc(void) {
    #####:37093:    int test_ret = 0;
        -:37094:
        -:37095:    int mem_base;
        -:37096:    int ret_val;
        -:37097:    xmlChar * utf; /* the input UTF8 * */
        -:37098:    int n_utf;
        -:37099:    xmlChar * utfchar; /* the UTF8 character to be found */
        -:37100:    int n_utfchar;
        -:37101:
    #####:37102:    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
    #####:37103:    for (n_utfchar = 0;n_utfchar < gen_nb_const_xmlChar_ptr;n_utfchar++) {
    #####:37104:        mem_base = xmlMemBlocks();
    #####:37105:        utf = gen_const_xmlChar_ptr(n_utf, 0);
    #####:37106:        utfchar = gen_const_xmlChar_ptr(n_utfchar, 1);
        -:37107:
    #####:37108:        ret_val = xmlUTF8Strloc((const xmlChar *)utf, (const xmlChar *)utfchar);
    #####:37109:        desret_int(ret_val);
    #####:37110:        call_tests++;
    #####:37111:        des_const_xmlChar_ptr(n_utf, (const xmlChar *)utf, 0);
    #####:37112:        des_const_xmlChar_ptr(n_utfchar, (const xmlChar *)utfchar, 1);
    #####:37113:        xmlResetLastError();
    #####:37114:        if (mem_base != xmlMemBlocks()) {
    #####:37115:            printf("Leak of %d blocks found in xmlUTF8Strloc",
    #####:37116:	           xmlMemBlocks() - mem_base);
    #####:37117:	    test_ret++;
    #####:37118:            printf(" %d", n_utf);
    #####:37119:            printf(" %d", n_utfchar);
    #####:37120:            printf("\n");
        -:37121:        }
        -:37122:    }
        -:37123:    }
    #####:37124:    function_tests++;
        -:37125:
    #####:37126:    return(test_ret);
        -:37127:}
        -:37128:
        -:37129:
        -:37130:static int
    #####:37131:test_xmlUTF8Strndup(void) {
    #####:37132:    int test_ret = 0;
        -:37133:
        -:37134:    int mem_base;
        -:37135:    xmlChar * ret_val;
        -:37136:    xmlChar * utf; /* the input UTF8 * */
        -:37137:    int n_utf;
        -:37138:    int len; /* the len of @utf (in chars) */
        -:37139:    int n_len;
        -:37140:
    #####:37141:    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
    #####:37142:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:37143:        mem_base = xmlMemBlocks();
    #####:37144:        utf = gen_const_xmlChar_ptr(n_utf, 0);
    #####:37145:        len = gen_int(n_len, 1);
        -:37146:
    #####:37147:        ret_val = xmlUTF8Strndup((const xmlChar *)utf, len);
    #####:37148:        desret_xmlChar_ptr(ret_val);
    #####:37149:        call_tests++;
    #####:37150:        des_const_xmlChar_ptr(n_utf, (const xmlChar *)utf, 0);
    #####:37151:        des_int(n_len, len, 1);
    #####:37152:        xmlResetLastError();
    #####:37153:        if (mem_base != xmlMemBlocks()) {
    #####:37154:            printf("Leak of %d blocks found in xmlUTF8Strndup",
    #####:37155:	           xmlMemBlocks() - mem_base);
    #####:37156:	    test_ret++;
    #####:37157:            printf(" %d", n_utf);
    #####:37158:            printf(" %d", n_len);
    #####:37159:            printf("\n");
        -:37160:        }
        -:37161:    }
        -:37162:    }
    #####:37163:    function_tests++;
        -:37164:
    #####:37165:    return(test_ret);
        -:37166:}
        -:37167:
        -:37168:
        -:37169:static int
    #####:37170:test_xmlUTF8Strpos(void) {
    #####:37171:    int test_ret = 0;
        -:37172:
        -:37173:    int mem_base;
        -:37174:    const xmlChar * ret_val;
        -:37175:    xmlChar * utf; /* the input UTF8 * */
        -:37176:    int n_utf;
        -:37177:    int pos; /* the position of the desired UTF8 char (in chars) */
        -:37178:    int n_pos;
        -:37179:
    #####:37180:    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
    #####:37181:    for (n_pos = 0;n_pos < gen_nb_int;n_pos++) {
    #####:37182:        mem_base = xmlMemBlocks();
    #####:37183:        utf = gen_const_xmlChar_ptr(n_utf, 0);
    #####:37184:        pos = gen_int(n_pos, 1);
        -:37185:
    #####:37186:        ret_val = xmlUTF8Strpos((const xmlChar *)utf, pos);
    #####:37187:        desret_const_xmlChar_ptr(ret_val);
    #####:37188:        call_tests++;
    #####:37189:        des_const_xmlChar_ptr(n_utf, (const xmlChar *)utf, 0);
    #####:37190:        des_int(n_pos, pos, 1);
    #####:37191:        xmlResetLastError();
    #####:37192:        if (mem_base != xmlMemBlocks()) {
    #####:37193:            printf("Leak of %d blocks found in xmlUTF8Strpos",
    #####:37194:	           xmlMemBlocks() - mem_base);
    #####:37195:	    test_ret++;
    #####:37196:            printf(" %d", n_utf);
    #####:37197:            printf(" %d", n_pos);
    #####:37198:            printf("\n");
        -:37199:        }
        -:37200:    }
        -:37201:    }
    #####:37202:    function_tests++;
        -:37203:
    #####:37204:    return(test_ret);
        -:37205:}
        -:37206:
        -:37207:
        -:37208:static int
    #####:37209:test_xmlUTF8Strsize(void) {
    #####:37210:    int test_ret = 0;
        -:37211:
        -:37212:    int mem_base;
        -:37213:    int ret_val;
        -:37214:    xmlChar * utf; /* a sequence of UTF-8 encoded bytes */
        -:37215:    int n_utf;
        -:37216:    int len; /* the number of characters in the array */
        -:37217:    int n_len;
        -:37218:
    #####:37219:    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
    #####:37220:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:37221:        mem_base = xmlMemBlocks();
    #####:37222:        utf = gen_const_xmlChar_ptr(n_utf, 0);
    #####:37223:        len = gen_int(n_len, 1);
        -:37224:
    #####:37225:        ret_val = xmlUTF8Strsize((const xmlChar *)utf, len);
    #####:37226:        desret_int(ret_val);
    #####:37227:        call_tests++;
    #####:37228:        des_const_xmlChar_ptr(n_utf, (const xmlChar *)utf, 0);
    #####:37229:        des_int(n_len, len, 1);
    #####:37230:        xmlResetLastError();
    #####:37231:        if (mem_base != xmlMemBlocks()) {
    #####:37232:            printf("Leak of %d blocks found in xmlUTF8Strsize",
    #####:37233:	           xmlMemBlocks() - mem_base);
    #####:37234:	    test_ret++;
    #####:37235:            printf(" %d", n_utf);
    #####:37236:            printf(" %d", n_len);
    #####:37237:            printf("\n");
        -:37238:        }
        -:37239:    }
        -:37240:    }
    #####:37241:    function_tests++;
        -:37242:
    #####:37243:    return(test_ret);
        -:37244:}
        -:37245:
        -:37246:
        -:37247:static int
    #####:37248:test_xmlUTF8Strsub(void) {
    #####:37249:    int test_ret = 0;
        -:37250:
        -:37251:    int mem_base;
        -:37252:    xmlChar * ret_val;
        -:37253:    xmlChar * utf; /* a sequence of UTF-8 encoded bytes */
        -:37254:    int n_utf;
        -:37255:    int start; /* relative pos of first char */
        -:37256:    int n_start;
        -:37257:    int len; /* total number to copy */
        -:37258:    int n_len;
        -:37259:
    #####:37260:    for (n_utf = 0;n_utf < gen_nb_const_xmlChar_ptr;n_utf++) {
    #####:37261:    for (n_start = 0;n_start < gen_nb_int;n_start++) {
    #####:37262:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:37263:        mem_base = xmlMemBlocks();
    #####:37264:        utf = gen_const_xmlChar_ptr(n_utf, 0);
    #####:37265:        start = gen_int(n_start, 1);
    #####:37266:        len = gen_int(n_len, 2);
        -:37267:
    #####:37268:        ret_val = xmlUTF8Strsub((const xmlChar *)utf, start, len);
    #####:37269:        desret_xmlChar_ptr(ret_val);
    #####:37270:        call_tests++;
    #####:37271:        des_const_xmlChar_ptr(n_utf, (const xmlChar *)utf, 0);
    #####:37272:        des_int(n_start, start, 1);
    #####:37273:        des_int(n_len, len, 2);
    #####:37274:        xmlResetLastError();
    #####:37275:        if (mem_base != xmlMemBlocks()) {
    #####:37276:            printf("Leak of %d blocks found in xmlUTF8Strsub",
    #####:37277:	           xmlMemBlocks() - mem_base);
    #####:37278:	    test_ret++;
    #####:37279:            printf(" %d", n_utf);
    #####:37280:            printf(" %d", n_start);
    #####:37281:            printf(" %d", n_len);
    #####:37282:            printf("\n");
        -:37283:        }
        -:37284:    }
        -:37285:    }
        -:37286:    }
    #####:37287:    function_tests++;
        -:37288:
    #####:37289:    return(test_ret);
        -:37290:}
        -:37291:
        -:37292:static int
    #####:37293:test_xmlstring(void) {
    #####:37294:    int test_ret = 0;
        -:37295:
    #####:37296:    if (quiet == 0) printf("Testing xmlstring : 26 of 30 functions ...\n");
    #####:37297:    test_ret += test_xmlCharStrdup();
    #####:37298:    test_ret += test_xmlCharStrndup();
    #####:37299:    test_ret += test_xmlCheckUTF8();
    #####:37300:    test_ret += test_xmlGetUTF8Char();
    #####:37301:    test_ret += test_xmlStrEqual();
    #####:37302:    test_ret += test_xmlStrPrintf();
    #####:37303:    test_ret += test_xmlStrQEqual();
    #####:37304:    test_ret += test_xmlStrVPrintf();
    #####:37305:    test_ret += test_xmlStrcasecmp();
    #####:37306:    test_ret += test_xmlStrcasestr();
    #####:37307:    test_ret += test_xmlStrchr();
    #####:37308:    test_ret += test_xmlStrcmp();
    #####:37309:    test_ret += test_xmlStrdup();
    #####:37310:    test_ret += test_xmlStrlen();
    #####:37311:    test_ret += test_xmlStrncasecmp();
    #####:37312:    test_ret += test_xmlStrncatNew();
    #####:37313:    test_ret += test_xmlStrncmp();
    #####:37314:    test_ret += test_xmlStrndup();
    #####:37315:    test_ret += test_xmlStrstr();
    #####:37316:    test_ret += test_xmlStrsub();
    #####:37317:    test_ret += test_xmlUTF8Charcmp();
    #####:37318:    test_ret += test_xmlUTF8Size();
    #####:37319:    test_ret += test_xmlUTF8Strlen();
    #####:37320:    test_ret += test_xmlUTF8Strloc();
    #####:37321:    test_ret += test_xmlUTF8Strndup();
    #####:37322:    test_ret += test_xmlUTF8Strpos();
    #####:37323:    test_ret += test_xmlUTF8Strsize();
    #####:37324:    test_ret += test_xmlUTF8Strsub();
        -:37325:
    #####:37326:    if (test_ret != 0)
    #####:37327:	printf("Module xmlstring: %d errors\n", test_ret);
    #####:37328:    return(test_ret);
        -:37329:}
        -:37330:
        -:37331:static int
    #####:37332:test_xmlUCSIsAegeanNumbers(void) {
    #####:37333:    int test_ret = 0;
        -:37334:
        -:37335:#if defined(LIBXML_UNICODE_ENABLED)
        -:37336:    int mem_base;
        -:37337:    int ret_val;
        -:37338:    int code; /* UCS code point */
        -:37339:    int n_code;
        -:37340:
    #####:37341:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:37342:        mem_base = xmlMemBlocks();
    #####:37343:        code = gen_int(n_code, 0);
        -:37344:
    #####:37345:        ret_val = xmlUCSIsAegeanNumbers(code);
    #####:37346:        desret_int(ret_val);
    #####:37347:        call_tests++;
    #####:37348:        des_int(n_code, code, 0);
    #####:37349:        xmlResetLastError();
    #####:37350:        if (mem_base != xmlMemBlocks()) {
    #####:37351:            printf("Leak of %d blocks found in xmlUCSIsAegeanNumbers",
    #####:37352:	           xmlMemBlocks() - mem_base);
    #####:37353:	    test_ret++;
    #####:37354:            printf(" %d", n_code);
    #####:37355:            printf("\n");
        -:37356:        }
        -:37357:    }
    #####:37358:    function_tests++;
        -:37359:#endif
        -:37360:
    #####:37361:    return(test_ret);
        -:37362:}
        -:37363:
        -:37364:
        -:37365:static int
    #####:37366:test_xmlUCSIsAlphabeticPresentationForms(void) {
    #####:37367:    int test_ret = 0;
        -:37368:
        -:37369:#if defined(LIBXML_UNICODE_ENABLED)
        -:37370:    int mem_base;
        -:37371:    int ret_val;
        -:37372:    int code; /* UCS code point */
        -:37373:    int n_code;
        -:37374:
    #####:37375:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:37376:        mem_base = xmlMemBlocks();
    #####:37377:        code = gen_int(n_code, 0);
        -:37378:
    #####:37379:        ret_val = xmlUCSIsAlphabeticPresentationForms(code);
    #####:37380:        desret_int(ret_val);
    #####:37381:        call_tests++;
    #####:37382:        des_int(n_code, code, 0);
    #####:37383:        xmlResetLastError();
    #####:37384:        if (mem_base != xmlMemBlocks()) {
    #####:37385:            printf("Leak of %d blocks found in xmlUCSIsAlphabeticPresentationForms",
    #####:37386:	           xmlMemBlocks() - mem_base);
    #####:37387:	    test_ret++;
    #####:37388:            printf(" %d", n_code);
    #####:37389:            printf("\n");
        -:37390:        }
        -:37391:    }
    #####:37392:    function_tests++;
        -:37393:#endif
        -:37394:
    #####:37395:    return(test_ret);
        -:37396:}
        -:37397:
        -:37398:
        -:37399:static int
    #####:37400:test_xmlUCSIsArabic(void) {
    #####:37401:    int test_ret = 0;
        -:37402:
        -:37403:#if defined(LIBXML_UNICODE_ENABLED)
        -:37404:    int mem_base;
        -:37405:    int ret_val;
        -:37406:    int code; /* UCS code point */
        -:37407:    int n_code;
        -:37408:
    #####:37409:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:37410:        mem_base = xmlMemBlocks();
    #####:37411:        code = gen_int(n_code, 0);
        -:37412:
    #####:37413:        ret_val = xmlUCSIsArabic(code);
    #####:37414:        desret_int(ret_val);
    #####:37415:        call_tests++;
    #####:37416:        des_int(n_code, code, 0);
    #####:37417:        xmlResetLastError();
    #####:37418:        if (mem_base != xmlMemBlocks()) {
    #####:37419:            printf("Leak of %d blocks found in xmlUCSIsArabic",
    #####:37420:	           xmlMemBlocks() - mem_base);
    #####:37421:	    test_ret++;
    #####:37422:            printf(" %d", n_code);
    #####:37423:            printf("\n");
        -:37424:        }
        -:37425:    }
    #####:37426:    function_tests++;
        -:37427:#endif
        -:37428:
    #####:37429:    return(test_ret);
        -:37430:}
        -:37431:
        -:37432:
        -:37433:static int
    #####:37434:test_xmlUCSIsArabicPresentationFormsA(void) {
    #####:37435:    int test_ret = 0;
        -:37436:
        -:37437:#if defined(LIBXML_UNICODE_ENABLED)
        -:37438:    int mem_base;
        -:37439:    int ret_val;
        -:37440:    int code; /* UCS code point */
        -:37441:    int n_code;
        -:37442:
    #####:37443:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:37444:        mem_base = xmlMemBlocks();
    #####:37445:        code = gen_int(n_code, 0);
        -:37446:
    #####:37447:        ret_val = xmlUCSIsArabicPresentationFormsA(code);
    #####:37448:        desret_int(ret_val);
    #####:37449:        call_tests++;
    #####:37450:        des_int(n_code, code, 0);
    #####:37451:        xmlResetLastError();
    #####:37452:        if (mem_base != xmlMemBlocks()) {
    #####:37453:            printf("Leak of %d blocks found in xmlUCSIsArabicPresentationFormsA",
    #####:37454:	           xmlMemBlocks() - mem_base);
    #####:37455:	    test_ret++;
    #####:37456:            printf(" %d", n_code);
    #####:37457:            printf("\n");
        -:37458:        }
        -:37459:    }
    #####:37460:    function_tests++;
        -:37461:#endif
        -:37462:
    #####:37463:    return(test_ret);
        -:37464:}
        -:37465:
        -:37466:
        -:37467:static int
    #####:37468:test_xmlUCSIsArabicPresentationFormsB(void) {
    #####:37469:    int test_ret = 0;
        -:37470:
        -:37471:#if defined(LIBXML_UNICODE_ENABLED)
        -:37472:    int mem_base;
        -:37473:    int ret_val;
        -:37474:    int code; /* UCS code point */
        -:37475:    int n_code;
        -:37476:
    #####:37477:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:37478:        mem_base = xmlMemBlocks();
    #####:37479:        code = gen_int(n_code, 0);
        -:37480:
    #####:37481:        ret_val = xmlUCSIsArabicPresentationFormsB(code);
    #####:37482:        desret_int(ret_val);
    #####:37483:        call_tests++;
    #####:37484:        des_int(n_code, code, 0);
    #####:37485:        xmlResetLastError();
    #####:37486:        if (mem_base != xmlMemBlocks()) {
    #####:37487:            printf("Leak of %d blocks found in xmlUCSIsArabicPresentationFormsB",
    #####:37488:	           xmlMemBlocks() - mem_base);
    #####:37489:	    test_ret++;
    #####:37490:            printf(" %d", n_code);
    #####:37491:            printf("\n");
        -:37492:        }
        -:37493:    }
    #####:37494:    function_tests++;
        -:37495:#endif
        -:37496:
    #####:37497:    return(test_ret);
        -:37498:}
        -:37499:
        -:37500:
        -:37501:static int
    #####:37502:test_xmlUCSIsArmenian(void) {
    #####:37503:    int test_ret = 0;
        -:37504:
        -:37505:#if defined(LIBXML_UNICODE_ENABLED)
        -:37506:    int mem_base;
        -:37507:    int ret_val;
        -:37508:    int code; /* UCS code point */
        -:37509:    int n_code;
        -:37510:
    #####:37511:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:37512:        mem_base = xmlMemBlocks();
    #####:37513:        code = gen_int(n_code, 0);
        -:37514:
    #####:37515:        ret_val = xmlUCSIsArmenian(code);
    #####:37516:        desret_int(ret_val);
    #####:37517:        call_tests++;
    #####:37518:        des_int(n_code, code, 0);
    #####:37519:        xmlResetLastError();
    #####:37520:        if (mem_base != xmlMemBlocks()) {
    #####:37521:            printf("Leak of %d blocks found in xmlUCSIsArmenian",
    #####:37522:	           xmlMemBlocks() - mem_base);
    #####:37523:	    test_ret++;
    #####:37524:            printf(" %d", n_code);
    #####:37525:            printf("\n");
        -:37526:        }
        -:37527:    }
    #####:37528:    function_tests++;
        -:37529:#endif
        -:37530:
    #####:37531:    return(test_ret);
        -:37532:}
        -:37533:
        -:37534:
        -:37535:static int
    #####:37536:test_xmlUCSIsArrows(void) {
    #####:37537:    int test_ret = 0;
        -:37538:
        -:37539:#if defined(LIBXML_UNICODE_ENABLED)
        -:37540:    int mem_base;
        -:37541:    int ret_val;
        -:37542:    int code; /* UCS code point */
        -:37543:    int n_code;
        -:37544:
    #####:37545:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:37546:        mem_base = xmlMemBlocks();
    #####:37547:        code = gen_int(n_code, 0);
        -:37548:
    #####:37549:        ret_val = xmlUCSIsArrows(code);
    #####:37550:        desret_int(ret_val);
    #####:37551:        call_tests++;
    #####:37552:        des_int(n_code, code, 0);
    #####:37553:        xmlResetLastError();
    #####:37554:        if (mem_base != xmlMemBlocks()) {
    #####:37555:            printf("Leak of %d blocks found in xmlUCSIsArrows",
    #####:37556:	           xmlMemBlocks() - mem_base);
    #####:37557:	    test_ret++;
    #####:37558:            printf(" %d", n_code);
    #####:37559:            printf("\n");
        -:37560:        }
        -:37561:    }
    #####:37562:    function_tests++;
        -:37563:#endif
        -:37564:
    #####:37565:    return(test_ret);
        -:37566:}
        -:37567:
        -:37568:
        -:37569:static int
    #####:37570:test_xmlUCSIsBasicLatin(void) {
    #####:37571:    int test_ret = 0;
        -:37572:
        -:37573:#if defined(LIBXML_UNICODE_ENABLED)
        -:37574:    int mem_base;
        -:37575:    int ret_val;
        -:37576:    int code; /* UCS code point */
        -:37577:    int n_code;
        -:37578:
    #####:37579:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:37580:        mem_base = xmlMemBlocks();
    #####:37581:        code = gen_int(n_code, 0);
        -:37582:
    #####:37583:        ret_val = xmlUCSIsBasicLatin(code);
    #####:37584:        desret_int(ret_val);
    #####:37585:        call_tests++;
    #####:37586:        des_int(n_code, code, 0);
    #####:37587:        xmlResetLastError();
    #####:37588:        if (mem_base != xmlMemBlocks()) {
    #####:37589:            printf("Leak of %d blocks found in xmlUCSIsBasicLatin",
    #####:37590:	           xmlMemBlocks() - mem_base);
    #####:37591:	    test_ret++;
    #####:37592:            printf(" %d", n_code);
    #####:37593:            printf("\n");
        -:37594:        }
        -:37595:    }
    #####:37596:    function_tests++;
        -:37597:#endif
        -:37598:
    #####:37599:    return(test_ret);
        -:37600:}
        -:37601:
        -:37602:
        -:37603:static int
    #####:37604:test_xmlUCSIsBengali(void) {
    #####:37605:    int test_ret = 0;
        -:37606:
        -:37607:#if defined(LIBXML_UNICODE_ENABLED)
        -:37608:    int mem_base;
        -:37609:    int ret_val;
        -:37610:    int code; /* UCS code point */
        -:37611:    int n_code;
        -:37612:
    #####:37613:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:37614:        mem_base = xmlMemBlocks();
    #####:37615:        code = gen_int(n_code, 0);
        -:37616:
    #####:37617:        ret_val = xmlUCSIsBengali(code);
    #####:37618:        desret_int(ret_val);
    #####:37619:        call_tests++;
    #####:37620:        des_int(n_code, code, 0);
    #####:37621:        xmlResetLastError();
    #####:37622:        if (mem_base != xmlMemBlocks()) {
    #####:37623:            printf("Leak of %d blocks found in xmlUCSIsBengali",
    #####:37624:	           xmlMemBlocks() - mem_base);
    #####:37625:	    test_ret++;
    #####:37626:            printf(" %d", n_code);
    #####:37627:            printf("\n");
        -:37628:        }
        -:37629:    }
    #####:37630:    function_tests++;
        -:37631:#endif
        -:37632:
    #####:37633:    return(test_ret);
        -:37634:}
        -:37635:
        -:37636:
        -:37637:static int
    #####:37638:test_xmlUCSIsBlock(void) {
    #####:37639:    int test_ret = 0;
        -:37640:
        -:37641:#if defined(LIBXML_UNICODE_ENABLED)
        -:37642:    int mem_base;
        -:37643:    int ret_val;
        -:37644:    int code; /* UCS code point */
        -:37645:    int n_code;
        -:37646:    char * block; /* UCS block name */
        -:37647:    int n_block;
        -:37648:
    #####:37649:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:37650:    for (n_block = 0;n_block < gen_nb_const_char_ptr;n_block++) {
    #####:37651:        mem_base = xmlMemBlocks();
    #####:37652:        code = gen_int(n_code, 0);
    #####:37653:        block = gen_const_char_ptr(n_block, 1);
        -:37654:
    #####:37655:        ret_val = xmlUCSIsBlock(code, (const char *)block);
    #####:37656:        desret_int(ret_val);
    #####:37657:        call_tests++;
    #####:37658:        des_int(n_code, code, 0);
    #####:37659:        des_const_char_ptr(n_block, (const char *)block, 1);
    #####:37660:        xmlResetLastError();
    #####:37661:        if (mem_base != xmlMemBlocks()) {
    #####:37662:            printf("Leak of %d blocks found in xmlUCSIsBlock",
    #####:37663:	           xmlMemBlocks() - mem_base);
    #####:37664:	    test_ret++;
    #####:37665:            printf(" %d", n_code);
    #####:37666:            printf(" %d", n_block);
    #####:37667:            printf("\n");
        -:37668:        }
        -:37669:    }
        -:37670:    }
    #####:37671:    function_tests++;
        -:37672:#endif
        -:37673:
    #####:37674:    return(test_ret);
        -:37675:}
        -:37676:
        -:37677:
        -:37678:static int
    #####:37679:test_xmlUCSIsBlockElements(void) {
    #####:37680:    int test_ret = 0;
        -:37681:
        -:37682:#if defined(LIBXML_UNICODE_ENABLED)
        -:37683:    int mem_base;
        -:37684:    int ret_val;
        -:37685:    int code; /* UCS code point */
        -:37686:    int n_code;
        -:37687:
    #####:37688:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:37689:        mem_base = xmlMemBlocks();
    #####:37690:        code = gen_int(n_code, 0);
        -:37691:
    #####:37692:        ret_val = xmlUCSIsBlockElements(code);
    #####:37693:        desret_int(ret_val);
    #####:37694:        call_tests++;
    #####:37695:        des_int(n_code, code, 0);
    #####:37696:        xmlResetLastError();
    #####:37697:        if (mem_base != xmlMemBlocks()) {
    #####:37698:            printf("Leak of %d blocks found in xmlUCSIsBlockElements",
    #####:37699:	           xmlMemBlocks() - mem_base);
    #####:37700:	    test_ret++;
    #####:37701:            printf(" %d", n_code);
    #####:37702:            printf("\n");
        -:37703:        }
        -:37704:    }
    #####:37705:    function_tests++;
        -:37706:#endif
        -:37707:
    #####:37708:    return(test_ret);
        -:37709:}
        -:37710:
        -:37711:
        -:37712:static int
    #####:37713:test_xmlUCSIsBopomofo(void) {
    #####:37714:    int test_ret = 0;
        -:37715:
        -:37716:#if defined(LIBXML_UNICODE_ENABLED)
        -:37717:    int mem_base;
        -:37718:    int ret_val;
        -:37719:    int code; /* UCS code point */
        -:37720:    int n_code;
        -:37721:
    #####:37722:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:37723:        mem_base = xmlMemBlocks();
    #####:37724:        code = gen_int(n_code, 0);
        -:37725:
    #####:37726:        ret_val = xmlUCSIsBopomofo(code);
    #####:37727:        desret_int(ret_val);
    #####:37728:        call_tests++;
    #####:37729:        des_int(n_code, code, 0);
    #####:37730:        xmlResetLastError();
    #####:37731:        if (mem_base != xmlMemBlocks()) {
    #####:37732:            printf("Leak of %d blocks found in xmlUCSIsBopomofo",
    #####:37733:	           xmlMemBlocks() - mem_base);
    #####:37734:	    test_ret++;
    #####:37735:            printf(" %d", n_code);
    #####:37736:            printf("\n");
        -:37737:        }
        -:37738:    }
    #####:37739:    function_tests++;
        -:37740:#endif
        -:37741:
    #####:37742:    return(test_ret);
        -:37743:}
        -:37744:
        -:37745:
        -:37746:static int
    #####:37747:test_xmlUCSIsBopomofoExtended(void) {
    #####:37748:    int test_ret = 0;
        -:37749:
        -:37750:#if defined(LIBXML_UNICODE_ENABLED)
        -:37751:    int mem_base;
        -:37752:    int ret_val;
        -:37753:    int code; /* UCS code point */
        -:37754:    int n_code;
        -:37755:
    #####:37756:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:37757:        mem_base = xmlMemBlocks();
    #####:37758:        code = gen_int(n_code, 0);
        -:37759:
    #####:37760:        ret_val = xmlUCSIsBopomofoExtended(code);
    #####:37761:        desret_int(ret_val);
    #####:37762:        call_tests++;
    #####:37763:        des_int(n_code, code, 0);
    #####:37764:        xmlResetLastError();
    #####:37765:        if (mem_base != xmlMemBlocks()) {
    #####:37766:            printf("Leak of %d blocks found in xmlUCSIsBopomofoExtended",
    #####:37767:	           xmlMemBlocks() - mem_base);
    #####:37768:	    test_ret++;
    #####:37769:            printf(" %d", n_code);
    #####:37770:            printf("\n");
        -:37771:        }
        -:37772:    }
    #####:37773:    function_tests++;
        -:37774:#endif
        -:37775:
    #####:37776:    return(test_ret);
        -:37777:}
        -:37778:
        -:37779:
        -:37780:static int
    #####:37781:test_xmlUCSIsBoxDrawing(void) {
    #####:37782:    int test_ret = 0;
        -:37783:
        -:37784:#if defined(LIBXML_UNICODE_ENABLED)
        -:37785:    int mem_base;
        -:37786:    int ret_val;
        -:37787:    int code; /* UCS code point */
        -:37788:    int n_code;
        -:37789:
    #####:37790:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:37791:        mem_base = xmlMemBlocks();
    #####:37792:        code = gen_int(n_code, 0);
        -:37793:
    #####:37794:        ret_val = xmlUCSIsBoxDrawing(code);
    #####:37795:        desret_int(ret_val);
    #####:37796:        call_tests++;
    #####:37797:        des_int(n_code, code, 0);
    #####:37798:        xmlResetLastError();
    #####:37799:        if (mem_base != xmlMemBlocks()) {
    #####:37800:            printf("Leak of %d blocks found in xmlUCSIsBoxDrawing",
    #####:37801:	           xmlMemBlocks() - mem_base);
    #####:37802:	    test_ret++;
    #####:37803:            printf(" %d", n_code);
    #####:37804:            printf("\n");
        -:37805:        }
        -:37806:    }
    #####:37807:    function_tests++;
        -:37808:#endif
        -:37809:
    #####:37810:    return(test_ret);
        -:37811:}
        -:37812:
        -:37813:
        -:37814:static int
    #####:37815:test_xmlUCSIsBraillePatterns(void) {
    #####:37816:    int test_ret = 0;
        -:37817:
        -:37818:#if defined(LIBXML_UNICODE_ENABLED)
        -:37819:    int mem_base;
        -:37820:    int ret_val;
        -:37821:    int code; /* UCS code point */
        -:37822:    int n_code;
        -:37823:
    #####:37824:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:37825:        mem_base = xmlMemBlocks();
    #####:37826:        code = gen_int(n_code, 0);
        -:37827:
    #####:37828:        ret_val = xmlUCSIsBraillePatterns(code);
    #####:37829:        desret_int(ret_val);
    #####:37830:        call_tests++;
    #####:37831:        des_int(n_code, code, 0);
    #####:37832:        xmlResetLastError();
    #####:37833:        if (mem_base != xmlMemBlocks()) {
    #####:37834:            printf("Leak of %d blocks found in xmlUCSIsBraillePatterns",
    #####:37835:	           xmlMemBlocks() - mem_base);
    #####:37836:	    test_ret++;
    #####:37837:            printf(" %d", n_code);
    #####:37838:            printf("\n");
        -:37839:        }
        -:37840:    }
    #####:37841:    function_tests++;
        -:37842:#endif
        -:37843:
    #####:37844:    return(test_ret);
        -:37845:}
        -:37846:
        -:37847:
        -:37848:static int
    #####:37849:test_xmlUCSIsBuhid(void) {
    #####:37850:    int test_ret = 0;
        -:37851:
        -:37852:#if defined(LIBXML_UNICODE_ENABLED)
        -:37853:    int mem_base;
        -:37854:    int ret_val;
        -:37855:    int code; /* UCS code point */
        -:37856:    int n_code;
        -:37857:
    #####:37858:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:37859:        mem_base = xmlMemBlocks();
    #####:37860:        code = gen_int(n_code, 0);
        -:37861:
    #####:37862:        ret_val = xmlUCSIsBuhid(code);
    #####:37863:        desret_int(ret_val);
    #####:37864:        call_tests++;
    #####:37865:        des_int(n_code, code, 0);
    #####:37866:        xmlResetLastError();
    #####:37867:        if (mem_base != xmlMemBlocks()) {
    #####:37868:            printf("Leak of %d blocks found in xmlUCSIsBuhid",
    #####:37869:	           xmlMemBlocks() - mem_base);
    #####:37870:	    test_ret++;
    #####:37871:            printf(" %d", n_code);
    #####:37872:            printf("\n");
        -:37873:        }
        -:37874:    }
    #####:37875:    function_tests++;
        -:37876:#endif
        -:37877:
    #####:37878:    return(test_ret);
        -:37879:}
        -:37880:
        -:37881:
        -:37882:static int
    #####:37883:test_xmlUCSIsByzantineMusicalSymbols(void) {
    #####:37884:    int test_ret = 0;
        -:37885:
        -:37886:#if defined(LIBXML_UNICODE_ENABLED)
        -:37887:    int mem_base;
        -:37888:    int ret_val;
        -:37889:    int code; /* UCS code point */
        -:37890:    int n_code;
        -:37891:
    #####:37892:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:37893:        mem_base = xmlMemBlocks();
    #####:37894:        code = gen_int(n_code, 0);
        -:37895:
    #####:37896:        ret_val = xmlUCSIsByzantineMusicalSymbols(code);
    #####:37897:        desret_int(ret_val);
    #####:37898:        call_tests++;
    #####:37899:        des_int(n_code, code, 0);
    #####:37900:        xmlResetLastError();
    #####:37901:        if (mem_base != xmlMemBlocks()) {
    #####:37902:            printf("Leak of %d blocks found in xmlUCSIsByzantineMusicalSymbols",
    #####:37903:	           xmlMemBlocks() - mem_base);
    #####:37904:	    test_ret++;
    #####:37905:            printf(" %d", n_code);
    #####:37906:            printf("\n");
        -:37907:        }
        -:37908:    }
    #####:37909:    function_tests++;
        -:37910:#endif
        -:37911:
    #####:37912:    return(test_ret);
        -:37913:}
        -:37914:
        -:37915:
        -:37916:static int
    #####:37917:test_xmlUCSIsCJKCompatibility(void) {
    #####:37918:    int test_ret = 0;
        -:37919:
        -:37920:#if defined(LIBXML_UNICODE_ENABLED)
        -:37921:    int mem_base;
        -:37922:    int ret_val;
        -:37923:    int code; /* UCS code point */
        -:37924:    int n_code;
        -:37925:
    #####:37926:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:37927:        mem_base = xmlMemBlocks();
    #####:37928:        code = gen_int(n_code, 0);
        -:37929:
    #####:37930:        ret_val = xmlUCSIsCJKCompatibility(code);
    #####:37931:        desret_int(ret_val);
    #####:37932:        call_tests++;
    #####:37933:        des_int(n_code, code, 0);
    #####:37934:        xmlResetLastError();
    #####:37935:        if (mem_base != xmlMemBlocks()) {
    #####:37936:            printf("Leak of %d blocks found in xmlUCSIsCJKCompatibility",
    #####:37937:	           xmlMemBlocks() - mem_base);
    #####:37938:	    test_ret++;
    #####:37939:            printf(" %d", n_code);
    #####:37940:            printf("\n");
        -:37941:        }
        -:37942:    }
    #####:37943:    function_tests++;
        -:37944:#endif
        -:37945:
    #####:37946:    return(test_ret);
        -:37947:}
        -:37948:
        -:37949:
        -:37950:static int
    #####:37951:test_xmlUCSIsCJKCompatibilityForms(void) {
    #####:37952:    int test_ret = 0;
        -:37953:
        -:37954:#if defined(LIBXML_UNICODE_ENABLED)
        -:37955:    int mem_base;
        -:37956:    int ret_val;
        -:37957:    int code; /* UCS code point */
        -:37958:    int n_code;
        -:37959:
    #####:37960:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:37961:        mem_base = xmlMemBlocks();
    #####:37962:        code = gen_int(n_code, 0);
        -:37963:
    #####:37964:        ret_val = xmlUCSIsCJKCompatibilityForms(code);
    #####:37965:        desret_int(ret_val);
    #####:37966:        call_tests++;
    #####:37967:        des_int(n_code, code, 0);
    #####:37968:        xmlResetLastError();
    #####:37969:        if (mem_base != xmlMemBlocks()) {
    #####:37970:            printf("Leak of %d blocks found in xmlUCSIsCJKCompatibilityForms",
    #####:37971:	           xmlMemBlocks() - mem_base);
    #####:37972:	    test_ret++;
    #####:37973:            printf(" %d", n_code);
    #####:37974:            printf("\n");
        -:37975:        }
        -:37976:    }
    #####:37977:    function_tests++;
        -:37978:#endif
        -:37979:
    #####:37980:    return(test_ret);
        -:37981:}
        -:37982:
        -:37983:
        -:37984:static int
    #####:37985:test_xmlUCSIsCJKCompatibilityIdeographs(void) {
    #####:37986:    int test_ret = 0;
        -:37987:
        -:37988:#if defined(LIBXML_UNICODE_ENABLED)
        -:37989:    int mem_base;
        -:37990:    int ret_val;
        -:37991:    int code; /* UCS code point */
        -:37992:    int n_code;
        -:37993:
    #####:37994:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:37995:        mem_base = xmlMemBlocks();
    #####:37996:        code = gen_int(n_code, 0);
        -:37997:
    #####:37998:        ret_val = xmlUCSIsCJKCompatibilityIdeographs(code);
    #####:37999:        desret_int(ret_val);
    #####:38000:        call_tests++;
    #####:38001:        des_int(n_code, code, 0);
    #####:38002:        xmlResetLastError();
    #####:38003:        if (mem_base != xmlMemBlocks()) {
    #####:38004:            printf("Leak of %d blocks found in xmlUCSIsCJKCompatibilityIdeographs",
    #####:38005:	           xmlMemBlocks() - mem_base);
    #####:38006:	    test_ret++;
    #####:38007:            printf(" %d", n_code);
    #####:38008:            printf("\n");
        -:38009:        }
        -:38010:    }
    #####:38011:    function_tests++;
        -:38012:#endif
        -:38013:
    #####:38014:    return(test_ret);
        -:38015:}
        -:38016:
        -:38017:
        -:38018:static int
    #####:38019:test_xmlUCSIsCJKCompatibilityIdeographsSupplement(void) {
    #####:38020:    int test_ret = 0;
        -:38021:
        -:38022:#if defined(LIBXML_UNICODE_ENABLED)
        -:38023:    int mem_base;
        -:38024:    int ret_val;
        -:38025:    int code; /* UCS code point */
        -:38026:    int n_code;
        -:38027:
    #####:38028:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:38029:        mem_base = xmlMemBlocks();
    #####:38030:        code = gen_int(n_code, 0);
        -:38031:
    #####:38032:        ret_val = xmlUCSIsCJKCompatibilityIdeographsSupplement(code);
    #####:38033:        desret_int(ret_val);
    #####:38034:        call_tests++;
    #####:38035:        des_int(n_code, code, 0);
    #####:38036:        xmlResetLastError();
    #####:38037:        if (mem_base != xmlMemBlocks()) {
    #####:38038:            printf("Leak of %d blocks found in xmlUCSIsCJKCompatibilityIdeographsSupplement",
    #####:38039:	           xmlMemBlocks() - mem_base);
    #####:38040:	    test_ret++;
    #####:38041:            printf(" %d", n_code);
    #####:38042:            printf("\n");
        -:38043:        }
        -:38044:    }
    #####:38045:    function_tests++;
        -:38046:#endif
        -:38047:
    #####:38048:    return(test_ret);
        -:38049:}
        -:38050:
        -:38051:
        -:38052:static int
    #####:38053:test_xmlUCSIsCJKRadicalsSupplement(void) {
    #####:38054:    int test_ret = 0;
        -:38055:
        -:38056:#if defined(LIBXML_UNICODE_ENABLED)
        -:38057:    int mem_base;
        -:38058:    int ret_val;
        -:38059:    int code; /* UCS code point */
        -:38060:    int n_code;
        -:38061:
    #####:38062:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:38063:        mem_base = xmlMemBlocks();
    #####:38064:        code = gen_int(n_code, 0);
        -:38065:
    #####:38066:        ret_val = xmlUCSIsCJKRadicalsSupplement(code);
    #####:38067:        desret_int(ret_val);
    #####:38068:        call_tests++;
    #####:38069:        des_int(n_code, code, 0);
    #####:38070:        xmlResetLastError();
    #####:38071:        if (mem_base != xmlMemBlocks()) {
    #####:38072:            printf("Leak of %d blocks found in xmlUCSIsCJKRadicalsSupplement",
    #####:38073:	           xmlMemBlocks() - mem_base);
    #####:38074:	    test_ret++;
    #####:38075:            printf(" %d", n_code);
    #####:38076:            printf("\n");
        -:38077:        }
        -:38078:    }
    #####:38079:    function_tests++;
        -:38080:#endif
        -:38081:
    #####:38082:    return(test_ret);
        -:38083:}
        -:38084:
        -:38085:
        -:38086:static int
    #####:38087:test_xmlUCSIsCJKSymbolsandPunctuation(void) {
    #####:38088:    int test_ret = 0;
        -:38089:
        -:38090:#if defined(LIBXML_UNICODE_ENABLED)
        -:38091:    int mem_base;
        -:38092:    int ret_val;
        -:38093:    int code; /* UCS code point */
        -:38094:    int n_code;
        -:38095:
    #####:38096:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:38097:        mem_base = xmlMemBlocks();
    #####:38098:        code = gen_int(n_code, 0);
        -:38099:
    #####:38100:        ret_val = xmlUCSIsCJKSymbolsandPunctuation(code);
    #####:38101:        desret_int(ret_val);
    #####:38102:        call_tests++;
    #####:38103:        des_int(n_code, code, 0);
    #####:38104:        xmlResetLastError();
    #####:38105:        if (mem_base != xmlMemBlocks()) {
    #####:38106:            printf("Leak of %d blocks found in xmlUCSIsCJKSymbolsandPunctuation",
    #####:38107:	           xmlMemBlocks() - mem_base);
    #####:38108:	    test_ret++;
    #####:38109:            printf(" %d", n_code);
    #####:38110:            printf("\n");
        -:38111:        }
        -:38112:    }
    #####:38113:    function_tests++;
        -:38114:#endif
        -:38115:
    #####:38116:    return(test_ret);
        -:38117:}
        -:38118:
        -:38119:
        -:38120:static int
    #####:38121:test_xmlUCSIsCJKUnifiedIdeographs(void) {
    #####:38122:    int test_ret = 0;
        -:38123:
        -:38124:#if defined(LIBXML_UNICODE_ENABLED)
        -:38125:    int mem_base;
        -:38126:    int ret_val;
        -:38127:    int code; /* UCS code point */
        -:38128:    int n_code;
        -:38129:
    #####:38130:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:38131:        mem_base = xmlMemBlocks();
    #####:38132:        code = gen_int(n_code, 0);
        -:38133:
    #####:38134:        ret_val = xmlUCSIsCJKUnifiedIdeographs(code);
    #####:38135:        desret_int(ret_val);
    #####:38136:        call_tests++;
    #####:38137:        des_int(n_code, code, 0);
    #####:38138:        xmlResetLastError();
    #####:38139:        if (mem_base != xmlMemBlocks()) {
    #####:38140:            printf("Leak of %d blocks found in xmlUCSIsCJKUnifiedIdeographs",
    #####:38141:	           xmlMemBlocks() - mem_base);
    #####:38142:	    test_ret++;
    #####:38143:            printf(" %d", n_code);
    #####:38144:            printf("\n");
        -:38145:        }
        -:38146:    }
    #####:38147:    function_tests++;
        -:38148:#endif
        -:38149:
    #####:38150:    return(test_ret);
        -:38151:}
        -:38152:
        -:38153:
        -:38154:static int
    #####:38155:test_xmlUCSIsCJKUnifiedIdeographsExtensionA(void) {
    #####:38156:    int test_ret = 0;
        -:38157:
        -:38158:#if defined(LIBXML_UNICODE_ENABLED)
        -:38159:    int mem_base;
        -:38160:    int ret_val;
        -:38161:    int code; /* UCS code point */
        -:38162:    int n_code;
        -:38163:
    #####:38164:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:38165:        mem_base = xmlMemBlocks();
    #####:38166:        code = gen_int(n_code, 0);
        -:38167:
    #####:38168:        ret_val = xmlUCSIsCJKUnifiedIdeographsExtensionA(code);
    #####:38169:        desret_int(ret_val);
    #####:38170:        call_tests++;
    #####:38171:        des_int(n_code, code, 0);
    #####:38172:        xmlResetLastError();
    #####:38173:        if (mem_base != xmlMemBlocks()) {
    #####:38174:            printf("Leak of %d blocks found in xmlUCSIsCJKUnifiedIdeographsExtensionA",
    #####:38175:	           xmlMemBlocks() - mem_base);
    #####:38176:	    test_ret++;
    #####:38177:            printf(" %d", n_code);
    #####:38178:            printf("\n");
        -:38179:        }
        -:38180:    }
    #####:38181:    function_tests++;
        -:38182:#endif
        -:38183:
    #####:38184:    return(test_ret);
        -:38185:}
        -:38186:
        -:38187:
        -:38188:static int
    #####:38189:test_xmlUCSIsCJKUnifiedIdeographsExtensionB(void) {
    #####:38190:    int test_ret = 0;
        -:38191:
        -:38192:#if defined(LIBXML_UNICODE_ENABLED)
        -:38193:    int mem_base;
        -:38194:    int ret_val;
        -:38195:    int code; /* UCS code point */
        -:38196:    int n_code;
        -:38197:
    #####:38198:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:38199:        mem_base = xmlMemBlocks();
    #####:38200:        code = gen_int(n_code, 0);
        -:38201:
    #####:38202:        ret_val = xmlUCSIsCJKUnifiedIdeographsExtensionB(code);
    #####:38203:        desret_int(ret_val);
    #####:38204:        call_tests++;
    #####:38205:        des_int(n_code, code, 0);
    #####:38206:        xmlResetLastError();
    #####:38207:        if (mem_base != xmlMemBlocks()) {
    #####:38208:            printf("Leak of %d blocks found in xmlUCSIsCJKUnifiedIdeographsExtensionB",
    #####:38209:	           xmlMemBlocks() - mem_base);
    #####:38210:	    test_ret++;
    #####:38211:            printf(" %d", n_code);
    #####:38212:            printf("\n");
        -:38213:        }
        -:38214:    }
    #####:38215:    function_tests++;
        -:38216:#endif
        -:38217:
    #####:38218:    return(test_ret);
        -:38219:}
        -:38220:
        -:38221:
        -:38222:static int
    #####:38223:test_xmlUCSIsCat(void) {
    #####:38224:    int test_ret = 0;
        -:38225:
        -:38226:#if defined(LIBXML_UNICODE_ENABLED)
        -:38227:    int mem_base;
        -:38228:    int ret_val;
        -:38229:    int code; /* UCS code point */
        -:38230:    int n_code;
        -:38231:    char * cat; /* UCS Category name */
        -:38232:    int n_cat;
        -:38233:
    #####:38234:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:38235:    for (n_cat = 0;n_cat < gen_nb_const_char_ptr;n_cat++) {
    #####:38236:        mem_base = xmlMemBlocks();
    #####:38237:        code = gen_int(n_code, 0);
    #####:38238:        cat = gen_const_char_ptr(n_cat, 1);
        -:38239:
    #####:38240:        ret_val = xmlUCSIsCat(code, (const char *)cat);
    #####:38241:        desret_int(ret_val);
    #####:38242:        call_tests++;
    #####:38243:        des_int(n_code, code, 0);
    #####:38244:        des_const_char_ptr(n_cat, (const char *)cat, 1);
    #####:38245:        xmlResetLastError();
    #####:38246:        if (mem_base != xmlMemBlocks()) {
    #####:38247:            printf("Leak of %d blocks found in xmlUCSIsCat",
    #####:38248:	           xmlMemBlocks() - mem_base);
    #####:38249:	    test_ret++;
    #####:38250:            printf(" %d", n_code);
    #####:38251:            printf(" %d", n_cat);
    #####:38252:            printf("\n");
        -:38253:        }
        -:38254:    }
        -:38255:    }
    #####:38256:    function_tests++;
        -:38257:#endif
        -:38258:
    #####:38259:    return(test_ret);
        -:38260:}
        -:38261:
        -:38262:
        -:38263:static int
    #####:38264:test_xmlUCSIsCatC(void) {
    #####:38265:    int test_ret = 0;
        -:38266:
        -:38267:#if defined(LIBXML_UNICODE_ENABLED)
        -:38268:    int mem_base;
        -:38269:    int ret_val;
        -:38270:    int code; /* UCS code point */
        -:38271:    int n_code;
        -:38272:
    #####:38273:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:38274:        mem_base = xmlMemBlocks();
    #####:38275:        code = gen_int(n_code, 0);
        -:38276:
    #####:38277:        ret_val = xmlUCSIsCatC(code);
    #####:38278:        desret_int(ret_val);
    #####:38279:        call_tests++;
    #####:38280:        des_int(n_code, code, 0);
    #####:38281:        xmlResetLastError();
    #####:38282:        if (mem_base != xmlMemBlocks()) {
    #####:38283:            printf("Leak of %d blocks found in xmlUCSIsCatC",
    #####:38284:	           xmlMemBlocks() - mem_base);
    #####:38285:	    test_ret++;
    #####:38286:            printf(" %d", n_code);
    #####:38287:            printf("\n");
        -:38288:        }
        -:38289:    }
    #####:38290:    function_tests++;
        -:38291:#endif
        -:38292:
    #####:38293:    return(test_ret);
        -:38294:}
        -:38295:
        -:38296:
        -:38297:static int
    #####:38298:test_xmlUCSIsCatCc(void) {
    #####:38299:    int test_ret = 0;
        -:38300:
        -:38301:#if defined(LIBXML_UNICODE_ENABLED)
        -:38302:    int mem_base;
        -:38303:    int ret_val;
        -:38304:    int code; /* UCS code point */
        -:38305:    int n_code;
        -:38306:
    #####:38307:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:38308:        mem_base = xmlMemBlocks();
    #####:38309:        code = gen_int(n_code, 0);
        -:38310:
    #####:38311:        ret_val = xmlUCSIsCatCc(code);
    #####:38312:        desret_int(ret_val);
    #####:38313:        call_tests++;
    #####:38314:        des_int(n_code, code, 0);
    #####:38315:        xmlResetLastError();
    #####:38316:        if (mem_base != xmlMemBlocks()) {
    #####:38317:            printf("Leak of %d blocks found in xmlUCSIsCatCc",
    #####:38318:	           xmlMemBlocks() - mem_base);
    #####:38319:	    test_ret++;
    #####:38320:            printf(" %d", n_code);
    #####:38321:            printf("\n");
        -:38322:        }
        -:38323:    }
    #####:38324:    function_tests++;
        -:38325:#endif
        -:38326:
    #####:38327:    return(test_ret);
        -:38328:}
        -:38329:
        -:38330:
        -:38331:static int
    #####:38332:test_xmlUCSIsCatCf(void) {
    #####:38333:    int test_ret = 0;
        -:38334:
        -:38335:#if defined(LIBXML_UNICODE_ENABLED)
        -:38336:    int mem_base;
        -:38337:    int ret_val;
        -:38338:    int code; /* UCS code point */
        -:38339:    int n_code;
        -:38340:
    #####:38341:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:38342:        mem_base = xmlMemBlocks();
    #####:38343:        code = gen_int(n_code, 0);
        -:38344:
    #####:38345:        ret_val = xmlUCSIsCatCf(code);
    #####:38346:        desret_int(ret_val);
    #####:38347:        call_tests++;
    #####:38348:        des_int(n_code, code, 0);
    #####:38349:        xmlResetLastError();
    #####:38350:        if (mem_base != xmlMemBlocks()) {
    #####:38351:            printf("Leak of %d blocks found in xmlUCSIsCatCf",
    #####:38352:	           xmlMemBlocks() - mem_base);
    #####:38353:	    test_ret++;
    #####:38354:            printf(" %d", n_code);
    #####:38355:            printf("\n");
        -:38356:        }
        -:38357:    }
    #####:38358:    function_tests++;
        -:38359:#endif
        -:38360:
    #####:38361:    return(test_ret);
        -:38362:}
        -:38363:
        -:38364:
        -:38365:static int
    #####:38366:test_xmlUCSIsCatCo(void) {
    #####:38367:    int test_ret = 0;
        -:38368:
        -:38369:#if defined(LIBXML_UNICODE_ENABLED)
        -:38370:    int mem_base;
        -:38371:    int ret_val;
        -:38372:    int code; /* UCS code point */
        -:38373:    int n_code;
        -:38374:
    #####:38375:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:38376:        mem_base = xmlMemBlocks();
    #####:38377:        code = gen_int(n_code, 0);
        -:38378:
    #####:38379:        ret_val = xmlUCSIsCatCo(code);
    #####:38380:        desret_int(ret_val);
    #####:38381:        call_tests++;
    #####:38382:        des_int(n_code, code, 0);
    #####:38383:        xmlResetLastError();
    #####:38384:        if (mem_base != xmlMemBlocks()) {
    #####:38385:            printf("Leak of %d blocks found in xmlUCSIsCatCo",
    #####:38386:	           xmlMemBlocks() - mem_base);
    #####:38387:	    test_ret++;
    #####:38388:            printf(" %d", n_code);
    #####:38389:            printf("\n");
        -:38390:        }
        -:38391:    }
    #####:38392:    function_tests++;
        -:38393:#endif
        -:38394:
    #####:38395:    return(test_ret);
        -:38396:}
        -:38397:
        -:38398:
        -:38399:static int
    #####:38400:test_xmlUCSIsCatCs(void) {
    #####:38401:    int test_ret = 0;
        -:38402:
        -:38403:#if defined(LIBXML_UNICODE_ENABLED)
        -:38404:    int mem_base;
        -:38405:    int ret_val;
        -:38406:    int code; /* UCS code point */
        -:38407:    int n_code;
        -:38408:
    #####:38409:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:38410:        mem_base = xmlMemBlocks();
    #####:38411:        code = gen_int(n_code, 0);
        -:38412:
    #####:38413:        ret_val = xmlUCSIsCatCs(code);
    #####:38414:        desret_int(ret_val);
    #####:38415:        call_tests++;
    #####:38416:        des_int(n_code, code, 0);
    #####:38417:        xmlResetLastError();
    #####:38418:        if (mem_base != xmlMemBlocks()) {
    #####:38419:            printf("Leak of %d blocks found in xmlUCSIsCatCs",
    #####:38420:	           xmlMemBlocks() - mem_base);
    #####:38421:	    test_ret++;
    #####:38422:            printf(" %d", n_code);
    #####:38423:            printf("\n");
        -:38424:        }
        -:38425:    }
    #####:38426:    function_tests++;
        -:38427:#endif
        -:38428:
    #####:38429:    return(test_ret);
        -:38430:}
        -:38431:
        -:38432:
        -:38433:static int
    #####:38434:test_xmlUCSIsCatL(void) {
    #####:38435:    int test_ret = 0;
        -:38436:
        -:38437:#if defined(LIBXML_UNICODE_ENABLED)
        -:38438:    int mem_base;
        -:38439:    int ret_val;
        -:38440:    int code; /* UCS code point */
        -:38441:    int n_code;
        -:38442:
    #####:38443:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:38444:        mem_base = xmlMemBlocks();
    #####:38445:        code = gen_int(n_code, 0);
        -:38446:
    #####:38447:        ret_val = xmlUCSIsCatL(code);
    #####:38448:        desret_int(ret_val);
    #####:38449:        call_tests++;
    #####:38450:        des_int(n_code, code, 0);
    #####:38451:        xmlResetLastError();
    #####:38452:        if (mem_base != xmlMemBlocks()) {
    #####:38453:            printf("Leak of %d blocks found in xmlUCSIsCatL",
    #####:38454:	           xmlMemBlocks() - mem_base);
    #####:38455:	    test_ret++;
    #####:38456:            printf(" %d", n_code);
    #####:38457:            printf("\n");
        -:38458:        }
        -:38459:    }
    #####:38460:    function_tests++;
        -:38461:#endif
        -:38462:
    #####:38463:    return(test_ret);
        -:38464:}
        -:38465:
        -:38466:
        -:38467:static int
    #####:38468:test_xmlUCSIsCatLl(void) {
    #####:38469:    int test_ret = 0;
        -:38470:
        -:38471:#if defined(LIBXML_UNICODE_ENABLED)
        -:38472:    int mem_base;
        -:38473:    int ret_val;
        -:38474:    int code; /* UCS code point */
        -:38475:    int n_code;
        -:38476:
    #####:38477:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:38478:        mem_base = xmlMemBlocks();
    #####:38479:        code = gen_int(n_code, 0);
        -:38480:
    #####:38481:        ret_val = xmlUCSIsCatLl(code);
    #####:38482:        desret_int(ret_val);
    #####:38483:        call_tests++;
    #####:38484:        des_int(n_code, code, 0);
    #####:38485:        xmlResetLastError();
    #####:38486:        if (mem_base != xmlMemBlocks()) {
    #####:38487:            printf("Leak of %d blocks found in xmlUCSIsCatLl",
    #####:38488:	           xmlMemBlocks() - mem_base);
    #####:38489:	    test_ret++;
    #####:38490:            printf(" %d", n_code);
    #####:38491:            printf("\n");
        -:38492:        }
        -:38493:    }
    #####:38494:    function_tests++;
        -:38495:#endif
        -:38496:
    #####:38497:    return(test_ret);
        -:38498:}
        -:38499:
        -:38500:
        -:38501:static int
    #####:38502:test_xmlUCSIsCatLm(void) {
    #####:38503:    int test_ret = 0;
        -:38504:
        -:38505:#if defined(LIBXML_UNICODE_ENABLED)
        -:38506:    int mem_base;
        -:38507:    int ret_val;
        -:38508:    int code; /* UCS code point */
        -:38509:    int n_code;
        -:38510:
    #####:38511:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:38512:        mem_base = xmlMemBlocks();
    #####:38513:        code = gen_int(n_code, 0);
        -:38514:
    #####:38515:        ret_val = xmlUCSIsCatLm(code);
    #####:38516:        desret_int(ret_val);
    #####:38517:        call_tests++;
    #####:38518:        des_int(n_code, code, 0);
    #####:38519:        xmlResetLastError();
    #####:38520:        if (mem_base != xmlMemBlocks()) {
    #####:38521:            printf("Leak of %d blocks found in xmlUCSIsCatLm",
    #####:38522:	           xmlMemBlocks() - mem_base);
    #####:38523:	    test_ret++;
    #####:38524:            printf(" %d", n_code);
    #####:38525:            printf("\n");
        -:38526:        }
        -:38527:    }
    #####:38528:    function_tests++;
        -:38529:#endif
        -:38530:
    #####:38531:    return(test_ret);
        -:38532:}
        -:38533:
        -:38534:
        -:38535:static int
    #####:38536:test_xmlUCSIsCatLo(void) {
    #####:38537:    int test_ret = 0;
        -:38538:
        -:38539:#if defined(LIBXML_UNICODE_ENABLED)
        -:38540:    int mem_base;
        -:38541:    int ret_val;
        -:38542:    int code; /* UCS code point */
        -:38543:    int n_code;
        -:38544:
    #####:38545:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:38546:        mem_base = xmlMemBlocks();
    #####:38547:        code = gen_int(n_code, 0);
        -:38548:
    #####:38549:        ret_val = xmlUCSIsCatLo(code);
    #####:38550:        desret_int(ret_val);
    #####:38551:        call_tests++;
    #####:38552:        des_int(n_code, code, 0);
    #####:38553:        xmlResetLastError();
    #####:38554:        if (mem_base != xmlMemBlocks()) {
    #####:38555:            printf("Leak of %d blocks found in xmlUCSIsCatLo",
    #####:38556:	           xmlMemBlocks() - mem_base);
    #####:38557:	    test_ret++;
    #####:38558:            printf(" %d", n_code);
    #####:38559:            printf("\n");
        -:38560:        }
        -:38561:    }
    #####:38562:    function_tests++;
        -:38563:#endif
        -:38564:
    #####:38565:    return(test_ret);
        -:38566:}
        -:38567:
        -:38568:
        -:38569:static int
    #####:38570:test_xmlUCSIsCatLt(void) {
    #####:38571:    int test_ret = 0;
        -:38572:
        -:38573:#if defined(LIBXML_UNICODE_ENABLED)
        -:38574:    int mem_base;
        -:38575:    int ret_val;
        -:38576:    int code; /* UCS code point */
        -:38577:    int n_code;
        -:38578:
    #####:38579:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:38580:        mem_base = xmlMemBlocks();
    #####:38581:        code = gen_int(n_code, 0);
        -:38582:
    #####:38583:        ret_val = xmlUCSIsCatLt(code);
    #####:38584:        desret_int(ret_val);
    #####:38585:        call_tests++;
    #####:38586:        des_int(n_code, code, 0);
    #####:38587:        xmlResetLastError();
    #####:38588:        if (mem_base != xmlMemBlocks()) {
    #####:38589:            printf("Leak of %d blocks found in xmlUCSIsCatLt",
    #####:38590:	           xmlMemBlocks() - mem_base);
    #####:38591:	    test_ret++;
    #####:38592:            printf(" %d", n_code);
    #####:38593:            printf("\n");
        -:38594:        }
        -:38595:    }
    #####:38596:    function_tests++;
        -:38597:#endif
        -:38598:
    #####:38599:    return(test_ret);
        -:38600:}
        -:38601:
        -:38602:
        -:38603:static int
    #####:38604:test_xmlUCSIsCatLu(void) {
    #####:38605:    int test_ret = 0;
        -:38606:
        -:38607:#if defined(LIBXML_UNICODE_ENABLED)
        -:38608:    int mem_base;
        -:38609:    int ret_val;
        -:38610:    int code; /* UCS code point */
        -:38611:    int n_code;
        -:38612:
    #####:38613:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:38614:        mem_base = xmlMemBlocks();
    #####:38615:        code = gen_int(n_code, 0);
        -:38616:
    #####:38617:        ret_val = xmlUCSIsCatLu(code);
    #####:38618:        desret_int(ret_val);
    #####:38619:        call_tests++;
    #####:38620:        des_int(n_code, code, 0);
    #####:38621:        xmlResetLastError();
    #####:38622:        if (mem_base != xmlMemBlocks()) {
    #####:38623:            printf("Leak of %d blocks found in xmlUCSIsCatLu",
    #####:38624:	           xmlMemBlocks() - mem_base);
    #####:38625:	    test_ret++;
    #####:38626:            printf(" %d", n_code);
    #####:38627:            printf("\n");
        -:38628:        }
        -:38629:    }
    #####:38630:    function_tests++;
        -:38631:#endif
        -:38632:
    #####:38633:    return(test_ret);
        -:38634:}
        -:38635:
        -:38636:
        -:38637:static int
    #####:38638:test_xmlUCSIsCatM(void) {
    #####:38639:    int test_ret = 0;
        -:38640:
        -:38641:#if defined(LIBXML_UNICODE_ENABLED)
        -:38642:    int mem_base;
        -:38643:    int ret_val;
        -:38644:    int code; /* UCS code point */
        -:38645:    int n_code;
        -:38646:
    #####:38647:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:38648:        mem_base = xmlMemBlocks();
    #####:38649:        code = gen_int(n_code, 0);
        -:38650:
    #####:38651:        ret_val = xmlUCSIsCatM(code);
    #####:38652:        desret_int(ret_val);
    #####:38653:        call_tests++;
    #####:38654:        des_int(n_code, code, 0);
    #####:38655:        xmlResetLastError();
    #####:38656:        if (mem_base != xmlMemBlocks()) {
    #####:38657:            printf("Leak of %d blocks found in xmlUCSIsCatM",
    #####:38658:	           xmlMemBlocks() - mem_base);
    #####:38659:	    test_ret++;
    #####:38660:            printf(" %d", n_code);
    #####:38661:            printf("\n");
        -:38662:        }
        -:38663:    }
    #####:38664:    function_tests++;
        -:38665:#endif
        -:38666:
    #####:38667:    return(test_ret);
        -:38668:}
        -:38669:
        -:38670:
        -:38671:static int
    #####:38672:test_xmlUCSIsCatMc(void) {
    #####:38673:    int test_ret = 0;
        -:38674:
        -:38675:#if defined(LIBXML_UNICODE_ENABLED)
        -:38676:    int mem_base;
        -:38677:    int ret_val;
        -:38678:    int code; /* UCS code point */
        -:38679:    int n_code;
        -:38680:
    #####:38681:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:38682:        mem_base = xmlMemBlocks();
    #####:38683:        code = gen_int(n_code, 0);
        -:38684:
    #####:38685:        ret_val = xmlUCSIsCatMc(code);
    #####:38686:        desret_int(ret_val);
    #####:38687:        call_tests++;
    #####:38688:        des_int(n_code, code, 0);
    #####:38689:        xmlResetLastError();
    #####:38690:        if (mem_base != xmlMemBlocks()) {
    #####:38691:            printf("Leak of %d blocks found in xmlUCSIsCatMc",
    #####:38692:	           xmlMemBlocks() - mem_base);
    #####:38693:	    test_ret++;
    #####:38694:            printf(" %d", n_code);
    #####:38695:            printf("\n");
        -:38696:        }
        -:38697:    }
    #####:38698:    function_tests++;
        -:38699:#endif
        -:38700:
    #####:38701:    return(test_ret);
        -:38702:}
        -:38703:
        -:38704:
        -:38705:static int
    #####:38706:test_xmlUCSIsCatMe(void) {
    #####:38707:    int test_ret = 0;
        -:38708:
        -:38709:#if defined(LIBXML_UNICODE_ENABLED)
        -:38710:    int mem_base;
        -:38711:    int ret_val;
        -:38712:    int code; /* UCS code point */
        -:38713:    int n_code;
        -:38714:
    #####:38715:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:38716:        mem_base = xmlMemBlocks();
    #####:38717:        code = gen_int(n_code, 0);
        -:38718:
    #####:38719:        ret_val = xmlUCSIsCatMe(code);
    #####:38720:        desret_int(ret_val);
    #####:38721:        call_tests++;
    #####:38722:        des_int(n_code, code, 0);
    #####:38723:        xmlResetLastError();
    #####:38724:        if (mem_base != xmlMemBlocks()) {
    #####:38725:            printf("Leak of %d blocks found in xmlUCSIsCatMe",
    #####:38726:	           xmlMemBlocks() - mem_base);
    #####:38727:	    test_ret++;
    #####:38728:            printf(" %d", n_code);
    #####:38729:            printf("\n");
        -:38730:        }
        -:38731:    }
    #####:38732:    function_tests++;
        -:38733:#endif
        -:38734:
    #####:38735:    return(test_ret);
        -:38736:}
        -:38737:
        -:38738:
        -:38739:static int
    #####:38740:test_xmlUCSIsCatMn(void) {
    #####:38741:    int test_ret = 0;
        -:38742:
        -:38743:#if defined(LIBXML_UNICODE_ENABLED)
        -:38744:    int mem_base;
        -:38745:    int ret_val;
        -:38746:    int code; /* UCS code point */
        -:38747:    int n_code;
        -:38748:
    #####:38749:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:38750:        mem_base = xmlMemBlocks();
    #####:38751:        code = gen_int(n_code, 0);
        -:38752:
    #####:38753:        ret_val = xmlUCSIsCatMn(code);
    #####:38754:        desret_int(ret_val);
    #####:38755:        call_tests++;
    #####:38756:        des_int(n_code, code, 0);
    #####:38757:        xmlResetLastError();
    #####:38758:        if (mem_base != xmlMemBlocks()) {
    #####:38759:            printf("Leak of %d blocks found in xmlUCSIsCatMn",
    #####:38760:	           xmlMemBlocks() - mem_base);
    #####:38761:	    test_ret++;
    #####:38762:            printf(" %d", n_code);
    #####:38763:            printf("\n");
        -:38764:        }
        -:38765:    }
    #####:38766:    function_tests++;
        -:38767:#endif
        -:38768:
    #####:38769:    return(test_ret);
        -:38770:}
        -:38771:
        -:38772:
        -:38773:static int
    #####:38774:test_xmlUCSIsCatN(void) {
    #####:38775:    int test_ret = 0;
        -:38776:
        -:38777:#if defined(LIBXML_UNICODE_ENABLED)
        -:38778:    int mem_base;
        -:38779:    int ret_val;
        -:38780:    int code; /* UCS code point */
        -:38781:    int n_code;
        -:38782:
    #####:38783:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:38784:        mem_base = xmlMemBlocks();
    #####:38785:        code = gen_int(n_code, 0);
        -:38786:
    #####:38787:        ret_val = xmlUCSIsCatN(code);
    #####:38788:        desret_int(ret_val);
    #####:38789:        call_tests++;
    #####:38790:        des_int(n_code, code, 0);
    #####:38791:        xmlResetLastError();
    #####:38792:        if (mem_base != xmlMemBlocks()) {
    #####:38793:            printf("Leak of %d blocks found in xmlUCSIsCatN",
    #####:38794:	           xmlMemBlocks() - mem_base);
    #####:38795:	    test_ret++;
    #####:38796:            printf(" %d", n_code);
    #####:38797:            printf("\n");
        -:38798:        }
        -:38799:    }
    #####:38800:    function_tests++;
        -:38801:#endif
        -:38802:
    #####:38803:    return(test_ret);
        -:38804:}
        -:38805:
        -:38806:
        -:38807:static int
    #####:38808:test_xmlUCSIsCatNd(void) {
    #####:38809:    int test_ret = 0;
        -:38810:
        -:38811:#if defined(LIBXML_UNICODE_ENABLED)
        -:38812:    int mem_base;
        -:38813:    int ret_val;
        -:38814:    int code; /* UCS code point */
        -:38815:    int n_code;
        -:38816:
    #####:38817:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:38818:        mem_base = xmlMemBlocks();
    #####:38819:        code = gen_int(n_code, 0);
        -:38820:
    #####:38821:        ret_val = xmlUCSIsCatNd(code);
    #####:38822:        desret_int(ret_val);
    #####:38823:        call_tests++;
    #####:38824:        des_int(n_code, code, 0);
    #####:38825:        xmlResetLastError();
    #####:38826:        if (mem_base != xmlMemBlocks()) {
    #####:38827:            printf("Leak of %d blocks found in xmlUCSIsCatNd",
    #####:38828:	           xmlMemBlocks() - mem_base);
    #####:38829:	    test_ret++;
    #####:38830:            printf(" %d", n_code);
    #####:38831:            printf("\n");
        -:38832:        }
        -:38833:    }
    #####:38834:    function_tests++;
        -:38835:#endif
        -:38836:
    #####:38837:    return(test_ret);
        -:38838:}
        -:38839:
        -:38840:
        -:38841:static int
    #####:38842:test_xmlUCSIsCatNl(void) {
    #####:38843:    int test_ret = 0;
        -:38844:
        -:38845:#if defined(LIBXML_UNICODE_ENABLED)
        -:38846:    int mem_base;
        -:38847:    int ret_val;
        -:38848:    int code; /* UCS code point */
        -:38849:    int n_code;
        -:38850:
    #####:38851:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:38852:        mem_base = xmlMemBlocks();
    #####:38853:        code = gen_int(n_code, 0);
        -:38854:
    #####:38855:        ret_val = xmlUCSIsCatNl(code);
    #####:38856:        desret_int(ret_val);
    #####:38857:        call_tests++;
    #####:38858:        des_int(n_code, code, 0);
    #####:38859:        xmlResetLastError();
    #####:38860:        if (mem_base != xmlMemBlocks()) {
    #####:38861:            printf("Leak of %d blocks found in xmlUCSIsCatNl",
    #####:38862:	           xmlMemBlocks() - mem_base);
    #####:38863:	    test_ret++;
    #####:38864:            printf(" %d", n_code);
    #####:38865:            printf("\n");
        -:38866:        }
        -:38867:    }
    #####:38868:    function_tests++;
        -:38869:#endif
        -:38870:
    #####:38871:    return(test_ret);
        -:38872:}
        -:38873:
        -:38874:
        -:38875:static int
    #####:38876:test_xmlUCSIsCatNo(void) {
    #####:38877:    int test_ret = 0;
        -:38878:
        -:38879:#if defined(LIBXML_UNICODE_ENABLED)
        -:38880:    int mem_base;
        -:38881:    int ret_val;
        -:38882:    int code; /* UCS code point */
        -:38883:    int n_code;
        -:38884:
    #####:38885:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:38886:        mem_base = xmlMemBlocks();
    #####:38887:        code = gen_int(n_code, 0);
        -:38888:
    #####:38889:        ret_val = xmlUCSIsCatNo(code);
    #####:38890:        desret_int(ret_val);
    #####:38891:        call_tests++;
    #####:38892:        des_int(n_code, code, 0);
    #####:38893:        xmlResetLastError();
    #####:38894:        if (mem_base != xmlMemBlocks()) {
    #####:38895:            printf("Leak of %d blocks found in xmlUCSIsCatNo",
    #####:38896:	           xmlMemBlocks() - mem_base);
    #####:38897:	    test_ret++;
    #####:38898:            printf(" %d", n_code);
    #####:38899:            printf("\n");
        -:38900:        }
        -:38901:    }
    #####:38902:    function_tests++;
        -:38903:#endif
        -:38904:
    #####:38905:    return(test_ret);
        -:38906:}
        -:38907:
        -:38908:
        -:38909:static int
    #####:38910:test_xmlUCSIsCatP(void) {
    #####:38911:    int test_ret = 0;
        -:38912:
        -:38913:#if defined(LIBXML_UNICODE_ENABLED)
        -:38914:    int mem_base;
        -:38915:    int ret_val;
        -:38916:    int code; /* UCS code point */
        -:38917:    int n_code;
        -:38918:
    #####:38919:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:38920:        mem_base = xmlMemBlocks();
    #####:38921:        code = gen_int(n_code, 0);
        -:38922:
    #####:38923:        ret_val = xmlUCSIsCatP(code);
    #####:38924:        desret_int(ret_val);
    #####:38925:        call_tests++;
    #####:38926:        des_int(n_code, code, 0);
    #####:38927:        xmlResetLastError();
    #####:38928:        if (mem_base != xmlMemBlocks()) {
    #####:38929:            printf("Leak of %d blocks found in xmlUCSIsCatP",
    #####:38930:	           xmlMemBlocks() - mem_base);
    #####:38931:	    test_ret++;
    #####:38932:            printf(" %d", n_code);
    #####:38933:            printf("\n");
        -:38934:        }
        -:38935:    }
    #####:38936:    function_tests++;
        -:38937:#endif
        -:38938:
    #####:38939:    return(test_ret);
        -:38940:}
        -:38941:
        -:38942:
        -:38943:static int
    #####:38944:test_xmlUCSIsCatPc(void) {
    #####:38945:    int test_ret = 0;
        -:38946:
        -:38947:#if defined(LIBXML_UNICODE_ENABLED)
        -:38948:    int mem_base;
        -:38949:    int ret_val;
        -:38950:    int code; /* UCS code point */
        -:38951:    int n_code;
        -:38952:
    #####:38953:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:38954:        mem_base = xmlMemBlocks();
    #####:38955:        code = gen_int(n_code, 0);
        -:38956:
    #####:38957:        ret_val = xmlUCSIsCatPc(code);
    #####:38958:        desret_int(ret_val);
    #####:38959:        call_tests++;
    #####:38960:        des_int(n_code, code, 0);
    #####:38961:        xmlResetLastError();
    #####:38962:        if (mem_base != xmlMemBlocks()) {
    #####:38963:            printf("Leak of %d blocks found in xmlUCSIsCatPc",
    #####:38964:	           xmlMemBlocks() - mem_base);
    #####:38965:	    test_ret++;
    #####:38966:            printf(" %d", n_code);
    #####:38967:            printf("\n");
        -:38968:        }
        -:38969:    }
    #####:38970:    function_tests++;
        -:38971:#endif
        -:38972:
    #####:38973:    return(test_ret);
        -:38974:}
        -:38975:
        -:38976:
        -:38977:static int
    #####:38978:test_xmlUCSIsCatPd(void) {
    #####:38979:    int test_ret = 0;
        -:38980:
        -:38981:#if defined(LIBXML_UNICODE_ENABLED)
        -:38982:    int mem_base;
        -:38983:    int ret_val;
        -:38984:    int code; /* UCS code point */
        -:38985:    int n_code;
        -:38986:
    #####:38987:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:38988:        mem_base = xmlMemBlocks();
    #####:38989:        code = gen_int(n_code, 0);
        -:38990:
    #####:38991:        ret_val = xmlUCSIsCatPd(code);
    #####:38992:        desret_int(ret_val);
    #####:38993:        call_tests++;
    #####:38994:        des_int(n_code, code, 0);
    #####:38995:        xmlResetLastError();
    #####:38996:        if (mem_base != xmlMemBlocks()) {
    #####:38997:            printf("Leak of %d blocks found in xmlUCSIsCatPd",
    #####:38998:	           xmlMemBlocks() - mem_base);
    #####:38999:	    test_ret++;
    #####:39000:            printf(" %d", n_code);
    #####:39001:            printf("\n");
        -:39002:        }
        -:39003:    }
    #####:39004:    function_tests++;
        -:39005:#endif
        -:39006:
    #####:39007:    return(test_ret);
        -:39008:}
        -:39009:
        -:39010:
        -:39011:static int
    #####:39012:test_xmlUCSIsCatPe(void) {
    #####:39013:    int test_ret = 0;
        -:39014:
        -:39015:#if defined(LIBXML_UNICODE_ENABLED)
        -:39016:    int mem_base;
        -:39017:    int ret_val;
        -:39018:    int code; /* UCS code point */
        -:39019:    int n_code;
        -:39020:
    #####:39021:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:39022:        mem_base = xmlMemBlocks();
    #####:39023:        code = gen_int(n_code, 0);
        -:39024:
    #####:39025:        ret_val = xmlUCSIsCatPe(code);
    #####:39026:        desret_int(ret_val);
    #####:39027:        call_tests++;
    #####:39028:        des_int(n_code, code, 0);
    #####:39029:        xmlResetLastError();
    #####:39030:        if (mem_base != xmlMemBlocks()) {
    #####:39031:            printf("Leak of %d blocks found in xmlUCSIsCatPe",
    #####:39032:	           xmlMemBlocks() - mem_base);
    #####:39033:	    test_ret++;
    #####:39034:            printf(" %d", n_code);
    #####:39035:            printf("\n");
        -:39036:        }
        -:39037:    }
    #####:39038:    function_tests++;
        -:39039:#endif
        -:39040:
    #####:39041:    return(test_ret);
        -:39042:}
        -:39043:
        -:39044:
        -:39045:static int
    #####:39046:test_xmlUCSIsCatPf(void) {
    #####:39047:    int test_ret = 0;
        -:39048:
        -:39049:#if defined(LIBXML_UNICODE_ENABLED)
        -:39050:    int mem_base;
        -:39051:    int ret_val;
        -:39052:    int code; /* UCS code point */
        -:39053:    int n_code;
        -:39054:
    #####:39055:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:39056:        mem_base = xmlMemBlocks();
    #####:39057:        code = gen_int(n_code, 0);
        -:39058:
    #####:39059:        ret_val = xmlUCSIsCatPf(code);
    #####:39060:        desret_int(ret_val);
    #####:39061:        call_tests++;
    #####:39062:        des_int(n_code, code, 0);
    #####:39063:        xmlResetLastError();
    #####:39064:        if (mem_base != xmlMemBlocks()) {
    #####:39065:            printf("Leak of %d blocks found in xmlUCSIsCatPf",
    #####:39066:	           xmlMemBlocks() - mem_base);
    #####:39067:	    test_ret++;
    #####:39068:            printf(" %d", n_code);
    #####:39069:            printf("\n");
        -:39070:        }
        -:39071:    }
    #####:39072:    function_tests++;
        -:39073:#endif
        -:39074:
    #####:39075:    return(test_ret);
        -:39076:}
        -:39077:
        -:39078:
        -:39079:static int
    #####:39080:test_xmlUCSIsCatPi(void) {
    #####:39081:    int test_ret = 0;
        -:39082:
        -:39083:#if defined(LIBXML_UNICODE_ENABLED)
        -:39084:    int mem_base;
        -:39085:    int ret_val;
        -:39086:    int code; /* UCS code point */
        -:39087:    int n_code;
        -:39088:
    #####:39089:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:39090:        mem_base = xmlMemBlocks();
    #####:39091:        code = gen_int(n_code, 0);
        -:39092:
    #####:39093:        ret_val = xmlUCSIsCatPi(code);
    #####:39094:        desret_int(ret_val);
    #####:39095:        call_tests++;
    #####:39096:        des_int(n_code, code, 0);
    #####:39097:        xmlResetLastError();
    #####:39098:        if (mem_base != xmlMemBlocks()) {
    #####:39099:            printf("Leak of %d blocks found in xmlUCSIsCatPi",
    #####:39100:	           xmlMemBlocks() - mem_base);
    #####:39101:	    test_ret++;
    #####:39102:            printf(" %d", n_code);
    #####:39103:            printf("\n");
        -:39104:        }
        -:39105:    }
    #####:39106:    function_tests++;
        -:39107:#endif
        -:39108:
    #####:39109:    return(test_ret);
        -:39110:}
        -:39111:
        -:39112:
        -:39113:static int
    #####:39114:test_xmlUCSIsCatPo(void) {
    #####:39115:    int test_ret = 0;
        -:39116:
        -:39117:#if defined(LIBXML_UNICODE_ENABLED)
        -:39118:    int mem_base;
        -:39119:    int ret_val;
        -:39120:    int code; /* UCS code point */
        -:39121:    int n_code;
        -:39122:
    #####:39123:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:39124:        mem_base = xmlMemBlocks();
    #####:39125:        code = gen_int(n_code, 0);
        -:39126:
    #####:39127:        ret_val = xmlUCSIsCatPo(code);
    #####:39128:        desret_int(ret_val);
    #####:39129:        call_tests++;
    #####:39130:        des_int(n_code, code, 0);
    #####:39131:        xmlResetLastError();
    #####:39132:        if (mem_base != xmlMemBlocks()) {
    #####:39133:            printf("Leak of %d blocks found in xmlUCSIsCatPo",
    #####:39134:	           xmlMemBlocks() - mem_base);
    #####:39135:	    test_ret++;
    #####:39136:            printf(" %d", n_code);
    #####:39137:            printf("\n");
        -:39138:        }
        -:39139:    }
    #####:39140:    function_tests++;
        -:39141:#endif
        -:39142:
    #####:39143:    return(test_ret);
        -:39144:}
        -:39145:
        -:39146:
        -:39147:static int
    #####:39148:test_xmlUCSIsCatPs(void) {
    #####:39149:    int test_ret = 0;
        -:39150:
        -:39151:#if defined(LIBXML_UNICODE_ENABLED)
        -:39152:    int mem_base;
        -:39153:    int ret_val;
        -:39154:    int code; /* UCS code point */
        -:39155:    int n_code;
        -:39156:
    #####:39157:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:39158:        mem_base = xmlMemBlocks();
    #####:39159:        code = gen_int(n_code, 0);
        -:39160:
    #####:39161:        ret_val = xmlUCSIsCatPs(code);
    #####:39162:        desret_int(ret_val);
    #####:39163:        call_tests++;
    #####:39164:        des_int(n_code, code, 0);
    #####:39165:        xmlResetLastError();
    #####:39166:        if (mem_base != xmlMemBlocks()) {
    #####:39167:            printf("Leak of %d blocks found in xmlUCSIsCatPs",
    #####:39168:	           xmlMemBlocks() - mem_base);
    #####:39169:	    test_ret++;
    #####:39170:            printf(" %d", n_code);
    #####:39171:            printf("\n");
        -:39172:        }
        -:39173:    }
    #####:39174:    function_tests++;
        -:39175:#endif
        -:39176:
    #####:39177:    return(test_ret);
        -:39178:}
        -:39179:
        -:39180:
        -:39181:static int
    #####:39182:test_xmlUCSIsCatS(void) {
    #####:39183:    int test_ret = 0;
        -:39184:
        -:39185:#if defined(LIBXML_UNICODE_ENABLED)
        -:39186:    int mem_base;
        -:39187:    int ret_val;
        -:39188:    int code; /* UCS code point */
        -:39189:    int n_code;
        -:39190:
    #####:39191:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:39192:        mem_base = xmlMemBlocks();
    #####:39193:        code = gen_int(n_code, 0);
        -:39194:
    #####:39195:        ret_val = xmlUCSIsCatS(code);
    #####:39196:        desret_int(ret_val);
    #####:39197:        call_tests++;
    #####:39198:        des_int(n_code, code, 0);
    #####:39199:        xmlResetLastError();
    #####:39200:        if (mem_base != xmlMemBlocks()) {
    #####:39201:            printf("Leak of %d blocks found in xmlUCSIsCatS",
    #####:39202:	           xmlMemBlocks() - mem_base);
    #####:39203:	    test_ret++;
    #####:39204:            printf(" %d", n_code);
    #####:39205:            printf("\n");
        -:39206:        }
        -:39207:    }
    #####:39208:    function_tests++;
        -:39209:#endif
        -:39210:
    #####:39211:    return(test_ret);
        -:39212:}
        -:39213:
        -:39214:
        -:39215:static int
    #####:39216:test_xmlUCSIsCatSc(void) {
    #####:39217:    int test_ret = 0;
        -:39218:
        -:39219:#if defined(LIBXML_UNICODE_ENABLED)
        -:39220:    int mem_base;
        -:39221:    int ret_val;
        -:39222:    int code; /* UCS code point */
        -:39223:    int n_code;
        -:39224:
    #####:39225:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:39226:        mem_base = xmlMemBlocks();
    #####:39227:        code = gen_int(n_code, 0);
        -:39228:
    #####:39229:        ret_val = xmlUCSIsCatSc(code);
    #####:39230:        desret_int(ret_val);
    #####:39231:        call_tests++;
    #####:39232:        des_int(n_code, code, 0);
    #####:39233:        xmlResetLastError();
    #####:39234:        if (mem_base != xmlMemBlocks()) {
    #####:39235:            printf("Leak of %d blocks found in xmlUCSIsCatSc",
    #####:39236:	           xmlMemBlocks() - mem_base);
    #####:39237:	    test_ret++;
    #####:39238:            printf(" %d", n_code);
    #####:39239:            printf("\n");
        -:39240:        }
        -:39241:    }
    #####:39242:    function_tests++;
        -:39243:#endif
        -:39244:
    #####:39245:    return(test_ret);
        -:39246:}
        -:39247:
        -:39248:
        -:39249:static int
    #####:39250:test_xmlUCSIsCatSk(void) {
    #####:39251:    int test_ret = 0;
        -:39252:
        -:39253:#if defined(LIBXML_UNICODE_ENABLED)
        -:39254:    int mem_base;
        -:39255:    int ret_val;
        -:39256:    int code; /* UCS code point */
        -:39257:    int n_code;
        -:39258:
    #####:39259:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:39260:        mem_base = xmlMemBlocks();
    #####:39261:        code = gen_int(n_code, 0);
        -:39262:
    #####:39263:        ret_val = xmlUCSIsCatSk(code);
    #####:39264:        desret_int(ret_val);
    #####:39265:        call_tests++;
    #####:39266:        des_int(n_code, code, 0);
    #####:39267:        xmlResetLastError();
    #####:39268:        if (mem_base != xmlMemBlocks()) {
    #####:39269:            printf("Leak of %d blocks found in xmlUCSIsCatSk",
    #####:39270:	           xmlMemBlocks() - mem_base);
    #####:39271:	    test_ret++;
    #####:39272:            printf(" %d", n_code);
    #####:39273:            printf("\n");
        -:39274:        }
        -:39275:    }
    #####:39276:    function_tests++;
        -:39277:#endif
        -:39278:
    #####:39279:    return(test_ret);
        -:39280:}
        -:39281:
        -:39282:
        -:39283:static int
    #####:39284:test_xmlUCSIsCatSm(void) {
    #####:39285:    int test_ret = 0;
        -:39286:
        -:39287:#if defined(LIBXML_UNICODE_ENABLED)
        -:39288:    int mem_base;
        -:39289:    int ret_val;
        -:39290:    int code; /* UCS code point */
        -:39291:    int n_code;
        -:39292:
    #####:39293:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:39294:        mem_base = xmlMemBlocks();
    #####:39295:        code = gen_int(n_code, 0);
        -:39296:
    #####:39297:        ret_val = xmlUCSIsCatSm(code);
    #####:39298:        desret_int(ret_val);
    #####:39299:        call_tests++;
    #####:39300:        des_int(n_code, code, 0);
    #####:39301:        xmlResetLastError();
    #####:39302:        if (mem_base != xmlMemBlocks()) {
    #####:39303:            printf("Leak of %d blocks found in xmlUCSIsCatSm",
    #####:39304:	           xmlMemBlocks() - mem_base);
    #####:39305:	    test_ret++;
    #####:39306:            printf(" %d", n_code);
    #####:39307:            printf("\n");
        -:39308:        }
        -:39309:    }
    #####:39310:    function_tests++;
        -:39311:#endif
        -:39312:
    #####:39313:    return(test_ret);
        -:39314:}
        -:39315:
        -:39316:
        -:39317:static int
    #####:39318:test_xmlUCSIsCatSo(void) {
    #####:39319:    int test_ret = 0;
        -:39320:
        -:39321:#if defined(LIBXML_UNICODE_ENABLED)
        -:39322:    int mem_base;
        -:39323:    int ret_val;
        -:39324:    int code; /* UCS code point */
        -:39325:    int n_code;
        -:39326:
    #####:39327:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:39328:        mem_base = xmlMemBlocks();
    #####:39329:        code = gen_int(n_code, 0);
        -:39330:
    #####:39331:        ret_val = xmlUCSIsCatSo(code);
    #####:39332:        desret_int(ret_val);
    #####:39333:        call_tests++;
    #####:39334:        des_int(n_code, code, 0);
    #####:39335:        xmlResetLastError();
    #####:39336:        if (mem_base != xmlMemBlocks()) {
    #####:39337:            printf("Leak of %d blocks found in xmlUCSIsCatSo",
    #####:39338:	           xmlMemBlocks() - mem_base);
    #####:39339:	    test_ret++;
    #####:39340:            printf(" %d", n_code);
    #####:39341:            printf("\n");
        -:39342:        }
        -:39343:    }
    #####:39344:    function_tests++;
        -:39345:#endif
        -:39346:
    #####:39347:    return(test_ret);
        -:39348:}
        -:39349:
        -:39350:
        -:39351:static int
    #####:39352:test_xmlUCSIsCatZ(void) {
    #####:39353:    int test_ret = 0;
        -:39354:
        -:39355:#if defined(LIBXML_UNICODE_ENABLED)
        -:39356:    int mem_base;
        -:39357:    int ret_val;
        -:39358:    int code; /* UCS code point */
        -:39359:    int n_code;
        -:39360:
    #####:39361:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:39362:        mem_base = xmlMemBlocks();
    #####:39363:        code = gen_int(n_code, 0);
        -:39364:
    #####:39365:        ret_val = xmlUCSIsCatZ(code);
    #####:39366:        desret_int(ret_val);
    #####:39367:        call_tests++;
    #####:39368:        des_int(n_code, code, 0);
    #####:39369:        xmlResetLastError();
    #####:39370:        if (mem_base != xmlMemBlocks()) {
    #####:39371:            printf("Leak of %d blocks found in xmlUCSIsCatZ",
    #####:39372:	           xmlMemBlocks() - mem_base);
    #####:39373:	    test_ret++;
    #####:39374:            printf(" %d", n_code);
    #####:39375:            printf("\n");
        -:39376:        }
        -:39377:    }
    #####:39378:    function_tests++;
        -:39379:#endif
        -:39380:
    #####:39381:    return(test_ret);
        -:39382:}
        -:39383:
        -:39384:
        -:39385:static int
    #####:39386:test_xmlUCSIsCatZl(void) {
    #####:39387:    int test_ret = 0;
        -:39388:
        -:39389:#if defined(LIBXML_UNICODE_ENABLED)
        -:39390:    int mem_base;
        -:39391:    int ret_val;
        -:39392:    int code; /* UCS code point */
        -:39393:    int n_code;
        -:39394:
    #####:39395:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:39396:        mem_base = xmlMemBlocks();
    #####:39397:        code = gen_int(n_code, 0);
        -:39398:
    #####:39399:        ret_val = xmlUCSIsCatZl(code);
    #####:39400:        desret_int(ret_val);
    #####:39401:        call_tests++;
    #####:39402:        des_int(n_code, code, 0);
    #####:39403:        xmlResetLastError();
    #####:39404:        if (mem_base != xmlMemBlocks()) {
    #####:39405:            printf("Leak of %d blocks found in xmlUCSIsCatZl",
    #####:39406:	           xmlMemBlocks() - mem_base);
    #####:39407:	    test_ret++;
    #####:39408:            printf(" %d", n_code);
    #####:39409:            printf("\n");
        -:39410:        }
        -:39411:    }
    #####:39412:    function_tests++;
        -:39413:#endif
        -:39414:
    #####:39415:    return(test_ret);
        -:39416:}
        -:39417:
        -:39418:
        -:39419:static int
    #####:39420:test_xmlUCSIsCatZp(void) {
    #####:39421:    int test_ret = 0;
        -:39422:
        -:39423:#if defined(LIBXML_UNICODE_ENABLED)
        -:39424:    int mem_base;
        -:39425:    int ret_val;
        -:39426:    int code; /* UCS code point */
        -:39427:    int n_code;
        -:39428:
    #####:39429:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:39430:        mem_base = xmlMemBlocks();
    #####:39431:        code = gen_int(n_code, 0);
        -:39432:
    #####:39433:        ret_val = xmlUCSIsCatZp(code);
    #####:39434:        desret_int(ret_val);
    #####:39435:        call_tests++;
    #####:39436:        des_int(n_code, code, 0);
    #####:39437:        xmlResetLastError();
    #####:39438:        if (mem_base != xmlMemBlocks()) {
    #####:39439:            printf("Leak of %d blocks found in xmlUCSIsCatZp",
    #####:39440:	           xmlMemBlocks() - mem_base);
    #####:39441:	    test_ret++;
    #####:39442:            printf(" %d", n_code);
    #####:39443:            printf("\n");
        -:39444:        }
        -:39445:    }
    #####:39446:    function_tests++;
        -:39447:#endif
        -:39448:
    #####:39449:    return(test_ret);
        -:39450:}
        -:39451:
        -:39452:
        -:39453:static int
    #####:39454:test_xmlUCSIsCatZs(void) {
    #####:39455:    int test_ret = 0;
        -:39456:
        -:39457:#if defined(LIBXML_UNICODE_ENABLED)
        -:39458:    int mem_base;
        -:39459:    int ret_val;
        -:39460:    int code; /* UCS code point */
        -:39461:    int n_code;
        -:39462:
    #####:39463:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:39464:        mem_base = xmlMemBlocks();
    #####:39465:        code = gen_int(n_code, 0);
        -:39466:
    #####:39467:        ret_val = xmlUCSIsCatZs(code);
    #####:39468:        desret_int(ret_val);
    #####:39469:        call_tests++;
    #####:39470:        des_int(n_code, code, 0);
    #####:39471:        xmlResetLastError();
    #####:39472:        if (mem_base != xmlMemBlocks()) {
    #####:39473:            printf("Leak of %d blocks found in xmlUCSIsCatZs",
    #####:39474:	           xmlMemBlocks() - mem_base);
    #####:39475:	    test_ret++;
    #####:39476:            printf(" %d", n_code);
    #####:39477:            printf("\n");
        -:39478:        }
        -:39479:    }
    #####:39480:    function_tests++;
        -:39481:#endif
        -:39482:
    #####:39483:    return(test_ret);
        -:39484:}
        -:39485:
        -:39486:
        -:39487:static int
    #####:39488:test_xmlUCSIsCherokee(void) {
    #####:39489:    int test_ret = 0;
        -:39490:
        -:39491:#if defined(LIBXML_UNICODE_ENABLED)
        -:39492:    int mem_base;
        -:39493:    int ret_val;
        -:39494:    int code; /* UCS code point */
        -:39495:    int n_code;
        -:39496:
    #####:39497:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:39498:        mem_base = xmlMemBlocks();
    #####:39499:        code = gen_int(n_code, 0);
        -:39500:
    #####:39501:        ret_val = xmlUCSIsCherokee(code);
    #####:39502:        desret_int(ret_val);
    #####:39503:        call_tests++;
    #####:39504:        des_int(n_code, code, 0);
    #####:39505:        xmlResetLastError();
    #####:39506:        if (mem_base != xmlMemBlocks()) {
    #####:39507:            printf("Leak of %d blocks found in xmlUCSIsCherokee",
    #####:39508:	           xmlMemBlocks() - mem_base);
    #####:39509:	    test_ret++;
    #####:39510:            printf(" %d", n_code);
    #####:39511:            printf("\n");
        -:39512:        }
        -:39513:    }
    #####:39514:    function_tests++;
        -:39515:#endif
        -:39516:
    #####:39517:    return(test_ret);
        -:39518:}
        -:39519:
        -:39520:
        -:39521:static int
    #####:39522:test_xmlUCSIsCombiningDiacriticalMarks(void) {
    #####:39523:    int test_ret = 0;
        -:39524:
        -:39525:#if defined(LIBXML_UNICODE_ENABLED)
        -:39526:    int mem_base;
        -:39527:    int ret_val;
        -:39528:    int code; /* UCS code point */
        -:39529:    int n_code;
        -:39530:
    #####:39531:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:39532:        mem_base = xmlMemBlocks();
    #####:39533:        code = gen_int(n_code, 0);
        -:39534:
    #####:39535:        ret_val = xmlUCSIsCombiningDiacriticalMarks(code);
    #####:39536:        desret_int(ret_val);
    #####:39537:        call_tests++;
    #####:39538:        des_int(n_code, code, 0);
    #####:39539:        xmlResetLastError();
    #####:39540:        if (mem_base != xmlMemBlocks()) {
    #####:39541:            printf("Leak of %d blocks found in xmlUCSIsCombiningDiacriticalMarks",
    #####:39542:	           xmlMemBlocks() - mem_base);
    #####:39543:	    test_ret++;
    #####:39544:            printf(" %d", n_code);
    #####:39545:            printf("\n");
        -:39546:        }
        -:39547:    }
    #####:39548:    function_tests++;
        -:39549:#endif
        -:39550:
    #####:39551:    return(test_ret);
        -:39552:}
        -:39553:
        -:39554:
        -:39555:static int
    #####:39556:test_xmlUCSIsCombiningDiacriticalMarksforSymbols(void) {
    #####:39557:    int test_ret = 0;
        -:39558:
        -:39559:#if defined(LIBXML_UNICODE_ENABLED)
        -:39560:    int mem_base;
        -:39561:    int ret_val;
        -:39562:    int code; /* UCS code point */
        -:39563:    int n_code;
        -:39564:
    #####:39565:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:39566:        mem_base = xmlMemBlocks();
    #####:39567:        code = gen_int(n_code, 0);
        -:39568:
    #####:39569:        ret_val = xmlUCSIsCombiningDiacriticalMarksforSymbols(code);
    #####:39570:        desret_int(ret_val);
    #####:39571:        call_tests++;
    #####:39572:        des_int(n_code, code, 0);
    #####:39573:        xmlResetLastError();
    #####:39574:        if (mem_base != xmlMemBlocks()) {
    #####:39575:            printf("Leak of %d blocks found in xmlUCSIsCombiningDiacriticalMarksforSymbols",
    #####:39576:	           xmlMemBlocks() - mem_base);
    #####:39577:	    test_ret++;
    #####:39578:            printf(" %d", n_code);
    #####:39579:            printf("\n");
        -:39580:        }
        -:39581:    }
    #####:39582:    function_tests++;
        -:39583:#endif
        -:39584:
    #####:39585:    return(test_ret);
        -:39586:}
        -:39587:
        -:39588:
        -:39589:static int
    #####:39590:test_xmlUCSIsCombiningHalfMarks(void) {
    #####:39591:    int test_ret = 0;
        -:39592:
        -:39593:#if defined(LIBXML_UNICODE_ENABLED)
        -:39594:    int mem_base;
        -:39595:    int ret_val;
        -:39596:    int code; /* UCS code point */
        -:39597:    int n_code;
        -:39598:
    #####:39599:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:39600:        mem_base = xmlMemBlocks();
    #####:39601:        code = gen_int(n_code, 0);
        -:39602:
    #####:39603:        ret_val = xmlUCSIsCombiningHalfMarks(code);
    #####:39604:        desret_int(ret_val);
    #####:39605:        call_tests++;
    #####:39606:        des_int(n_code, code, 0);
    #####:39607:        xmlResetLastError();
    #####:39608:        if (mem_base != xmlMemBlocks()) {
    #####:39609:            printf("Leak of %d blocks found in xmlUCSIsCombiningHalfMarks",
    #####:39610:	           xmlMemBlocks() - mem_base);
    #####:39611:	    test_ret++;
    #####:39612:            printf(" %d", n_code);
    #####:39613:            printf("\n");
        -:39614:        }
        -:39615:    }
    #####:39616:    function_tests++;
        -:39617:#endif
        -:39618:
    #####:39619:    return(test_ret);
        -:39620:}
        -:39621:
        -:39622:
        -:39623:static int
    #####:39624:test_xmlUCSIsCombiningMarksforSymbols(void) {
    #####:39625:    int test_ret = 0;
        -:39626:
        -:39627:#if defined(LIBXML_UNICODE_ENABLED)
        -:39628:    int mem_base;
        -:39629:    int ret_val;
        -:39630:    int code; /* UCS code point */
        -:39631:    int n_code;
        -:39632:
    #####:39633:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:39634:        mem_base = xmlMemBlocks();
    #####:39635:        code = gen_int(n_code, 0);
        -:39636:
    #####:39637:        ret_val = xmlUCSIsCombiningMarksforSymbols(code);
    #####:39638:        desret_int(ret_val);
    #####:39639:        call_tests++;
    #####:39640:        des_int(n_code, code, 0);
    #####:39641:        xmlResetLastError();
    #####:39642:        if (mem_base != xmlMemBlocks()) {
    #####:39643:            printf("Leak of %d blocks found in xmlUCSIsCombiningMarksforSymbols",
    #####:39644:	           xmlMemBlocks() - mem_base);
    #####:39645:	    test_ret++;
    #####:39646:            printf(" %d", n_code);
    #####:39647:            printf("\n");
        -:39648:        }
        -:39649:    }
    #####:39650:    function_tests++;
        -:39651:#endif
        -:39652:
    #####:39653:    return(test_ret);
        -:39654:}
        -:39655:
        -:39656:
        -:39657:static int
    #####:39658:test_xmlUCSIsControlPictures(void) {
    #####:39659:    int test_ret = 0;
        -:39660:
        -:39661:#if defined(LIBXML_UNICODE_ENABLED)
        -:39662:    int mem_base;
        -:39663:    int ret_val;
        -:39664:    int code; /* UCS code point */
        -:39665:    int n_code;
        -:39666:
    #####:39667:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:39668:        mem_base = xmlMemBlocks();
    #####:39669:        code = gen_int(n_code, 0);
        -:39670:
    #####:39671:        ret_val = xmlUCSIsControlPictures(code);
    #####:39672:        desret_int(ret_val);
    #####:39673:        call_tests++;
    #####:39674:        des_int(n_code, code, 0);
    #####:39675:        xmlResetLastError();
    #####:39676:        if (mem_base != xmlMemBlocks()) {
    #####:39677:            printf("Leak of %d blocks found in xmlUCSIsControlPictures",
    #####:39678:	           xmlMemBlocks() - mem_base);
    #####:39679:	    test_ret++;
    #####:39680:            printf(" %d", n_code);
    #####:39681:            printf("\n");
        -:39682:        }
        -:39683:    }
    #####:39684:    function_tests++;
        -:39685:#endif
        -:39686:
    #####:39687:    return(test_ret);
        -:39688:}
        -:39689:
        -:39690:
        -:39691:static int
    #####:39692:test_xmlUCSIsCurrencySymbols(void) {
    #####:39693:    int test_ret = 0;
        -:39694:
        -:39695:#if defined(LIBXML_UNICODE_ENABLED)
        -:39696:    int mem_base;
        -:39697:    int ret_val;
        -:39698:    int code; /* UCS code point */
        -:39699:    int n_code;
        -:39700:
    #####:39701:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:39702:        mem_base = xmlMemBlocks();
    #####:39703:        code = gen_int(n_code, 0);
        -:39704:
    #####:39705:        ret_val = xmlUCSIsCurrencySymbols(code);
    #####:39706:        desret_int(ret_val);
    #####:39707:        call_tests++;
    #####:39708:        des_int(n_code, code, 0);
    #####:39709:        xmlResetLastError();
    #####:39710:        if (mem_base != xmlMemBlocks()) {
    #####:39711:            printf("Leak of %d blocks found in xmlUCSIsCurrencySymbols",
    #####:39712:	           xmlMemBlocks() - mem_base);
    #####:39713:	    test_ret++;
    #####:39714:            printf(" %d", n_code);
    #####:39715:            printf("\n");
        -:39716:        }
        -:39717:    }
    #####:39718:    function_tests++;
        -:39719:#endif
        -:39720:
    #####:39721:    return(test_ret);
        -:39722:}
        -:39723:
        -:39724:
        -:39725:static int
    #####:39726:test_xmlUCSIsCypriotSyllabary(void) {
    #####:39727:    int test_ret = 0;
        -:39728:
        -:39729:#if defined(LIBXML_UNICODE_ENABLED)
        -:39730:    int mem_base;
        -:39731:    int ret_val;
        -:39732:    int code; /* UCS code point */
        -:39733:    int n_code;
        -:39734:
    #####:39735:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:39736:        mem_base = xmlMemBlocks();
    #####:39737:        code = gen_int(n_code, 0);
        -:39738:
    #####:39739:        ret_val = xmlUCSIsCypriotSyllabary(code);
    #####:39740:        desret_int(ret_val);
    #####:39741:        call_tests++;
    #####:39742:        des_int(n_code, code, 0);
    #####:39743:        xmlResetLastError();
    #####:39744:        if (mem_base != xmlMemBlocks()) {
    #####:39745:            printf("Leak of %d blocks found in xmlUCSIsCypriotSyllabary",
    #####:39746:	           xmlMemBlocks() - mem_base);
    #####:39747:	    test_ret++;
    #####:39748:            printf(" %d", n_code);
    #####:39749:            printf("\n");
        -:39750:        }
        -:39751:    }
    #####:39752:    function_tests++;
        -:39753:#endif
        -:39754:
    #####:39755:    return(test_ret);
        -:39756:}
        -:39757:
        -:39758:
        -:39759:static int
    #####:39760:test_xmlUCSIsCyrillic(void) {
    #####:39761:    int test_ret = 0;
        -:39762:
        -:39763:#if defined(LIBXML_UNICODE_ENABLED)
        -:39764:    int mem_base;
        -:39765:    int ret_val;
        -:39766:    int code; /* UCS code point */
        -:39767:    int n_code;
        -:39768:
    #####:39769:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:39770:        mem_base = xmlMemBlocks();
    #####:39771:        code = gen_int(n_code, 0);
        -:39772:
    #####:39773:        ret_val = xmlUCSIsCyrillic(code);
    #####:39774:        desret_int(ret_val);
    #####:39775:        call_tests++;
    #####:39776:        des_int(n_code, code, 0);
    #####:39777:        xmlResetLastError();
    #####:39778:        if (mem_base != xmlMemBlocks()) {
    #####:39779:            printf("Leak of %d blocks found in xmlUCSIsCyrillic",
    #####:39780:	           xmlMemBlocks() - mem_base);
    #####:39781:	    test_ret++;
    #####:39782:            printf(" %d", n_code);
    #####:39783:            printf("\n");
        -:39784:        }
        -:39785:    }
    #####:39786:    function_tests++;
        -:39787:#endif
        -:39788:
    #####:39789:    return(test_ret);
        -:39790:}
        -:39791:
        -:39792:
        -:39793:static int
    #####:39794:test_xmlUCSIsCyrillicSupplement(void) {
    #####:39795:    int test_ret = 0;
        -:39796:
        -:39797:#if defined(LIBXML_UNICODE_ENABLED)
        -:39798:    int mem_base;
        -:39799:    int ret_val;
        -:39800:    int code; /* UCS code point */
        -:39801:    int n_code;
        -:39802:
    #####:39803:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:39804:        mem_base = xmlMemBlocks();
    #####:39805:        code = gen_int(n_code, 0);
        -:39806:
    #####:39807:        ret_val = xmlUCSIsCyrillicSupplement(code);
    #####:39808:        desret_int(ret_val);
    #####:39809:        call_tests++;
    #####:39810:        des_int(n_code, code, 0);
    #####:39811:        xmlResetLastError();
    #####:39812:        if (mem_base != xmlMemBlocks()) {
    #####:39813:            printf("Leak of %d blocks found in xmlUCSIsCyrillicSupplement",
    #####:39814:	           xmlMemBlocks() - mem_base);
    #####:39815:	    test_ret++;
    #####:39816:            printf(" %d", n_code);
    #####:39817:            printf("\n");
        -:39818:        }
        -:39819:    }
    #####:39820:    function_tests++;
        -:39821:#endif
        -:39822:
    #####:39823:    return(test_ret);
        -:39824:}
        -:39825:
        -:39826:
        -:39827:static int
    #####:39828:test_xmlUCSIsDeseret(void) {
    #####:39829:    int test_ret = 0;
        -:39830:
        -:39831:#if defined(LIBXML_UNICODE_ENABLED)
        -:39832:    int mem_base;
        -:39833:    int ret_val;
        -:39834:    int code; /* UCS code point */
        -:39835:    int n_code;
        -:39836:
    #####:39837:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:39838:        mem_base = xmlMemBlocks();
    #####:39839:        code = gen_int(n_code, 0);
        -:39840:
    #####:39841:        ret_val = xmlUCSIsDeseret(code);
    #####:39842:        desret_int(ret_val);
    #####:39843:        call_tests++;
    #####:39844:        des_int(n_code, code, 0);
    #####:39845:        xmlResetLastError();
    #####:39846:        if (mem_base != xmlMemBlocks()) {
    #####:39847:            printf("Leak of %d blocks found in xmlUCSIsDeseret",
    #####:39848:	           xmlMemBlocks() - mem_base);
    #####:39849:	    test_ret++;
    #####:39850:            printf(" %d", n_code);
    #####:39851:            printf("\n");
        -:39852:        }
        -:39853:    }
    #####:39854:    function_tests++;
        -:39855:#endif
        -:39856:
    #####:39857:    return(test_ret);
        -:39858:}
        -:39859:
        -:39860:
        -:39861:static int
    #####:39862:test_xmlUCSIsDevanagari(void) {
    #####:39863:    int test_ret = 0;
        -:39864:
        -:39865:#if defined(LIBXML_UNICODE_ENABLED)
        -:39866:    int mem_base;
        -:39867:    int ret_val;
        -:39868:    int code; /* UCS code point */
        -:39869:    int n_code;
        -:39870:
    #####:39871:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:39872:        mem_base = xmlMemBlocks();
    #####:39873:        code = gen_int(n_code, 0);
        -:39874:
    #####:39875:        ret_val = xmlUCSIsDevanagari(code);
    #####:39876:        desret_int(ret_val);
    #####:39877:        call_tests++;
    #####:39878:        des_int(n_code, code, 0);
    #####:39879:        xmlResetLastError();
    #####:39880:        if (mem_base != xmlMemBlocks()) {
    #####:39881:            printf("Leak of %d blocks found in xmlUCSIsDevanagari",
    #####:39882:	           xmlMemBlocks() - mem_base);
    #####:39883:	    test_ret++;
    #####:39884:            printf(" %d", n_code);
    #####:39885:            printf("\n");
        -:39886:        }
        -:39887:    }
    #####:39888:    function_tests++;
        -:39889:#endif
        -:39890:
    #####:39891:    return(test_ret);
        -:39892:}
        -:39893:
        -:39894:
        -:39895:static int
    #####:39896:test_xmlUCSIsDingbats(void) {
    #####:39897:    int test_ret = 0;
        -:39898:
        -:39899:#if defined(LIBXML_UNICODE_ENABLED)
        -:39900:    int mem_base;
        -:39901:    int ret_val;
        -:39902:    int code; /* UCS code point */
        -:39903:    int n_code;
        -:39904:
    #####:39905:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:39906:        mem_base = xmlMemBlocks();
    #####:39907:        code = gen_int(n_code, 0);
        -:39908:
    #####:39909:        ret_val = xmlUCSIsDingbats(code);
    #####:39910:        desret_int(ret_val);
    #####:39911:        call_tests++;
    #####:39912:        des_int(n_code, code, 0);
    #####:39913:        xmlResetLastError();
    #####:39914:        if (mem_base != xmlMemBlocks()) {
    #####:39915:            printf("Leak of %d blocks found in xmlUCSIsDingbats",
    #####:39916:	           xmlMemBlocks() - mem_base);
    #####:39917:	    test_ret++;
    #####:39918:            printf(" %d", n_code);
    #####:39919:            printf("\n");
        -:39920:        }
        -:39921:    }
    #####:39922:    function_tests++;
        -:39923:#endif
        -:39924:
    #####:39925:    return(test_ret);
        -:39926:}
        -:39927:
        -:39928:
        -:39929:static int
    #####:39930:test_xmlUCSIsEnclosedAlphanumerics(void) {
    #####:39931:    int test_ret = 0;
        -:39932:
        -:39933:#if defined(LIBXML_UNICODE_ENABLED)
        -:39934:    int mem_base;
        -:39935:    int ret_val;
        -:39936:    int code; /* UCS code point */
        -:39937:    int n_code;
        -:39938:
    #####:39939:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:39940:        mem_base = xmlMemBlocks();
    #####:39941:        code = gen_int(n_code, 0);
        -:39942:
    #####:39943:        ret_val = xmlUCSIsEnclosedAlphanumerics(code);
    #####:39944:        desret_int(ret_val);
    #####:39945:        call_tests++;
    #####:39946:        des_int(n_code, code, 0);
    #####:39947:        xmlResetLastError();
    #####:39948:        if (mem_base != xmlMemBlocks()) {
    #####:39949:            printf("Leak of %d blocks found in xmlUCSIsEnclosedAlphanumerics",
    #####:39950:	           xmlMemBlocks() - mem_base);
    #####:39951:	    test_ret++;
    #####:39952:            printf(" %d", n_code);
    #####:39953:            printf("\n");
        -:39954:        }
        -:39955:    }
    #####:39956:    function_tests++;
        -:39957:#endif
        -:39958:
    #####:39959:    return(test_ret);
        -:39960:}
        -:39961:
        -:39962:
        -:39963:static int
    #####:39964:test_xmlUCSIsEnclosedCJKLettersandMonths(void) {
    #####:39965:    int test_ret = 0;
        -:39966:
        -:39967:#if defined(LIBXML_UNICODE_ENABLED)
        -:39968:    int mem_base;
        -:39969:    int ret_val;
        -:39970:    int code; /* UCS code point */
        -:39971:    int n_code;
        -:39972:
    #####:39973:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:39974:        mem_base = xmlMemBlocks();
    #####:39975:        code = gen_int(n_code, 0);
        -:39976:
    #####:39977:        ret_val = xmlUCSIsEnclosedCJKLettersandMonths(code);
    #####:39978:        desret_int(ret_val);
    #####:39979:        call_tests++;
    #####:39980:        des_int(n_code, code, 0);
    #####:39981:        xmlResetLastError();
    #####:39982:        if (mem_base != xmlMemBlocks()) {
    #####:39983:            printf("Leak of %d blocks found in xmlUCSIsEnclosedCJKLettersandMonths",
    #####:39984:	           xmlMemBlocks() - mem_base);
    #####:39985:	    test_ret++;
    #####:39986:            printf(" %d", n_code);
    #####:39987:            printf("\n");
        -:39988:        }
        -:39989:    }
    #####:39990:    function_tests++;
        -:39991:#endif
        -:39992:
    #####:39993:    return(test_ret);
        -:39994:}
        -:39995:
        -:39996:
        -:39997:static int
    #####:39998:test_xmlUCSIsEthiopic(void) {
    #####:39999:    int test_ret = 0;
        -:40000:
        -:40001:#if defined(LIBXML_UNICODE_ENABLED)
        -:40002:    int mem_base;
        -:40003:    int ret_val;
        -:40004:    int code; /* UCS code point */
        -:40005:    int n_code;
        -:40006:
    #####:40007:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:40008:        mem_base = xmlMemBlocks();
    #####:40009:        code = gen_int(n_code, 0);
        -:40010:
    #####:40011:        ret_val = xmlUCSIsEthiopic(code);
    #####:40012:        desret_int(ret_val);
    #####:40013:        call_tests++;
    #####:40014:        des_int(n_code, code, 0);
    #####:40015:        xmlResetLastError();
    #####:40016:        if (mem_base != xmlMemBlocks()) {
    #####:40017:            printf("Leak of %d blocks found in xmlUCSIsEthiopic",
    #####:40018:	           xmlMemBlocks() - mem_base);
    #####:40019:	    test_ret++;
    #####:40020:            printf(" %d", n_code);
    #####:40021:            printf("\n");
        -:40022:        }
        -:40023:    }
    #####:40024:    function_tests++;
        -:40025:#endif
        -:40026:
    #####:40027:    return(test_ret);
        -:40028:}
        -:40029:
        -:40030:
        -:40031:static int
    #####:40032:test_xmlUCSIsGeneralPunctuation(void) {
    #####:40033:    int test_ret = 0;
        -:40034:
        -:40035:#if defined(LIBXML_UNICODE_ENABLED)
        -:40036:    int mem_base;
        -:40037:    int ret_val;
        -:40038:    int code; /* UCS code point */
        -:40039:    int n_code;
        -:40040:
    #####:40041:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:40042:        mem_base = xmlMemBlocks();
    #####:40043:        code = gen_int(n_code, 0);
        -:40044:
    #####:40045:        ret_val = xmlUCSIsGeneralPunctuation(code);
    #####:40046:        desret_int(ret_val);
    #####:40047:        call_tests++;
    #####:40048:        des_int(n_code, code, 0);
    #####:40049:        xmlResetLastError();
    #####:40050:        if (mem_base != xmlMemBlocks()) {
    #####:40051:            printf("Leak of %d blocks found in xmlUCSIsGeneralPunctuation",
    #####:40052:	           xmlMemBlocks() - mem_base);
    #####:40053:	    test_ret++;
    #####:40054:            printf(" %d", n_code);
    #####:40055:            printf("\n");
        -:40056:        }
        -:40057:    }
    #####:40058:    function_tests++;
        -:40059:#endif
        -:40060:
    #####:40061:    return(test_ret);
        -:40062:}
        -:40063:
        -:40064:
        -:40065:static int
    #####:40066:test_xmlUCSIsGeometricShapes(void) {
    #####:40067:    int test_ret = 0;
        -:40068:
        -:40069:#if defined(LIBXML_UNICODE_ENABLED)
        -:40070:    int mem_base;
        -:40071:    int ret_val;
        -:40072:    int code; /* UCS code point */
        -:40073:    int n_code;
        -:40074:
    #####:40075:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:40076:        mem_base = xmlMemBlocks();
    #####:40077:        code = gen_int(n_code, 0);
        -:40078:
    #####:40079:        ret_val = xmlUCSIsGeometricShapes(code);
    #####:40080:        desret_int(ret_val);
    #####:40081:        call_tests++;
    #####:40082:        des_int(n_code, code, 0);
    #####:40083:        xmlResetLastError();
    #####:40084:        if (mem_base != xmlMemBlocks()) {
    #####:40085:            printf("Leak of %d blocks found in xmlUCSIsGeometricShapes",
    #####:40086:	           xmlMemBlocks() - mem_base);
    #####:40087:	    test_ret++;
    #####:40088:            printf(" %d", n_code);
    #####:40089:            printf("\n");
        -:40090:        }
        -:40091:    }
    #####:40092:    function_tests++;
        -:40093:#endif
        -:40094:
    #####:40095:    return(test_ret);
        -:40096:}
        -:40097:
        -:40098:
        -:40099:static int
    #####:40100:test_xmlUCSIsGeorgian(void) {
    #####:40101:    int test_ret = 0;
        -:40102:
        -:40103:#if defined(LIBXML_UNICODE_ENABLED)
        -:40104:    int mem_base;
        -:40105:    int ret_val;
        -:40106:    int code; /* UCS code point */
        -:40107:    int n_code;
        -:40108:
    #####:40109:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:40110:        mem_base = xmlMemBlocks();
    #####:40111:        code = gen_int(n_code, 0);
        -:40112:
    #####:40113:        ret_val = xmlUCSIsGeorgian(code);
    #####:40114:        desret_int(ret_val);
    #####:40115:        call_tests++;
    #####:40116:        des_int(n_code, code, 0);
    #####:40117:        xmlResetLastError();
    #####:40118:        if (mem_base != xmlMemBlocks()) {
    #####:40119:            printf("Leak of %d blocks found in xmlUCSIsGeorgian",
    #####:40120:	           xmlMemBlocks() - mem_base);
    #####:40121:	    test_ret++;
    #####:40122:            printf(" %d", n_code);
    #####:40123:            printf("\n");
        -:40124:        }
        -:40125:    }
    #####:40126:    function_tests++;
        -:40127:#endif
        -:40128:
    #####:40129:    return(test_ret);
        -:40130:}
        -:40131:
        -:40132:
        -:40133:static int
    #####:40134:test_xmlUCSIsGothic(void) {
    #####:40135:    int test_ret = 0;
        -:40136:
        -:40137:#if defined(LIBXML_UNICODE_ENABLED)
        -:40138:    int mem_base;
        -:40139:    int ret_val;
        -:40140:    int code; /* UCS code point */
        -:40141:    int n_code;
        -:40142:
    #####:40143:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:40144:        mem_base = xmlMemBlocks();
    #####:40145:        code = gen_int(n_code, 0);
        -:40146:
    #####:40147:        ret_val = xmlUCSIsGothic(code);
    #####:40148:        desret_int(ret_val);
    #####:40149:        call_tests++;
    #####:40150:        des_int(n_code, code, 0);
    #####:40151:        xmlResetLastError();
    #####:40152:        if (mem_base != xmlMemBlocks()) {
    #####:40153:            printf("Leak of %d blocks found in xmlUCSIsGothic",
    #####:40154:	           xmlMemBlocks() - mem_base);
    #####:40155:	    test_ret++;
    #####:40156:            printf(" %d", n_code);
    #####:40157:            printf("\n");
        -:40158:        }
        -:40159:    }
    #####:40160:    function_tests++;
        -:40161:#endif
        -:40162:
    #####:40163:    return(test_ret);
        -:40164:}
        -:40165:
        -:40166:
        -:40167:static int
    #####:40168:test_xmlUCSIsGreek(void) {
    #####:40169:    int test_ret = 0;
        -:40170:
        -:40171:#if defined(LIBXML_UNICODE_ENABLED)
        -:40172:    int mem_base;
        -:40173:    int ret_val;
        -:40174:    int code; /* UCS code point */
        -:40175:    int n_code;
        -:40176:
    #####:40177:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:40178:        mem_base = xmlMemBlocks();
    #####:40179:        code = gen_int(n_code, 0);
        -:40180:
    #####:40181:        ret_val = xmlUCSIsGreek(code);
    #####:40182:        desret_int(ret_val);
    #####:40183:        call_tests++;
    #####:40184:        des_int(n_code, code, 0);
    #####:40185:        xmlResetLastError();
    #####:40186:        if (mem_base != xmlMemBlocks()) {
    #####:40187:            printf("Leak of %d blocks found in xmlUCSIsGreek",
    #####:40188:	           xmlMemBlocks() - mem_base);
    #####:40189:	    test_ret++;
    #####:40190:            printf(" %d", n_code);
    #####:40191:            printf("\n");
        -:40192:        }
        -:40193:    }
    #####:40194:    function_tests++;
        -:40195:#endif
        -:40196:
    #####:40197:    return(test_ret);
        -:40198:}
        -:40199:
        -:40200:
        -:40201:static int
    #####:40202:test_xmlUCSIsGreekExtended(void) {
    #####:40203:    int test_ret = 0;
        -:40204:
        -:40205:#if defined(LIBXML_UNICODE_ENABLED)
        -:40206:    int mem_base;
        -:40207:    int ret_val;
        -:40208:    int code; /* UCS code point */
        -:40209:    int n_code;
        -:40210:
    #####:40211:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:40212:        mem_base = xmlMemBlocks();
    #####:40213:        code = gen_int(n_code, 0);
        -:40214:
    #####:40215:        ret_val = xmlUCSIsGreekExtended(code);
    #####:40216:        desret_int(ret_val);
    #####:40217:        call_tests++;
    #####:40218:        des_int(n_code, code, 0);
    #####:40219:        xmlResetLastError();
    #####:40220:        if (mem_base != xmlMemBlocks()) {
    #####:40221:            printf("Leak of %d blocks found in xmlUCSIsGreekExtended",
    #####:40222:	           xmlMemBlocks() - mem_base);
    #####:40223:	    test_ret++;
    #####:40224:            printf(" %d", n_code);
    #####:40225:            printf("\n");
        -:40226:        }
        -:40227:    }
    #####:40228:    function_tests++;
        -:40229:#endif
        -:40230:
    #####:40231:    return(test_ret);
        -:40232:}
        -:40233:
        -:40234:
        -:40235:static int
    #####:40236:test_xmlUCSIsGreekandCoptic(void) {
    #####:40237:    int test_ret = 0;
        -:40238:
        -:40239:#if defined(LIBXML_UNICODE_ENABLED)
        -:40240:    int mem_base;
        -:40241:    int ret_val;
        -:40242:    int code; /* UCS code point */
        -:40243:    int n_code;
        -:40244:
    #####:40245:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:40246:        mem_base = xmlMemBlocks();
    #####:40247:        code = gen_int(n_code, 0);
        -:40248:
    #####:40249:        ret_val = xmlUCSIsGreekandCoptic(code);
    #####:40250:        desret_int(ret_val);
    #####:40251:        call_tests++;
    #####:40252:        des_int(n_code, code, 0);
    #####:40253:        xmlResetLastError();
    #####:40254:        if (mem_base != xmlMemBlocks()) {
    #####:40255:            printf("Leak of %d blocks found in xmlUCSIsGreekandCoptic",
    #####:40256:	           xmlMemBlocks() - mem_base);
    #####:40257:	    test_ret++;
    #####:40258:            printf(" %d", n_code);
    #####:40259:            printf("\n");
        -:40260:        }
        -:40261:    }
    #####:40262:    function_tests++;
        -:40263:#endif
        -:40264:
    #####:40265:    return(test_ret);
        -:40266:}
        -:40267:
        -:40268:
        -:40269:static int
    #####:40270:test_xmlUCSIsGujarati(void) {
    #####:40271:    int test_ret = 0;
        -:40272:
        -:40273:#if defined(LIBXML_UNICODE_ENABLED)
        -:40274:    int mem_base;
        -:40275:    int ret_val;
        -:40276:    int code; /* UCS code point */
        -:40277:    int n_code;
        -:40278:
    #####:40279:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:40280:        mem_base = xmlMemBlocks();
    #####:40281:        code = gen_int(n_code, 0);
        -:40282:
    #####:40283:        ret_val = xmlUCSIsGujarati(code);
    #####:40284:        desret_int(ret_val);
    #####:40285:        call_tests++;
    #####:40286:        des_int(n_code, code, 0);
    #####:40287:        xmlResetLastError();
    #####:40288:        if (mem_base != xmlMemBlocks()) {
    #####:40289:            printf("Leak of %d blocks found in xmlUCSIsGujarati",
    #####:40290:	           xmlMemBlocks() - mem_base);
    #####:40291:	    test_ret++;
    #####:40292:            printf(" %d", n_code);
    #####:40293:            printf("\n");
        -:40294:        }
        -:40295:    }
    #####:40296:    function_tests++;
        -:40297:#endif
        -:40298:
    #####:40299:    return(test_ret);
        -:40300:}
        -:40301:
        -:40302:
        -:40303:static int
    #####:40304:test_xmlUCSIsGurmukhi(void) {
    #####:40305:    int test_ret = 0;
        -:40306:
        -:40307:#if defined(LIBXML_UNICODE_ENABLED)
        -:40308:    int mem_base;
        -:40309:    int ret_val;
        -:40310:    int code; /* UCS code point */
        -:40311:    int n_code;
        -:40312:
    #####:40313:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:40314:        mem_base = xmlMemBlocks();
    #####:40315:        code = gen_int(n_code, 0);
        -:40316:
    #####:40317:        ret_val = xmlUCSIsGurmukhi(code);
    #####:40318:        desret_int(ret_val);
    #####:40319:        call_tests++;
    #####:40320:        des_int(n_code, code, 0);
    #####:40321:        xmlResetLastError();
    #####:40322:        if (mem_base != xmlMemBlocks()) {
    #####:40323:            printf("Leak of %d blocks found in xmlUCSIsGurmukhi",
    #####:40324:	           xmlMemBlocks() - mem_base);
    #####:40325:	    test_ret++;
    #####:40326:            printf(" %d", n_code);
    #####:40327:            printf("\n");
        -:40328:        }
        -:40329:    }
    #####:40330:    function_tests++;
        -:40331:#endif
        -:40332:
    #####:40333:    return(test_ret);
        -:40334:}
        -:40335:
        -:40336:
        -:40337:static int
    #####:40338:test_xmlUCSIsHalfwidthandFullwidthForms(void) {
    #####:40339:    int test_ret = 0;
        -:40340:
        -:40341:#if defined(LIBXML_UNICODE_ENABLED)
        -:40342:    int mem_base;
        -:40343:    int ret_val;
        -:40344:    int code; /* UCS code point */
        -:40345:    int n_code;
        -:40346:
    #####:40347:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:40348:        mem_base = xmlMemBlocks();
    #####:40349:        code = gen_int(n_code, 0);
        -:40350:
    #####:40351:        ret_val = xmlUCSIsHalfwidthandFullwidthForms(code);
    #####:40352:        desret_int(ret_val);
    #####:40353:        call_tests++;
    #####:40354:        des_int(n_code, code, 0);
    #####:40355:        xmlResetLastError();
    #####:40356:        if (mem_base != xmlMemBlocks()) {
    #####:40357:            printf("Leak of %d blocks found in xmlUCSIsHalfwidthandFullwidthForms",
    #####:40358:	           xmlMemBlocks() - mem_base);
    #####:40359:	    test_ret++;
    #####:40360:            printf(" %d", n_code);
    #####:40361:            printf("\n");
        -:40362:        }
        -:40363:    }
    #####:40364:    function_tests++;
        -:40365:#endif
        -:40366:
    #####:40367:    return(test_ret);
        -:40368:}
        -:40369:
        -:40370:
        -:40371:static int
    #####:40372:test_xmlUCSIsHangulCompatibilityJamo(void) {
    #####:40373:    int test_ret = 0;
        -:40374:
        -:40375:#if defined(LIBXML_UNICODE_ENABLED)
        -:40376:    int mem_base;
        -:40377:    int ret_val;
        -:40378:    int code; /* UCS code point */
        -:40379:    int n_code;
        -:40380:
    #####:40381:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:40382:        mem_base = xmlMemBlocks();
    #####:40383:        code = gen_int(n_code, 0);
        -:40384:
    #####:40385:        ret_val = xmlUCSIsHangulCompatibilityJamo(code);
    #####:40386:        desret_int(ret_val);
    #####:40387:        call_tests++;
    #####:40388:        des_int(n_code, code, 0);
    #####:40389:        xmlResetLastError();
    #####:40390:        if (mem_base != xmlMemBlocks()) {
    #####:40391:            printf("Leak of %d blocks found in xmlUCSIsHangulCompatibilityJamo",
    #####:40392:	           xmlMemBlocks() - mem_base);
    #####:40393:	    test_ret++;
    #####:40394:            printf(" %d", n_code);
    #####:40395:            printf("\n");
        -:40396:        }
        -:40397:    }
    #####:40398:    function_tests++;
        -:40399:#endif
        -:40400:
    #####:40401:    return(test_ret);
        -:40402:}
        -:40403:
        -:40404:
        -:40405:static int
    #####:40406:test_xmlUCSIsHangulJamo(void) {
    #####:40407:    int test_ret = 0;
        -:40408:
        -:40409:#if defined(LIBXML_UNICODE_ENABLED)
        -:40410:    int mem_base;
        -:40411:    int ret_val;
        -:40412:    int code; /* UCS code point */
        -:40413:    int n_code;
        -:40414:
    #####:40415:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:40416:        mem_base = xmlMemBlocks();
    #####:40417:        code = gen_int(n_code, 0);
        -:40418:
    #####:40419:        ret_val = xmlUCSIsHangulJamo(code);
    #####:40420:        desret_int(ret_val);
    #####:40421:        call_tests++;
    #####:40422:        des_int(n_code, code, 0);
    #####:40423:        xmlResetLastError();
    #####:40424:        if (mem_base != xmlMemBlocks()) {
    #####:40425:            printf("Leak of %d blocks found in xmlUCSIsHangulJamo",
    #####:40426:	           xmlMemBlocks() - mem_base);
    #####:40427:	    test_ret++;
    #####:40428:            printf(" %d", n_code);
    #####:40429:            printf("\n");
        -:40430:        }
        -:40431:    }
    #####:40432:    function_tests++;
        -:40433:#endif
        -:40434:
    #####:40435:    return(test_ret);
        -:40436:}
        -:40437:
        -:40438:
        -:40439:static int
    #####:40440:test_xmlUCSIsHangulSyllables(void) {
    #####:40441:    int test_ret = 0;
        -:40442:
        -:40443:#if defined(LIBXML_UNICODE_ENABLED)
        -:40444:    int mem_base;
        -:40445:    int ret_val;
        -:40446:    int code; /* UCS code point */
        -:40447:    int n_code;
        -:40448:
    #####:40449:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:40450:        mem_base = xmlMemBlocks();
    #####:40451:        code = gen_int(n_code, 0);
        -:40452:
    #####:40453:        ret_val = xmlUCSIsHangulSyllables(code);
    #####:40454:        desret_int(ret_val);
    #####:40455:        call_tests++;
    #####:40456:        des_int(n_code, code, 0);
    #####:40457:        xmlResetLastError();
    #####:40458:        if (mem_base != xmlMemBlocks()) {
    #####:40459:            printf("Leak of %d blocks found in xmlUCSIsHangulSyllables",
    #####:40460:	           xmlMemBlocks() - mem_base);
    #####:40461:	    test_ret++;
    #####:40462:            printf(" %d", n_code);
    #####:40463:            printf("\n");
        -:40464:        }
        -:40465:    }
    #####:40466:    function_tests++;
        -:40467:#endif
        -:40468:
    #####:40469:    return(test_ret);
        -:40470:}
        -:40471:
        -:40472:
        -:40473:static int
    #####:40474:test_xmlUCSIsHanunoo(void) {
    #####:40475:    int test_ret = 0;
        -:40476:
        -:40477:#if defined(LIBXML_UNICODE_ENABLED)
        -:40478:    int mem_base;
        -:40479:    int ret_val;
        -:40480:    int code; /* UCS code point */
        -:40481:    int n_code;
        -:40482:
    #####:40483:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:40484:        mem_base = xmlMemBlocks();
    #####:40485:        code = gen_int(n_code, 0);
        -:40486:
    #####:40487:        ret_val = xmlUCSIsHanunoo(code);
    #####:40488:        desret_int(ret_val);
    #####:40489:        call_tests++;
    #####:40490:        des_int(n_code, code, 0);
    #####:40491:        xmlResetLastError();
    #####:40492:        if (mem_base != xmlMemBlocks()) {
    #####:40493:            printf("Leak of %d blocks found in xmlUCSIsHanunoo",
    #####:40494:	           xmlMemBlocks() - mem_base);
    #####:40495:	    test_ret++;
    #####:40496:            printf(" %d", n_code);
    #####:40497:            printf("\n");
        -:40498:        }
        -:40499:    }
    #####:40500:    function_tests++;
        -:40501:#endif
        -:40502:
    #####:40503:    return(test_ret);
        -:40504:}
        -:40505:
        -:40506:
        -:40507:static int
    #####:40508:test_xmlUCSIsHebrew(void) {
    #####:40509:    int test_ret = 0;
        -:40510:
        -:40511:#if defined(LIBXML_UNICODE_ENABLED)
        -:40512:    int mem_base;
        -:40513:    int ret_val;
        -:40514:    int code; /* UCS code point */
        -:40515:    int n_code;
        -:40516:
    #####:40517:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:40518:        mem_base = xmlMemBlocks();
    #####:40519:        code = gen_int(n_code, 0);
        -:40520:
    #####:40521:        ret_val = xmlUCSIsHebrew(code);
    #####:40522:        desret_int(ret_val);
    #####:40523:        call_tests++;
    #####:40524:        des_int(n_code, code, 0);
    #####:40525:        xmlResetLastError();
    #####:40526:        if (mem_base != xmlMemBlocks()) {
    #####:40527:            printf("Leak of %d blocks found in xmlUCSIsHebrew",
    #####:40528:	           xmlMemBlocks() - mem_base);
    #####:40529:	    test_ret++;
    #####:40530:            printf(" %d", n_code);
    #####:40531:            printf("\n");
        -:40532:        }
        -:40533:    }
    #####:40534:    function_tests++;
        -:40535:#endif
        -:40536:
    #####:40537:    return(test_ret);
        -:40538:}
        -:40539:
        -:40540:
        -:40541:static int
    #####:40542:test_xmlUCSIsHighPrivateUseSurrogates(void) {
    #####:40543:    int test_ret = 0;
        -:40544:
        -:40545:#if defined(LIBXML_UNICODE_ENABLED)
        -:40546:    int mem_base;
        -:40547:    int ret_val;
        -:40548:    int code; /* UCS code point */
        -:40549:    int n_code;
        -:40550:
    #####:40551:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:40552:        mem_base = xmlMemBlocks();
    #####:40553:        code = gen_int(n_code, 0);
        -:40554:
    #####:40555:        ret_val = xmlUCSIsHighPrivateUseSurrogates(code);
    #####:40556:        desret_int(ret_val);
    #####:40557:        call_tests++;
    #####:40558:        des_int(n_code, code, 0);
    #####:40559:        xmlResetLastError();
    #####:40560:        if (mem_base != xmlMemBlocks()) {
    #####:40561:            printf("Leak of %d blocks found in xmlUCSIsHighPrivateUseSurrogates",
    #####:40562:	           xmlMemBlocks() - mem_base);
    #####:40563:	    test_ret++;
    #####:40564:            printf(" %d", n_code);
    #####:40565:            printf("\n");
        -:40566:        }
        -:40567:    }
    #####:40568:    function_tests++;
        -:40569:#endif
        -:40570:
    #####:40571:    return(test_ret);
        -:40572:}
        -:40573:
        -:40574:
        -:40575:static int
    #####:40576:test_xmlUCSIsHighSurrogates(void) {
    #####:40577:    int test_ret = 0;
        -:40578:
        -:40579:#if defined(LIBXML_UNICODE_ENABLED)
        -:40580:    int mem_base;
        -:40581:    int ret_val;
        -:40582:    int code; /* UCS code point */
        -:40583:    int n_code;
        -:40584:
    #####:40585:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:40586:        mem_base = xmlMemBlocks();
    #####:40587:        code = gen_int(n_code, 0);
        -:40588:
    #####:40589:        ret_val = xmlUCSIsHighSurrogates(code);
    #####:40590:        desret_int(ret_val);
    #####:40591:        call_tests++;
    #####:40592:        des_int(n_code, code, 0);
    #####:40593:        xmlResetLastError();
    #####:40594:        if (mem_base != xmlMemBlocks()) {
    #####:40595:            printf("Leak of %d blocks found in xmlUCSIsHighSurrogates",
    #####:40596:	           xmlMemBlocks() - mem_base);
    #####:40597:	    test_ret++;
    #####:40598:            printf(" %d", n_code);
    #####:40599:            printf("\n");
        -:40600:        }
        -:40601:    }
    #####:40602:    function_tests++;
        -:40603:#endif
        -:40604:
    #####:40605:    return(test_ret);
        -:40606:}
        -:40607:
        -:40608:
        -:40609:static int
    #####:40610:test_xmlUCSIsHiragana(void) {
    #####:40611:    int test_ret = 0;
        -:40612:
        -:40613:#if defined(LIBXML_UNICODE_ENABLED)
        -:40614:    int mem_base;
        -:40615:    int ret_val;
        -:40616:    int code; /* UCS code point */
        -:40617:    int n_code;
        -:40618:
    #####:40619:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:40620:        mem_base = xmlMemBlocks();
    #####:40621:        code = gen_int(n_code, 0);
        -:40622:
    #####:40623:        ret_val = xmlUCSIsHiragana(code);
    #####:40624:        desret_int(ret_val);
    #####:40625:        call_tests++;
    #####:40626:        des_int(n_code, code, 0);
    #####:40627:        xmlResetLastError();
    #####:40628:        if (mem_base != xmlMemBlocks()) {
    #####:40629:            printf("Leak of %d blocks found in xmlUCSIsHiragana",
    #####:40630:	           xmlMemBlocks() - mem_base);
    #####:40631:	    test_ret++;
    #####:40632:            printf(" %d", n_code);
    #####:40633:            printf("\n");
        -:40634:        }
        -:40635:    }
    #####:40636:    function_tests++;
        -:40637:#endif
        -:40638:
    #####:40639:    return(test_ret);
        -:40640:}
        -:40641:
        -:40642:
        -:40643:static int
    #####:40644:test_xmlUCSIsIPAExtensions(void) {
    #####:40645:    int test_ret = 0;
        -:40646:
        -:40647:#if defined(LIBXML_UNICODE_ENABLED)
        -:40648:    int mem_base;
        -:40649:    int ret_val;
        -:40650:    int code; /* UCS code point */
        -:40651:    int n_code;
        -:40652:
    #####:40653:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:40654:        mem_base = xmlMemBlocks();
    #####:40655:        code = gen_int(n_code, 0);
        -:40656:
    #####:40657:        ret_val = xmlUCSIsIPAExtensions(code);
    #####:40658:        desret_int(ret_val);
    #####:40659:        call_tests++;
    #####:40660:        des_int(n_code, code, 0);
    #####:40661:        xmlResetLastError();
    #####:40662:        if (mem_base != xmlMemBlocks()) {
    #####:40663:            printf("Leak of %d blocks found in xmlUCSIsIPAExtensions",
    #####:40664:	           xmlMemBlocks() - mem_base);
    #####:40665:	    test_ret++;
    #####:40666:            printf(" %d", n_code);
    #####:40667:            printf("\n");
        -:40668:        }
        -:40669:    }
    #####:40670:    function_tests++;
        -:40671:#endif
        -:40672:
    #####:40673:    return(test_ret);
        -:40674:}
        -:40675:
        -:40676:
        -:40677:static int
    #####:40678:test_xmlUCSIsIdeographicDescriptionCharacters(void) {
    #####:40679:    int test_ret = 0;
        -:40680:
        -:40681:#if defined(LIBXML_UNICODE_ENABLED)
        -:40682:    int mem_base;
        -:40683:    int ret_val;
        -:40684:    int code; /* UCS code point */
        -:40685:    int n_code;
        -:40686:
    #####:40687:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:40688:        mem_base = xmlMemBlocks();
    #####:40689:        code = gen_int(n_code, 0);
        -:40690:
    #####:40691:        ret_val = xmlUCSIsIdeographicDescriptionCharacters(code);
    #####:40692:        desret_int(ret_val);
    #####:40693:        call_tests++;
    #####:40694:        des_int(n_code, code, 0);
    #####:40695:        xmlResetLastError();
    #####:40696:        if (mem_base != xmlMemBlocks()) {
    #####:40697:            printf("Leak of %d blocks found in xmlUCSIsIdeographicDescriptionCharacters",
    #####:40698:	           xmlMemBlocks() - mem_base);
    #####:40699:	    test_ret++;
    #####:40700:            printf(" %d", n_code);
    #####:40701:            printf("\n");
        -:40702:        }
        -:40703:    }
    #####:40704:    function_tests++;
        -:40705:#endif
        -:40706:
    #####:40707:    return(test_ret);
        -:40708:}
        -:40709:
        -:40710:
        -:40711:static int
    #####:40712:test_xmlUCSIsKanbun(void) {
    #####:40713:    int test_ret = 0;
        -:40714:
        -:40715:#if defined(LIBXML_UNICODE_ENABLED)
        -:40716:    int mem_base;
        -:40717:    int ret_val;
        -:40718:    int code; /* UCS code point */
        -:40719:    int n_code;
        -:40720:
    #####:40721:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:40722:        mem_base = xmlMemBlocks();
    #####:40723:        code = gen_int(n_code, 0);
        -:40724:
    #####:40725:        ret_val = xmlUCSIsKanbun(code);
    #####:40726:        desret_int(ret_val);
    #####:40727:        call_tests++;
    #####:40728:        des_int(n_code, code, 0);
    #####:40729:        xmlResetLastError();
    #####:40730:        if (mem_base != xmlMemBlocks()) {
    #####:40731:            printf("Leak of %d blocks found in xmlUCSIsKanbun",
    #####:40732:	           xmlMemBlocks() - mem_base);
    #####:40733:	    test_ret++;
    #####:40734:            printf(" %d", n_code);
    #####:40735:            printf("\n");
        -:40736:        }
        -:40737:    }
    #####:40738:    function_tests++;
        -:40739:#endif
        -:40740:
    #####:40741:    return(test_ret);
        -:40742:}
        -:40743:
        -:40744:
        -:40745:static int
    #####:40746:test_xmlUCSIsKangxiRadicals(void) {
    #####:40747:    int test_ret = 0;
        -:40748:
        -:40749:#if defined(LIBXML_UNICODE_ENABLED)
        -:40750:    int mem_base;
        -:40751:    int ret_val;
        -:40752:    int code; /* UCS code point */
        -:40753:    int n_code;
        -:40754:
    #####:40755:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:40756:        mem_base = xmlMemBlocks();
    #####:40757:        code = gen_int(n_code, 0);
        -:40758:
    #####:40759:        ret_val = xmlUCSIsKangxiRadicals(code);
    #####:40760:        desret_int(ret_val);
    #####:40761:        call_tests++;
    #####:40762:        des_int(n_code, code, 0);
    #####:40763:        xmlResetLastError();
    #####:40764:        if (mem_base != xmlMemBlocks()) {
    #####:40765:            printf("Leak of %d blocks found in xmlUCSIsKangxiRadicals",
    #####:40766:	           xmlMemBlocks() - mem_base);
    #####:40767:	    test_ret++;
    #####:40768:            printf(" %d", n_code);
    #####:40769:            printf("\n");
        -:40770:        }
        -:40771:    }
    #####:40772:    function_tests++;
        -:40773:#endif
        -:40774:
    #####:40775:    return(test_ret);
        -:40776:}
        -:40777:
        -:40778:
        -:40779:static int
    #####:40780:test_xmlUCSIsKannada(void) {
    #####:40781:    int test_ret = 0;
        -:40782:
        -:40783:#if defined(LIBXML_UNICODE_ENABLED)
        -:40784:    int mem_base;
        -:40785:    int ret_val;
        -:40786:    int code; /* UCS code point */
        -:40787:    int n_code;
        -:40788:
    #####:40789:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:40790:        mem_base = xmlMemBlocks();
    #####:40791:        code = gen_int(n_code, 0);
        -:40792:
    #####:40793:        ret_val = xmlUCSIsKannada(code);
    #####:40794:        desret_int(ret_val);
    #####:40795:        call_tests++;
    #####:40796:        des_int(n_code, code, 0);
    #####:40797:        xmlResetLastError();
    #####:40798:        if (mem_base != xmlMemBlocks()) {
    #####:40799:            printf("Leak of %d blocks found in xmlUCSIsKannada",
    #####:40800:	           xmlMemBlocks() - mem_base);
    #####:40801:	    test_ret++;
    #####:40802:            printf(" %d", n_code);
    #####:40803:            printf("\n");
        -:40804:        }
        -:40805:    }
    #####:40806:    function_tests++;
        -:40807:#endif
        -:40808:
    #####:40809:    return(test_ret);
        -:40810:}
        -:40811:
        -:40812:
        -:40813:static int
    #####:40814:test_xmlUCSIsKatakana(void) {
    #####:40815:    int test_ret = 0;
        -:40816:
        -:40817:#if defined(LIBXML_UNICODE_ENABLED)
        -:40818:    int mem_base;
        -:40819:    int ret_val;
        -:40820:    int code; /* UCS code point */
        -:40821:    int n_code;
        -:40822:
    #####:40823:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:40824:        mem_base = xmlMemBlocks();
    #####:40825:        code = gen_int(n_code, 0);
        -:40826:
    #####:40827:        ret_val = xmlUCSIsKatakana(code);
    #####:40828:        desret_int(ret_val);
    #####:40829:        call_tests++;
    #####:40830:        des_int(n_code, code, 0);
    #####:40831:        xmlResetLastError();
    #####:40832:        if (mem_base != xmlMemBlocks()) {
    #####:40833:            printf("Leak of %d blocks found in xmlUCSIsKatakana",
    #####:40834:	           xmlMemBlocks() - mem_base);
    #####:40835:	    test_ret++;
    #####:40836:            printf(" %d", n_code);
    #####:40837:            printf("\n");
        -:40838:        }
        -:40839:    }
    #####:40840:    function_tests++;
        -:40841:#endif
        -:40842:
    #####:40843:    return(test_ret);
        -:40844:}
        -:40845:
        -:40846:
        -:40847:static int
    #####:40848:test_xmlUCSIsKatakanaPhoneticExtensions(void) {
    #####:40849:    int test_ret = 0;
        -:40850:
        -:40851:#if defined(LIBXML_UNICODE_ENABLED)
        -:40852:    int mem_base;
        -:40853:    int ret_val;
        -:40854:    int code; /* UCS code point */
        -:40855:    int n_code;
        -:40856:
    #####:40857:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:40858:        mem_base = xmlMemBlocks();
    #####:40859:        code = gen_int(n_code, 0);
        -:40860:
    #####:40861:        ret_val = xmlUCSIsKatakanaPhoneticExtensions(code);
    #####:40862:        desret_int(ret_val);
    #####:40863:        call_tests++;
    #####:40864:        des_int(n_code, code, 0);
    #####:40865:        xmlResetLastError();
    #####:40866:        if (mem_base != xmlMemBlocks()) {
    #####:40867:            printf("Leak of %d blocks found in xmlUCSIsKatakanaPhoneticExtensions",
    #####:40868:	           xmlMemBlocks() - mem_base);
    #####:40869:	    test_ret++;
    #####:40870:            printf(" %d", n_code);
    #####:40871:            printf("\n");
        -:40872:        }
        -:40873:    }
    #####:40874:    function_tests++;
        -:40875:#endif
        -:40876:
    #####:40877:    return(test_ret);
        -:40878:}
        -:40879:
        -:40880:
        -:40881:static int
    #####:40882:test_xmlUCSIsKhmer(void) {
    #####:40883:    int test_ret = 0;
        -:40884:
        -:40885:#if defined(LIBXML_UNICODE_ENABLED)
        -:40886:    int mem_base;
        -:40887:    int ret_val;
        -:40888:    int code; /* UCS code point */
        -:40889:    int n_code;
        -:40890:
    #####:40891:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:40892:        mem_base = xmlMemBlocks();
    #####:40893:        code = gen_int(n_code, 0);
        -:40894:
    #####:40895:        ret_val = xmlUCSIsKhmer(code);
    #####:40896:        desret_int(ret_val);
    #####:40897:        call_tests++;
    #####:40898:        des_int(n_code, code, 0);
    #####:40899:        xmlResetLastError();
    #####:40900:        if (mem_base != xmlMemBlocks()) {
    #####:40901:            printf("Leak of %d blocks found in xmlUCSIsKhmer",
    #####:40902:	           xmlMemBlocks() - mem_base);
    #####:40903:	    test_ret++;
    #####:40904:            printf(" %d", n_code);
    #####:40905:            printf("\n");
        -:40906:        }
        -:40907:    }
    #####:40908:    function_tests++;
        -:40909:#endif
        -:40910:
    #####:40911:    return(test_ret);
        -:40912:}
        -:40913:
        -:40914:
        -:40915:static int
    #####:40916:test_xmlUCSIsKhmerSymbols(void) {
    #####:40917:    int test_ret = 0;
        -:40918:
        -:40919:#if defined(LIBXML_UNICODE_ENABLED)
        -:40920:    int mem_base;
        -:40921:    int ret_val;
        -:40922:    int code; /* UCS code point */
        -:40923:    int n_code;
        -:40924:
    #####:40925:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:40926:        mem_base = xmlMemBlocks();
    #####:40927:        code = gen_int(n_code, 0);
        -:40928:
    #####:40929:        ret_val = xmlUCSIsKhmerSymbols(code);
    #####:40930:        desret_int(ret_val);
    #####:40931:        call_tests++;
    #####:40932:        des_int(n_code, code, 0);
    #####:40933:        xmlResetLastError();
    #####:40934:        if (mem_base != xmlMemBlocks()) {
    #####:40935:            printf("Leak of %d blocks found in xmlUCSIsKhmerSymbols",
    #####:40936:	           xmlMemBlocks() - mem_base);
    #####:40937:	    test_ret++;
    #####:40938:            printf(" %d", n_code);
    #####:40939:            printf("\n");
        -:40940:        }
        -:40941:    }
    #####:40942:    function_tests++;
        -:40943:#endif
        -:40944:
    #####:40945:    return(test_ret);
        -:40946:}
        -:40947:
        -:40948:
        -:40949:static int
    #####:40950:test_xmlUCSIsLao(void) {
    #####:40951:    int test_ret = 0;
        -:40952:
        -:40953:#if defined(LIBXML_UNICODE_ENABLED)
        -:40954:    int mem_base;
        -:40955:    int ret_val;
        -:40956:    int code; /* UCS code point */
        -:40957:    int n_code;
        -:40958:
    #####:40959:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:40960:        mem_base = xmlMemBlocks();
    #####:40961:        code = gen_int(n_code, 0);
        -:40962:
    #####:40963:        ret_val = xmlUCSIsLao(code);
    #####:40964:        desret_int(ret_val);
    #####:40965:        call_tests++;
    #####:40966:        des_int(n_code, code, 0);
    #####:40967:        xmlResetLastError();
    #####:40968:        if (mem_base != xmlMemBlocks()) {
    #####:40969:            printf("Leak of %d blocks found in xmlUCSIsLao",
    #####:40970:	           xmlMemBlocks() - mem_base);
    #####:40971:	    test_ret++;
    #####:40972:            printf(" %d", n_code);
    #####:40973:            printf("\n");
        -:40974:        }
        -:40975:    }
    #####:40976:    function_tests++;
        -:40977:#endif
        -:40978:
    #####:40979:    return(test_ret);
        -:40980:}
        -:40981:
        -:40982:
        -:40983:static int
    #####:40984:test_xmlUCSIsLatin1Supplement(void) {
    #####:40985:    int test_ret = 0;
        -:40986:
        -:40987:#if defined(LIBXML_UNICODE_ENABLED)
        -:40988:    int mem_base;
        -:40989:    int ret_val;
        -:40990:    int code; /* UCS code point */
        -:40991:    int n_code;
        -:40992:
    #####:40993:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:40994:        mem_base = xmlMemBlocks();
    #####:40995:        code = gen_int(n_code, 0);
        -:40996:
    #####:40997:        ret_val = xmlUCSIsLatin1Supplement(code);
    #####:40998:        desret_int(ret_val);
    #####:40999:        call_tests++;
    #####:41000:        des_int(n_code, code, 0);
    #####:41001:        xmlResetLastError();
    #####:41002:        if (mem_base != xmlMemBlocks()) {
    #####:41003:            printf("Leak of %d blocks found in xmlUCSIsLatin1Supplement",
    #####:41004:	           xmlMemBlocks() - mem_base);
    #####:41005:	    test_ret++;
    #####:41006:            printf(" %d", n_code);
    #####:41007:            printf("\n");
        -:41008:        }
        -:41009:    }
    #####:41010:    function_tests++;
        -:41011:#endif
        -:41012:
    #####:41013:    return(test_ret);
        -:41014:}
        -:41015:
        -:41016:
        -:41017:static int
    #####:41018:test_xmlUCSIsLatinExtendedA(void) {
    #####:41019:    int test_ret = 0;
        -:41020:
        -:41021:#if defined(LIBXML_UNICODE_ENABLED)
        -:41022:    int mem_base;
        -:41023:    int ret_val;
        -:41024:    int code; /* UCS code point */
        -:41025:    int n_code;
        -:41026:
    #####:41027:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:41028:        mem_base = xmlMemBlocks();
    #####:41029:        code = gen_int(n_code, 0);
        -:41030:
    #####:41031:        ret_val = xmlUCSIsLatinExtendedA(code);
    #####:41032:        desret_int(ret_val);
    #####:41033:        call_tests++;
    #####:41034:        des_int(n_code, code, 0);
    #####:41035:        xmlResetLastError();
    #####:41036:        if (mem_base != xmlMemBlocks()) {
    #####:41037:            printf("Leak of %d blocks found in xmlUCSIsLatinExtendedA",
    #####:41038:	           xmlMemBlocks() - mem_base);
    #####:41039:	    test_ret++;
    #####:41040:            printf(" %d", n_code);
    #####:41041:            printf("\n");
        -:41042:        }
        -:41043:    }
    #####:41044:    function_tests++;
        -:41045:#endif
        -:41046:
    #####:41047:    return(test_ret);
        -:41048:}
        -:41049:
        -:41050:
        -:41051:static int
    #####:41052:test_xmlUCSIsLatinExtendedAdditional(void) {
    #####:41053:    int test_ret = 0;
        -:41054:
        -:41055:#if defined(LIBXML_UNICODE_ENABLED)
        -:41056:    int mem_base;
        -:41057:    int ret_val;
        -:41058:    int code; /* UCS code point */
        -:41059:    int n_code;
        -:41060:
    #####:41061:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:41062:        mem_base = xmlMemBlocks();
    #####:41063:        code = gen_int(n_code, 0);
        -:41064:
    #####:41065:        ret_val = xmlUCSIsLatinExtendedAdditional(code);
    #####:41066:        desret_int(ret_val);
    #####:41067:        call_tests++;
    #####:41068:        des_int(n_code, code, 0);
    #####:41069:        xmlResetLastError();
    #####:41070:        if (mem_base != xmlMemBlocks()) {
    #####:41071:            printf("Leak of %d blocks found in xmlUCSIsLatinExtendedAdditional",
    #####:41072:	           xmlMemBlocks() - mem_base);
    #####:41073:	    test_ret++;
    #####:41074:            printf(" %d", n_code);
    #####:41075:            printf("\n");
        -:41076:        }
        -:41077:    }
    #####:41078:    function_tests++;
        -:41079:#endif
        -:41080:
    #####:41081:    return(test_ret);
        -:41082:}
        -:41083:
        -:41084:
        -:41085:static int
    #####:41086:test_xmlUCSIsLatinExtendedB(void) {
    #####:41087:    int test_ret = 0;
        -:41088:
        -:41089:#if defined(LIBXML_UNICODE_ENABLED)
        -:41090:    int mem_base;
        -:41091:    int ret_val;
        -:41092:    int code; /* UCS code point */
        -:41093:    int n_code;
        -:41094:
    #####:41095:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:41096:        mem_base = xmlMemBlocks();
    #####:41097:        code = gen_int(n_code, 0);
        -:41098:
    #####:41099:        ret_val = xmlUCSIsLatinExtendedB(code);
    #####:41100:        desret_int(ret_val);
    #####:41101:        call_tests++;
    #####:41102:        des_int(n_code, code, 0);
    #####:41103:        xmlResetLastError();
    #####:41104:        if (mem_base != xmlMemBlocks()) {
    #####:41105:            printf("Leak of %d blocks found in xmlUCSIsLatinExtendedB",
    #####:41106:	           xmlMemBlocks() - mem_base);
    #####:41107:	    test_ret++;
    #####:41108:            printf(" %d", n_code);
    #####:41109:            printf("\n");
        -:41110:        }
        -:41111:    }
    #####:41112:    function_tests++;
        -:41113:#endif
        -:41114:
    #####:41115:    return(test_ret);
        -:41116:}
        -:41117:
        -:41118:
        -:41119:static int
    #####:41120:test_xmlUCSIsLetterlikeSymbols(void) {
    #####:41121:    int test_ret = 0;
        -:41122:
        -:41123:#if defined(LIBXML_UNICODE_ENABLED)
        -:41124:    int mem_base;
        -:41125:    int ret_val;
        -:41126:    int code; /* UCS code point */
        -:41127:    int n_code;
        -:41128:
    #####:41129:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:41130:        mem_base = xmlMemBlocks();
    #####:41131:        code = gen_int(n_code, 0);
        -:41132:
    #####:41133:        ret_val = xmlUCSIsLetterlikeSymbols(code);
    #####:41134:        desret_int(ret_val);
    #####:41135:        call_tests++;
    #####:41136:        des_int(n_code, code, 0);
    #####:41137:        xmlResetLastError();
    #####:41138:        if (mem_base != xmlMemBlocks()) {
    #####:41139:            printf("Leak of %d blocks found in xmlUCSIsLetterlikeSymbols",
    #####:41140:	           xmlMemBlocks() - mem_base);
    #####:41141:	    test_ret++;
    #####:41142:            printf(" %d", n_code);
    #####:41143:            printf("\n");
        -:41144:        }
        -:41145:    }
    #####:41146:    function_tests++;
        -:41147:#endif
        -:41148:
    #####:41149:    return(test_ret);
        -:41150:}
        -:41151:
        -:41152:
        -:41153:static int
    #####:41154:test_xmlUCSIsLimbu(void) {
    #####:41155:    int test_ret = 0;
        -:41156:
        -:41157:#if defined(LIBXML_UNICODE_ENABLED)
        -:41158:    int mem_base;
        -:41159:    int ret_val;
        -:41160:    int code; /* UCS code point */
        -:41161:    int n_code;
        -:41162:
    #####:41163:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:41164:        mem_base = xmlMemBlocks();
    #####:41165:        code = gen_int(n_code, 0);
        -:41166:
    #####:41167:        ret_val = xmlUCSIsLimbu(code);
    #####:41168:        desret_int(ret_val);
    #####:41169:        call_tests++;
    #####:41170:        des_int(n_code, code, 0);
    #####:41171:        xmlResetLastError();
    #####:41172:        if (mem_base != xmlMemBlocks()) {
    #####:41173:            printf("Leak of %d blocks found in xmlUCSIsLimbu",
    #####:41174:	           xmlMemBlocks() - mem_base);
    #####:41175:	    test_ret++;
    #####:41176:            printf(" %d", n_code);
    #####:41177:            printf("\n");
        -:41178:        }
        -:41179:    }
    #####:41180:    function_tests++;
        -:41181:#endif
        -:41182:
    #####:41183:    return(test_ret);
        -:41184:}
        -:41185:
        -:41186:
        -:41187:static int
    #####:41188:test_xmlUCSIsLinearBIdeograms(void) {
    #####:41189:    int test_ret = 0;
        -:41190:
        -:41191:#if defined(LIBXML_UNICODE_ENABLED)
        -:41192:    int mem_base;
        -:41193:    int ret_val;
        -:41194:    int code; /* UCS code point */
        -:41195:    int n_code;
        -:41196:
    #####:41197:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:41198:        mem_base = xmlMemBlocks();
    #####:41199:        code = gen_int(n_code, 0);
        -:41200:
    #####:41201:        ret_val = xmlUCSIsLinearBIdeograms(code);
    #####:41202:        desret_int(ret_val);
    #####:41203:        call_tests++;
    #####:41204:        des_int(n_code, code, 0);
    #####:41205:        xmlResetLastError();
    #####:41206:        if (mem_base != xmlMemBlocks()) {
    #####:41207:            printf("Leak of %d blocks found in xmlUCSIsLinearBIdeograms",
    #####:41208:	           xmlMemBlocks() - mem_base);
    #####:41209:	    test_ret++;
    #####:41210:            printf(" %d", n_code);
    #####:41211:            printf("\n");
        -:41212:        }
        -:41213:    }
    #####:41214:    function_tests++;
        -:41215:#endif
        -:41216:
    #####:41217:    return(test_ret);
        -:41218:}
        -:41219:
        -:41220:
        -:41221:static int
    #####:41222:test_xmlUCSIsLinearBSyllabary(void) {
    #####:41223:    int test_ret = 0;
        -:41224:
        -:41225:#if defined(LIBXML_UNICODE_ENABLED)
        -:41226:    int mem_base;
        -:41227:    int ret_val;
        -:41228:    int code; /* UCS code point */
        -:41229:    int n_code;
        -:41230:
    #####:41231:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:41232:        mem_base = xmlMemBlocks();
    #####:41233:        code = gen_int(n_code, 0);
        -:41234:
    #####:41235:        ret_val = xmlUCSIsLinearBSyllabary(code);
    #####:41236:        desret_int(ret_val);
    #####:41237:        call_tests++;
    #####:41238:        des_int(n_code, code, 0);
    #####:41239:        xmlResetLastError();
    #####:41240:        if (mem_base != xmlMemBlocks()) {
    #####:41241:            printf("Leak of %d blocks found in xmlUCSIsLinearBSyllabary",
    #####:41242:	           xmlMemBlocks() - mem_base);
    #####:41243:	    test_ret++;
    #####:41244:            printf(" %d", n_code);
    #####:41245:            printf("\n");
        -:41246:        }
        -:41247:    }
    #####:41248:    function_tests++;
        -:41249:#endif
        -:41250:
    #####:41251:    return(test_ret);
        -:41252:}
        -:41253:
        -:41254:
        -:41255:static int
    #####:41256:test_xmlUCSIsLowSurrogates(void) {
    #####:41257:    int test_ret = 0;
        -:41258:
        -:41259:#if defined(LIBXML_UNICODE_ENABLED)
        -:41260:    int mem_base;
        -:41261:    int ret_val;
        -:41262:    int code; /* UCS code point */
        -:41263:    int n_code;
        -:41264:
    #####:41265:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:41266:        mem_base = xmlMemBlocks();
    #####:41267:        code = gen_int(n_code, 0);
        -:41268:
    #####:41269:        ret_val = xmlUCSIsLowSurrogates(code);
    #####:41270:        desret_int(ret_val);
    #####:41271:        call_tests++;
    #####:41272:        des_int(n_code, code, 0);
    #####:41273:        xmlResetLastError();
    #####:41274:        if (mem_base != xmlMemBlocks()) {
    #####:41275:            printf("Leak of %d blocks found in xmlUCSIsLowSurrogates",
    #####:41276:	           xmlMemBlocks() - mem_base);
    #####:41277:	    test_ret++;
    #####:41278:            printf(" %d", n_code);
    #####:41279:            printf("\n");
        -:41280:        }
        -:41281:    }
    #####:41282:    function_tests++;
        -:41283:#endif
        -:41284:
    #####:41285:    return(test_ret);
        -:41286:}
        -:41287:
        -:41288:
        -:41289:static int
    #####:41290:test_xmlUCSIsMalayalam(void) {
    #####:41291:    int test_ret = 0;
        -:41292:
        -:41293:#if defined(LIBXML_UNICODE_ENABLED)
        -:41294:    int mem_base;
        -:41295:    int ret_val;
        -:41296:    int code; /* UCS code point */
        -:41297:    int n_code;
        -:41298:
    #####:41299:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:41300:        mem_base = xmlMemBlocks();
    #####:41301:        code = gen_int(n_code, 0);
        -:41302:
    #####:41303:        ret_val = xmlUCSIsMalayalam(code);
    #####:41304:        desret_int(ret_val);
    #####:41305:        call_tests++;
    #####:41306:        des_int(n_code, code, 0);
    #####:41307:        xmlResetLastError();
    #####:41308:        if (mem_base != xmlMemBlocks()) {
    #####:41309:            printf("Leak of %d blocks found in xmlUCSIsMalayalam",
    #####:41310:	           xmlMemBlocks() - mem_base);
    #####:41311:	    test_ret++;
    #####:41312:            printf(" %d", n_code);
    #####:41313:            printf("\n");
        -:41314:        }
        -:41315:    }
    #####:41316:    function_tests++;
        -:41317:#endif
        -:41318:
    #####:41319:    return(test_ret);
        -:41320:}
        -:41321:
        -:41322:
        -:41323:static int
    #####:41324:test_xmlUCSIsMathematicalAlphanumericSymbols(void) {
    #####:41325:    int test_ret = 0;
        -:41326:
        -:41327:#if defined(LIBXML_UNICODE_ENABLED)
        -:41328:    int mem_base;
        -:41329:    int ret_val;
        -:41330:    int code; /* UCS code point */
        -:41331:    int n_code;
        -:41332:
    #####:41333:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:41334:        mem_base = xmlMemBlocks();
    #####:41335:        code = gen_int(n_code, 0);
        -:41336:
    #####:41337:        ret_val = xmlUCSIsMathematicalAlphanumericSymbols(code);
    #####:41338:        desret_int(ret_val);
    #####:41339:        call_tests++;
    #####:41340:        des_int(n_code, code, 0);
    #####:41341:        xmlResetLastError();
    #####:41342:        if (mem_base != xmlMemBlocks()) {
    #####:41343:            printf("Leak of %d blocks found in xmlUCSIsMathematicalAlphanumericSymbols",
    #####:41344:	           xmlMemBlocks() - mem_base);
    #####:41345:	    test_ret++;
    #####:41346:            printf(" %d", n_code);
    #####:41347:            printf("\n");
        -:41348:        }
        -:41349:    }
    #####:41350:    function_tests++;
        -:41351:#endif
        -:41352:
    #####:41353:    return(test_ret);
        -:41354:}
        -:41355:
        -:41356:
        -:41357:static int
    #####:41358:test_xmlUCSIsMathematicalOperators(void) {
    #####:41359:    int test_ret = 0;
        -:41360:
        -:41361:#if defined(LIBXML_UNICODE_ENABLED)
        -:41362:    int mem_base;
        -:41363:    int ret_val;
        -:41364:    int code; /* UCS code point */
        -:41365:    int n_code;
        -:41366:
    #####:41367:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:41368:        mem_base = xmlMemBlocks();
    #####:41369:        code = gen_int(n_code, 0);
        -:41370:
    #####:41371:        ret_val = xmlUCSIsMathematicalOperators(code);
    #####:41372:        desret_int(ret_val);
    #####:41373:        call_tests++;
    #####:41374:        des_int(n_code, code, 0);
    #####:41375:        xmlResetLastError();
    #####:41376:        if (mem_base != xmlMemBlocks()) {
    #####:41377:            printf("Leak of %d blocks found in xmlUCSIsMathematicalOperators",
    #####:41378:	           xmlMemBlocks() - mem_base);
    #####:41379:	    test_ret++;
    #####:41380:            printf(" %d", n_code);
    #####:41381:            printf("\n");
        -:41382:        }
        -:41383:    }
    #####:41384:    function_tests++;
        -:41385:#endif
        -:41386:
    #####:41387:    return(test_ret);
        -:41388:}
        -:41389:
        -:41390:
        -:41391:static int
    #####:41392:test_xmlUCSIsMiscellaneousMathematicalSymbolsA(void) {
    #####:41393:    int test_ret = 0;
        -:41394:
        -:41395:#if defined(LIBXML_UNICODE_ENABLED)
        -:41396:    int mem_base;
        -:41397:    int ret_val;
        -:41398:    int code; /* UCS code point */
        -:41399:    int n_code;
        -:41400:
    #####:41401:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:41402:        mem_base = xmlMemBlocks();
    #####:41403:        code = gen_int(n_code, 0);
        -:41404:
    #####:41405:        ret_val = xmlUCSIsMiscellaneousMathematicalSymbolsA(code);
    #####:41406:        desret_int(ret_val);
    #####:41407:        call_tests++;
    #####:41408:        des_int(n_code, code, 0);
    #####:41409:        xmlResetLastError();
    #####:41410:        if (mem_base != xmlMemBlocks()) {
    #####:41411:            printf("Leak of %d blocks found in xmlUCSIsMiscellaneousMathematicalSymbolsA",
    #####:41412:	           xmlMemBlocks() - mem_base);
    #####:41413:	    test_ret++;
    #####:41414:            printf(" %d", n_code);
    #####:41415:            printf("\n");
        -:41416:        }
        -:41417:    }
    #####:41418:    function_tests++;
        -:41419:#endif
        -:41420:
    #####:41421:    return(test_ret);
        -:41422:}
        -:41423:
        -:41424:
        -:41425:static int
    #####:41426:test_xmlUCSIsMiscellaneousMathematicalSymbolsB(void) {
    #####:41427:    int test_ret = 0;
        -:41428:
        -:41429:#if defined(LIBXML_UNICODE_ENABLED)
        -:41430:    int mem_base;
        -:41431:    int ret_val;
        -:41432:    int code; /* UCS code point */
        -:41433:    int n_code;
        -:41434:
    #####:41435:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:41436:        mem_base = xmlMemBlocks();
    #####:41437:        code = gen_int(n_code, 0);
        -:41438:
    #####:41439:        ret_val = xmlUCSIsMiscellaneousMathematicalSymbolsB(code);
    #####:41440:        desret_int(ret_val);
    #####:41441:        call_tests++;
    #####:41442:        des_int(n_code, code, 0);
    #####:41443:        xmlResetLastError();
    #####:41444:        if (mem_base != xmlMemBlocks()) {
    #####:41445:            printf("Leak of %d blocks found in xmlUCSIsMiscellaneousMathematicalSymbolsB",
    #####:41446:	           xmlMemBlocks() - mem_base);
    #####:41447:	    test_ret++;
    #####:41448:            printf(" %d", n_code);
    #####:41449:            printf("\n");
        -:41450:        }
        -:41451:    }
    #####:41452:    function_tests++;
        -:41453:#endif
        -:41454:
    #####:41455:    return(test_ret);
        -:41456:}
        -:41457:
        -:41458:
        -:41459:static int
    #####:41460:test_xmlUCSIsMiscellaneousSymbols(void) {
    #####:41461:    int test_ret = 0;
        -:41462:
        -:41463:#if defined(LIBXML_UNICODE_ENABLED)
        -:41464:    int mem_base;
        -:41465:    int ret_val;
        -:41466:    int code; /* UCS code point */
        -:41467:    int n_code;
        -:41468:
    #####:41469:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:41470:        mem_base = xmlMemBlocks();
    #####:41471:        code = gen_int(n_code, 0);
        -:41472:
    #####:41473:        ret_val = xmlUCSIsMiscellaneousSymbols(code);
    #####:41474:        desret_int(ret_val);
    #####:41475:        call_tests++;
    #####:41476:        des_int(n_code, code, 0);
    #####:41477:        xmlResetLastError();
    #####:41478:        if (mem_base != xmlMemBlocks()) {
    #####:41479:            printf("Leak of %d blocks found in xmlUCSIsMiscellaneousSymbols",
    #####:41480:	           xmlMemBlocks() - mem_base);
    #####:41481:	    test_ret++;
    #####:41482:            printf(" %d", n_code);
    #####:41483:            printf("\n");
        -:41484:        }
        -:41485:    }
    #####:41486:    function_tests++;
        -:41487:#endif
        -:41488:
    #####:41489:    return(test_ret);
        -:41490:}
        -:41491:
        -:41492:
        -:41493:static int
    #####:41494:test_xmlUCSIsMiscellaneousSymbolsandArrows(void) {
    #####:41495:    int test_ret = 0;
        -:41496:
        -:41497:#if defined(LIBXML_UNICODE_ENABLED)
        -:41498:    int mem_base;
        -:41499:    int ret_val;
        -:41500:    int code; /* UCS code point */
        -:41501:    int n_code;
        -:41502:
    #####:41503:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:41504:        mem_base = xmlMemBlocks();
    #####:41505:        code = gen_int(n_code, 0);
        -:41506:
    #####:41507:        ret_val = xmlUCSIsMiscellaneousSymbolsandArrows(code);
    #####:41508:        desret_int(ret_val);
    #####:41509:        call_tests++;
    #####:41510:        des_int(n_code, code, 0);
    #####:41511:        xmlResetLastError();
    #####:41512:        if (mem_base != xmlMemBlocks()) {
    #####:41513:            printf("Leak of %d blocks found in xmlUCSIsMiscellaneousSymbolsandArrows",
    #####:41514:	           xmlMemBlocks() - mem_base);
    #####:41515:	    test_ret++;
    #####:41516:            printf(" %d", n_code);
    #####:41517:            printf("\n");
        -:41518:        }
        -:41519:    }
    #####:41520:    function_tests++;
        -:41521:#endif
        -:41522:
    #####:41523:    return(test_ret);
        -:41524:}
        -:41525:
        -:41526:
        -:41527:static int
    #####:41528:test_xmlUCSIsMiscellaneousTechnical(void) {
    #####:41529:    int test_ret = 0;
        -:41530:
        -:41531:#if defined(LIBXML_UNICODE_ENABLED)
        -:41532:    int mem_base;
        -:41533:    int ret_val;
        -:41534:    int code; /* UCS code point */
        -:41535:    int n_code;
        -:41536:
    #####:41537:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:41538:        mem_base = xmlMemBlocks();
    #####:41539:        code = gen_int(n_code, 0);
        -:41540:
    #####:41541:        ret_val = xmlUCSIsMiscellaneousTechnical(code);
    #####:41542:        desret_int(ret_val);
    #####:41543:        call_tests++;
    #####:41544:        des_int(n_code, code, 0);
    #####:41545:        xmlResetLastError();
    #####:41546:        if (mem_base != xmlMemBlocks()) {
    #####:41547:            printf("Leak of %d blocks found in xmlUCSIsMiscellaneousTechnical",
    #####:41548:	           xmlMemBlocks() - mem_base);
    #####:41549:	    test_ret++;
    #####:41550:            printf(" %d", n_code);
    #####:41551:            printf("\n");
        -:41552:        }
        -:41553:    }
    #####:41554:    function_tests++;
        -:41555:#endif
        -:41556:
    #####:41557:    return(test_ret);
        -:41558:}
        -:41559:
        -:41560:
        -:41561:static int
    #####:41562:test_xmlUCSIsMongolian(void) {
    #####:41563:    int test_ret = 0;
        -:41564:
        -:41565:#if defined(LIBXML_UNICODE_ENABLED)
        -:41566:    int mem_base;
        -:41567:    int ret_val;
        -:41568:    int code; /* UCS code point */
        -:41569:    int n_code;
        -:41570:
    #####:41571:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:41572:        mem_base = xmlMemBlocks();
    #####:41573:        code = gen_int(n_code, 0);
        -:41574:
    #####:41575:        ret_val = xmlUCSIsMongolian(code);
    #####:41576:        desret_int(ret_val);
    #####:41577:        call_tests++;
    #####:41578:        des_int(n_code, code, 0);
    #####:41579:        xmlResetLastError();
    #####:41580:        if (mem_base != xmlMemBlocks()) {
    #####:41581:            printf("Leak of %d blocks found in xmlUCSIsMongolian",
    #####:41582:	           xmlMemBlocks() - mem_base);
    #####:41583:	    test_ret++;
    #####:41584:            printf(" %d", n_code);
    #####:41585:            printf("\n");
        -:41586:        }
        -:41587:    }
    #####:41588:    function_tests++;
        -:41589:#endif
        -:41590:
    #####:41591:    return(test_ret);
        -:41592:}
        -:41593:
        -:41594:
        -:41595:static int
    #####:41596:test_xmlUCSIsMusicalSymbols(void) {
    #####:41597:    int test_ret = 0;
        -:41598:
        -:41599:#if defined(LIBXML_UNICODE_ENABLED)
        -:41600:    int mem_base;
        -:41601:    int ret_val;
        -:41602:    int code; /* UCS code point */
        -:41603:    int n_code;
        -:41604:
    #####:41605:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:41606:        mem_base = xmlMemBlocks();
    #####:41607:        code = gen_int(n_code, 0);
        -:41608:
    #####:41609:        ret_val = xmlUCSIsMusicalSymbols(code);
    #####:41610:        desret_int(ret_val);
    #####:41611:        call_tests++;
    #####:41612:        des_int(n_code, code, 0);
    #####:41613:        xmlResetLastError();
    #####:41614:        if (mem_base != xmlMemBlocks()) {
    #####:41615:            printf("Leak of %d blocks found in xmlUCSIsMusicalSymbols",
    #####:41616:	           xmlMemBlocks() - mem_base);
    #####:41617:	    test_ret++;
    #####:41618:            printf(" %d", n_code);
    #####:41619:            printf("\n");
        -:41620:        }
        -:41621:    }
    #####:41622:    function_tests++;
        -:41623:#endif
        -:41624:
    #####:41625:    return(test_ret);
        -:41626:}
        -:41627:
        -:41628:
        -:41629:static int
    #####:41630:test_xmlUCSIsMyanmar(void) {
    #####:41631:    int test_ret = 0;
        -:41632:
        -:41633:#if defined(LIBXML_UNICODE_ENABLED)
        -:41634:    int mem_base;
        -:41635:    int ret_val;
        -:41636:    int code; /* UCS code point */
        -:41637:    int n_code;
        -:41638:
    #####:41639:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:41640:        mem_base = xmlMemBlocks();
    #####:41641:        code = gen_int(n_code, 0);
        -:41642:
    #####:41643:        ret_val = xmlUCSIsMyanmar(code);
    #####:41644:        desret_int(ret_val);
    #####:41645:        call_tests++;
    #####:41646:        des_int(n_code, code, 0);
    #####:41647:        xmlResetLastError();
    #####:41648:        if (mem_base != xmlMemBlocks()) {
    #####:41649:            printf("Leak of %d blocks found in xmlUCSIsMyanmar",
    #####:41650:	           xmlMemBlocks() - mem_base);
    #####:41651:	    test_ret++;
    #####:41652:            printf(" %d", n_code);
    #####:41653:            printf("\n");
        -:41654:        }
        -:41655:    }
    #####:41656:    function_tests++;
        -:41657:#endif
        -:41658:
    #####:41659:    return(test_ret);
        -:41660:}
        -:41661:
        -:41662:
        -:41663:static int
    #####:41664:test_xmlUCSIsNumberForms(void) {
    #####:41665:    int test_ret = 0;
        -:41666:
        -:41667:#if defined(LIBXML_UNICODE_ENABLED)
        -:41668:    int mem_base;
        -:41669:    int ret_val;
        -:41670:    int code; /* UCS code point */
        -:41671:    int n_code;
        -:41672:
    #####:41673:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:41674:        mem_base = xmlMemBlocks();
    #####:41675:        code = gen_int(n_code, 0);
        -:41676:
    #####:41677:        ret_val = xmlUCSIsNumberForms(code);
    #####:41678:        desret_int(ret_val);
    #####:41679:        call_tests++;
    #####:41680:        des_int(n_code, code, 0);
    #####:41681:        xmlResetLastError();
    #####:41682:        if (mem_base != xmlMemBlocks()) {
    #####:41683:            printf("Leak of %d blocks found in xmlUCSIsNumberForms",
    #####:41684:	           xmlMemBlocks() - mem_base);
    #####:41685:	    test_ret++;
    #####:41686:            printf(" %d", n_code);
    #####:41687:            printf("\n");
        -:41688:        }
        -:41689:    }
    #####:41690:    function_tests++;
        -:41691:#endif
        -:41692:
    #####:41693:    return(test_ret);
        -:41694:}
        -:41695:
        -:41696:
        -:41697:static int
    #####:41698:test_xmlUCSIsOgham(void) {
    #####:41699:    int test_ret = 0;
        -:41700:
        -:41701:#if defined(LIBXML_UNICODE_ENABLED)
        -:41702:    int mem_base;
        -:41703:    int ret_val;
        -:41704:    int code; /* UCS code point */
        -:41705:    int n_code;
        -:41706:
    #####:41707:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:41708:        mem_base = xmlMemBlocks();
    #####:41709:        code = gen_int(n_code, 0);
        -:41710:
    #####:41711:        ret_val = xmlUCSIsOgham(code);
    #####:41712:        desret_int(ret_val);
    #####:41713:        call_tests++;
    #####:41714:        des_int(n_code, code, 0);
    #####:41715:        xmlResetLastError();
    #####:41716:        if (mem_base != xmlMemBlocks()) {
    #####:41717:            printf("Leak of %d blocks found in xmlUCSIsOgham",
    #####:41718:	           xmlMemBlocks() - mem_base);
    #####:41719:	    test_ret++;
    #####:41720:            printf(" %d", n_code);
    #####:41721:            printf("\n");
        -:41722:        }
        -:41723:    }
    #####:41724:    function_tests++;
        -:41725:#endif
        -:41726:
    #####:41727:    return(test_ret);
        -:41728:}
        -:41729:
        -:41730:
        -:41731:static int
    #####:41732:test_xmlUCSIsOldItalic(void) {
    #####:41733:    int test_ret = 0;
        -:41734:
        -:41735:#if defined(LIBXML_UNICODE_ENABLED)
        -:41736:    int mem_base;
        -:41737:    int ret_val;
        -:41738:    int code; /* UCS code point */
        -:41739:    int n_code;
        -:41740:
    #####:41741:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:41742:        mem_base = xmlMemBlocks();
    #####:41743:        code = gen_int(n_code, 0);
        -:41744:
    #####:41745:        ret_val = xmlUCSIsOldItalic(code);
    #####:41746:        desret_int(ret_val);
    #####:41747:        call_tests++;
    #####:41748:        des_int(n_code, code, 0);
    #####:41749:        xmlResetLastError();
    #####:41750:        if (mem_base != xmlMemBlocks()) {
    #####:41751:            printf("Leak of %d blocks found in xmlUCSIsOldItalic",
    #####:41752:	           xmlMemBlocks() - mem_base);
    #####:41753:	    test_ret++;
    #####:41754:            printf(" %d", n_code);
    #####:41755:            printf("\n");
        -:41756:        }
        -:41757:    }
    #####:41758:    function_tests++;
        -:41759:#endif
        -:41760:
    #####:41761:    return(test_ret);
        -:41762:}
        -:41763:
        -:41764:
        -:41765:static int
    #####:41766:test_xmlUCSIsOpticalCharacterRecognition(void) {
    #####:41767:    int test_ret = 0;
        -:41768:
        -:41769:#if defined(LIBXML_UNICODE_ENABLED)
        -:41770:    int mem_base;
        -:41771:    int ret_val;
        -:41772:    int code; /* UCS code point */
        -:41773:    int n_code;
        -:41774:
    #####:41775:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:41776:        mem_base = xmlMemBlocks();
    #####:41777:        code = gen_int(n_code, 0);
        -:41778:
    #####:41779:        ret_val = xmlUCSIsOpticalCharacterRecognition(code);
    #####:41780:        desret_int(ret_val);
    #####:41781:        call_tests++;
    #####:41782:        des_int(n_code, code, 0);
    #####:41783:        xmlResetLastError();
    #####:41784:        if (mem_base != xmlMemBlocks()) {
    #####:41785:            printf("Leak of %d blocks found in xmlUCSIsOpticalCharacterRecognition",
    #####:41786:	           xmlMemBlocks() - mem_base);
    #####:41787:	    test_ret++;
    #####:41788:            printf(" %d", n_code);
    #####:41789:            printf("\n");
        -:41790:        }
        -:41791:    }
    #####:41792:    function_tests++;
        -:41793:#endif
        -:41794:
    #####:41795:    return(test_ret);
        -:41796:}
        -:41797:
        -:41798:
        -:41799:static int
    #####:41800:test_xmlUCSIsOriya(void) {
    #####:41801:    int test_ret = 0;
        -:41802:
        -:41803:#if defined(LIBXML_UNICODE_ENABLED)
        -:41804:    int mem_base;
        -:41805:    int ret_val;
        -:41806:    int code; /* UCS code point */
        -:41807:    int n_code;
        -:41808:
    #####:41809:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:41810:        mem_base = xmlMemBlocks();
    #####:41811:        code = gen_int(n_code, 0);
        -:41812:
    #####:41813:        ret_val = xmlUCSIsOriya(code);
    #####:41814:        desret_int(ret_val);
    #####:41815:        call_tests++;
    #####:41816:        des_int(n_code, code, 0);
    #####:41817:        xmlResetLastError();
    #####:41818:        if (mem_base != xmlMemBlocks()) {
    #####:41819:            printf("Leak of %d blocks found in xmlUCSIsOriya",
    #####:41820:	           xmlMemBlocks() - mem_base);
    #####:41821:	    test_ret++;
    #####:41822:            printf(" %d", n_code);
    #####:41823:            printf("\n");
        -:41824:        }
        -:41825:    }
    #####:41826:    function_tests++;
        -:41827:#endif
        -:41828:
    #####:41829:    return(test_ret);
        -:41830:}
        -:41831:
        -:41832:
        -:41833:static int
    #####:41834:test_xmlUCSIsOsmanya(void) {
    #####:41835:    int test_ret = 0;
        -:41836:
        -:41837:#if defined(LIBXML_UNICODE_ENABLED)
        -:41838:    int mem_base;
        -:41839:    int ret_val;
        -:41840:    int code; /* UCS code point */
        -:41841:    int n_code;
        -:41842:
    #####:41843:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:41844:        mem_base = xmlMemBlocks();
    #####:41845:        code = gen_int(n_code, 0);
        -:41846:
    #####:41847:        ret_val = xmlUCSIsOsmanya(code);
    #####:41848:        desret_int(ret_val);
    #####:41849:        call_tests++;
    #####:41850:        des_int(n_code, code, 0);
    #####:41851:        xmlResetLastError();
    #####:41852:        if (mem_base != xmlMemBlocks()) {
    #####:41853:            printf("Leak of %d blocks found in xmlUCSIsOsmanya",
    #####:41854:	           xmlMemBlocks() - mem_base);
    #####:41855:	    test_ret++;
    #####:41856:            printf(" %d", n_code);
    #####:41857:            printf("\n");
        -:41858:        }
        -:41859:    }
    #####:41860:    function_tests++;
        -:41861:#endif
        -:41862:
    #####:41863:    return(test_ret);
        -:41864:}
        -:41865:
        -:41866:
        -:41867:static int
    #####:41868:test_xmlUCSIsPhoneticExtensions(void) {
    #####:41869:    int test_ret = 0;
        -:41870:
        -:41871:#if defined(LIBXML_UNICODE_ENABLED)
        -:41872:    int mem_base;
        -:41873:    int ret_val;
        -:41874:    int code; /* UCS code point */
        -:41875:    int n_code;
        -:41876:
    #####:41877:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:41878:        mem_base = xmlMemBlocks();
    #####:41879:        code = gen_int(n_code, 0);
        -:41880:
    #####:41881:        ret_val = xmlUCSIsPhoneticExtensions(code);
    #####:41882:        desret_int(ret_val);
    #####:41883:        call_tests++;
    #####:41884:        des_int(n_code, code, 0);
    #####:41885:        xmlResetLastError();
    #####:41886:        if (mem_base != xmlMemBlocks()) {
    #####:41887:            printf("Leak of %d blocks found in xmlUCSIsPhoneticExtensions",
    #####:41888:	           xmlMemBlocks() - mem_base);
    #####:41889:	    test_ret++;
    #####:41890:            printf(" %d", n_code);
    #####:41891:            printf("\n");
        -:41892:        }
        -:41893:    }
    #####:41894:    function_tests++;
        -:41895:#endif
        -:41896:
    #####:41897:    return(test_ret);
        -:41898:}
        -:41899:
        -:41900:
        -:41901:static int
    #####:41902:test_xmlUCSIsPrivateUse(void) {
    #####:41903:    int test_ret = 0;
        -:41904:
        -:41905:#if defined(LIBXML_UNICODE_ENABLED)
        -:41906:    int mem_base;
        -:41907:    int ret_val;
        -:41908:    int code; /* UCS code point */
        -:41909:    int n_code;
        -:41910:
    #####:41911:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:41912:        mem_base = xmlMemBlocks();
    #####:41913:        code = gen_int(n_code, 0);
        -:41914:
    #####:41915:        ret_val = xmlUCSIsPrivateUse(code);
    #####:41916:        desret_int(ret_val);
    #####:41917:        call_tests++;
    #####:41918:        des_int(n_code, code, 0);
    #####:41919:        xmlResetLastError();
    #####:41920:        if (mem_base != xmlMemBlocks()) {
    #####:41921:            printf("Leak of %d blocks found in xmlUCSIsPrivateUse",
    #####:41922:	           xmlMemBlocks() - mem_base);
    #####:41923:	    test_ret++;
    #####:41924:            printf(" %d", n_code);
    #####:41925:            printf("\n");
        -:41926:        }
        -:41927:    }
    #####:41928:    function_tests++;
        -:41929:#endif
        -:41930:
    #####:41931:    return(test_ret);
        -:41932:}
        -:41933:
        -:41934:
        -:41935:static int
    #####:41936:test_xmlUCSIsPrivateUseArea(void) {
    #####:41937:    int test_ret = 0;
        -:41938:
        -:41939:#if defined(LIBXML_UNICODE_ENABLED)
        -:41940:    int mem_base;
        -:41941:    int ret_val;
        -:41942:    int code; /* UCS code point */
        -:41943:    int n_code;
        -:41944:
    #####:41945:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:41946:        mem_base = xmlMemBlocks();
    #####:41947:        code = gen_int(n_code, 0);
        -:41948:
    #####:41949:        ret_val = xmlUCSIsPrivateUseArea(code);
    #####:41950:        desret_int(ret_val);
    #####:41951:        call_tests++;
    #####:41952:        des_int(n_code, code, 0);
    #####:41953:        xmlResetLastError();
    #####:41954:        if (mem_base != xmlMemBlocks()) {
    #####:41955:            printf("Leak of %d blocks found in xmlUCSIsPrivateUseArea",
    #####:41956:	           xmlMemBlocks() - mem_base);
    #####:41957:	    test_ret++;
    #####:41958:            printf(" %d", n_code);
    #####:41959:            printf("\n");
        -:41960:        }
        -:41961:    }
    #####:41962:    function_tests++;
        -:41963:#endif
        -:41964:
    #####:41965:    return(test_ret);
        -:41966:}
        -:41967:
        -:41968:
        -:41969:static int
    #####:41970:test_xmlUCSIsRunic(void) {
    #####:41971:    int test_ret = 0;
        -:41972:
        -:41973:#if defined(LIBXML_UNICODE_ENABLED)
        -:41974:    int mem_base;
        -:41975:    int ret_val;
        -:41976:    int code; /* UCS code point */
        -:41977:    int n_code;
        -:41978:
    #####:41979:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:41980:        mem_base = xmlMemBlocks();
    #####:41981:        code = gen_int(n_code, 0);
        -:41982:
    #####:41983:        ret_val = xmlUCSIsRunic(code);
    #####:41984:        desret_int(ret_val);
    #####:41985:        call_tests++;
    #####:41986:        des_int(n_code, code, 0);
    #####:41987:        xmlResetLastError();
    #####:41988:        if (mem_base != xmlMemBlocks()) {
    #####:41989:            printf("Leak of %d blocks found in xmlUCSIsRunic",
    #####:41990:	           xmlMemBlocks() - mem_base);
    #####:41991:	    test_ret++;
    #####:41992:            printf(" %d", n_code);
    #####:41993:            printf("\n");
        -:41994:        }
        -:41995:    }
    #####:41996:    function_tests++;
        -:41997:#endif
        -:41998:
    #####:41999:    return(test_ret);
        -:42000:}
        -:42001:
        -:42002:
        -:42003:static int
    #####:42004:test_xmlUCSIsShavian(void) {
    #####:42005:    int test_ret = 0;
        -:42006:
        -:42007:#if defined(LIBXML_UNICODE_ENABLED)
        -:42008:    int mem_base;
        -:42009:    int ret_val;
        -:42010:    int code; /* UCS code point */
        -:42011:    int n_code;
        -:42012:
    #####:42013:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:42014:        mem_base = xmlMemBlocks();
    #####:42015:        code = gen_int(n_code, 0);
        -:42016:
    #####:42017:        ret_val = xmlUCSIsShavian(code);
    #####:42018:        desret_int(ret_val);
    #####:42019:        call_tests++;
    #####:42020:        des_int(n_code, code, 0);
    #####:42021:        xmlResetLastError();
    #####:42022:        if (mem_base != xmlMemBlocks()) {
    #####:42023:            printf("Leak of %d blocks found in xmlUCSIsShavian",
    #####:42024:	           xmlMemBlocks() - mem_base);
    #####:42025:	    test_ret++;
    #####:42026:            printf(" %d", n_code);
    #####:42027:            printf("\n");
        -:42028:        }
        -:42029:    }
    #####:42030:    function_tests++;
        -:42031:#endif
        -:42032:
    #####:42033:    return(test_ret);
        -:42034:}
        -:42035:
        -:42036:
        -:42037:static int
    #####:42038:test_xmlUCSIsSinhala(void) {
    #####:42039:    int test_ret = 0;
        -:42040:
        -:42041:#if defined(LIBXML_UNICODE_ENABLED)
        -:42042:    int mem_base;
        -:42043:    int ret_val;
        -:42044:    int code; /* UCS code point */
        -:42045:    int n_code;
        -:42046:
    #####:42047:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:42048:        mem_base = xmlMemBlocks();
    #####:42049:        code = gen_int(n_code, 0);
        -:42050:
    #####:42051:        ret_val = xmlUCSIsSinhala(code);
    #####:42052:        desret_int(ret_val);
    #####:42053:        call_tests++;
    #####:42054:        des_int(n_code, code, 0);
    #####:42055:        xmlResetLastError();
    #####:42056:        if (mem_base != xmlMemBlocks()) {
    #####:42057:            printf("Leak of %d blocks found in xmlUCSIsSinhala",
    #####:42058:	           xmlMemBlocks() - mem_base);
    #####:42059:	    test_ret++;
    #####:42060:            printf(" %d", n_code);
    #####:42061:            printf("\n");
        -:42062:        }
        -:42063:    }
    #####:42064:    function_tests++;
        -:42065:#endif
        -:42066:
    #####:42067:    return(test_ret);
        -:42068:}
        -:42069:
        -:42070:
        -:42071:static int
    #####:42072:test_xmlUCSIsSmallFormVariants(void) {
    #####:42073:    int test_ret = 0;
        -:42074:
        -:42075:#if defined(LIBXML_UNICODE_ENABLED)
        -:42076:    int mem_base;
        -:42077:    int ret_val;
        -:42078:    int code; /* UCS code point */
        -:42079:    int n_code;
        -:42080:
    #####:42081:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:42082:        mem_base = xmlMemBlocks();
    #####:42083:        code = gen_int(n_code, 0);
        -:42084:
    #####:42085:        ret_val = xmlUCSIsSmallFormVariants(code);
    #####:42086:        desret_int(ret_val);
    #####:42087:        call_tests++;
    #####:42088:        des_int(n_code, code, 0);
    #####:42089:        xmlResetLastError();
    #####:42090:        if (mem_base != xmlMemBlocks()) {
    #####:42091:            printf("Leak of %d blocks found in xmlUCSIsSmallFormVariants",
    #####:42092:	           xmlMemBlocks() - mem_base);
    #####:42093:	    test_ret++;
    #####:42094:            printf(" %d", n_code);
    #####:42095:            printf("\n");
        -:42096:        }
        -:42097:    }
    #####:42098:    function_tests++;
        -:42099:#endif
        -:42100:
    #####:42101:    return(test_ret);
        -:42102:}
        -:42103:
        -:42104:
        -:42105:static int
    #####:42106:test_xmlUCSIsSpacingModifierLetters(void) {
    #####:42107:    int test_ret = 0;
        -:42108:
        -:42109:#if defined(LIBXML_UNICODE_ENABLED)
        -:42110:    int mem_base;
        -:42111:    int ret_val;
        -:42112:    int code; /* UCS code point */
        -:42113:    int n_code;
        -:42114:
    #####:42115:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:42116:        mem_base = xmlMemBlocks();
    #####:42117:        code = gen_int(n_code, 0);
        -:42118:
    #####:42119:        ret_val = xmlUCSIsSpacingModifierLetters(code);
    #####:42120:        desret_int(ret_val);
    #####:42121:        call_tests++;
    #####:42122:        des_int(n_code, code, 0);
    #####:42123:        xmlResetLastError();
    #####:42124:        if (mem_base != xmlMemBlocks()) {
    #####:42125:            printf("Leak of %d blocks found in xmlUCSIsSpacingModifierLetters",
    #####:42126:	           xmlMemBlocks() - mem_base);
    #####:42127:	    test_ret++;
    #####:42128:            printf(" %d", n_code);
    #####:42129:            printf("\n");
        -:42130:        }
        -:42131:    }
    #####:42132:    function_tests++;
        -:42133:#endif
        -:42134:
    #####:42135:    return(test_ret);
        -:42136:}
        -:42137:
        -:42138:
        -:42139:static int
    #####:42140:test_xmlUCSIsSpecials(void) {
    #####:42141:    int test_ret = 0;
        -:42142:
        -:42143:#if defined(LIBXML_UNICODE_ENABLED)
        -:42144:    int mem_base;
        -:42145:    int ret_val;
        -:42146:    int code; /* UCS code point */
        -:42147:    int n_code;
        -:42148:
    #####:42149:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:42150:        mem_base = xmlMemBlocks();
    #####:42151:        code = gen_int(n_code, 0);
        -:42152:
    #####:42153:        ret_val = xmlUCSIsSpecials(code);
    #####:42154:        desret_int(ret_val);
    #####:42155:        call_tests++;
    #####:42156:        des_int(n_code, code, 0);
    #####:42157:        xmlResetLastError();
    #####:42158:        if (mem_base != xmlMemBlocks()) {
    #####:42159:            printf("Leak of %d blocks found in xmlUCSIsSpecials",
    #####:42160:	           xmlMemBlocks() - mem_base);
    #####:42161:	    test_ret++;
    #####:42162:            printf(" %d", n_code);
    #####:42163:            printf("\n");
        -:42164:        }
        -:42165:    }
    #####:42166:    function_tests++;
        -:42167:#endif
        -:42168:
    #####:42169:    return(test_ret);
        -:42170:}
        -:42171:
        -:42172:
        -:42173:static int
    #####:42174:test_xmlUCSIsSuperscriptsandSubscripts(void) {
    #####:42175:    int test_ret = 0;
        -:42176:
        -:42177:#if defined(LIBXML_UNICODE_ENABLED)
        -:42178:    int mem_base;
        -:42179:    int ret_val;
        -:42180:    int code; /* UCS code point */
        -:42181:    int n_code;
        -:42182:
    #####:42183:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:42184:        mem_base = xmlMemBlocks();
    #####:42185:        code = gen_int(n_code, 0);
        -:42186:
    #####:42187:        ret_val = xmlUCSIsSuperscriptsandSubscripts(code);
    #####:42188:        desret_int(ret_val);
    #####:42189:        call_tests++;
    #####:42190:        des_int(n_code, code, 0);
    #####:42191:        xmlResetLastError();
    #####:42192:        if (mem_base != xmlMemBlocks()) {
    #####:42193:            printf("Leak of %d blocks found in xmlUCSIsSuperscriptsandSubscripts",
    #####:42194:	           xmlMemBlocks() - mem_base);
    #####:42195:	    test_ret++;
    #####:42196:            printf(" %d", n_code);
    #####:42197:            printf("\n");
        -:42198:        }
        -:42199:    }
    #####:42200:    function_tests++;
        -:42201:#endif
        -:42202:
    #####:42203:    return(test_ret);
        -:42204:}
        -:42205:
        -:42206:
        -:42207:static int
    #####:42208:test_xmlUCSIsSupplementalArrowsA(void) {
    #####:42209:    int test_ret = 0;
        -:42210:
        -:42211:#if defined(LIBXML_UNICODE_ENABLED)
        -:42212:    int mem_base;
        -:42213:    int ret_val;
        -:42214:    int code; /* UCS code point */
        -:42215:    int n_code;
        -:42216:
    #####:42217:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:42218:        mem_base = xmlMemBlocks();
    #####:42219:        code = gen_int(n_code, 0);
        -:42220:
    #####:42221:        ret_val = xmlUCSIsSupplementalArrowsA(code);
    #####:42222:        desret_int(ret_val);
    #####:42223:        call_tests++;
    #####:42224:        des_int(n_code, code, 0);
    #####:42225:        xmlResetLastError();
    #####:42226:        if (mem_base != xmlMemBlocks()) {
    #####:42227:            printf("Leak of %d blocks found in xmlUCSIsSupplementalArrowsA",
    #####:42228:	           xmlMemBlocks() - mem_base);
    #####:42229:	    test_ret++;
    #####:42230:            printf(" %d", n_code);
    #####:42231:            printf("\n");
        -:42232:        }
        -:42233:    }
    #####:42234:    function_tests++;
        -:42235:#endif
        -:42236:
    #####:42237:    return(test_ret);
        -:42238:}
        -:42239:
        -:42240:
        -:42241:static int
    #####:42242:test_xmlUCSIsSupplementalArrowsB(void) {
    #####:42243:    int test_ret = 0;
        -:42244:
        -:42245:#if defined(LIBXML_UNICODE_ENABLED)
        -:42246:    int mem_base;
        -:42247:    int ret_val;
        -:42248:    int code; /* UCS code point */
        -:42249:    int n_code;
        -:42250:
    #####:42251:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:42252:        mem_base = xmlMemBlocks();
    #####:42253:        code = gen_int(n_code, 0);
        -:42254:
    #####:42255:        ret_val = xmlUCSIsSupplementalArrowsB(code);
    #####:42256:        desret_int(ret_val);
    #####:42257:        call_tests++;
    #####:42258:        des_int(n_code, code, 0);
    #####:42259:        xmlResetLastError();
    #####:42260:        if (mem_base != xmlMemBlocks()) {
    #####:42261:            printf("Leak of %d blocks found in xmlUCSIsSupplementalArrowsB",
    #####:42262:	           xmlMemBlocks() - mem_base);
    #####:42263:	    test_ret++;
    #####:42264:            printf(" %d", n_code);
    #####:42265:            printf("\n");
        -:42266:        }
        -:42267:    }
    #####:42268:    function_tests++;
        -:42269:#endif
        -:42270:
    #####:42271:    return(test_ret);
        -:42272:}
        -:42273:
        -:42274:
        -:42275:static int
    #####:42276:test_xmlUCSIsSupplementalMathematicalOperators(void) {
    #####:42277:    int test_ret = 0;
        -:42278:
        -:42279:#if defined(LIBXML_UNICODE_ENABLED)
        -:42280:    int mem_base;
        -:42281:    int ret_val;
        -:42282:    int code; /* UCS code point */
        -:42283:    int n_code;
        -:42284:
    #####:42285:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:42286:        mem_base = xmlMemBlocks();
    #####:42287:        code = gen_int(n_code, 0);
        -:42288:
    #####:42289:        ret_val = xmlUCSIsSupplementalMathematicalOperators(code);
    #####:42290:        desret_int(ret_val);
    #####:42291:        call_tests++;
    #####:42292:        des_int(n_code, code, 0);
    #####:42293:        xmlResetLastError();
    #####:42294:        if (mem_base != xmlMemBlocks()) {
    #####:42295:            printf("Leak of %d blocks found in xmlUCSIsSupplementalMathematicalOperators",
    #####:42296:	           xmlMemBlocks() - mem_base);
    #####:42297:	    test_ret++;
    #####:42298:            printf(" %d", n_code);
    #####:42299:            printf("\n");
        -:42300:        }
        -:42301:    }
    #####:42302:    function_tests++;
        -:42303:#endif
        -:42304:
    #####:42305:    return(test_ret);
        -:42306:}
        -:42307:
        -:42308:
        -:42309:static int
    #####:42310:test_xmlUCSIsSupplementaryPrivateUseAreaA(void) {
    #####:42311:    int test_ret = 0;
        -:42312:
        -:42313:#if defined(LIBXML_UNICODE_ENABLED)
        -:42314:    int mem_base;
        -:42315:    int ret_val;
        -:42316:    int code; /* UCS code point */
        -:42317:    int n_code;
        -:42318:
    #####:42319:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:42320:        mem_base = xmlMemBlocks();
    #####:42321:        code = gen_int(n_code, 0);
        -:42322:
    #####:42323:        ret_val = xmlUCSIsSupplementaryPrivateUseAreaA(code);
    #####:42324:        desret_int(ret_val);
    #####:42325:        call_tests++;
    #####:42326:        des_int(n_code, code, 0);
    #####:42327:        xmlResetLastError();
    #####:42328:        if (mem_base != xmlMemBlocks()) {
    #####:42329:            printf("Leak of %d blocks found in xmlUCSIsSupplementaryPrivateUseAreaA",
    #####:42330:	           xmlMemBlocks() - mem_base);
    #####:42331:	    test_ret++;
    #####:42332:            printf(" %d", n_code);
    #####:42333:            printf("\n");
        -:42334:        }
        -:42335:    }
    #####:42336:    function_tests++;
        -:42337:#endif
        -:42338:
    #####:42339:    return(test_ret);
        -:42340:}
        -:42341:
        -:42342:
        -:42343:static int
    #####:42344:test_xmlUCSIsSupplementaryPrivateUseAreaB(void) {
    #####:42345:    int test_ret = 0;
        -:42346:
        -:42347:#if defined(LIBXML_UNICODE_ENABLED)
        -:42348:    int mem_base;
        -:42349:    int ret_val;
        -:42350:    int code; /* UCS code point */
        -:42351:    int n_code;
        -:42352:
    #####:42353:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:42354:        mem_base = xmlMemBlocks();
    #####:42355:        code = gen_int(n_code, 0);
        -:42356:
    #####:42357:        ret_val = xmlUCSIsSupplementaryPrivateUseAreaB(code);
    #####:42358:        desret_int(ret_val);
    #####:42359:        call_tests++;
    #####:42360:        des_int(n_code, code, 0);
    #####:42361:        xmlResetLastError();
    #####:42362:        if (mem_base != xmlMemBlocks()) {
    #####:42363:            printf("Leak of %d blocks found in xmlUCSIsSupplementaryPrivateUseAreaB",
    #####:42364:	           xmlMemBlocks() - mem_base);
    #####:42365:	    test_ret++;
    #####:42366:            printf(" %d", n_code);
    #####:42367:            printf("\n");
        -:42368:        }
        -:42369:    }
    #####:42370:    function_tests++;
        -:42371:#endif
        -:42372:
    #####:42373:    return(test_ret);
        -:42374:}
        -:42375:
        -:42376:
        -:42377:static int
    #####:42378:test_xmlUCSIsSyriac(void) {
    #####:42379:    int test_ret = 0;
        -:42380:
        -:42381:#if defined(LIBXML_UNICODE_ENABLED)
        -:42382:    int mem_base;
        -:42383:    int ret_val;
        -:42384:    int code; /* UCS code point */
        -:42385:    int n_code;
        -:42386:
    #####:42387:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:42388:        mem_base = xmlMemBlocks();
    #####:42389:        code = gen_int(n_code, 0);
        -:42390:
    #####:42391:        ret_val = xmlUCSIsSyriac(code);
    #####:42392:        desret_int(ret_val);
    #####:42393:        call_tests++;
    #####:42394:        des_int(n_code, code, 0);
    #####:42395:        xmlResetLastError();
    #####:42396:        if (mem_base != xmlMemBlocks()) {
    #####:42397:            printf("Leak of %d blocks found in xmlUCSIsSyriac",
    #####:42398:	           xmlMemBlocks() - mem_base);
    #####:42399:	    test_ret++;
    #####:42400:            printf(" %d", n_code);
    #####:42401:            printf("\n");
        -:42402:        }
        -:42403:    }
    #####:42404:    function_tests++;
        -:42405:#endif
        -:42406:
    #####:42407:    return(test_ret);
        -:42408:}
        -:42409:
        -:42410:
        -:42411:static int
    #####:42412:test_xmlUCSIsTagalog(void) {
    #####:42413:    int test_ret = 0;
        -:42414:
        -:42415:#if defined(LIBXML_UNICODE_ENABLED)
        -:42416:    int mem_base;
        -:42417:    int ret_val;
        -:42418:    int code; /* UCS code point */
        -:42419:    int n_code;
        -:42420:
    #####:42421:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:42422:        mem_base = xmlMemBlocks();
    #####:42423:        code = gen_int(n_code, 0);
        -:42424:
    #####:42425:        ret_val = xmlUCSIsTagalog(code);
    #####:42426:        desret_int(ret_val);
    #####:42427:        call_tests++;
    #####:42428:        des_int(n_code, code, 0);
    #####:42429:        xmlResetLastError();
    #####:42430:        if (mem_base != xmlMemBlocks()) {
    #####:42431:            printf("Leak of %d blocks found in xmlUCSIsTagalog",
    #####:42432:	           xmlMemBlocks() - mem_base);
    #####:42433:	    test_ret++;
    #####:42434:            printf(" %d", n_code);
    #####:42435:            printf("\n");
        -:42436:        }
        -:42437:    }
    #####:42438:    function_tests++;
        -:42439:#endif
        -:42440:
    #####:42441:    return(test_ret);
        -:42442:}
        -:42443:
        -:42444:
        -:42445:static int
    #####:42446:test_xmlUCSIsTagbanwa(void) {
    #####:42447:    int test_ret = 0;
        -:42448:
        -:42449:#if defined(LIBXML_UNICODE_ENABLED)
        -:42450:    int mem_base;
        -:42451:    int ret_val;
        -:42452:    int code; /* UCS code point */
        -:42453:    int n_code;
        -:42454:
    #####:42455:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:42456:        mem_base = xmlMemBlocks();
    #####:42457:        code = gen_int(n_code, 0);
        -:42458:
    #####:42459:        ret_val = xmlUCSIsTagbanwa(code);
    #####:42460:        desret_int(ret_val);
    #####:42461:        call_tests++;
    #####:42462:        des_int(n_code, code, 0);
    #####:42463:        xmlResetLastError();
    #####:42464:        if (mem_base != xmlMemBlocks()) {
    #####:42465:            printf("Leak of %d blocks found in xmlUCSIsTagbanwa",
    #####:42466:	           xmlMemBlocks() - mem_base);
    #####:42467:	    test_ret++;
    #####:42468:            printf(" %d", n_code);
    #####:42469:            printf("\n");
        -:42470:        }
        -:42471:    }
    #####:42472:    function_tests++;
        -:42473:#endif
        -:42474:
    #####:42475:    return(test_ret);
        -:42476:}
        -:42477:
        -:42478:
        -:42479:static int
    #####:42480:test_xmlUCSIsTags(void) {
    #####:42481:    int test_ret = 0;
        -:42482:
        -:42483:#if defined(LIBXML_UNICODE_ENABLED)
        -:42484:    int mem_base;
        -:42485:    int ret_val;
        -:42486:    int code; /* UCS code point */
        -:42487:    int n_code;
        -:42488:
    #####:42489:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:42490:        mem_base = xmlMemBlocks();
    #####:42491:        code = gen_int(n_code, 0);
        -:42492:
    #####:42493:        ret_val = xmlUCSIsTags(code);
    #####:42494:        desret_int(ret_val);
    #####:42495:        call_tests++;
    #####:42496:        des_int(n_code, code, 0);
    #####:42497:        xmlResetLastError();
    #####:42498:        if (mem_base != xmlMemBlocks()) {
    #####:42499:            printf("Leak of %d blocks found in xmlUCSIsTags",
    #####:42500:	           xmlMemBlocks() - mem_base);
    #####:42501:	    test_ret++;
    #####:42502:            printf(" %d", n_code);
    #####:42503:            printf("\n");
        -:42504:        }
        -:42505:    }
    #####:42506:    function_tests++;
        -:42507:#endif
        -:42508:
    #####:42509:    return(test_ret);
        -:42510:}
        -:42511:
        -:42512:
        -:42513:static int
    #####:42514:test_xmlUCSIsTaiLe(void) {
    #####:42515:    int test_ret = 0;
        -:42516:
        -:42517:#if defined(LIBXML_UNICODE_ENABLED)
        -:42518:    int mem_base;
        -:42519:    int ret_val;
        -:42520:    int code; /* UCS code point */
        -:42521:    int n_code;
        -:42522:
    #####:42523:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:42524:        mem_base = xmlMemBlocks();
    #####:42525:        code = gen_int(n_code, 0);
        -:42526:
    #####:42527:        ret_val = xmlUCSIsTaiLe(code);
    #####:42528:        desret_int(ret_val);
    #####:42529:        call_tests++;
    #####:42530:        des_int(n_code, code, 0);
    #####:42531:        xmlResetLastError();
    #####:42532:        if (mem_base != xmlMemBlocks()) {
    #####:42533:            printf("Leak of %d blocks found in xmlUCSIsTaiLe",
    #####:42534:	           xmlMemBlocks() - mem_base);
    #####:42535:	    test_ret++;
    #####:42536:            printf(" %d", n_code);
    #####:42537:            printf("\n");
        -:42538:        }
        -:42539:    }
    #####:42540:    function_tests++;
        -:42541:#endif
        -:42542:
    #####:42543:    return(test_ret);
        -:42544:}
        -:42545:
        -:42546:
        -:42547:static int
    #####:42548:test_xmlUCSIsTaiXuanJingSymbols(void) {
    #####:42549:    int test_ret = 0;
        -:42550:
        -:42551:#if defined(LIBXML_UNICODE_ENABLED)
        -:42552:    int mem_base;
        -:42553:    int ret_val;
        -:42554:    int code; /* UCS code point */
        -:42555:    int n_code;
        -:42556:
    #####:42557:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:42558:        mem_base = xmlMemBlocks();
    #####:42559:        code = gen_int(n_code, 0);
        -:42560:
    #####:42561:        ret_val = xmlUCSIsTaiXuanJingSymbols(code);
    #####:42562:        desret_int(ret_val);
    #####:42563:        call_tests++;
    #####:42564:        des_int(n_code, code, 0);
    #####:42565:        xmlResetLastError();
    #####:42566:        if (mem_base != xmlMemBlocks()) {
    #####:42567:            printf("Leak of %d blocks found in xmlUCSIsTaiXuanJingSymbols",
    #####:42568:	           xmlMemBlocks() - mem_base);
    #####:42569:	    test_ret++;
    #####:42570:            printf(" %d", n_code);
    #####:42571:            printf("\n");
        -:42572:        }
        -:42573:    }
    #####:42574:    function_tests++;
        -:42575:#endif
        -:42576:
    #####:42577:    return(test_ret);
        -:42578:}
        -:42579:
        -:42580:
        -:42581:static int
    #####:42582:test_xmlUCSIsTamil(void) {
    #####:42583:    int test_ret = 0;
        -:42584:
        -:42585:#if defined(LIBXML_UNICODE_ENABLED)
        -:42586:    int mem_base;
        -:42587:    int ret_val;
        -:42588:    int code; /* UCS code point */
        -:42589:    int n_code;
        -:42590:
    #####:42591:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:42592:        mem_base = xmlMemBlocks();
    #####:42593:        code = gen_int(n_code, 0);
        -:42594:
    #####:42595:        ret_val = xmlUCSIsTamil(code);
    #####:42596:        desret_int(ret_val);
    #####:42597:        call_tests++;
    #####:42598:        des_int(n_code, code, 0);
    #####:42599:        xmlResetLastError();
    #####:42600:        if (mem_base != xmlMemBlocks()) {
    #####:42601:            printf("Leak of %d blocks found in xmlUCSIsTamil",
    #####:42602:	           xmlMemBlocks() - mem_base);
    #####:42603:	    test_ret++;
    #####:42604:            printf(" %d", n_code);
    #####:42605:            printf("\n");
        -:42606:        }
        -:42607:    }
    #####:42608:    function_tests++;
        -:42609:#endif
        -:42610:
    #####:42611:    return(test_ret);
        -:42612:}
        -:42613:
        -:42614:
        -:42615:static int
    #####:42616:test_xmlUCSIsTelugu(void) {
    #####:42617:    int test_ret = 0;
        -:42618:
        -:42619:#if defined(LIBXML_UNICODE_ENABLED)
        -:42620:    int mem_base;
        -:42621:    int ret_val;
        -:42622:    int code; /* UCS code point */
        -:42623:    int n_code;
        -:42624:
    #####:42625:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:42626:        mem_base = xmlMemBlocks();
    #####:42627:        code = gen_int(n_code, 0);
        -:42628:
    #####:42629:        ret_val = xmlUCSIsTelugu(code);
    #####:42630:        desret_int(ret_val);
    #####:42631:        call_tests++;
    #####:42632:        des_int(n_code, code, 0);
    #####:42633:        xmlResetLastError();
    #####:42634:        if (mem_base != xmlMemBlocks()) {
    #####:42635:            printf("Leak of %d blocks found in xmlUCSIsTelugu",
    #####:42636:	           xmlMemBlocks() - mem_base);
    #####:42637:	    test_ret++;
    #####:42638:            printf(" %d", n_code);
    #####:42639:            printf("\n");
        -:42640:        }
        -:42641:    }
    #####:42642:    function_tests++;
        -:42643:#endif
        -:42644:
    #####:42645:    return(test_ret);
        -:42646:}
        -:42647:
        -:42648:
        -:42649:static int
    #####:42650:test_xmlUCSIsThaana(void) {
    #####:42651:    int test_ret = 0;
        -:42652:
        -:42653:#if defined(LIBXML_UNICODE_ENABLED)
        -:42654:    int mem_base;
        -:42655:    int ret_val;
        -:42656:    int code; /* UCS code point */
        -:42657:    int n_code;
        -:42658:
    #####:42659:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:42660:        mem_base = xmlMemBlocks();
    #####:42661:        code = gen_int(n_code, 0);
        -:42662:
    #####:42663:        ret_val = xmlUCSIsThaana(code);
    #####:42664:        desret_int(ret_val);
    #####:42665:        call_tests++;
    #####:42666:        des_int(n_code, code, 0);
    #####:42667:        xmlResetLastError();
    #####:42668:        if (mem_base != xmlMemBlocks()) {
    #####:42669:            printf("Leak of %d blocks found in xmlUCSIsThaana",
    #####:42670:	           xmlMemBlocks() - mem_base);
    #####:42671:	    test_ret++;
    #####:42672:            printf(" %d", n_code);
    #####:42673:            printf("\n");
        -:42674:        }
        -:42675:    }
    #####:42676:    function_tests++;
        -:42677:#endif
        -:42678:
    #####:42679:    return(test_ret);
        -:42680:}
        -:42681:
        -:42682:
        -:42683:static int
    #####:42684:test_xmlUCSIsThai(void) {
    #####:42685:    int test_ret = 0;
        -:42686:
        -:42687:#if defined(LIBXML_UNICODE_ENABLED)
        -:42688:    int mem_base;
        -:42689:    int ret_val;
        -:42690:    int code; /* UCS code point */
        -:42691:    int n_code;
        -:42692:
    #####:42693:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:42694:        mem_base = xmlMemBlocks();
    #####:42695:        code = gen_int(n_code, 0);
        -:42696:
    #####:42697:        ret_val = xmlUCSIsThai(code);
    #####:42698:        desret_int(ret_val);
    #####:42699:        call_tests++;
    #####:42700:        des_int(n_code, code, 0);
    #####:42701:        xmlResetLastError();
    #####:42702:        if (mem_base != xmlMemBlocks()) {
    #####:42703:            printf("Leak of %d blocks found in xmlUCSIsThai",
    #####:42704:	           xmlMemBlocks() - mem_base);
    #####:42705:	    test_ret++;
    #####:42706:            printf(" %d", n_code);
    #####:42707:            printf("\n");
        -:42708:        }
        -:42709:    }
    #####:42710:    function_tests++;
        -:42711:#endif
        -:42712:
    #####:42713:    return(test_ret);
        -:42714:}
        -:42715:
        -:42716:
        -:42717:static int
    #####:42718:test_xmlUCSIsTibetan(void) {
    #####:42719:    int test_ret = 0;
        -:42720:
        -:42721:#if defined(LIBXML_UNICODE_ENABLED)
        -:42722:    int mem_base;
        -:42723:    int ret_val;
        -:42724:    int code; /* UCS code point */
        -:42725:    int n_code;
        -:42726:
    #####:42727:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:42728:        mem_base = xmlMemBlocks();
    #####:42729:        code = gen_int(n_code, 0);
        -:42730:
    #####:42731:        ret_val = xmlUCSIsTibetan(code);
    #####:42732:        desret_int(ret_val);
    #####:42733:        call_tests++;
    #####:42734:        des_int(n_code, code, 0);
    #####:42735:        xmlResetLastError();
    #####:42736:        if (mem_base != xmlMemBlocks()) {
    #####:42737:            printf("Leak of %d blocks found in xmlUCSIsTibetan",
    #####:42738:	           xmlMemBlocks() - mem_base);
    #####:42739:	    test_ret++;
    #####:42740:            printf(" %d", n_code);
    #####:42741:            printf("\n");
        -:42742:        }
        -:42743:    }
    #####:42744:    function_tests++;
        -:42745:#endif
        -:42746:
    #####:42747:    return(test_ret);
        -:42748:}
        -:42749:
        -:42750:
        -:42751:static int
    #####:42752:test_xmlUCSIsUgaritic(void) {
    #####:42753:    int test_ret = 0;
        -:42754:
        -:42755:#if defined(LIBXML_UNICODE_ENABLED)
        -:42756:    int mem_base;
        -:42757:    int ret_val;
        -:42758:    int code; /* UCS code point */
        -:42759:    int n_code;
        -:42760:
    #####:42761:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:42762:        mem_base = xmlMemBlocks();
    #####:42763:        code = gen_int(n_code, 0);
        -:42764:
    #####:42765:        ret_val = xmlUCSIsUgaritic(code);
    #####:42766:        desret_int(ret_val);
    #####:42767:        call_tests++;
    #####:42768:        des_int(n_code, code, 0);
    #####:42769:        xmlResetLastError();
    #####:42770:        if (mem_base != xmlMemBlocks()) {
    #####:42771:            printf("Leak of %d blocks found in xmlUCSIsUgaritic",
    #####:42772:	           xmlMemBlocks() - mem_base);
    #####:42773:	    test_ret++;
    #####:42774:            printf(" %d", n_code);
    #####:42775:            printf("\n");
        -:42776:        }
        -:42777:    }
    #####:42778:    function_tests++;
        -:42779:#endif
        -:42780:
    #####:42781:    return(test_ret);
        -:42782:}
        -:42783:
        -:42784:
        -:42785:static int
    #####:42786:test_xmlUCSIsUnifiedCanadianAboriginalSyllabics(void) {
    #####:42787:    int test_ret = 0;
        -:42788:
        -:42789:#if defined(LIBXML_UNICODE_ENABLED)
        -:42790:    int mem_base;
        -:42791:    int ret_val;
        -:42792:    int code; /* UCS code point */
        -:42793:    int n_code;
        -:42794:
    #####:42795:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:42796:        mem_base = xmlMemBlocks();
    #####:42797:        code = gen_int(n_code, 0);
        -:42798:
    #####:42799:        ret_val = xmlUCSIsUnifiedCanadianAboriginalSyllabics(code);
    #####:42800:        desret_int(ret_val);
    #####:42801:        call_tests++;
    #####:42802:        des_int(n_code, code, 0);
    #####:42803:        xmlResetLastError();
    #####:42804:        if (mem_base != xmlMemBlocks()) {
    #####:42805:            printf("Leak of %d blocks found in xmlUCSIsUnifiedCanadianAboriginalSyllabics",
    #####:42806:	           xmlMemBlocks() - mem_base);
    #####:42807:	    test_ret++;
    #####:42808:            printf(" %d", n_code);
    #####:42809:            printf("\n");
        -:42810:        }
        -:42811:    }
    #####:42812:    function_tests++;
        -:42813:#endif
        -:42814:
    #####:42815:    return(test_ret);
        -:42816:}
        -:42817:
        -:42818:
        -:42819:static int
    #####:42820:test_xmlUCSIsVariationSelectors(void) {
    #####:42821:    int test_ret = 0;
        -:42822:
        -:42823:#if defined(LIBXML_UNICODE_ENABLED)
        -:42824:    int mem_base;
        -:42825:    int ret_val;
        -:42826:    int code; /* UCS code point */
        -:42827:    int n_code;
        -:42828:
    #####:42829:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:42830:        mem_base = xmlMemBlocks();
    #####:42831:        code = gen_int(n_code, 0);
        -:42832:
    #####:42833:        ret_val = xmlUCSIsVariationSelectors(code);
    #####:42834:        desret_int(ret_val);
    #####:42835:        call_tests++;
    #####:42836:        des_int(n_code, code, 0);
    #####:42837:        xmlResetLastError();
    #####:42838:        if (mem_base != xmlMemBlocks()) {
    #####:42839:            printf("Leak of %d blocks found in xmlUCSIsVariationSelectors",
    #####:42840:	           xmlMemBlocks() - mem_base);
    #####:42841:	    test_ret++;
    #####:42842:            printf(" %d", n_code);
    #####:42843:            printf("\n");
        -:42844:        }
        -:42845:    }
    #####:42846:    function_tests++;
        -:42847:#endif
        -:42848:
    #####:42849:    return(test_ret);
        -:42850:}
        -:42851:
        -:42852:
        -:42853:static int
    #####:42854:test_xmlUCSIsVariationSelectorsSupplement(void) {
    #####:42855:    int test_ret = 0;
        -:42856:
        -:42857:#if defined(LIBXML_UNICODE_ENABLED)
        -:42858:    int mem_base;
        -:42859:    int ret_val;
        -:42860:    int code; /* UCS code point */
        -:42861:    int n_code;
        -:42862:
    #####:42863:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:42864:        mem_base = xmlMemBlocks();
    #####:42865:        code = gen_int(n_code, 0);
        -:42866:
    #####:42867:        ret_val = xmlUCSIsVariationSelectorsSupplement(code);
    #####:42868:        desret_int(ret_val);
    #####:42869:        call_tests++;
    #####:42870:        des_int(n_code, code, 0);
    #####:42871:        xmlResetLastError();
    #####:42872:        if (mem_base != xmlMemBlocks()) {
    #####:42873:            printf("Leak of %d blocks found in xmlUCSIsVariationSelectorsSupplement",
    #####:42874:	           xmlMemBlocks() - mem_base);
    #####:42875:	    test_ret++;
    #####:42876:            printf(" %d", n_code);
    #####:42877:            printf("\n");
        -:42878:        }
        -:42879:    }
    #####:42880:    function_tests++;
        -:42881:#endif
        -:42882:
    #####:42883:    return(test_ret);
        -:42884:}
        -:42885:
        -:42886:
        -:42887:static int
    #####:42888:test_xmlUCSIsYiRadicals(void) {
    #####:42889:    int test_ret = 0;
        -:42890:
        -:42891:#if defined(LIBXML_UNICODE_ENABLED)
        -:42892:    int mem_base;
        -:42893:    int ret_val;
        -:42894:    int code; /* UCS code point */
        -:42895:    int n_code;
        -:42896:
    #####:42897:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:42898:        mem_base = xmlMemBlocks();
    #####:42899:        code = gen_int(n_code, 0);
        -:42900:
    #####:42901:        ret_val = xmlUCSIsYiRadicals(code);
    #####:42902:        desret_int(ret_val);
    #####:42903:        call_tests++;
    #####:42904:        des_int(n_code, code, 0);
    #####:42905:        xmlResetLastError();
    #####:42906:        if (mem_base != xmlMemBlocks()) {
    #####:42907:            printf("Leak of %d blocks found in xmlUCSIsYiRadicals",
    #####:42908:	           xmlMemBlocks() - mem_base);
    #####:42909:	    test_ret++;
    #####:42910:            printf(" %d", n_code);
    #####:42911:            printf("\n");
        -:42912:        }
        -:42913:    }
    #####:42914:    function_tests++;
        -:42915:#endif
        -:42916:
    #####:42917:    return(test_ret);
        -:42918:}
        -:42919:
        -:42920:
        -:42921:static int
    #####:42922:test_xmlUCSIsYiSyllables(void) {
    #####:42923:    int test_ret = 0;
        -:42924:
        -:42925:#if defined(LIBXML_UNICODE_ENABLED)
        -:42926:    int mem_base;
        -:42927:    int ret_val;
        -:42928:    int code; /* UCS code point */
        -:42929:    int n_code;
        -:42930:
    #####:42931:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:42932:        mem_base = xmlMemBlocks();
    #####:42933:        code = gen_int(n_code, 0);
        -:42934:
    #####:42935:        ret_val = xmlUCSIsYiSyllables(code);
    #####:42936:        desret_int(ret_val);
    #####:42937:        call_tests++;
    #####:42938:        des_int(n_code, code, 0);
    #####:42939:        xmlResetLastError();
    #####:42940:        if (mem_base != xmlMemBlocks()) {
    #####:42941:            printf("Leak of %d blocks found in xmlUCSIsYiSyllables",
    #####:42942:	           xmlMemBlocks() - mem_base);
    #####:42943:	    test_ret++;
    #####:42944:            printf(" %d", n_code);
    #####:42945:            printf("\n");
        -:42946:        }
        -:42947:    }
    #####:42948:    function_tests++;
        -:42949:#endif
        -:42950:
    #####:42951:    return(test_ret);
        -:42952:}
        -:42953:
        -:42954:
        -:42955:static int
    #####:42956:test_xmlUCSIsYijingHexagramSymbols(void) {
    #####:42957:    int test_ret = 0;
        -:42958:
        -:42959:#if defined(LIBXML_UNICODE_ENABLED)
        -:42960:    int mem_base;
        -:42961:    int ret_val;
        -:42962:    int code; /* UCS code point */
        -:42963:    int n_code;
        -:42964:
    #####:42965:    for (n_code = 0;n_code < gen_nb_int;n_code++) {
    #####:42966:        mem_base = xmlMemBlocks();
    #####:42967:        code = gen_int(n_code, 0);
        -:42968:
    #####:42969:        ret_val = xmlUCSIsYijingHexagramSymbols(code);
    #####:42970:        desret_int(ret_val);
    #####:42971:        call_tests++;
    #####:42972:        des_int(n_code, code, 0);
    #####:42973:        xmlResetLastError();
    #####:42974:        if (mem_base != xmlMemBlocks()) {
    #####:42975:            printf("Leak of %d blocks found in xmlUCSIsYijingHexagramSymbols",
    #####:42976:	           xmlMemBlocks() - mem_base);
    #####:42977:	    test_ret++;
    #####:42978:            printf(" %d", n_code);
    #####:42979:            printf("\n");
        -:42980:        }
        -:42981:    }
    #####:42982:    function_tests++;
        -:42983:#endif
        -:42984:
    #####:42985:    return(test_ret);
        -:42986:}
        -:42987:
        -:42988:static int
    #####:42989:test_xmlunicode(void) {
    #####:42990:    int test_ret = 0;
        -:42991:
    #####:42992:    if (quiet == 0) printf("Testing xmlunicode : 166 of 166 functions ...\n");
    #####:42993:    test_ret += test_xmlUCSIsAegeanNumbers();
    #####:42994:    test_ret += test_xmlUCSIsAlphabeticPresentationForms();
    #####:42995:    test_ret += test_xmlUCSIsArabic();
    #####:42996:    test_ret += test_xmlUCSIsArabicPresentationFormsA();
    #####:42997:    test_ret += test_xmlUCSIsArabicPresentationFormsB();
    #####:42998:    test_ret += test_xmlUCSIsArmenian();
    #####:42999:    test_ret += test_xmlUCSIsArrows();
    #####:43000:    test_ret += test_xmlUCSIsBasicLatin();
    #####:43001:    test_ret += test_xmlUCSIsBengali();
    #####:43002:    test_ret += test_xmlUCSIsBlock();
    #####:43003:    test_ret += test_xmlUCSIsBlockElements();
    #####:43004:    test_ret += test_xmlUCSIsBopomofo();
    #####:43005:    test_ret += test_xmlUCSIsBopomofoExtended();
    #####:43006:    test_ret += test_xmlUCSIsBoxDrawing();
    #####:43007:    test_ret += test_xmlUCSIsBraillePatterns();
    #####:43008:    test_ret += test_xmlUCSIsBuhid();
    #####:43009:    test_ret += test_xmlUCSIsByzantineMusicalSymbols();
    #####:43010:    test_ret += test_xmlUCSIsCJKCompatibility();
    #####:43011:    test_ret += test_xmlUCSIsCJKCompatibilityForms();
    #####:43012:    test_ret += test_xmlUCSIsCJKCompatibilityIdeographs();
    #####:43013:    test_ret += test_xmlUCSIsCJKCompatibilityIdeographsSupplement();
    #####:43014:    test_ret += test_xmlUCSIsCJKRadicalsSupplement();
    #####:43015:    test_ret += test_xmlUCSIsCJKSymbolsandPunctuation();
    #####:43016:    test_ret += test_xmlUCSIsCJKUnifiedIdeographs();
    #####:43017:    test_ret += test_xmlUCSIsCJKUnifiedIdeographsExtensionA();
    #####:43018:    test_ret += test_xmlUCSIsCJKUnifiedIdeographsExtensionB();
    #####:43019:    test_ret += test_xmlUCSIsCat();
    #####:43020:    test_ret += test_xmlUCSIsCatC();
    #####:43021:    test_ret += test_xmlUCSIsCatCc();
    #####:43022:    test_ret += test_xmlUCSIsCatCf();
    #####:43023:    test_ret += test_xmlUCSIsCatCo();
    #####:43024:    test_ret += test_xmlUCSIsCatCs();
    #####:43025:    test_ret += test_xmlUCSIsCatL();
    #####:43026:    test_ret += test_xmlUCSIsCatLl();
    #####:43027:    test_ret += test_xmlUCSIsCatLm();
    #####:43028:    test_ret += test_xmlUCSIsCatLo();
    #####:43029:    test_ret += test_xmlUCSIsCatLt();
    #####:43030:    test_ret += test_xmlUCSIsCatLu();
    #####:43031:    test_ret += test_xmlUCSIsCatM();
    #####:43032:    test_ret += test_xmlUCSIsCatMc();
    #####:43033:    test_ret += test_xmlUCSIsCatMe();
    #####:43034:    test_ret += test_xmlUCSIsCatMn();
    #####:43035:    test_ret += test_xmlUCSIsCatN();
    #####:43036:    test_ret += test_xmlUCSIsCatNd();
    #####:43037:    test_ret += test_xmlUCSIsCatNl();
    #####:43038:    test_ret += test_xmlUCSIsCatNo();
    #####:43039:    test_ret += test_xmlUCSIsCatP();
    #####:43040:    test_ret += test_xmlUCSIsCatPc();
    #####:43041:    test_ret += test_xmlUCSIsCatPd();
    #####:43042:    test_ret += test_xmlUCSIsCatPe();
    #####:43043:    test_ret += test_xmlUCSIsCatPf();
    #####:43044:    test_ret += test_xmlUCSIsCatPi();
    #####:43045:    test_ret += test_xmlUCSIsCatPo();
    #####:43046:    test_ret += test_xmlUCSIsCatPs();
    #####:43047:    test_ret += test_xmlUCSIsCatS();
    #####:43048:    test_ret += test_xmlUCSIsCatSc();
    #####:43049:    test_ret += test_xmlUCSIsCatSk();
    #####:43050:    test_ret += test_xmlUCSIsCatSm();
    #####:43051:    test_ret += test_xmlUCSIsCatSo();
    #####:43052:    test_ret += test_xmlUCSIsCatZ();
    #####:43053:    test_ret += test_xmlUCSIsCatZl();
    #####:43054:    test_ret += test_xmlUCSIsCatZp();
    #####:43055:    test_ret += test_xmlUCSIsCatZs();
    #####:43056:    test_ret += test_xmlUCSIsCherokee();
    #####:43057:    test_ret += test_xmlUCSIsCombiningDiacriticalMarks();
    #####:43058:    test_ret += test_xmlUCSIsCombiningDiacriticalMarksforSymbols();
    #####:43059:    test_ret += test_xmlUCSIsCombiningHalfMarks();
    #####:43060:    test_ret += test_xmlUCSIsCombiningMarksforSymbols();
    #####:43061:    test_ret += test_xmlUCSIsControlPictures();
    #####:43062:    test_ret += test_xmlUCSIsCurrencySymbols();
    #####:43063:    test_ret += test_xmlUCSIsCypriotSyllabary();
    #####:43064:    test_ret += test_xmlUCSIsCyrillic();
    #####:43065:    test_ret += test_xmlUCSIsCyrillicSupplement();
    #####:43066:    test_ret += test_xmlUCSIsDeseret();
    #####:43067:    test_ret += test_xmlUCSIsDevanagari();
    #####:43068:    test_ret += test_xmlUCSIsDingbats();
    #####:43069:    test_ret += test_xmlUCSIsEnclosedAlphanumerics();
    #####:43070:    test_ret += test_xmlUCSIsEnclosedCJKLettersandMonths();
    #####:43071:    test_ret += test_xmlUCSIsEthiopic();
    #####:43072:    test_ret += test_xmlUCSIsGeneralPunctuation();
    #####:43073:    test_ret += test_xmlUCSIsGeometricShapes();
    #####:43074:    test_ret += test_xmlUCSIsGeorgian();
    #####:43075:    test_ret += test_xmlUCSIsGothic();
    #####:43076:    test_ret += test_xmlUCSIsGreek();
    #####:43077:    test_ret += test_xmlUCSIsGreekExtended();
    #####:43078:    test_ret += test_xmlUCSIsGreekandCoptic();
    #####:43079:    test_ret += test_xmlUCSIsGujarati();
    #####:43080:    test_ret += test_xmlUCSIsGurmukhi();
    #####:43081:    test_ret += test_xmlUCSIsHalfwidthandFullwidthForms();
    #####:43082:    test_ret += test_xmlUCSIsHangulCompatibilityJamo();
    #####:43083:    test_ret += test_xmlUCSIsHangulJamo();
    #####:43084:    test_ret += test_xmlUCSIsHangulSyllables();
    #####:43085:    test_ret += test_xmlUCSIsHanunoo();
    #####:43086:    test_ret += test_xmlUCSIsHebrew();
    #####:43087:    test_ret += test_xmlUCSIsHighPrivateUseSurrogates();
    #####:43088:    test_ret += test_xmlUCSIsHighSurrogates();
    #####:43089:    test_ret += test_xmlUCSIsHiragana();
    #####:43090:    test_ret += test_xmlUCSIsIPAExtensions();
    #####:43091:    test_ret += test_xmlUCSIsIdeographicDescriptionCharacters();
    #####:43092:    test_ret += test_xmlUCSIsKanbun();
    #####:43093:    test_ret += test_xmlUCSIsKangxiRadicals();
    #####:43094:    test_ret += test_xmlUCSIsKannada();
    #####:43095:    test_ret += test_xmlUCSIsKatakana();
    #####:43096:    test_ret += test_xmlUCSIsKatakanaPhoneticExtensions();
    #####:43097:    test_ret += test_xmlUCSIsKhmer();
    #####:43098:    test_ret += test_xmlUCSIsKhmerSymbols();
    #####:43099:    test_ret += test_xmlUCSIsLao();
    #####:43100:    test_ret += test_xmlUCSIsLatin1Supplement();
    #####:43101:    test_ret += test_xmlUCSIsLatinExtendedA();
    #####:43102:    test_ret += test_xmlUCSIsLatinExtendedAdditional();
    #####:43103:    test_ret += test_xmlUCSIsLatinExtendedB();
    #####:43104:    test_ret += test_xmlUCSIsLetterlikeSymbols();
    #####:43105:    test_ret += test_xmlUCSIsLimbu();
    #####:43106:    test_ret += test_xmlUCSIsLinearBIdeograms();
    #####:43107:    test_ret += test_xmlUCSIsLinearBSyllabary();
    #####:43108:    test_ret += test_xmlUCSIsLowSurrogates();
    #####:43109:    test_ret += test_xmlUCSIsMalayalam();
    #####:43110:    test_ret += test_xmlUCSIsMathematicalAlphanumericSymbols();
    #####:43111:    test_ret += test_xmlUCSIsMathematicalOperators();
    #####:43112:    test_ret += test_xmlUCSIsMiscellaneousMathematicalSymbolsA();
    #####:43113:    test_ret += test_xmlUCSIsMiscellaneousMathematicalSymbolsB();
    #####:43114:    test_ret += test_xmlUCSIsMiscellaneousSymbols();
    #####:43115:    test_ret += test_xmlUCSIsMiscellaneousSymbolsandArrows();
    #####:43116:    test_ret += test_xmlUCSIsMiscellaneousTechnical();
    #####:43117:    test_ret += test_xmlUCSIsMongolian();
    #####:43118:    test_ret += test_xmlUCSIsMusicalSymbols();
    #####:43119:    test_ret += test_xmlUCSIsMyanmar();
    #####:43120:    test_ret += test_xmlUCSIsNumberForms();
    #####:43121:    test_ret += test_xmlUCSIsOgham();
    #####:43122:    test_ret += test_xmlUCSIsOldItalic();
    #####:43123:    test_ret += test_xmlUCSIsOpticalCharacterRecognition();
    #####:43124:    test_ret += test_xmlUCSIsOriya();
    #####:43125:    test_ret += test_xmlUCSIsOsmanya();
    #####:43126:    test_ret += test_xmlUCSIsPhoneticExtensions();
    #####:43127:    test_ret += test_xmlUCSIsPrivateUse();
    #####:43128:    test_ret += test_xmlUCSIsPrivateUseArea();
    #####:43129:    test_ret += test_xmlUCSIsRunic();
    #####:43130:    test_ret += test_xmlUCSIsShavian();
    #####:43131:    test_ret += test_xmlUCSIsSinhala();
    #####:43132:    test_ret += test_xmlUCSIsSmallFormVariants();
    #####:43133:    test_ret += test_xmlUCSIsSpacingModifierLetters();
    #####:43134:    test_ret += test_xmlUCSIsSpecials();
    #####:43135:    test_ret += test_xmlUCSIsSuperscriptsandSubscripts();
    #####:43136:    test_ret += test_xmlUCSIsSupplementalArrowsA();
    #####:43137:    test_ret += test_xmlUCSIsSupplementalArrowsB();
    #####:43138:    test_ret += test_xmlUCSIsSupplementalMathematicalOperators();
    #####:43139:    test_ret += test_xmlUCSIsSupplementaryPrivateUseAreaA();
    #####:43140:    test_ret += test_xmlUCSIsSupplementaryPrivateUseAreaB();
    #####:43141:    test_ret += test_xmlUCSIsSyriac();
    #####:43142:    test_ret += test_xmlUCSIsTagalog();
    #####:43143:    test_ret += test_xmlUCSIsTagbanwa();
    #####:43144:    test_ret += test_xmlUCSIsTags();
    #####:43145:    test_ret += test_xmlUCSIsTaiLe();
    #####:43146:    test_ret += test_xmlUCSIsTaiXuanJingSymbols();
    #####:43147:    test_ret += test_xmlUCSIsTamil();
    #####:43148:    test_ret += test_xmlUCSIsTelugu();
    #####:43149:    test_ret += test_xmlUCSIsThaana();
    #####:43150:    test_ret += test_xmlUCSIsThai();
    #####:43151:    test_ret += test_xmlUCSIsTibetan();
    #####:43152:    test_ret += test_xmlUCSIsUgaritic();
    #####:43153:    test_ret += test_xmlUCSIsUnifiedCanadianAboriginalSyllabics();
    #####:43154:    test_ret += test_xmlUCSIsVariationSelectors();
    #####:43155:    test_ret += test_xmlUCSIsVariationSelectorsSupplement();
    #####:43156:    test_ret += test_xmlUCSIsYiRadicals();
    #####:43157:    test_ret += test_xmlUCSIsYiSyllables();
    #####:43158:    test_ret += test_xmlUCSIsYijingHexagramSymbols();
        -:43159:
    #####:43160:    if (test_ret != 0)
    #####:43161:	printf("Module xmlunicode: %d errors\n", test_ret);
    #####:43162:    return(test_ret);
        -:43163:}
        -:43164:
        -:43165:static int
    #####:43166:test_xmlNewTextWriter(void) {
    #####:43167:    int test_ret = 0;
        -:43168:
        -:43169:#if defined(LIBXML_WRITER_ENABLED)
        -:43170:    int mem_base;
        -:43171:    xmlTextWriterPtr ret_val;
        -:43172:    xmlOutputBufferPtr out; /* an xmlOutputBufferPtr */
        -:43173:    int n_out;
        -:43174:
    #####:43175:    for (n_out = 0;n_out < gen_nb_xmlOutputBufferPtr;n_out++) {
    #####:43176:        mem_base = xmlMemBlocks();
    #####:43177:        out = gen_xmlOutputBufferPtr(n_out, 0);
        -:43178:
    #####:43179:        ret_val = xmlNewTextWriter(out);
    #####:43180:        if (ret_val != NULL) out = NULL;
    #####:43181:        desret_xmlTextWriterPtr(ret_val);
    #####:43182:        call_tests++;
    #####:43183:        des_xmlOutputBufferPtr(n_out, out, 0);
    #####:43184:        xmlResetLastError();
    #####:43185:        if (mem_base != xmlMemBlocks()) {
    #####:43186:            printf("Leak of %d blocks found in xmlNewTextWriter",
    #####:43187:	           xmlMemBlocks() - mem_base);
    #####:43188:	    test_ret++;
    #####:43189:            printf(" %d", n_out);
    #####:43190:            printf("\n");
        -:43191:        }
        -:43192:    }
    #####:43193:    function_tests++;
        -:43194:#endif
        -:43195:
    #####:43196:    return(test_ret);
        -:43197:}
        -:43198:
        -:43199:
        -:43200:static int
    #####:43201:test_xmlNewTextWriterFilename(void) {
    #####:43202:    int test_ret = 0;
        -:43203:
        -:43204:#if defined(LIBXML_WRITER_ENABLED)
        -:43205:    int mem_base;
        -:43206:    xmlTextWriterPtr ret_val;
        -:43207:    const char * uri; /* the URI of the resource for the output */
        -:43208:    int n_uri;
        -:43209:    int compression; /* compress the output? */
        -:43210:    int n_compression;
        -:43211:
    #####:43212:    for (n_uri = 0;n_uri < gen_nb_fileoutput;n_uri++) {
    #####:43213:    for (n_compression = 0;n_compression < gen_nb_int;n_compression++) {
    #####:43214:        mem_base = xmlMemBlocks();
    #####:43215:        uri = gen_fileoutput(n_uri, 0);
    #####:43216:        compression = gen_int(n_compression, 1);
        -:43217:
    #####:43218:        ret_val = xmlNewTextWriterFilename(uri, compression);
    #####:43219:        desret_xmlTextWriterPtr(ret_val);
    #####:43220:        call_tests++;
    #####:43221:        des_fileoutput(n_uri, uri, 0);
    #####:43222:        des_int(n_compression, compression, 1);
    #####:43223:        xmlResetLastError();
    #####:43224:        if (mem_base != xmlMemBlocks()) {
    #####:43225:            printf("Leak of %d blocks found in xmlNewTextWriterFilename",
    #####:43226:	           xmlMemBlocks() - mem_base);
    #####:43227:	    test_ret++;
    #####:43228:            printf(" %d", n_uri);
    #####:43229:            printf(" %d", n_compression);
    #####:43230:            printf("\n");
        -:43231:        }
        -:43232:    }
        -:43233:    }
    #####:43234:    function_tests++;
        -:43235:#endif
        -:43236:
    #####:43237:    return(test_ret);
        -:43238:}
        -:43239:
        -:43240:
        -:43241:static int
    #####:43242:test_xmlNewTextWriterMemory(void) {
    #####:43243:    int test_ret = 0;
        -:43244:
        -:43245:#if defined(LIBXML_WRITER_ENABLED)
        -:43246:    int mem_base;
        -:43247:    xmlTextWriterPtr ret_val;
        -:43248:    xmlBufferPtr buf; /* xmlBufferPtr */
        -:43249:    int n_buf;
        -:43250:    int compression; /* compress the output? */
        -:43251:    int n_compression;
        -:43252:
    #####:43253:    for (n_buf = 0;n_buf < gen_nb_xmlBufferPtr;n_buf++) {
    #####:43254:    for (n_compression = 0;n_compression < gen_nb_int;n_compression++) {
    #####:43255:        mem_base = xmlMemBlocks();
    #####:43256:        buf = gen_xmlBufferPtr(n_buf, 0);
    #####:43257:        compression = gen_int(n_compression, 1);
        -:43258:
    #####:43259:        ret_val = xmlNewTextWriterMemory(buf, compression);
    #####:43260:        desret_xmlTextWriterPtr(ret_val);
    #####:43261:        call_tests++;
    #####:43262:        des_xmlBufferPtr(n_buf, buf, 0);
    #####:43263:        des_int(n_compression, compression, 1);
    #####:43264:        xmlResetLastError();
    #####:43265:        if (mem_base != xmlMemBlocks()) {
    #####:43266:            printf("Leak of %d blocks found in xmlNewTextWriterMemory",
    #####:43267:	           xmlMemBlocks() - mem_base);
    #####:43268:	    test_ret++;
    #####:43269:            printf(" %d", n_buf);
    #####:43270:            printf(" %d", n_compression);
    #####:43271:            printf("\n");
        -:43272:        }
        -:43273:    }
        -:43274:    }
    #####:43275:    function_tests++;
        -:43276:#endif
        -:43277:
    #####:43278:    return(test_ret);
        -:43279:}
        -:43280:
        -:43281:
        -:43282:static int
    #####:43283:test_xmlNewTextWriterPushParser(void) {
    #####:43284:    int test_ret = 0;
        -:43285:
        -:43286:#if defined(LIBXML_WRITER_ENABLED)
        -:43287:    int mem_base;
        -:43288:    xmlTextWriterPtr ret_val;
        -:43289:    xmlParserCtxtPtr ctxt; /* xmlParserCtxtPtr to hold the new XML document tree */
        -:43290:    int n_ctxt;
        -:43291:    int compression; /* compress the output? */
        -:43292:    int n_compression;
        -:43293:
    #####:43294:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlParserCtxtPtr;n_ctxt++) {
    #####:43295:    for (n_compression = 0;n_compression < gen_nb_int;n_compression++) {
    #####:43296:        mem_base = xmlMemBlocks();
    #####:43297:        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
    #####:43298:        compression = gen_int(n_compression, 1);
        -:43299:
    #####:43300:        ret_val = xmlNewTextWriterPushParser(ctxt, compression);
    #####:43301:        if (ctxt != NULL) {xmlFreeDoc(ctxt->myDoc); ctxt->myDoc = NULL;} if (ret_val != NULL) ctxt = NULL;
    #####:43302:        desret_xmlTextWriterPtr(ret_val);
    #####:43303:        call_tests++;
    #####:43304:        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
    #####:43305:        des_int(n_compression, compression, 1);
    #####:43306:        xmlResetLastError();
    #####:43307:        if (mem_base != xmlMemBlocks()) {
    #####:43308:            printf("Leak of %d blocks found in xmlNewTextWriterPushParser",
    #####:43309:	           xmlMemBlocks() - mem_base);
    #####:43310:	    test_ret++;
    #####:43311:            printf(" %d", n_ctxt);
    #####:43312:            printf(" %d", n_compression);
    #####:43313:            printf("\n");
        -:43314:        }
        -:43315:    }
        -:43316:    }
    #####:43317:    function_tests++;
        -:43318:#endif
        -:43319:
    #####:43320:    return(test_ret);
        -:43321:}
        -:43322:
        -:43323:
        -:43324:static int
    #####:43325:test_xmlNewTextWriterTree(void) {
    #####:43326:    int test_ret = 0;
        -:43327:
        -:43328:#if defined(LIBXML_WRITER_ENABLED)
        -:43329:    int mem_base;
        -:43330:    xmlTextWriterPtr ret_val;
        -:43331:    xmlDocPtr doc; /* xmlDocPtr */
        -:43332:    int n_doc;
        -:43333:    xmlNodePtr node; /* xmlNodePtr or NULL for doc->children */
        -:43334:    int n_node;
        -:43335:    int compression; /* compress the output? */
        -:43336:    int n_compression;
        -:43337:
    #####:43338:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:43339:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:43340:    for (n_compression = 0;n_compression < gen_nb_int;n_compression++) {
    #####:43341:        mem_base = xmlMemBlocks();
    #####:43342:        doc = gen_xmlDocPtr(n_doc, 0);
    #####:43343:        node = gen_xmlNodePtr(n_node, 1);
    #####:43344:        compression = gen_int(n_compression, 2);
        -:43345:
    #####:43346:        ret_val = xmlNewTextWriterTree(doc, node, compression);
    #####:43347:        desret_xmlTextWriterPtr(ret_val);
    #####:43348:        call_tests++;
    #####:43349:        des_xmlDocPtr(n_doc, doc, 0);
    #####:43350:        des_xmlNodePtr(n_node, node, 1);
    #####:43351:        des_int(n_compression, compression, 2);
    #####:43352:        xmlResetLastError();
    #####:43353:        if (mem_base != xmlMemBlocks()) {
    #####:43354:            printf("Leak of %d blocks found in xmlNewTextWriterTree",
    #####:43355:	           xmlMemBlocks() - mem_base);
    #####:43356:	    test_ret++;
    #####:43357:            printf(" %d", n_doc);
    #####:43358:            printf(" %d", n_node);
    #####:43359:            printf(" %d", n_compression);
    #####:43360:            printf("\n");
        -:43361:        }
        -:43362:    }
        -:43363:    }
        -:43364:    }
    #####:43365:    function_tests++;
        -:43366:#endif
        -:43367:
    #####:43368:    return(test_ret);
        -:43369:}
        -:43370:
        -:43371:
        -:43372:static int
    #####:43373:test_xmlTextWriterEndAttribute(void) {
    #####:43374:    int test_ret = 0;
        -:43375:
        -:43376:#if defined(LIBXML_WRITER_ENABLED)
        -:43377:    int mem_base;
        -:43378:    int ret_val;
        -:43379:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:43380:    int n_writer;
        -:43381:
    #####:43382:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:43383:        mem_base = xmlMemBlocks();
    #####:43384:        writer = gen_xmlTextWriterPtr(n_writer, 0);
        -:43385:
    #####:43386:        ret_val = xmlTextWriterEndAttribute(writer);
    #####:43387:        desret_int(ret_val);
    #####:43388:        call_tests++;
    #####:43389:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:43390:        xmlResetLastError();
    #####:43391:        if (mem_base != xmlMemBlocks()) {
    #####:43392:            printf("Leak of %d blocks found in xmlTextWriterEndAttribute",
    #####:43393:	           xmlMemBlocks() - mem_base);
    #####:43394:	    test_ret++;
    #####:43395:            printf(" %d", n_writer);
    #####:43396:            printf("\n");
        -:43397:        }
        -:43398:    }
    #####:43399:    function_tests++;
        -:43400:#endif
        -:43401:
    #####:43402:    return(test_ret);
        -:43403:}
        -:43404:
        -:43405:
        -:43406:static int
    #####:43407:test_xmlTextWriterEndCDATA(void) {
    #####:43408:    int test_ret = 0;
        -:43409:
        -:43410:#if defined(LIBXML_WRITER_ENABLED)
        -:43411:    int mem_base;
        -:43412:    int ret_val;
        -:43413:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:43414:    int n_writer;
        -:43415:
    #####:43416:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:43417:        mem_base = xmlMemBlocks();
    #####:43418:        writer = gen_xmlTextWriterPtr(n_writer, 0);
        -:43419:
    #####:43420:        ret_val = xmlTextWriterEndCDATA(writer);
    #####:43421:        desret_int(ret_val);
    #####:43422:        call_tests++;
    #####:43423:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:43424:        xmlResetLastError();
    #####:43425:        if (mem_base != xmlMemBlocks()) {
    #####:43426:            printf("Leak of %d blocks found in xmlTextWriterEndCDATA",
    #####:43427:	           xmlMemBlocks() - mem_base);
    #####:43428:	    test_ret++;
    #####:43429:            printf(" %d", n_writer);
    #####:43430:            printf("\n");
        -:43431:        }
        -:43432:    }
    #####:43433:    function_tests++;
        -:43434:#endif
        -:43435:
    #####:43436:    return(test_ret);
        -:43437:}
        -:43438:
        -:43439:
        -:43440:static int
    #####:43441:test_xmlTextWriterEndComment(void) {
    #####:43442:    int test_ret = 0;
        -:43443:
        -:43444:#if defined(LIBXML_WRITER_ENABLED)
        -:43445:    int mem_base;
        -:43446:    int ret_val;
        -:43447:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:43448:    int n_writer;
        -:43449:
    #####:43450:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:43451:        mem_base = xmlMemBlocks();
    #####:43452:        writer = gen_xmlTextWriterPtr(n_writer, 0);
        -:43453:
    #####:43454:        ret_val = xmlTextWriterEndComment(writer);
    #####:43455:        desret_int(ret_val);
    #####:43456:        call_tests++;
    #####:43457:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:43458:        xmlResetLastError();
    #####:43459:        if (mem_base != xmlMemBlocks()) {
    #####:43460:            printf("Leak of %d blocks found in xmlTextWriterEndComment",
    #####:43461:	           xmlMemBlocks() - mem_base);
    #####:43462:	    test_ret++;
    #####:43463:            printf(" %d", n_writer);
    #####:43464:            printf("\n");
        -:43465:        }
        -:43466:    }
    #####:43467:    function_tests++;
        -:43468:#endif
        -:43469:
    #####:43470:    return(test_ret);
        -:43471:}
        -:43472:
        -:43473:
        -:43474:static int
    #####:43475:test_xmlTextWriterEndDTD(void) {
    #####:43476:    int test_ret = 0;
        -:43477:
        -:43478:#if defined(LIBXML_WRITER_ENABLED)
        -:43479:    int mem_base;
        -:43480:    int ret_val;
        -:43481:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:43482:    int n_writer;
        -:43483:
    #####:43484:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:43485:        mem_base = xmlMemBlocks();
    #####:43486:        writer = gen_xmlTextWriterPtr(n_writer, 0);
        -:43487:
    #####:43488:        ret_val = xmlTextWriterEndDTD(writer);
    #####:43489:        desret_int(ret_val);
    #####:43490:        call_tests++;
    #####:43491:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:43492:        xmlResetLastError();
    #####:43493:        if (mem_base != xmlMemBlocks()) {
    #####:43494:            printf("Leak of %d blocks found in xmlTextWriterEndDTD",
    #####:43495:	           xmlMemBlocks() - mem_base);
    #####:43496:	    test_ret++;
    #####:43497:            printf(" %d", n_writer);
    #####:43498:            printf("\n");
        -:43499:        }
        -:43500:    }
    #####:43501:    function_tests++;
        -:43502:#endif
        -:43503:
    #####:43504:    return(test_ret);
        -:43505:}
        -:43506:
        -:43507:
        -:43508:static int
    #####:43509:test_xmlTextWriterEndDTDAttlist(void) {
    #####:43510:    int test_ret = 0;
        -:43511:
        -:43512:#if defined(LIBXML_WRITER_ENABLED)
        -:43513:    int mem_base;
        -:43514:    int ret_val;
        -:43515:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:43516:    int n_writer;
        -:43517:
    #####:43518:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:43519:        mem_base = xmlMemBlocks();
    #####:43520:        writer = gen_xmlTextWriterPtr(n_writer, 0);
        -:43521:
    #####:43522:        ret_val = xmlTextWriterEndDTDAttlist(writer);
    #####:43523:        desret_int(ret_val);
    #####:43524:        call_tests++;
    #####:43525:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:43526:        xmlResetLastError();
    #####:43527:        if (mem_base != xmlMemBlocks()) {
    #####:43528:            printf("Leak of %d blocks found in xmlTextWriterEndDTDAttlist",
    #####:43529:	           xmlMemBlocks() - mem_base);
    #####:43530:	    test_ret++;
    #####:43531:            printf(" %d", n_writer);
    #####:43532:            printf("\n");
        -:43533:        }
        -:43534:    }
    #####:43535:    function_tests++;
        -:43536:#endif
        -:43537:
    #####:43538:    return(test_ret);
        -:43539:}
        -:43540:
        -:43541:
        -:43542:static int
    #####:43543:test_xmlTextWriterEndDTDElement(void) {
    #####:43544:    int test_ret = 0;
        -:43545:
        -:43546:#if defined(LIBXML_WRITER_ENABLED)
        -:43547:    int mem_base;
        -:43548:    int ret_val;
        -:43549:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:43550:    int n_writer;
        -:43551:
    #####:43552:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:43553:        mem_base = xmlMemBlocks();
    #####:43554:        writer = gen_xmlTextWriterPtr(n_writer, 0);
        -:43555:
    #####:43556:        ret_val = xmlTextWriterEndDTDElement(writer);
    #####:43557:        desret_int(ret_val);
    #####:43558:        call_tests++;
    #####:43559:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:43560:        xmlResetLastError();
    #####:43561:        if (mem_base != xmlMemBlocks()) {
    #####:43562:            printf("Leak of %d blocks found in xmlTextWriterEndDTDElement",
    #####:43563:	           xmlMemBlocks() - mem_base);
    #####:43564:	    test_ret++;
    #####:43565:            printf(" %d", n_writer);
    #####:43566:            printf("\n");
        -:43567:        }
        -:43568:    }
    #####:43569:    function_tests++;
        -:43570:#endif
        -:43571:
    #####:43572:    return(test_ret);
        -:43573:}
        -:43574:
        -:43575:
        -:43576:static int
    #####:43577:test_xmlTextWriterEndDTDEntity(void) {
    #####:43578:    int test_ret = 0;
        -:43579:
        -:43580:#if defined(LIBXML_WRITER_ENABLED)
        -:43581:    int mem_base;
        -:43582:    int ret_val;
        -:43583:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:43584:    int n_writer;
        -:43585:
    #####:43586:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:43587:        mem_base = xmlMemBlocks();
    #####:43588:        writer = gen_xmlTextWriterPtr(n_writer, 0);
        -:43589:
    #####:43590:        ret_val = xmlTextWriterEndDTDEntity(writer);
    #####:43591:        desret_int(ret_val);
    #####:43592:        call_tests++;
    #####:43593:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:43594:        xmlResetLastError();
    #####:43595:        if (mem_base != xmlMemBlocks()) {
    #####:43596:            printf("Leak of %d blocks found in xmlTextWriterEndDTDEntity",
    #####:43597:	           xmlMemBlocks() - mem_base);
    #####:43598:	    test_ret++;
    #####:43599:            printf(" %d", n_writer);
    #####:43600:            printf("\n");
        -:43601:        }
        -:43602:    }
    #####:43603:    function_tests++;
        -:43604:#endif
        -:43605:
    #####:43606:    return(test_ret);
        -:43607:}
        -:43608:
        -:43609:
        -:43610:static int
    #####:43611:test_xmlTextWriterEndDocument(void) {
    #####:43612:    int test_ret = 0;
        -:43613:
        -:43614:#if defined(LIBXML_WRITER_ENABLED)
        -:43615:    int mem_base;
        -:43616:    int ret_val;
        -:43617:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:43618:    int n_writer;
        -:43619:
    #####:43620:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:43621:        mem_base = xmlMemBlocks();
    #####:43622:        writer = gen_xmlTextWriterPtr(n_writer, 0);
        -:43623:
    #####:43624:        ret_val = xmlTextWriterEndDocument(writer);
    #####:43625:        desret_int(ret_val);
    #####:43626:        call_tests++;
    #####:43627:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:43628:        xmlResetLastError();
    #####:43629:        if (mem_base != xmlMemBlocks()) {
    #####:43630:            printf("Leak of %d blocks found in xmlTextWriterEndDocument",
    #####:43631:	           xmlMemBlocks() - mem_base);
    #####:43632:	    test_ret++;
    #####:43633:            printf(" %d", n_writer);
    #####:43634:            printf("\n");
        -:43635:        }
        -:43636:    }
    #####:43637:    function_tests++;
        -:43638:#endif
        -:43639:
    #####:43640:    return(test_ret);
        -:43641:}
        -:43642:
        -:43643:
        -:43644:static int
    #####:43645:test_xmlTextWriterEndElement(void) {
    #####:43646:    int test_ret = 0;
        -:43647:
        -:43648:#if defined(LIBXML_WRITER_ENABLED)
        -:43649:    int mem_base;
        -:43650:    int ret_val;
        -:43651:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:43652:    int n_writer;
        -:43653:
    #####:43654:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:43655:        mem_base = xmlMemBlocks();
    #####:43656:        writer = gen_xmlTextWriterPtr(n_writer, 0);
        -:43657:
    #####:43658:        ret_val = xmlTextWriterEndElement(writer);
    #####:43659:        desret_int(ret_val);
    #####:43660:        call_tests++;
    #####:43661:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:43662:        xmlResetLastError();
    #####:43663:        if (mem_base != xmlMemBlocks()) {
    #####:43664:            printf("Leak of %d blocks found in xmlTextWriterEndElement",
    #####:43665:	           xmlMemBlocks() - mem_base);
    #####:43666:	    test_ret++;
    #####:43667:            printf(" %d", n_writer);
    #####:43668:            printf("\n");
        -:43669:        }
        -:43670:    }
    #####:43671:    function_tests++;
        -:43672:#endif
        -:43673:
    #####:43674:    return(test_ret);
        -:43675:}
        -:43676:
        -:43677:
        -:43678:static int
    #####:43679:test_xmlTextWriterEndPI(void) {
    #####:43680:    int test_ret = 0;
        -:43681:
        -:43682:#if defined(LIBXML_WRITER_ENABLED)
        -:43683:    int mem_base;
        -:43684:    int ret_val;
        -:43685:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:43686:    int n_writer;
        -:43687:
    #####:43688:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:43689:        mem_base = xmlMemBlocks();
    #####:43690:        writer = gen_xmlTextWriterPtr(n_writer, 0);
        -:43691:
    #####:43692:        ret_val = xmlTextWriterEndPI(writer);
    #####:43693:        desret_int(ret_val);
    #####:43694:        call_tests++;
    #####:43695:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:43696:        xmlResetLastError();
    #####:43697:        if (mem_base != xmlMemBlocks()) {
    #####:43698:            printf("Leak of %d blocks found in xmlTextWriterEndPI",
    #####:43699:	           xmlMemBlocks() - mem_base);
    #####:43700:	    test_ret++;
    #####:43701:            printf(" %d", n_writer);
    #####:43702:            printf("\n");
        -:43703:        }
        -:43704:    }
    #####:43705:    function_tests++;
        -:43706:#endif
        -:43707:
    #####:43708:    return(test_ret);
        -:43709:}
        -:43710:
        -:43711:
        -:43712:static int
    #####:43713:test_xmlTextWriterFlush(void) {
    #####:43714:    int test_ret = 0;
        -:43715:
        -:43716:#if defined(LIBXML_WRITER_ENABLED)
        -:43717:    int mem_base;
        -:43718:    int ret_val;
        -:43719:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:43720:    int n_writer;
        -:43721:
    #####:43722:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:43723:        mem_base = xmlMemBlocks();
    #####:43724:        writer = gen_xmlTextWriterPtr(n_writer, 0);
        -:43725:
    #####:43726:        ret_val = xmlTextWriterFlush(writer);
    #####:43727:        desret_int(ret_val);
    #####:43728:        call_tests++;
    #####:43729:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:43730:        xmlResetLastError();
    #####:43731:        if (mem_base != xmlMemBlocks()) {
    #####:43732:            printf("Leak of %d blocks found in xmlTextWriterFlush",
    #####:43733:	           xmlMemBlocks() - mem_base);
    #####:43734:	    test_ret++;
    #####:43735:            printf(" %d", n_writer);
    #####:43736:            printf("\n");
        -:43737:        }
        -:43738:    }
    #####:43739:    function_tests++;
        -:43740:#endif
        -:43741:
    #####:43742:    return(test_ret);
        -:43743:}
        -:43744:
        -:43745:
        -:43746:static int
    #####:43747:test_xmlTextWriterFullEndElement(void) {
    #####:43748:    int test_ret = 0;
        -:43749:
        -:43750:#if defined(LIBXML_WRITER_ENABLED)
        -:43751:    int mem_base;
        -:43752:    int ret_val;
        -:43753:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:43754:    int n_writer;
        -:43755:
    #####:43756:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:43757:        mem_base = xmlMemBlocks();
    #####:43758:        writer = gen_xmlTextWriterPtr(n_writer, 0);
        -:43759:
    #####:43760:        ret_val = xmlTextWriterFullEndElement(writer);
    #####:43761:        desret_int(ret_val);
    #####:43762:        call_tests++;
    #####:43763:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:43764:        xmlResetLastError();
    #####:43765:        if (mem_base != xmlMemBlocks()) {
    #####:43766:            printf("Leak of %d blocks found in xmlTextWriterFullEndElement",
    #####:43767:	           xmlMemBlocks() - mem_base);
    #####:43768:	    test_ret++;
    #####:43769:            printf(" %d", n_writer);
    #####:43770:            printf("\n");
        -:43771:        }
        -:43772:    }
    #####:43773:    function_tests++;
        -:43774:#endif
        -:43775:
    #####:43776:    return(test_ret);
        -:43777:}
        -:43778:
        -:43779:
        -:43780:static int
    #####:43781:test_xmlTextWriterSetIndent(void) {
    #####:43782:    int test_ret = 0;
        -:43783:
        -:43784:#if defined(LIBXML_WRITER_ENABLED)
        -:43785:    int mem_base;
        -:43786:    int ret_val;
        -:43787:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:43788:    int n_writer;
        -:43789:    int indent; /* do indentation? */
        -:43790:    int n_indent;
        -:43791:
    #####:43792:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:43793:    for (n_indent = 0;n_indent < gen_nb_int;n_indent++) {
    #####:43794:        mem_base = xmlMemBlocks();
    #####:43795:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:43796:        indent = gen_int(n_indent, 1);
        -:43797:
    #####:43798:        ret_val = xmlTextWriterSetIndent(writer, indent);
    #####:43799:        desret_int(ret_val);
    #####:43800:        call_tests++;
    #####:43801:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:43802:        des_int(n_indent, indent, 1);
    #####:43803:        xmlResetLastError();
    #####:43804:        if (mem_base != xmlMemBlocks()) {
    #####:43805:            printf("Leak of %d blocks found in xmlTextWriterSetIndent",
    #####:43806:	           xmlMemBlocks() - mem_base);
    #####:43807:	    test_ret++;
    #####:43808:            printf(" %d", n_writer);
    #####:43809:            printf(" %d", n_indent);
    #####:43810:            printf("\n");
        -:43811:        }
        -:43812:    }
        -:43813:    }
    #####:43814:    function_tests++;
        -:43815:#endif
        -:43816:
    #####:43817:    return(test_ret);
        -:43818:}
        -:43819:
        -:43820:
        -:43821:static int
    #####:43822:test_xmlTextWriterSetIndentString(void) {
    #####:43823:    int test_ret = 0;
        -:43824:
        -:43825:#if defined(LIBXML_WRITER_ENABLED)
        -:43826:    int mem_base;
        -:43827:    int ret_val;
        -:43828:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:43829:    int n_writer;
        -:43830:    xmlChar * str; /* the xmlChar string */
        -:43831:    int n_str;
        -:43832:
    #####:43833:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:43834:    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    #####:43835:        mem_base = xmlMemBlocks();
    #####:43836:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:43837:        str = gen_const_xmlChar_ptr(n_str, 1);
        -:43838:
    #####:43839:        ret_val = xmlTextWriterSetIndentString(writer, (const xmlChar *)str);
    #####:43840:        desret_int(ret_val);
    #####:43841:        call_tests++;
    #####:43842:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:43843:        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 1);
    #####:43844:        xmlResetLastError();
    #####:43845:        if (mem_base != xmlMemBlocks()) {
    #####:43846:            printf("Leak of %d blocks found in xmlTextWriterSetIndentString",
    #####:43847:	           xmlMemBlocks() - mem_base);
    #####:43848:	    test_ret++;
    #####:43849:            printf(" %d", n_writer);
    #####:43850:            printf(" %d", n_str);
    #####:43851:            printf("\n");
        -:43852:        }
        -:43853:    }
        -:43854:    }
    #####:43855:    function_tests++;
        -:43856:#endif
        -:43857:
    #####:43858:    return(test_ret);
        -:43859:}
        -:43860:
        -:43861:
        -:43862:static int
    #####:43863:test_xmlTextWriterSetQuoteChar(void) {
    #####:43864:    int test_ret = 0;
        -:43865:
        -:43866:#if defined(LIBXML_WRITER_ENABLED)
        -:43867:    int mem_base;
        -:43868:    int ret_val;
        -:43869:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:43870:    int n_writer;
        -:43871:    xmlChar quotechar; /* the quote character */
        -:43872:    int n_quotechar;
        -:43873:
    #####:43874:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:43875:    for (n_quotechar = 0;n_quotechar < gen_nb_xmlChar;n_quotechar++) {
    #####:43876:        mem_base = xmlMemBlocks();
    #####:43877:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:43878:        quotechar = gen_xmlChar(n_quotechar, 1);
        -:43879:
    #####:43880:        ret_val = xmlTextWriterSetQuoteChar(writer, quotechar);
    #####:43881:        desret_int(ret_val);
    #####:43882:        call_tests++;
    #####:43883:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:43884:        des_xmlChar(n_quotechar, quotechar, 1);
    #####:43885:        xmlResetLastError();
    #####:43886:        if (mem_base != xmlMemBlocks()) {
    #####:43887:            printf("Leak of %d blocks found in xmlTextWriterSetQuoteChar",
    #####:43888:	           xmlMemBlocks() - mem_base);
    #####:43889:	    test_ret++;
    #####:43890:            printf(" %d", n_writer);
    #####:43891:            printf(" %d", n_quotechar);
    #####:43892:            printf("\n");
        -:43893:        }
        -:43894:    }
        -:43895:    }
    #####:43896:    function_tests++;
        -:43897:#endif
        -:43898:
    #####:43899:    return(test_ret);
        -:43900:}
        -:43901:
        -:43902:
        -:43903:static int
    #####:43904:test_xmlTextWriterStartAttribute(void) {
    #####:43905:    int test_ret = 0;
        -:43906:
        -:43907:#if defined(LIBXML_WRITER_ENABLED)
        -:43908:    int mem_base;
        -:43909:    int ret_val;
        -:43910:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:43911:    int n_writer;
        -:43912:    xmlChar * name; /* element name */
        -:43913:    int n_name;
        -:43914:
    #####:43915:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:43916:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:43917:        mem_base = xmlMemBlocks();
    #####:43918:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:43919:        name = gen_const_xmlChar_ptr(n_name, 1);
        -:43920:
    #####:43921:        ret_val = xmlTextWriterStartAttribute(writer, (const xmlChar *)name);
    #####:43922:        desret_int(ret_val);
    #####:43923:        call_tests++;
    #####:43924:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:43925:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:43926:        xmlResetLastError();
    #####:43927:        if (mem_base != xmlMemBlocks()) {
    #####:43928:            printf("Leak of %d blocks found in xmlTextWriterStartAttribute",
    #####:43929:	           xmlMemBlocks() - mem_base);
    #####:43930:	    test_ret++;
    #####:43931:            printf(" %d", n_writer);
    #####:43932:            printf(" %d", n_name);
    #####:43933:            printf("\n");
        -:43934:        }
        -:43935:    }
        -:43936:    }
    #####:43937:    function_tests++;
        -:43938:#endif
        -:43939:
    #####:43940:    return(test_ret);
        -:43941:}
        -:43942:
        -:43943:
        -:43944:static int
    #####:43945:test_xmlTextWriterStartAttributeNS(void) {
    #####:43946:    int test_ret = 0;
        -:43947:
        -:43948:#if defined(LIBXML_WRITER_ENABLED)
        -:43949:    int mem_base;
        -:43950:    int ret_val;
        -:43951:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:43952:    int n_writer;
        -:43953:    xmlChar * prefix; /* namespace prefix or NULL */
        -:43954:    int n_prefix;
        -:43955:    xmlChar * name; /* element local name */
        -:43956:    int n_name;
        -:43957:    xmlChar * namespaceURI; /* namespace URI or NULL */
        -:43958:    int n_namespaceURI;
        -:43959:
    #####:43960:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:43961:    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    #####:43962:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:43963:    for (n_namespaceURI = 0;n_namespaceURI < gen_nb_const_xmlChar_ptr;n_namespaceURI++) {
    #####:43964:        mem_base = xmlMemBlocks();
    #####:43965:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:43966:        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
    #####:43967:        name = gen_const_xmlChar_ptr(n_name, 2);
    #####:43968:        namespaceURI = gen_const_xmlChar_ptr(n_namespaceURI, 3);
        -:43969:
    #####:43970:        ret_val = xmlTextWriterStartAttributeNS(writer, (const xmlChar *)prefix, (const xmlChar *)name, (const xmlChar *)namespaceURI);
    #####:43971:        desret_int(ret_val);
    #####:43972:        call_tests++;
    #####:43973:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:43974:        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 1);
    #####:43975:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
    #####:43976:        des_const_xmlChar_ptr(n_namespaceURI, (const xmlChar *)namespaceURI, 3);
    #####:43977:        xmlResetLastError();
    #####:43978:        if (mem_base != xmlMemBlocks()) {
    #####:43979:            printf("Leak of %d blocks found in xmlTextWriterStartAttributeNS",
    #####:43980:	           xmlMemBlocks() - mem_base);
    #####:43981:	    test_ret++;
    #####:43982:            printf(" %d", n_writer);
    #####:43983:            printf(" %d", n_prefix);
    #####:43984:            printf(" %d", n_name);
    #####:43985:            printf(" %d", n_namespaceURI);
    #####:43986:            printf("\n");
        -:43987:        }
        -:43988:    }
        -:43989:    }
        -:43990:    }
        -:43991:    }
    #####:43992:    function_tests++;
        -:43993:#endif
        -:43994:
    #####:43995:    return(test_ret);
        -:43996:}
        -:43997:
        -:43998:
        -:43999:static int
    #####:44000:test_xmlTextWriterStartCDATA(void) {
    #####:44001:    int test_ret = 0;
        -:44002:
        -:44003:#if defined(LIBXML_WRITER_ENABLED)
        -:44004:    int mem_base;
        -:44005:    int ret_val;
        -:44006:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:44007:    int n_writer;
        -:44008:
    #####:44009:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:44010:        mem_base = xmlMemBlocks();
    #####:44011:        writer = gen_xmlTextWriterPtr(n_writer, 0);
        -:44012:
    #####:44013:        ret_val = xmlTextWriterStartCDATA(writer);
    #####:44014:        desret_int(ret_val);
    #####:44015:        call_tests++;
    #####:44016:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:44017:        xmlResetLastError();
    #####:44018:        if (mem_base != xmlMemBlocks()) {
    #####:44019:            printf("Leak of %d blocks found in xmlTextWriterStartCDATA",
    #####:44020:	           xmlMemBlocks() - mem_base);
    #####:44021:	    test_ret++;
    #####:44022:            printf(" %d", n_writer);
    #####:44023:            printf("\n");
        -:44024:        }
        -:44025:    }
    #####:44026:    function_tests++;
        -:44027:#endif
        -:44028:
    #####:44029:    return(test_ret);
        -:44030:}
        -:44031:
        -:44032:
        -:44033:static int
    #####:44034:test_xmlTextWriterStartComment(void) {
    #####:44035:    int test_ret = 0;
        -:44036:
        -:44037:#if defined(LIBXML_WRITER_ENABLED)
        -:44038:    int mem_base;
        -:44039:    int ret_val;
        -:44040:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:44041:    int n_writer;
        -:44042:
    #####:44043:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:44044:        mem_base = xmlMemBlocks();
    #####:44045:        writer = gen_xmlTextWriterPtr(n_writer, 0);
        -:44046:
    #####:44047:        ret_val = xmlTextWriterStartComment(writer);
    #####:44048:        desret_int(ret_val);
    #####:44049:        call_tests++;
    #####:44050:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:44051:        xmlResetLastError();
    #####:44052:        if (mem_base != xmlMemBlocks()) {
    #####:44053:            printf("Leak of %d blocks found in xmlTextWriterStartComment",
    #####:44054:	           xmlMemBlocks() - mem_base);
    #####:44055:	    test_ret++;
    #####:44056:            printf(" %d", n_writer);
    #####:44057:            printf("\n");
        -:44058:        }
        -:44059:    }
    #####:44060:    function_tests++;
        -:44061:#endif
        -:44062:
    #####:44063:    return(test_ret);
        -:44064:}
        -:44065:
        -:44066:
        -:44067:static int
    #####:44068:test_xmlTextWriterStartDTD(void) {
    #####:44069:    int test_ret = 0;
        -:44070:
        -:44071:#if defined(LIBXML_WRITER_ENABLED)
        -:44072:    int mem_base;
        -:44073:    int ret_val;
        -:44074:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:44075:    int n_writer;
        -:44076:    xmlChar * name; /* the name of the DTD */
        -:44077:    int n_name;
        -:44078:    xmlChar * pubid; /* the public identifier, which is an alternative to the system identifier */
        -:44079:    int n_pubid;
        -:44080:    xmlChar * sysid; /* the system identifier, which is the URI of the DTD */
        -:44081:    int n_sysid;
        -:44082:
    #####:44083:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:44084:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:44085:    for (n_pubid = 0;n_pubid < gen_nb_const_xmlChar_ptr;n_pubid++) {
    #####:44086:    for (n_sysid = 0;n_sysid < gen_nb_const_xmlChar_ptr;n_sysid++) {
    #####:44087:        mem_base = xmlMemBlocks();
    #####:44088:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:44089:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:44090:        pubid = gen_const_xmlChar_ptr(n_pubid, 2);
    #####:44091:        sysid = gen_const_xmlChar_ptr(n_sysid, 3);
        -:44092:
    #####:44093:        ret_val = xmlTextWriterStartDTD(writer, (const xmlChar *)name, (const xmlChar *)pubid, (const xmlChar *)sysid);
    #####:44094:        desret_int(ret_val);
    #####:44095:        call_tests++;
    #####:44096:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:44097:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:44098:        des_const_xmlChar_ptr(n_pubid, (const xmlChar *)pubid, 2);
    #####:44099:        des_const_xmlChar_ptr(n_sysid, (const xmlChar *)sysid, 3);
    #####:44100:        xmlResetLastError();
    #####:44101:        if (mem_base != xmlMemBlocks()) {
    #####:44102:            printf("Leak of %d blocks found in xmlTextWriterStartDTD",
    #####:44103:	           xmlMemBlocks() - mem_base);
    #####:44104:	    test_ret++;
    #####:44105:            printf(" %d", n_writer);
    #####:44106:            printf(" %d", n_name);
    #####:44107:            printf(" %d", n_pubid);
    #####:44108:            printf(" %d", n_sysid);
    #####:44109:            printf("\n");
        -:44110:        }
        -:44111:    }
        -:44112:    }
        -:44113:    }
        -:44114:    }
    #####:44115:    function_tests++;
        -:44116:#endif
        -:44117:
    #####:44118:    return(test_ret);
        -:44119:}
        -:44120:
        -:44121:
        -:44122:static int
    #####:44123:test_xmlTextWriterStartDTDAttlist(void) {
    #####:44124:    int test_ret = 0;
        -:44125:
        -:44126:#if defined(LIBXML_WRITER_ENABLED)
        -:44127:    int mem_base;
        -:44128:    int ret_val;
        -:44129:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:44130:    int n_writer;
        -:44131:    xmlChar * name; /* the name of the DTD ATTLIST */
        -:44132:    int n_name;
        -:44133:
    #####:44134:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:44135:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:44136:        mem_base = xmlMemBlocks();
    #####:44137:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:44138:        name = gen_const_xmlChar_ptr(n_name, 1);
        -:44139:
    #####:44140:        ret_val = xmlTextWriterStartDTDAttlist(writer, (const xmlChar *)name);
    #####:44141:        desret_int(ret_val);
    #####:44142:        call_tests++;
    #####:44143:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:44144:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:44145:        xmlResetLastError();
    #####:44146:        if (mem_base != xmlMemBlocks()) {
    #####:44147:            printf("Leak of %d blocks found in xmlTextWriterStartDTDAttlist",
    #####:44148:	           xmlMemBlocks() - mem_base);
    #####:44149:	    test_ret++;
    #####:44150:            printf(" %d", n_writer);
    #####:44151:            printf(" %d", n_name);
    #####:44152:            printf("\n");
        -:44153:        }
        -:44154:    }
        -:44155:    }
    #####:44156:    function_tests++;
        -:44157:#endif
        -:44158:
    #####:44159:    return(test_ret);
        -:44160:}
        -:44161:
        -:44162:
        -:44163:static int
    #####:44164:test_xmlTextWriterStartDTDElement(void) {
    #####:44165:    int test_ret = 0;
        -:44166:
        -:44167:#if defined(LIBXML_WRITER_ENABLED)
        -:44168:    int mem_base;
        -:44169:    int ret_val;
        -:44170:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:44171:    int n_writer;
        -:44172:    xmlChar * name; /* the name of the DTD element */
        -:44173:    int n_name;
        -:44174:
    #####:44175:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:44176:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:44177:        mem_base = xmlMemBlocks();
    #####:44178:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:44179:        name = gen_const_xmlChar_ptr(n_name, 1);
        -:44180:
    #####:44181:        ret_val = xmlTextWriterStartDTDElement(writer, (const xmlChar *)name);
    #####:44182:        desret_int(ret_val);
    #####:44183:        call_tests++;
    #####:44184:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:44185:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:44186:        xmlResetLastError();
    #####:44187:        if (mem_base != xmlMemBlocks()) {
    #####:44188:            printf("Leak of %d blocks found in xmlTextWriterStartDTDElement",
    #####:44189:	           xmlMemBlocks() - mem_base);
    #####:44190:	    test_ret++;
    #####:44191:            printf(" %d", n_writer);
    #####:44192:            printf(" %d", n_name);
    #####:44193:            printf("\n");
        -:44194:        }
        -:44195:    }
        -:44196:    }
    #####:44197:    function_tests++;
        -:44198:#endif
        -:44199:
    #####:44200:    return(test_ret);
        -:44201:}
        -:44202:
        -:44203:
        -:44204:static int
    #####:44205:test_xmlTextWriterStartDTDEntity(void) {
    #####:44206:    int test_ret = 0;
        -:44207:
        -:44208:#if defined(LIBXML_WRITER_ENABLED)
        -:44209:    int mem_base;
        -:44210:    int ret_val;
        -:44211:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:44212:    int n_writer;
        -:44213:    int pe; /* TRUE if this is a parameter entity, FALSE if not */
        -:44214:    int n_pe;
        -:44215:    xmlChar * name; /* the name of the DTD ATTLIST */
        -:44216:    int n_name;
        -:44217:
    #####:44218:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:44219:    for (n_pe = 0;n_pe < gen_nb_int;n_pe++) {
    #####:44220:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:44221:        mem_base = xmlMemBlocks();
    #####:44222:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:44223:        pe = gen_int(n_pe, 1);
    #####:44224:        name = gen_const_xmlChar_ptr(n_name, 2);
        -:44225:
    #####:44226:        ret_val = xmlTextWriterStartDTDEntity(writer, pe, (const xmlChar *)name);
    #####:44227:        desret_int(ret_val);
    #####:44228:        call_tests++;
    #####:44229:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:44230:        des_int(n_pe, pe, 1);
    #####:44231:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
    #####:44232:        xmlResetLastError();
    #####:44233:        if (mem_base != xmlMemBlocks()) {
    #####:44234:            printf("Leak of %d blocks found in xmlTextWriterStartDTDEntity",
    #####:44235:	           xmlMemBlocks() - mem_base);
    #####:44236:	    test_ret++;
    #####:44237:            printf(" %d", n_writer);
    #####:44238:            printf(" %d", n_pe);
    #####:44239:            printf(" %d", n_name);
    #####:44240:            printf("\n");
        -:44241:        }
        -:44242:    }
        -:44243:    }
        -:44244:    }
    #####:44245:    function_tests++;
        -:44246:#endif
        -:44247:
    #####:44248:    return(test_ret);
        -:44249:}
        -:44250:
        -:44251:
        -:44252:static int
    #####:44253:test_xmlTextWriterStartDocument(void) {
    #####:44254:    int test_ret = 0;
        -:44255:
        -:44256:#if defined(LIBXML_WRITER_ENABLED)
        -:44257:    int mem_base;
        -:44258:    int ret_val;
        -:44259:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:44260:    int n_writer;
        -:44261:    char * version; /* the xml version ("1.0") or NULL for default ("1.0") */
        -:44262:    int n_version;
        -:44263:    char * encoding; /* the encoding or NULL for default */
        -:44264:    int n_encoding;
        -:44265:    char * standalone; /* "yes" or "no" or NULL for default */
        -:44266:    int n_standalone;
        -:44267:
    #####:44268:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:44269:    for (n_version = 0;n_version < gen_nb_const_char_ptr;n_version++) {
    #####:44270:    for (n_encoding = 0;n_encoding < gen_nb_const_char_ptr;n_encoding++) {
    #####:44271:    for (n_standalone = 0;n_standalone < gen_nb_const_char_ptr;n_standalone++) {
    #####:44272:        mem_base = xmlMemBlocks();
    #####:44273:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:44274:        version = gen_const_char_ptr(n_version, 1);
    #####:44275:        encoding = gen_const_char_ptr(n_encoding, 2);
    #####:44276:        standalone = gen_const_char_ptr(n_standalone, 3);
        -:44277:
    #####:44278:        ret_val = xmlTextWriterStartDocument(writer, (const char *)version, (const char *)encoding, (const char *)standalone);
    #####:44279:        desret_int(ret_val);
    #####:44280:        call_tests++;
    #####:44281:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:44282:        des_const_char_ptr(n_version, (const char *)version, 1);
    #####:44283:        des_const_char_ptr(n_encoding, (const char *)encoding, 2);
    #####:44284:        des_const_char_ptr(n_standalone, (const char *)standalone, 3);
    #####:44285:        xmlResetLastError();
    #####:44286:        if (mem_base != xmlMemBlocks()) {
    #####:44287:            printf("Leak of %d blocks found in xmlTextWriterStartDocument",
    #####:44288:	           xmlMemBlocks() - mem_base);
    #####:44289:	    test_ret++;
    #####:44290:            printf(" %d", n_writer);
    #####:44291:            printf(" %d", n_version);
    #####:44292:            printf(" %d", n_encoding);
    #####:44293:            printf(" %d", n_standalone);
    #####:44294:            printf("\n");
        -:44295:        }
        -:44296:    }
        -:44297:    }
        -:44298:    }
        -:44299:    }
    #####:44300:    function_tests++;
        -:44301:#endif
        -:44302:
    #####:44303:    return(test_ret);
        -:44304:}
        -:44305:
        -:44306:
        -:44307:static int
    #####:44308:test_xmlTextWriterStartElement(void) {
    #####:44309:    int test_ret = 0;
        -:44310:
        -:44311:#if defined(LIBXML_WRITER_ENABLED)
        -:44312:    int mem_base;
        -:44313:    int ret_val;
        -:44314:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:44315:    int n_writer;
        -:44316:    xmlChar * name; /* element name */
        -:44317:    int n_name;
        -:44318:
    #####:44319:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:44320:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:44321:        mem_base = xmlMemBlocks();
    #####:44322:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:44323:        name = gen_const_xmlChar_ptr(n_name, 1);
        -:44324:
    #####:44325:        ret_val = xmlTextWriterStartElement(writer, (const xmlChar *)name);
    #####:44326:        desret_int(ret_val);
    #####:44327:        call_tests++;
    #####:44328:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:44329:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:44330:        xmlResetLastError();
    #####:44331:        if (mem_base != xmlMemBlocks()) {
    #####:44332:            printf("Leak of %d blocks found in xmlTextWriterStartElement",
    #####:44333:	           xmlMemBlocks() - mem_base);
    #####:44334:	    test_ret++;
    #####:44335:            printf(" %d", n_writer);
    #####:44336:            printf(" %d", n_name);
    #####:44337:            printf("\n");
        -:44338:        }
        -:44339:    }
        -:44340:    }
    #####:44341:    function_tests++;
        -:44342:#endif
        -:44343:
    #####:44344:    return(test_ret);
        -:44345:}
        -:44346:
        -:44347:
        -:44348:static int
    #####:44349:test_xmlTextWriterStartElementNS(void) {
    #####:44350:    int test_ret = 0;
        -:44351:
        -:44352:#if defined(LIBXML_WRITER_ENABLED)
        -:44353:    int mem_base;
        -:44354:    int ret_val;
        -:44355:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:44356:    int n_writer;
        -:44357:    xmlChar * prefix; /* namespace prefix or NULL */
        -:44358:    int n_prefix;
        -:44359:    xmlChar * name; /* element local name */
        -:44360:    int n_name;
        -:44361:    xmlChar * namespaceURI; /* namespace URI or NULL */
        -:44362:    int n_namespaceURI;
        -:44363:
    #####:44364:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:44365:    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    #####:44366:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:44367:    for (n_namespaceURI = 0;n_namespaceURI < gen_nb_const_xmlChar_ptr;n_namespaceURI++) {
    #####:44368:        mem_base = xmlMemBlocks();
    #####:44369:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:44370:        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
    #####:44371:        name = gen_const_xmlChar_ptr(n_name, 2);
    #####:44372:        namespaceURI = gen_const_xmlChar_ptr(n_namespaceURI, 3);
        -:44373:
    #####:44374:        ret_val = xmlTextWriterStartElementNS(writer, (const xmlChar *)prefix, (const xmlChar *)name, (const xmlChar *)namespaceURI);
    #####:44375:        desret_int(ret_val);
    #####:44376:        call_tests++;
    #####:44377:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:44378:        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 1);
    #####:44379:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
    #####:44380:        des_const_xmlChar_ptr(n_namespaceURI, (const xmlChar *)namespaceURI, 3);
    #####:44381:        xmlResetLastError();
    #####:44382:        if (mem_base != xmlMemBlocks()) {
    #####:44383:            printf("Leak of %d blocks found in xmlTextWriterStartElementNS",
    #####:44384:	           xmlMemBlocks() - mem_base);
    #####:44385:	    test_ret++;
    #####:44386:            printf(" %d", n_writer);
    #####:44387:            printf(" %d", n_prefix);
    #####:44388:            printf(" %d", n_name);
    #####:44389:            printf(" %d", n_namespaceURI);
    #####:44390:            printf("\n");
        -:44391:        }
        -:44392:    }
        -:44393:    }
        -:44394:    }
        -:44395:    }
    #####:44396:    function_tests++;
        -:44397:#endif
        -:44398:
    #####:44399:    return(test_ret);
        -:44400:}
        -:44401:
        -:44402:
        -:44403:static int
    #####:44404:test_xmlTextWriterStartPI(void) {
    #####:44405:    int test_ret = 0;
        -:44406:
        -:44407:#if defined(LIBXML_WRITER_ENABLED)
        -:44408:    int mem_base;
        -:44409:    int ret_val;
        -:44410:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:44411:    int n_writer;
        -:44412:    xmlChar * target; /* PI target */
        -:44413:    int n_target;
        -:44414:
    #####:44415:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:44416:    for (n_target = 0;n_target < gen_nb_const_xmlChar_ptr;n_target++) {
    #####:44417:        mem_base = xmlMemBlocks();
    #####:44418:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:44419:        target = gen_const_xmlChar_ptr(n_target, 1);
        -:44420:
    #####:44421:        ret_val = xmlTextWriterStartPI(writer, (const xmlChar *)target);
    #####:44422:        desret_int(ret_val);
    #####:44423:        call_tests++;
    #####:44424:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:44425:        des_const_xmlChar_ptr(n_target, (const xmlChar *)target, 1);
    #####:44426:        xmlResetLastError();
    #####:44427:        if (mem_base != xmlMemBlocks()) {
    #####:44428:            printf("Leak of %d blocks found in xmlTextWriterStartPI",
    #####:44429:	           xmlMemBlocks() - mem_base);
    #####:44430:	    test_ret++;
    #####:44431:            printf(" %d", n_writer);
    #####:44432:            printf(" %d", n_target);
    #####:44433:            printf("\n");
        -:44434:        }
        -:44435:    }
        -:44436:    }
    #####:44437:    function_tests++;
        -:44438:#endif
        -:44439:
    #####:44440:    return(test_ret);
        -:44441:}
        -:44442:
        -:44443:
        -:44444:static int
    #####:44445:test_xmlTextWriterWriteAttribute(void) {
    #####:44446:    int test_ret = 0;
        -:44447:
        -:44448:#if defined(LIBXML_WRITER_ENABLED)
        -:44449:    int mem_base;
        -:44450:    int ret_val;
        -:44451:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:44452:    int n_writer;
        -:44453:    xmlChar * name; /* attribute name */
        -:44454:    int n_name;
        -:44455:    xmlChar * content; /* attribute content */
        -:44456:    int n_content;
        -:44457:
    #####:44458:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:44459:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:44460:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:44461:        mem_base = xmlMemBlocks();
    #####:44462:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:44463:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:44464:        content = gen_const_xmlChar_ptr(n_content, 2);
        -:44465:
    #####:44466:        ret_val = xmlTextWriterWriteAttribute(writer, (const xmlChar *)name, (const xmlChar *)content);
    #####:44467:        desret_int(ret_val);
    #####:44468:        call_tests++;
    #####:44469:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:44470:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:44471:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 2);
    #####:44472:        xmlResetLastError();
    #####:44473:        if (mem_base != xmlMemBlocks()) {
    #####:44474:            printf("Leak of %d blocks found in xmlTextWriterWriteAttribute",
    #####:44475:	           xmlMemBlocks() - mem_base);
    #####:44476:	    test_ret++;
    #####:44477:            printf(" %d", n_writer);
    #####:44478:            printf(" %d", n_name);
    #####:44479:            printf(" %d", n_content);
    #####:44480:            printf("\n");
        -:44481:        }
        -:44482:    }
        -:44483:    }
        -:44484:    }
    #####:44485:    function_tests++;
        -:44486:#endif
        -:44487:
    #####:44488:    return(test_ret);
        -:44489:}
        -:44490:
        -:44491:
        -:44492:static int
    #####:44493:test_xmlTextWriterWriteAttributeNS(void) {
    #####:44494:    int test_ret = 0;
        -:44495:
        -:44496:#if defined(LIBXML_WRITER_ENABLED)
        -:44497:    int mem_base;
        -:44498:    int ret_val;
        -:44499:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:44500:    int n_writer;
        -:44501:    xmlChar * prefix; /* namespace prefix */
        -:44502:    int n_prefix;
        -:44503:    xmlChar * name; /* attribute local name */
        -:44504:    int n_name;
        -:44505:    xmlChar * namespaceURI; /* namespace URI */
        -:44506:    int n_namespaceURI;
        -:44507:    xmlChar * content; /* attribute content */
        -:44508:    int n_content;
        -:44509:
    #####:44510:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:44511:    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    #####:44512:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:44513:    for (n_namespaceURI = 0;n_namespaceURI < gen_nb_const_xmlChar_ptr;n_namespaceURI++) {
    #####:44514:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:44515:        mem_base = xmlMemBlocks();
    #####:44516:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:44517:        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
    #####:44518:        name = gen_const_xmlChar_ptr(n_name, 2);
    #####:44519:        namespaceURI = gen_const_xmlChar_ptr(n_namespaceURI, 3);
    #####:44520:        content = gen_const_xmlChar_ptr(n_content, 4);
        -:44521:
    #####:44522:        ret_val = xmlTextWriterWriteAttributeNS(writer, (const xmlChar *)prefix, (const xmlChar *)name, (const xmlChar *)namespaceURI, (const xmlChar *)content);
    #####:44523:        desret_int(ret_val);
    #####:44524:        call_tests++;
    #####:44525:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:44526:        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 1);
    #####:44527:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
    #####:44528:        des_const_xmlChar_ptr(n_namespaceURI, (const xmlChar *)namespaceURI, 3);
    #####:44529:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 4);
    #####:44530:        xmlResetLastError();
    #####:44531:        if (mem_base != xmlMemBlocks()) {
    #####:44532:            printf("Leak of %d blocks found in xmlTextWriterWriteAttributeNS",
    #####:44533:	           xmlMemBlocks() - mem_base);
    #####:44534:	    test_ret++;
    #####:44535:            printf(" %d", n_writer);
    #####:44536:            printf(" %d", n_prefix);
    #####:44537:            printf(" %d", n_name);
    #####:44538:            printf(" %d", n_namespaceURI);
    #####:44539:            printf(" %d", n_content);
    #####:44540:            printf("\n");
        -:44541:        }
        -:44542:    }
        -:44543:    }
        -:44544:    }
        -:44545:    }
        -:44546:    }
    #####:44547:    function_tests++;
        -:44548:#endif
        -:44549:
    #####:44550:    return(test_ret);
        -:44551:}
        -:44552:
        -:44553:
        -:44554:static int
    #####:44555:test_xmlTextWriterWriteBase64(void) {
    #####:44556:    int test_ret = 0;
        -:44557:
        -:44558:#if defined(LIBXML_WRITER_ENABLED)
        -:44559:    int mem_base;
        -:44560:    int ret_val;
        -:44561:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:44562:    int n_writer;
        -:44563:    char * data; /* binary data */
        -:44564:    int n_data;
        -:44565:    int start; /* the position within the data of the first byte to encode */
        -:44566:    int n_start;
        -:44567:    int len; /* the number of bytes to encode */
        -:44568:    int n_len;
        -:44569:
    #####:44570:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:44571:    for (n_data = 0;n_data < gen_nb_const_char_ptr;n_data++) {
    #####:44572:    for (n_start = 0;n_start < gen_nb_int;n_start++) {
    #####:44573:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:44574:        mem_base = xmlMemBlocks();
    #####:44575:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:44576:        data = gen_const_char_ptr(n_data, 1);
    #####:44577:        start = gen_int(n_start, 2);
    #####:44578:        len = gen_int(n_len, 3);
        -:44579:
    #####:44580:        ret_val = xmlTextWriterWriteBase64(writer, (const char *)data, start, len);
    #####:44581:        desret_int(ret_val);
    #####:44582:        call_tests++;
    #####:44583:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:44584:        des_const_char_ptr(n_data, (const char *)data, 1);
    #####:44585:        des_int(n_start, start, 2);
    #####:44586:        des_int(n_len, len, 3);
    #####:44587:        xmlResetLastError();
    #####:44588:        if (mem_base != xmlMemBlocks()) {
    #####:44589:            printf("Leak of %d blocks found in xmlTextWriterWriteBase64",
    #####:44590:	           xmlMemBlocks() - mem_base);
    #####:44591:	    test_ret++;
    #####:44592:            printf(" %d", n_writer);
    #####:44593:            printf(" %d", n_data);
    #####:44594:            printf(" %d", n_start);
    #####:44595:            printf(" %d", n_len);
    #####:44596:            printf("\n");
        -:44597:        }
        -:44598:    }
        -:44599:    }
        -:44600:    }
        -:44601:    }
    #####:44602:    function_tests++;
        -:44603:#endif
        -:44604:
    #####:44605:    return(test_ret);
        -:44606:}
        -:44607:
        -:44608:
        -:44609:static int
    #####:44610:test_xmlTextWriterWriteBinHex(void) {
    #####:44611:    int test_ret = 0;
        -:44612:
        -:44613:#if defined(LIBXML_WRITER_ENABLED)
        -:44614:    int mem_base;
        -:44615:    int ret_val;
        -:44616:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:44617:    int n_writer;
        -:44618:    char * data; /* binary data */
        -:44619:    int n_data;
        -:44620:    int start; /* the position within the data of the first byte to encode */
        -:44621:    int n_start;
        -:44622:    int len; /* the number of bytes to encode */
        -:44623:    int n_len;
        -:44624:
    #####:44625:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:44626:    for (n_data = 0;n_data < gen_nb_const_char_ptr;n_data++) {
    #####:44627:    for (n_start = 0;n_start < gen_nb_int;n_start++) {
    #####:44628:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:44629:        mem_base = xmlMemBlocks();
    #####:44630:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:44631:        data = gen_const_char_ptr(n_data, 1);
    #####:44632:        start = gen_int(n_start, 2);
    #####:44633:        len = gen_int(n_len, 3);
        -:44634:
    #####:44635:        ret_val = xmlTextWriterWriteBinHex(writer, (const char *)data, start, len);
    #####:44636:        desret_int(ret_val);
    #####:44637:        call_tests++;
    #####:44638:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:44639:        des_const_char_ptr(n_data, (const char *)data, 1);
    #####:44640:        des_int(n_start, start, 2);
    #####:44641:        des_int(n_len, len, 3);
    #####:44642:        xmlResetLastError();
    #####:44643:        if (mem_base != xmlMemBlocks()) {
    #####:44644:            printf("Leak of %d blocks found in xmlTextWriterWriteBinHex",
    #####:44645:	           xmlMemBlocks() - mem_base);
    #####:44646:	    test_ret++;
    #####:44647:            printf(" %d", n_writer);
    #####:44648:            printf(" %d", n_data);
    #####:44649:            printf(" %d", n_start);
    #####:44650:            printf(" %d", n_len);
    #####:44651:            printf("\n");
        -:44652:        }
        -:44653:    }
        -:44654:    }
        -:44655:    }
        -:44656:    }
    #####:44657:    function_tests++;
        -:44658:#endif
        -:44659:
    #####:44660:    return(test_ret);
        -:44661:}
        -:44662:
        -:44663:
        -:44664:static int
    #####:44665:test_xmlTextWriterWriteCDATA(void) {
    #####:44666:    int test_ret = 0;
        -:44667:
        -:44668:#if defined(LIBXML_WRITER_ENABLED)
        -:44669:    int mem_base;
        -:44670:    int ret_val;
        -:44671:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:44672:    int n_writer;
        -:44673:    xmlChar * content; /* CDATA content */
        -:44674:    int n_content;
        -:44675:
    #####:44676:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:44677:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:44678:        mem_base = xmlMemBlocks();
    #####:44679:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:44680:        content = gen_const_xmlChar_ptr(n_content, 1);
        -:44681:
    #####:44682:        ret_val = xmlTextWriterWriteCDATA(writer, (const xmlChar *)content);
    #####:44683:        desret_int(ret_val);
    #####:44684:        call_tests++;
    #####:44685:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:44686:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
    #####:44687:        xmlResetLastError();
    #####:44688:        if (mem_base != xmlMemBlocks()) {
    #####:44689:            printf("Leak of %d blocks found in xmlTextWriterWriteCDATA",
    #####:44690:	           xmlMemBlocks() - mem_base);
    #####:44691:	    test_ret++;
    #####:44692:            printf(" %d", n_writer);
    #####:44693:            printf(" %d", n_content);
    #####:44694:            printf("\n");
        -:44695:        }
        -:44696:    }
        -:44697:    }
    #####:44698:    function_tests++;
        -:44699:#endif
        -:44700:
    #####:44701:    return(test_ret);
        -:44702:}
        -:44703:
        -:44704:
        -:44705:static int
    #####:44706:test_xmlTextWriterWriteComment(void) {
    #####:44707:    int test_ret = 0;
        -:44708:
        -:44709:#if defined(LIBXML_WRITER_ENABLED)
        -:44710:    int mem_base;
        -:44711:    int ret_val;
        -:44712:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:44713:    int n_writer;
        -:44714:    xmlChar * content; /* comment string */
        -:44715:    int n_content;
        -:44716:
    #####:44717:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:44718:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:44719:        mem_base = xmlMemBlocks();
    #####:44720:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:44721:        content = gen_const_xmlChar_ptr(n_content, 1);
        -:44722:
    #####:44723:        ret_val = xmlTextWriterWriteComment(writer, (const xmlChar *)content);
    #####:44724:        desret_int(ret_val);
    #####:44725:        call_tests++;
    #####:44726:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:44727:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
    #####:44728:        xmlResetLastError();
    #####:44729:        if (mem_base != xmlMemBlocks()) {
    #####:44730:            printf("Leak of %d blocks found in xmlTextWriterWriteComment",
    #####:44731:	           xmlMemBlocks() - mem_base);
    #####:44732:	    test_ret++;
    #####:44733:            printf(" %d", n_writer);
    #####:44734:            printf(" %d", n_content);
    #####:44735:            printf("\n");
        -:44736:        }
        -:44737:    }
        -:44738:    }
    #####:44739:    function_tests++;
        -:44740:#endif
        -:44741:
    #####:44742:    return(test_ret);
        -:44743:}
        -:44744:
        -:44745:
        -:44746:static int
    #####:44747:test_xmlTextWriterWriteDTD(void) {
    #####:44748:    int test_ret = 0;
        -:44749:
        -:44750:#if defined(LIBXML_WRITER_ENABLED)
        -:44751:    int mem_base;
        -:44752:    int ret_val;
        -:44753:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:44754:    int n_writer;
        -:44755:    xmlChar * name; /* the name of the DTD */
        -:44756:    int n_name;
        -:44757:    xmlChar * pubid; /* the public identifier, which is an alternative to the system identifier */
        -:44758:    int n_pubid;
        -:44759:    xmlChar * sysid; /* the system identifier, which is the URI of the DTD */
        -:44760:    int n_sysid;
        -:44761:    xmlChar * subset; /* string content of the DTD */
        -:44762:    int n_subset;
        -:44763:
    #####:44764:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:44765:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:44766:    for (n_pubid = 0;n_pubid < gen_nb_const_xmlChar_ptr;n_pubid++) {
    #####:44767:    for (n_sysid = 0;n_sysid < gen_nb_const_xmlChar_ptr;n_sysid++) {
    #####:44768:    for (n_subset = 0;n_subset < gen_nb_const_xmlChar_ptr;n_subset++) {
    #####:44769:        mem_base = xmlMemBlocks();
    #####:44770:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:44771:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:44772:        pubid = gen_const_xmlChar_ptr(n_pubid, 2);
    #####:44773:        sysid = gen_const_xmlChar_ptr(n_sysid, 3);
    #####:44774:        subset = gen_const_xmlChar_ptr(n_subset, 4);
        -:44775:
    #####:44776:        ret_val = xmlTextWriterWriteDTD(writer, (const xmlChar *)name, (const xmlChar *)pubid, (const xmlChar *)sysid, (const xmlChar *)subset);
    #####:44777:        desret_int(ret_val);
    #####:44778:        call_tests++;
    #####:44779:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:44780:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:44781:        des_const_xmlChar_ptr(n_pubid, (const xmlChar *)pubid, 2);
    #####:44782:        des_const_xmlChar_ptr(n_sysid, (const xmlChar *)sysid, 3);
    #####:44783:        des_const_xmlChar_ptr(n_subset, (const xmlChar *)subset, 4);
    #####:44784:        xmlResetLastError();
    #####:44785:        if (mem_base != xmlMemBlocks()) {
    #####:44786:            printf("Leak of %d blocks found in xmlTextWriterWriteDTD",
    #####:44787:	           xmlMemBlocks() - mem_base);
    #####:44788:	    test_ret++;
    #####:44789:            printf(" %d", n_writer);
    #####:44790:            printf(" %d", n_name);
    #####:44791:            printf(" %d", n_pubid);
    #####:44792:            printf(" %d", n_sysid);
    #####:44793:            printf(" %d", n_subset);
    #####:44794:            printf("\n");
        -:44795:        }
        -:44796:    }
        -:44797:    }
        -:44798:    }
        -:44799:    }
        -:44800:    }
    #####:44801:    function_tests++;
        -:44802:#endif
        -:44803:
    #####:44804:    return(test_ret);
        -:44805:}
        -:44806:
        -:44807:
        -:44808:static int
    #####:44809:test_xmlTextWriterWriteDTDAttlist(void) {
    #####:44810:    int test_ret = 0;
        -:44811:
        -:44812:#if defined(LIBXML_WRITER_ENABLED)
        -:44813:    int mem_base;
        -:44814:    int ret_val;
        -:44815:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:44816:    int n_writer;
        -:44817:    xmlChar * name; /* the name of the DTD ATTLIST */
        -:44818:    int n_name;
        -:44819:    xmlChar * content; /* content of the ATTLIST */
        -:44820:    int n_content;
        -:44821:
    #####:44822:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:44823:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:44824:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:44825:        mem_base = xmlMemBlocks();
    #####:44826:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:44827:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:44828:        content = gen_const_xmlChar_ptr(n_content, 2);
        -:44829:
    #####:44830:        ret_val = xmlTextWriterWriteDTDAttlist(writer, (const xmlChar *)name, (const xmlChar *)content);
    #####:44831:        desret_int(ret_val);
    #####:44832:        call_tests++;
    #####:44833:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:44834:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:44835:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 2);
    #####:44836:        xmlResetLastError();
    #####:44837:        if (mem_base != xmlMemBlocks()) {
    #####:44838:            printf("Leak of %d blocks found in xmlTextWriterWriteDTDAttlist",
    #####:44839:	           xmlMemBlocks() - mem_base);
    #####:44840:	    test_ret++;
    #####:44841:            printf(" %d", n_writer);
    #####:44842:            printf(" %d", n_name);
    #####:44843:            printf(" %d", n_content);
    #####:44844:            printf("\n");
        -:44845:        }
        -:44846:    }
        -:44847:    }
        -:44848:    }
    #####:44849:    function_tests++;
        -:44850:#endif
        -:44851:
    #####:44852:    return(test_ret);
        -:44853:}
        -:44854:
        -:44855:
        -:44856:static int
    #####:44857:test_xmlTextWriterWriteDTDElement(void) {
    #####:44858:    int test_ret = 0;
        -:44859:
        -:44860:#if defined(LIBXML_WRITER_ENABLED)
        -:44861:    int mem_base;
        -:44862:    int ret_val;
        -:44863:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:44864:    int n_writer;
        -:44865:    xmlChar * name; /* the name of the DTD element */
        -:44866:    int n_name;
        -:44867:    xmlChar * content; /* content of the element */
        -:44868:    int n_content;
        -:44869:
    #####:44870:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:44871:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:44872:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:44873:        mem_base = xmlMemBlocks();
    #####:44874:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:44875:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:44876:        content = gen_const_xmlChar_ptr(n_content, 2);
        -:44877:
    #####:44878:        ret_val = xmlTextWriterWriteDTDElement(writer, (const xmlChar *)name, (const xmlChar *)content);
    #####:44879:        desret_int(ret_val);
    #####:44880:        call_tests++;
    #####:44881:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:44882:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:44883:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 2);
    #####:44884:        xmlResetLastError();
    #####:44885:        if (mem_base != xmlMemBlocks()) {
    #####:44886:            printf("Leak of %d blocks found in xmlTextWriterWriteDTDElement",
    #####:44887:	           xmlMemBlocks() - mem_base);
    #####:44888:	    test_ret++;
    #####:44889:            printf(" %d", n_writer);
    #####:44890:            printf(" %d", n_name);
    #####:44891:            printf(" %d", n_content);
    #####:44892:            printf("\n");
        -:44893:        }
        -:44894:    }
        -:44895:    }
        -:44896:    }
    #####:44897:    function_tests++;
        -:44898:#endif
        -:44899:
    #####:44900:    return(test_ret);
        -:44901:}
        -:44902:
        -:44903:
        -:44904:static int
    #####:44905:test_xmlTextWriterWriteDTDEntity(void) {
    #####:44906:    int test_ret = 0;
        -:44907:
        -:44908:#if defined(LIBXML_WRITER_ENABLED)
        -:44909:    int mem_base;
        -:44910:    int ret_val;
        -:44911:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:44912:    int n_writer;
        -:44913:    int pe; /* TRUE if this is a parameter entity, FALSE if not */
        -:44914:    int n_pe;
        -:44915:    xmlChar * name; /* the name of the DTD entity */
        -:44916:    int n_name;
        -:44917:    xmlChar * pubid; /* the public identifier, which is an alternative to the system identifier */
        -:44918:    int n_pubid;
        -:44919:    xmlChar * sysid; /* the system identifier, which is the URI of the DTD */
        -:44920:    int n_sysid;
        -:44921:    xmlChar * ndataid; /* the xml notation name. */
        -:44922:    int n_ndataid;
        -:44923:    xmlChar * content; /* content of the entity */
        -:44924:    int n_content;
        -:44925:
    #####:44926:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:44927:    for (n_pe = 0;n_pe < gen_nb_int;n_pe++) {
    #####:44928:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:44929:    for (n_pubid = 0;n_pubid < gen_nb_const_xmlChar_ptr;n_pubid++) {
    #####:44930:    for (n_sysid = 0;n_sysid < gen_nb_const_xmlChar_ptr;n_sysid++) {
    #####:44931:    for (n_ndataid = 0;n_ndataid < gen_nb_const_xmlChar_ptr;n_ndataid++) {
    #####:44932:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:44933:        mem_base = xmlMemBlocks();
    #####:44934:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:44935:        pe = gen_int(n_pe, 1);
    #####:44936:        name = gen_const_xmlChar_ptr(n_name, 2);
    #####:44937:        pubid = gen_const_xmlChar_ptr(n_pubid, 3);
    #####:44938:        sysid = gen_const_xmlChar_ptr(n_sysid, 4);
    #####:44939:        ndataid = gen_const_xmlChar_ptr(n_ndataid, 5);
    #####:44940:        content = gen_const_xmlChar_ptr(n_content, 6);
        -:44941:
    #####:44942:        ret_val = xmlTextWriterWriteDTDEntity(writer, pe, (const xmlChar *)name, (const xmlChar *)pubid, (const xmlChar *)sysid, (const xmlChar *)ndataid, (const xmlChar *)content);
    #####:44943:        desret_int(ret_val);
    #####:44944:        call_tests++;
    #####:44945:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:44946:        des_int(n_pe, pe, 1);
    #####:44947:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
    #####:44948:        des_const_xmlChar_ptr(n_pubid, (const xmlChar *)pubid, 3);
    #####:44949:        des_const_xmlChar_ptr(n_sysid, (const xmlChar *)sysid, 4);
    #####:44950:        des_const_xmlChar_ptr(n_ndataid, (const xmlChar *)ndataid, 5);
    #####:44951:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 6);
    #####:44952:        xmlResetLastError();
    #####:44953:        if (mem_base != xmlMemBlocks()) {
    #####:44954:            printf("Leak of %d blocks found in xmlTextWriterWriteDTDEntity",
    #####:44955:	           xmlMemBlocks() - mem_base);
    #####:44956:	    test_ret++;
    #####:44957:            printf(" %d", n_writer);
    #####:44958:            printf(" %d", n_pe);
    #####:44959:            printf(" %d", n_name);
    #####:44960:            printf(" %d", n_pubid);
    #####:44961:            printf(" %d", n_sysid);
    #####:44962:            printf(" %d", n_ndataid);
    #####:44963:            printf(" %d", n_content);
    #####:44964:            printf("\n");
        -:44965:        }
        -:44966:    }
        -:44967:    }
        -:44968:    }
        -:44969:    }
        -:44970:    }
        -:44971:    }
        -:44972:    }
    #####:44973:    function_tests++;
        -:44974:#endif
        -:44975:
    #####:44976:    return(test_ret);
        -:44977:}
        -:44978:
        -:44979:
        -:44980:static int
    #####:44981:test_xmlTextWriterWriteDTDExternalEntity(void) {
    #####:44982:    int test_ret = 0;
        -:44983:
        -:44984:#if defined(LIBXML_WRITER_ENABLED)
        -:44985:    int mem_base;
        -:44986:    int ret_val;
        -:44987:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:44988:    int n_writer;
        -:44989:    int pe; /* TRUE if this is a parameter entity, FALSE if not */
        -:44990:    int n_pe;
        -:44991:    xmlChar * name; /* the name of the DTD entity */
        -:44992:    int n_name;
        -:44993:    xmlChar * pubid; /* the public identifier, which is an alternative to the system identifier */
        -:44994:    int n_pubid;
        -:44995:    xmlChar * sysid; /* the system identifier, which is the URI of the DTD */
        -:44996:    int n_sysid;
        -:44997:    xmlChar * ndataid; /* the xml notation name. */
        -:44998:    int n_ndataid;
        -:44999:
    #####:45000:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:45001:    for (n_pe = 0;n_pe < gen_nb_int;n_pe++) {
    #####:45002:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:45003:    for (n_pubid = 0;n_pubid < gen_nb_const_xmlChar_ptr;n_pubid++) {
    #####:45004:    for (n_sysid = 0;n_sysid < gen_nb_const_xmlChar_ptr;n_sysid++) {
    #####:45005:    for (n_ndataid = 0;n_ndataid < gen_nb_const_xmlChar_ptr;n_ndataid++) {
    #####:45006:        mem_base = xmlMemBlocks();
    #####:45007:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:45008:        pe = gen_int(n_pe, 1);
    #####:45009:        name = gen_const_xmlChar_ptr(n_name, 2);
    #####:45010:        pubid = gen_const_xmlChar_ptr(n_pubid, 3);
    #####:45011:        sysid = gen_const_xmlChar_ptr(n_sysid, 4);
    #####:45012:        ndataid = gen_const_xmlChar_ptr(n_ndataid, 5);
        -:45013:
    #####:45014:        ret_val = xmlTextWriterWriteDTDExternalEntity(writer, pe, (const xmlChar *)name, (const xmlChar *)pubid, (const xmlChar *)sysid, (const xmlChar *)ndataid);
    #####:45015:        desret_int(ret_val);
    #####:45016:        call_tests++;
    #####:45017:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:45018:        des_int(n_pe, pe, 1);
    #####:45019:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
    #####:45020:        des_const_xmlChar_ptr(n_pubid, (const xmlChar *)pubid, 3);
    #####:45021:        des_const_xmlChar_ptr(n_sysid, (const xmlChar *)sysid, 4);
    #####:45022:        des_const_xmlChar_ptr(n_ndataid, (const xmlChar *)ndataid, 5);
    #####:45023:        xmlResetLastError();
    #####:45024:        if (mem_base != xmlMemBlocks()) {
    #####:45025:            printf("Leak of %d blocks found in xmlTextWriterWriteDTDExternalEntity",
    #####:45026:	           xmlMemBlocks() - mem_base);
    #####:45027:	    test_ret++;
    #####:45028:            printf(" %d", n_writer);
    #####:45029:            printf(" %d", n_pe);
    #####:45030:            printf(" %d", n_name);
    #####:45031:            printf(" %d", n_pubid);
    #####:45032:            printf(" %d", n_sysid);
    #####:45033:            printf(" %d", n_ndataid);
    #####:45034:            printf("\n");
        -:45035:        }
        -:45036:    }
        -:45037:    }
        -:45038:    }
        -:45039:    }
        -:45040:    }
        -:45041:    }
    #####:45042:    function_tests++;
        -:45043:#endif
        -:45044:
    #####:45045:    return(test_ret);
        -:45046:}
        -:45047:
        -:45048:
        -:45049:static int
    #####:45050:test_xmlTextWriterWriteDTDExternalEntityContents(void) {
    #####:45051:    int test_ret = 0;
        -:45052:
        -:45053:#if defined(LIBXML_WRITER_ENABLED)
        -:45054:    int mem_base;
        -:45055:    int ret_val;
        -:45056:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:45057:    int n_writer;
        -:45058:    xmlChar * pubid; /* the public identifier, which is an alternative to the system identifier */
        -:45059:    int n_pubid;
        -:45060:    xmlChar * sysid; /* the system identifier, which is the URI of the DTD */
        -:45061:    int n_sysid;
        -:45062:    xmlChar * ndataid; /* the xml notation name. */
        -:45063:    int n_ndataid;
        -:45064:
    #####:45065:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:45066:    for (n_pubid = 0;n_pubid < gen_nb_const_xmlChar_ptr;n_pubid++) {
    #####:45067:    for (n_sysid = 0;n_sysid < gen_nb_const_xmlChar_ptr;n_sysid++) {
    #####:45068:    for (n_ndataid = 0;n_ndataid < gen_nb_const_xmlChar_ptr;n_ndataid++) {
    #####:45069:        mem_base = xmlMemBlocks();
    #####:45070:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:45071:        pubid = gen_const_xmlChar_ptr(n_pubid, 1);
    #####:45072:        sysid = gen_const_xmlChar_ptr(n_sysid, 2);
    #####:45073:        ndataid = gen_const_xmlChar_ptr(n_ndataid, 3);
        -:45074:
    #####:45075:        ret_val = xmlTextWriterWriteDTDExternalEntityContents(writer, (const xmlChar *)pubid, (const xmlChar *)sysid, (const xmlChar *)ndataid);
    #####:45076:        desret_int(ret_val);
    #####:45077:        call_tests++;
    #####:45078:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:45079:        des_const_xmlChar_ptr(n_pubid, (const xmlChar *)pubid, 1);
    #####:45080:        des_const_xmlChar_ptr(n_sysid, (const xmlChar *)sysid, 2);
    #####:45081:        des_const_xmlChar_ptr(n_ndataid, (const xmlChar *)ndataid, 3);
    #####:45082:        xmlResetLastError();
    #####:45083:        if (mem_base != xmlMemBlocks()) {
    #####:45084:            printf("Leak of %d blocks found in xmlTextWriterWriteDTDExternalEntityContents",
    #####:45085:	           xmlMemBlocks() - mem_base);
    #####:45086:	    test_ret++;
    #####:45087:            printf(" %d", n_writer);
    #####:45088:            printf(" %d", n_pubid);
    #####:45089:            printf(" %d", n_sysid);
    #####:45090:            printf(" %d", n_ndataid);
    #####:45091:            printf("\n");
        -:45092:        }
        -:45093:    }
        -:45094:    }
        -:45095:    }
        -:45096:    }
    #####:45097:    function_tests++;
        -:45098:#endif
        -:45099:
    #####:45100:    return(test_ret);
        -:45101:}
        -:45102:
        -:45103:
        -:45104:static int
    #####:45105:test_xmlTextWriterWriteDTDInternalEntity(void) {
    #####:45106:    int test_ret = 0;
        -:45107:
        -:45108:#if defined(LIBXML_WRITER_ENABLED)
        -:45109:    int mem_base;
        -:45110:    int ret_val;
        -:45111:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:45112:    int n_writer;
        -:45113:    int pe; /* TRUE if this is a parameter entity, FALSE if not */
        -:45114:    int n_pe;
        -:45115:    xmlChar * name; /* the name of the DTD entity */
        -:45116:    int n_name;
        -:45117:    xmlChar * content; /* content of the entity */
        -:45118:    int n_content;
        -:45119:
    #####:45120:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:45121:    for (n_pe = 0;n_pe < gen_nb_int;n_pe++) {
    #####:45122:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:45123:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:45124:        mem_base = xmlMemBlocks();
    #####:45125:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:45126:        pe = gen_int(n_pe, 1);
    #####:45127:        name = gen_const_xmlChar_ptr(n_name, 2);
    #####:45128:        content = gen_const_xmlChar_ptr(n_content, 3);
        -:45129:
    #####:45130:        ret_val = xmlTextWriterWriteDTDInternalEntity(writer, pe, (const xmlChar *)name, (const xmlChar *)content);
    #####:45131:        desret_int(ret_val);
    #####:45132:        call_tests++;
    #####:45133:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:45134:        des_int(n_pe, pe, 1);
    #####:45135:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
    #####:45136:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 3);
    #####:45137:        xmlResetLastError();
    #####:45138:        if (mem_base != xmlMemBlocks()) {
    #####:45139:            printf("Leak of %d blocks found in xmlTextWriterWriteDTDInternalEntity",
    #####:45140:	           xmlMemBlocks() - mem_base);
    #####:45141:	    test_ret++;
    #####:45142:            printf(" %d", n_writer);
    #####:45143:            printf(" %d", n_pe);
    #####:45144:            printf(" %d", n_name);
    #####:45145:            printf(" %d", n_content);
    #####:45146:            printf("\n");
        -:45147:        }
        -:45148:    }
        -:45149:    }
        -:45150:    }
        -:45151:    }
    #####:45152:    function_tests++;
        -:45153:#endif
        -:45154:
    #####:45155:    return(test_ret);
        -:45156:}
        -:45157:
        -:45158:
        -:45159:static int
    #####:45160:test_xmlTextWriterWriteDTDNotation(void) {
    #####:45161:    int test_ret = 0;
        -:45162:
        -:45163:#if defined(LIBXML_WRITER_ENABLED)
        -:45164:    int mem_base;
        -:45165:    int ret_val;
        -:45166:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:45167:    int n_writer;
        -:45168:    xmlChar * name; /* the name of the xml notation */
        -:45169:    int n_name;
        -:45170:    xmlChar * pubid; /* the public identifier, which is an alternative to the system identifier */
        -:45171:    int n_pubid;
        -:45172:    xmlChar * sysid; /* the system identifier, which is the URI of the DTD */
        -:45173:    int n_sysid;
        -:45174:
    #####:45175:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:45176:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:45177:    for (n_pubid = 0;n_pubid < gen_nb_const_xmlChar_ptr;n_pubid++) {
    #####:45178:    for (n_sysid = 0;n_sysid < gen_nb_const_xmlChar_ptr;n_sysid++) {
    #####:45179:        mem_base = xmlMemBlocks();
    #####:45180:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:45181:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:45182:        pubid = gen_const_xmlChar_ptr(n_pubid, 2);
    #####:45183:        sysid = gen_const_xmlChar_ptr(n_sysid, 3);
        -:45184:
    #####:45185:        ret_val = xmlTextWriterWriteDTDNotation(writer, (const xmlChar *)name, (const xmlChar *)pubid, (const xmlChar *)sysid);
    #####:45186:        desret_int(ret_val);
    #####:45187:        call_tests++;
    #####:45188:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:45189:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:45190:        des_const_xmlChar_ptr(n_pubid, (const xmlChar *)pubid, 2);
    #####:45191:        des_const_xmlChar_ptr(n_sysid, (const xmlChar *)sysid, 3);
    #####:45192:        xmlResetLastError();
    #####:45193:        if (mem_base != xmlMemBlocks()) {
    #####:45194:            printf("Leak of %d blocks found in xmlTextWriterWriteDTDNotation",
    #####:45195:	           xmlMemBlocks() - mem_base);
    #####:45196:	    test_ret++;
    #####:45197:            printf(" %d", n_writer);
    #####:45198:            printf(" %d", n_name);
    #####:45199:            printf(" %d", n_pubid);
    #####:45200:            printf(" %d", n_sysid);
    #####:45201:            printf("\n");
        -:45202:        }
        -:45203:    }
        -:45204:    }
        -:45205:    }
        -:45206:    }
    #####:45207:    function_tests++;
        -:45208:#endif
        -:45209:
    #####:45210:    return(test_ret);
        -:45211:}
        -:45212:
        -:45213:
        -:45214:static int
    #####:45215:test_xmlTextWriterWriteElement(void) {
    #####:45216:    int test_ret = 0;
        -:45217:
        -:45218:#if defined(LIBXML_WRITER_ENABLED)
        -:45219:    int mem_base;
        -:45220:    int ret_val;
        -:45221:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:45222:    int n_writer;
        -:45223:    xmlChar * name; /* element name */
        -:45224:    int n_name;
        -:45225:    xmlChar * content; /* element content */
        -:45226:    int n_content;
        -:45227:
    #####:45228:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:45229:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:45230:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:45231:        mem_base = xmlMemBlocks();
    #####:45232:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:45233:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:45234:        content = gen_const_xmlChar_ptr(n_content, 2);
        -:45235:
    #####:45236:        ret_val = xmlTextWriterWriteElement(writer, (const xmlChar *)name, (const xmlChar *)content);
    #####:45237:        desret_int(ret_val);
    #####:45238:        call_tests++;
    #####:45239:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:45240:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:45241:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 2);
    #####:45242:        xmlResetLastError();
    #####:45243:        if (mem_base != xmlMemBlocks()) {
    #####:45244:            printf("Leak of %d blocks found in xmlTextWriterWriteElement",
    #####:45245:	           xmlMemBlocks() - mem_base);
    #####:45246:	    test_ret++;
    #####:45247:            printf(" %d", n_writer);
    #####:45248:            printf(" %d", n_name);
    #####:45249:            printf(" %d", n_content);
    #####:45250:            printf("\n");
        -:45251:        }
        -:45252:    }
        -:45253:    }
        -:45254:    }
    #####:45255:    function_tests++;
        -:45256:#endif
        -:45257:
    #####:45258:    return(test_ret);
        -:45259:}
        -:45260:
        -:45261:
        -:45262:static int
    #####:45263:test_xmlTextWriterWriteElementNS(void) {
    #####:45264:    int test_ret = 0;
        -:45265:
        -:45266:#if defined(LIBXML_WRITER_ENABLED)
        -:45267:    int mem_base;
        -:45268:    int ret_val;
        -:45269:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:45270:    int n_writer;
        -:45271:    xmlChar * prefix; /* namespace prefix */
        -:45272:    int n_prefix;
        -:45273:    xmlChar * name; /* element local name */
        -:45274:    int n_name;
        -:45275:    xmlChar * namespaceURI; /* namespace URI */
        -:45276:    int n_namespaceURI;
        -:45277:    xmlChar * content; /* element content */
        -:45278:    int n_content;
        -:45279:
    #####:45280:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:45281:    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    #####:45282:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:45283:    for (n_namespaceURI = 0;n_namespaceURI < gen_nb_const_xmlChar_ptr;n_namespaceURI++) {
    #####:45284:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:45285:        mem_base = xmlMemBlocks();
    #####:45286:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:45287:        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
    #####:45288:        name = gen_const_xmlChar_ptr(n_name, 2);
    #####:45289:        namespaceURI = gen_const_xmlChar_ptr(n_namespaceURI, 3);
    #####:45290:        content = gen_const_xmlChar_ptr(n_content, 4);
        -:45291:
    #####:45292:        ret_val = xmlTextWriterWriteElementNS(writer, (const xmlChar *)prefix, (const xmlChar *)name, (const xmlChar *)namespaceURI, (const xmlChar *)content);
    #####:45293:        desret_int(ret_val);
    #####:45294:        call_tests++;
    #####:45295:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:45296:        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 1);
    #####:45297:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
    #####:45298:        des_const_xmlChar_ptr(n_namespaceURI, (const xmlChar *)namespaceURI, 3);
    #####:45299:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 4);
    #####:45300:        xmlResetLastError();
    #####:45301:        if (mem_base != xmlMemBlocks()) {
    #####:45302:            printf("Leak of %d blocks found in xmlTextWriterWriteElementNS",
    #####:45303:	           xmlMemBlocks() - mem_base);
    #####:45304:	    test_ret++;
    #####:45305:            printf(" %d", n_writer);
    #####:45306:            printf(" %d", n_prefix);
    #####:45307:            printf(" %d", n_name);
    #####:45308:            printf(" %d", n_namespaceURI);
    #####:45309:            printf(" %d", n_content);
    #####:45310:            printf("\n");
        -:45311:        }
        -:45312:    }
        -:45313:    }
        -:45314:    }
        -:45315:    }
        -:45316:    }
    #####:45317:    function_tests++;
        -:45318:#endif
        -:45319:
    #####:45320:    return(test_ret);
        -:45321:}
        -:45322:
        -:45323:
        -:45324:static int
    #####:45325:test_xmlTextWriterWriteFormatAttribute(void) {
    #####:45326:    int test_ret = 0;
        -:45327:
        -:45328:
        -:45329:    /* missing type support */
    #####:45330:    return(test_ret);
        -:45331:}
        -:45332:
        -:45333:
        -:45334:static int
    #####:45335:test_xmlTextWriterWriteFormatAttributeNS(void) {
    #####:45336:    int test_ret = 0;
        -:45337:
        -:45338:
        -:45339:    /* missing type support */
    #####:45340:    return(test_ret);
        -:45341:}
        -:45342:
        -:45343:
        -:45344:static int
    #####:45345:test_xmlTextWriterWriteFormatCDATA(void) {
    #####:45346:    int test_ret = 0;
        -:45347:
        -:45348:
        -:45349:    /* missing type support */
    #####:45350:    return(test_ret);
        -:45351:}
        -:45352:
        -:45353:
        -:45354:static int
    #####:45355:test_xmlTextWriterWriteFormatComment(void) {
    #####:45356:    int test_ret = 0;
        -:45357:
        -:45358:
        -:45359:    /* missing type support */
    #####:45360:    return(test_ret);
        -:45361:}
        -:45362:
        -:45363:
        -:45364:static int
    #####:45365:test_xmlTextWriterWriteFormatDTD(void) {
    #####:45366:    int test_ret = 0;
        -:45367:
        -:45368:
        -:45369:    /* missing type support */
    #####:45370:    return(test_ret);
        -:45371:}
        -:45372:
        -:45373:
        -:45374:static int
    #####:45375:test_xmlTextWriterWriteFormatDTDAttlist(void) {
    #####:45376:    int test_ret = 0;
        -:45377:
        -:45378:
        -:45379:    /* missing type support */
    #####:45380:    return(test_ret);
        -:45381:}
        -:45382:
        -:45383:
        -:45384:static int
    #####:45385:test_xmlTextWriterWriteFormatDTDElement(void) {
    #####:45386:    int test_ret = 0;
        -:45387:
        -:45388:
        -:45389:    /* missing type support */
    #####:45390:    return(test_ret);
        -:45391:}
        -:45392:
        -:45393:
        -:45394:static int
    #####:45395:test_xmlTextWriterWriteFormatDTDInternalEntity(void) {
    #####:45396:    int test_ret = 0;
        -:45397:
        -:45398:
        -:45399:    /* missing type support */
    #####:45400:    return(test_ret);
        -:45401:}
        -:45402:
        -:45403:
        -:45404:static int
    #####:45405:test_xmlTextWriterWriteFormatElement(void) {
    #####:45406:    int test_ret = 0;
        -:45407:
        -:45408:
        -:45409:    /* missing type support */
    #####:45410:    return(test_ret);
        -:45411:}
        -:45412:
        -:45413:
        -:45414:static int
    #####:45415:test_xmlTextWriterWriteFormatElementNS(void) {
    #####:45416:    int test_ret = 0;
        -:45417:
        -:45418:
        -:45419:    /* missing type support */
    #####:45420:    return(test_ret);
        -:45421:}
        -:45422:
        -:45423:
        -:45424:static int
    #####:45425:test_xmlTextWriterWriteFormatPI(void) {
    #####:45426:    int test_ret = 0;
        -:45427:
        -:45428:
        -:45429:    /* missing type support */
    #####:45430:    return(test_ret);
        -:45431:}
        -:45432:
        -:45433:
        -:45434:static int
    #####:45435:test_xmlTextWriterWriteFormatRaw(void) {
    #####:45436:    int test_ret = 0;
        -:45437:
        -:45438:
        -:45439:    /* missing type support */
    #####:45440:    return(test_ret);
        -:45441:}
        -:45442:
        -:45443:
        -:45444:static int
    #####:45445:test_xmlTextWriterWriteFormatString(void) {
    #####:45446:    int test_ret = 0;
        -:45447:
        -:45448:
        -:45449:    /* missing type support */
    #####:45450:    return(test_ret);
        -:45451:}
        -:45452:
        -:45453:
        -:45454:static int
    #####:45455:test_xmlTextWriterWritePI(void) {
    #####:45456:    int test_ret = 0;
        -:45457:
        -:45458:#if defined(LIBXML_WRITER_ENABLED)
        -:45459:    int mem_base;
        -:45460:    int ret_val;
        -:45461:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:45462:    int n_writer;
        -:45463:    xmlChar * target; /* PI target */
        -:45464:    int n_target;
        -:45465:    xmlChar * content; /* PI content */
        -:45466:    int n_content;
        -:45467:
    #####:45468:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:45469:    for (n_target = 0;n_target < gen_nb_const_xmlChar_ptr;n_target++) {
    #####:45470:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:45471:        mem_base = xmlMemBlocks();
    #####:45472:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:45473:        target = gen_const_xmlChar_ptr(n_target, 1);
    #####:45474:        content = gen_const_xmlChar_ptr(n_content, 2);
        -:45475:
    #####:45476:        ret_val = xmlTextWriterWritePI(writer, (const xmlChar *)target, (const xmlChar *)content);
    #####:45477:        desret_int(ret_val);
    #####:45478:        call_tests++;
    #####:45479:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:45480:        des_const_xmlChar_ptr(n_target, (const xmlChar *)target, 1);
    #####:45481:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 2);
    #####:45482:        xmlResetLastError();
    #####:45483:        if (mem_base != xmlMemBlocks()) {
    #####:45484:            printf("Leak of %d blocks found in xmlTextWriterWritePI",
    #####:45485:	           xmlMemBlocks() - mem_base);
    #####:45486:	    test_ret++;
    #####:45487:            printf(" %d", n_writer);
    #####:45488:            printf(" %d", n_target);
    #####:45489:            printf(" %d", n_content);
    #####:45490:            printf("\n");
        -:45491:        }
        -:45492:    }
        -:45493:    }
        -:45494:    }
    #####:45495:    function_tests++;
        -:45496:#endif
        -:45497:
    #####:45498:    return(test_ret);
        -:45499:}
        -:45500:
        -:45501:
        -:45502:static int
    #####:45503:test_xmlTextWriterWriteRaw(void) {
    #####:45504:    int test_ret = 0;
        -:45505:
        -:45506:#if defined(LIBXML_WRITER_ENABLED)
        -:45507:    int mem_base;
        -:45508:    int ret_val;
        -:45509:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:45510:    int n_writer;
        -:45511:    xmlChar * content; /* text string */
        -:45512:    int n_content;
        -:45513:
    #####:45514:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:45515:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:45516:        mem_base = xmlMemBlocks();
    #####:45517:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:45518:        content = gen_const_xmlChar_ptr(n_content, 1);
        -:45519:
    #####:45520:        ret_val = xmlTextWriterWriteRaw(writer, (const xmlChar *)content);
    #####:45521:        desret_int(ret_val);
    #####:45522:        call_tests++;
    #####:45523:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:45524:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
    #####:45525:        xmlResetLastError();
    #####:45526:        if (mem_base != xmlMemBlocks()) {
    #####:45527:            printf("Leak of %d blocks found in xmlTextWriterWriteRaw",
    #####:45528:	           xmlMemBlocks() - mem_base);
    #####:45529:	    test_ret++;
    #####:45530:            printf(" %d", n_writer);
    #####:45531:            printf(" %d", n_content);
    #####:45532:            printf("\n");
        -:45533:        }
        -:45534:    }
        -:45535:    }
    #####:45536:    function_tests++;
        -:45537:#endif
        -:45538:
    #####:45539:    return(test_ret);
        -:45540:}
        -:45541:
        -:45542:
        -:45543:static int
    #####:45544:test_xmlTextWriterWriteRawLen(void) {
    #####:45545:    int test_ret = 0;
        -:45546:
        -:45547:#if defined(LIBXML_WRITER_ENABLED)
        -:45548:    int mem_base;
        -:45549:    int ret_val;
        -:45550:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:45551:    int n_writer;
        -:45552:    xmlChar * content; /* text string */
        -:45553:    int n_content;
        -:45554:    int len; /* length of the text string */
        -:45555:    int n_len;
        -:45556:
    #####:45557:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:45558:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:45559:    for (n_len = 0;n_len < gen_nb_int;n_len++) {
    #####:45560:        mem_base = xmlMemBlocks();
    #####:45561:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:45562:        content = gen_const_xmlChar_ptr(n_content, 1);
    #####:45563:        len = gen_int(n_len, 2);
        -:45564:
    #####:45565:        ret_val = xmlTextWriterWriteRawLen(writer, (const xmlChar *)content, len);
    #####:45566:        desret_int(ret_val);
    #####:45567:        call_tests++;
    #####:45568:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:45569:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
    #####:45570:        des_int(n_len, len, 2);
    #####:45571:        xmlResetLastError();
    #####:45572:        if (mem_base != xmlMemBlocks()) {
    #####:45573:            printf("Leak of %d blocks found in xmlTextWriterWriteRawLen",
    #####:45574:	           xmlMemBlocks() - mem_base);
    #####:45575:	    test_ret++;
    #####:45576:            printf(" %d", n_writer);
    #####:45577:            printf(" %d", n_content);
    #####:45578:            printf(" %d", n_len);
    #####:45579:            printf("\n");
        -:45580:        }
        -:45581:    }
        -:45582:    }
        -:45583:    }
    #####:45584:    function_tests++;
        -:45585:#endif
        -:45586:
    #####:45587:    return(test_ret);
        -:45588:}
        -:45589:
        -:45590:
        -:45591:static int
    #####:45592:test_xmlTextWriterWriteString(void) {
    #####:45593:    int test_ret = 0;
        -:45594:
        -:45595:#if defined(LIBXML_WRITER_ENABLED)
        -:45596:    int mem_base;
        -:45597:    int ret_val;
        -:45598:    xmlTextWriterPtr writer; /* the xmlTextWriterPtr */
        -:45599:    int n_writer;
        -:45600:    xmlChar * content; /* text string */
        -:45601:    int n_content;
        -:45602:
    #####:45603:    for (n_writer = 0;n_writer < gen_nb_xmlTextWriterPtr;n_writer++) {
    #####:45604:    for (n_content = 0;n_content < gen_nb_const_xmlChar_ptr;n_content++) {
    #####:45605:        mem_base = xmlMemBlocks();
    #####:45606:        writer = gen_xmlTextWriterPtr(n_writer, 0);
    #####:45607:        content = gen_const_xmlChar_ptr(n_content, 1);
        -:45608:
    #####:45609:        ret_val = xmlTextWriterWriteString(writer, (const xmlChar *)content);
    #####:45610:        desret_int(ret_val);
    #####:45611:        call_tests++;
    #####:45612:        des_xmlTextWriterPtr(n_writer, writer, 0);
    #####:45613:        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
    #####:45614:        xmlResetLastError();
    #####:45615:        if (mem_base != xmlMemBlocks()) {
    #####:45616:            printf("Leak of %d blocks found in xmlTextWriterWriteString",
    #####:45617:	           xmlMemBlocks() - mem_base);
    #####:45618:	    test_ret++;
    #####:45619:            printf(" %d", n_writer);
    #####:45620:            printf(" %d", n_content);
    #####:45621:            printf("\n");
        -:45622:        }
        -:45623:    }
        -:45624:    }
    #####:45625:    function_tests++;
        -:45626:#endif
        -:45627:
    #####:45628:    return(test_ret);
        -:45629:}
        -:45630:
        -:45631:
        -:45632:static int
    #####:45633:test_xmlTextWriterWriteVFormatAttribute(void) {
    #####:45634:    int test_ret = 0;
        -:45635:
        -:45636:
        -:45637:    /* missing type support */
    #####:45638:    return(test_ret);
        -:45639:}
        -:45640:
        -:45641:
        -:45642:static int
    #####:45643:test_xmlTextWriterWriteVFormatAttributeNS(void) {
    #####:45644:    int test_ret = 0;
        -:45645:
        -:45646:
        -:45647:    /* missing type support */
    #####:45648:    return(test_ret);
        -:45649:}
        -:45650:
        -:45651:
        -:45652:static int
    #####:45653:test_xmlTextWriterWriteVFormatCDATA(void) {
    #####:45654:    int test_ret = 0;
        -:45655:
        -:45656:
        -:45657:    /* missing type support */
    #####:45658:    return(test_ret);
        -:45659:}
        -:45660:
        -:45661:
        -:45662:static int
    #####:45663:test_xmlTextWriterWriteVFormatComment(void) {
    #####:45664:    int test_ret = 0;
        -:45665:
        -:45666:
        -:45667:    /* missing type support */
    #####:45668:    return(test_ret);
        -:45669:}
        -:45670:
        -:45671:
        -:45672:static int
    #####:45673:test_xmlTextWriterWriteVFormatDTD(void) {
    #####:45674:    int test_ret = 0;
        -:45675:
        -:45676:
        -:45677:    /* missing type support */
    #####:45678:    return(test_ret);
        -:45679:}
        -:45680:
        -:45681:
        -:45682:static int
    #####:45683:test_xmlTextWriterWriteVFormatDTDAttlist(void) {
    #####:45684:    int test_ret = 0;
        -:45685:
        -:45686:
        -:45687:    /* missing type support */
    #####:45688:    return(test_ret);
        -:45689:}
        -:45690:
        -:45691:
        -:45692:static int
    #####:45693:test_xmlTextWriterWriteVFormatDTDElement(void) {
    #####:45694:    int test_ret = 0;
        -:45695:
        -:45696:
        -:45697:    /* missing type support */
    #####:45698:    return(test_ret);
        -:45699:}
        -:45700:
        -:45701:
        -:45702:static int
    #####:45703:test_xmlTextWriterWriteVFormatDTDInternalEntity(void) {
    #####:45704:    int test_ret = 0;
        -:45705:
        -:45706:
        -:45707:    /* missing type support */
    #####:45708:    return(test_ret);
        -:45709:}
        -:45710:
        -:45711:
        -:45712:static int
    #####:45713:test_xmlTextWriterWriteVFormatElement(void) {
    #####:45714:    int test_ret = 0;
        -:45715:
        -:45716:
        -:45717:    /* missing type support */
    #####:45718:    return(test_ret);
        -:45719:}
        -:45720:
        -:45721:
        -:45722:static int
    #####:45723:test_xmlTextWriterWriteVFormatElementNS(void) {
    #####:45724:    int test_ret = 0;
        -:45725:
        -:45726:
        -:45727:    /* missing type support */
    #####:45728:    return(test_ret);
        -:45729:}
        -:45730:
        -:45731:
        -:45732:static int
    #####:45733:test_xmlTextWriterWriteVFormatPI(void) {
    #####:45734:    int test_ret = 0;
        -:45735:
        -:45736:
        -:45737:    /* missing type support */
    #####:45738:    return(test_ret);
        -:45739:}
        -:45740:
        -:45741:
        -:45742:static int
    #####:45743:test_xmlTextWriterWriteVFormatRaw(void) {
    #####:45744:    int test_ret = 0;
        -:45745:
        -:45746:
        -:45747:    /* missing type support */
    #####:45748:    return(test_ret);
        -:45749:}
        -:45750:
        -:45751:
        -:45752:static int
    #####:45753:test_xmlTextWriterWriteVFormatString(void) {
    #####:45754:    int test_ret = 0;
        -:45755:
        -:45756:
        -:45757:    /* missing type support */
    #####:45758:    return(test_ret);
        -:45759:}
        -:45760:
        -:45761:static int
    #####:45762:test_xmlwriter(void) {
    #####:45763:    int test_ret = 0;
        -:45764:
    #####:45765:    if (quiet == 0) printf("Testing xmlwriter : 52 of 80 functions ...\n");
    #####:45766:    test_ret += test_xmlNewTextWriter();
    #####:45767:    test_ret += test_xmlNewTextWriterFilename();
    #####:45768:    test_ret += test_xmlNewTextWriterMemory();
    #####:45769:    test_ret += test_xmlNewTextWriterPushParser();
    #####:45770:    test_ret += test_xmlNewTextWriterTree();
    #####:45771:    test_ret += test_xmlTextWriterEndAttribute();
    #####:45772:    test_ret += test_xmlTextWriterEndCDATA();
    #####:45773:    test_ret += test_xmlTextWriterEndComment();
    #####:45774:    test_ret += test_xmlTextWriterEndDTD();
    #####:45775:    test_ret += test_xmlTextWriterEndDTDAttlist();
    #####:45776:    test_ret += test_xmlTextWriterEndDTDElement();
    #####:45777:    test_ret += test_xmlTextWriterEndDTDEntity();
    #####:45778:    test_ret += test_xmlTextWriterEndDocument();
    #####:45779:    test_ret += test_xmlTextWriterEndElement();
    #####:45780:    test_ret += test_xmlTextWriterEndPI();
    #####:45781:    test_ret += test_xmlTextWriterFlush();
    #####:45782:    test_ret += test_xmlTextWriterFullEndElement();
    #####:45783:    test_ret += test_xmlTextWriterSetIndent();
    #####:45784:    test_ret += test_xmlTextWriterSetIndentString();
    #####:45785:    test_ret += test_xmlTextWriterSetQuoteChar();
    #####:45786:    test_ret += test_xmlTextWriterStartAttribute();
    #####:45787:    test_ret += test_xmlTextWriterStartAttributeNS();
    #####:45788:    test_ret += test_xmlTextWriterStartCDATA();
    #####:45789:    test_ret += test_xmlTextWriterStartComment();
    #####:45790:    test_ret += test_xmlTextWriterStartDTD();
    #####:45791:    test_ret += test_xmlTextWriterStartDTDAttlist();
    #####:45792:    test_ret += test_xmlTextWriterStartDTDElement();
    #####:45793:    test_ret += test_xmlTextWriterStartDTDEntity();
    #####:45794:    test_ret += test_xmlTextWriterStartDocument();
    #####:45795:    test_ret += test_xmlTextWriterStartElement();
    #####:45796:    test_ret += test_xmlTextWriterStartElementNS();
    #####:45797:    test_ret += test_xmlTextWriterStartPI();
    #####:45798:    test_ret += test_xmlTextWriterWriteAttribute();
    #####:45799:    test_ret += test_xmlTextWriterWriteAttributeNS();
    #####:45800:    test_ret += test_xmlTextWriterWriteBase64();
    #####:45801:    test_ret += test_xmlTextWriterWriteBinHex();
    #####:45802:    test_ret += test_xmlTextWriterWriteCDATA();
    #####:45803:    test_ret += test_xmlTextWriterWriteComment();
    #####:45804:    test_ret += test_xmlTextWriterWriteDTD();
    #####:45805:    test_ret += test_xmlTextWriterWriteDTDAttlist();
    #####:45806:    test_ret += test_xmlTextWriterWriteDTDElement();
    #####:45807:    test_ret += test_xmlTextWriterWriteDTDEntity();
    #####:45808:    test_ret += test_xmlTextWriterWriteDTDExternalEntity();
    #####:45809:    test_ret += test_xmlTextWriterWriteDTDExternalEntityContents();
    #####:45810:    test_ret += test_xmlTextWriterWriteDTDInternalEntity();
    #####:45811:    test_ret += test_xmlTextWriterWriteDTDNotation();
    #####:45812:    test_ret += test_xmlTextWriterWriteElement();
    #####:45813:    test_ret += test_xmlTextWriterWriteElementNS();
    #####:45814:    test_ret += test_xmlTextWriterWriteFormatAttribute();
    #####:45815:    test_ret += test_xmlTextWriterWriteFormatAttributeNS();
    #####:45816:    test_ret += test_xmlTextWriterWriteFormatCDATA();
    #####:45817:    test_ret += test_xmlTextWriterWriteFormatComment();
    #####:45818:    test_ret += test_xmlTextWriterWriteFormatDTD();
    #####:45819:    test_ret += test_xmlTextWriterWriteFormatDTDAttlist();
    #####:45820:    test_ret += test_xmlTextWriterWriteFormatDTDElement();
    #####:45821:    test_ret += test_xmlTextWriterWriteFormatDTDInternalEntity();
    #####:45822:    test_ret += test_xmlTextWriterWriteFormatElement();
    #####:45823:    test_ret += test_xmlTextWriterWriteFormatElementNS();
    #####:45824:    test_ret += test_xmlTextWriterWriteFormatPI();
    #####:45825:    test_ret += test_xmlTextWriterWriteFormatRaw();
    #####:45826:    test_ret += test_xmlTextWriterWriteFormatString();
    #####:45827:    test_ret += test_xmlTextWriterWritePI();
    #####:45828:    test_ret += test_xmlTextWriterWriteRaw();
    #####:45829:    test_ret += test_xmlTextWriterWriteRawLen();
    #####:45830:    test_ret += test_xmlTextWriterWriteString();
    #####:45831:    test_ret += test_xmlTextWriterWriteVFormatAttribute();
    #####:45832:    test_ret += test_xmlTextWriterWriteVFormatAttributeNS();
    #####:45833:    test_ret += test_xmlTextWriterWriteVFormatCDATA();
    #####:45834:    test_ret += test_xmlTextWriterWriteVFormatComment();
    #####:45835:    test_ret += test_xmlTextWriterWriteVFormatDTD();
    #####:45836:    test_ret += test_xmlTextWriterWriteVFormatDTDAttlist();
    #####:45837:    test_ret += test_xmlTextWriterWriteVFormatDTDElement();
    #####:45838:    test_ret += test_xmlTextWriterWriteVFormatDTDInternalEntity();
    #####:45839:    test_ret += test_xmlTextWriterWriteVFormatElement();
    #####:45840:    test_ret += test_xmlTextWriterWriteVFormatElementNS();
    #####:45841:    test_ret += test_xmlTextWriterWriteVFormatPI();
    #####:45842:    test_ret += test_xmlTextWriterWriteVFormatRaw();
    #####:45843:    test_ret += test_xmlTextWriterWriteVFormatString();
        -:45844:
    #####:45845:    if (test_ret != 0)
    #####:45846:	printf("Module xmlwriter: %d errors\n", test_ret);
    #####:45847:    return(test_ret);
        -:45848:}
        -:45849:
        -:45850:static int
    #####:45851:test_xmlXPathCastBooleanToNumber(void) {
    #####:45852:    int test_ret = 0;
        -:45853:
        -:45854:#if defined(LIBXML_XPATH_ENABLED)
        -:45855:    int mem_base;
        -:45856:    double ret_val;
        -:45857:    int val; /* a boolean */
        -:45858:    int n_val;
        -:45859:
    #####:45860:    for (n_val = 0;n_val < gen_nb_int;n_val++) {
    #####:45861:        mem_base = xmlMemBlocks();
    #####:45862:        val = gen_int(n_val, 0);
        -:45863:
    #####:45864:        ret_val = xmlXPathCastBooleanToNumber(val);
    #####:45865:        desret_double(ret_val);
    #####:45866:        call_tests++;
    #####:45867:        des_int(n_val, val, 0);
    #####:45868:        xmlResetLastError();
    #####:45869:        if (mem_base != xmlMemBlocks()) {
    #####:45870:            printf("Leak of %d blocks found in xmlXPathCastBooleanToNumber",
    #####:45871:	           xmlMemBlocks() - mem_base);
    #####:45872:	    test_ret++;
    #####:45873:            printf(" %d", n_val);
    #####:45874:            printf("\n");
        -:45875:        }
        -:45876:    }
    #####:45877:    function_tests++;
        -:45878:#endif
        -:45879:
    #####:45880:    return(test_ret);
        -:45881:}
        -:45882:
        -:45883:
        -:45884:static int
    #####:45885:test_xmlXPathCastBooleanToString(void) {
    #####:45886:    int test_ret = 0;
        -:45887:
        -:45888:#if defined(LIBXML_XPATH_ENABLED)
        -:45889:    int mem_base;
        -:45890:    xmlChar * ret_val;
        -:45891:    int val; /* a boolean */
        -:45892:    int n_val;
        -:45893:
    #####:45894:    for (n_val = 0;n_val < gen_nb_int;n_val++) {
    #####:45895:        mem_base = xmlMemBlocks();
    #####:45896:        val = gen_int(n_val, 0);
        -:45897:
    #####:45898:        ret_val = xmlXPathCastBooleanToString(val);
    #####:45899:        desret_xmlChar_ptr(ret_val);
    #####:45900:        call_tests++;
    #####:45901:        des_int(n_val, val, 0);
    #####:45902:        xmlResetLastError();
    #####:45903:        if (mem_base != xmlMemBlocks()) {
    #####:45904:            printf("Leak of %d blocks found in xmlXPathCastBooleanToString",
    #####:45905:	           xmlMemBlocks() - mem_base);
    #####:45906:	    test_ret++;
    #####:45907:            printf(" %d", n_val);
    #####:45908:            printf("\n");
        -:45909:        }
        -:45910:    }
    #####:45911:    function_tests++;
        -:45912:#endif
        -:45913:
    #####:45914:    return(test_ret);
        -:45915:}
        -:45916:
        -:45917:
        -:45918:static int
    #####:45919:test_xmlXPathCastNodeSetToBoolean(void) {
    #####:45920:    int test_ret = 0;
        -:45921:
        -:45922:#if defined(LIBXML_XPATH_ENABLED)
        -:45923:    int mem_base;
        -:45924:    int ret_val;
        -:45925:    xmlNodeSetPtr ns; /* a node-set */
        -:45926:    int n_ns;
        -:45927:
    #####:45928:    for (n_ns = 0;n_ns < gen_nb_xmlNodeSetPtr;n_ns++) {
    #####:45929:        mem_base = xmlMemBlocks();
    #####:45930:        ns = gen_xmlNodeSetPtr(n_ns, 0);
        -:45931:
    #####:45932:        ret_val = xmlXPathCastNodeSetToBoolean(ns);
    #####:45933:        desret_int(ret_val);
    #####:45934:        call_tests++;
    #####:45935:        des_xmlNodeSetPtr(n_ns, ns, 0);
    #####:45936:        xmlResetLastError();
    #####:45937:        if (mem_base != xmlMemBlocks()) {
    #####:45938:            printf("Leak of %d blocks found in xmlXPathCastNodeSetToBoolean",
    #####:45939:	           xmlMemBlocks() - mem_base);
    #####:45940:	    test_ret++;
    #####:45941:            printf(" %d", n_ns);
    #####:45942:            printf("\n");
        -:45943:        }
        -:45944:    }
    #####:45945:    function_tests++;
        -:45946:#endif
        -:45947:
    #####:45948:    return(test_ret);
        -:45949:}
        -:45950:
        -:45951:
        -:45952:static int
    #####:45953:test_xmlXPathCastNodeSetToNumber(void) {
    #####:45954:    int test_ret = 0;
        -:45955:
        -:45956:#if defined(LIBXML_XPATH_ENABLED)
        -:45957:    int mem_base;
        -:45958:    double ret_val;
        -:45959:    xmlNodeSetPtr ns; /* a node-set */
        -:45960:    int n_ns;
        -:45961:
    #####:45962:    for (n_ns = 0;n_ns < gen_nb_xmlNodeSetPtr;n_ns++) {
    #####:45963:        mem_base = xmlMemBlocks();
    #####:45964:        ns = gen_xmlNodeSetPtr(n_ns, 0);
        -:45965:
    #####:45966:        ret_val = xmlXPathCastNodeSetToNumber(ns);
    #####:45967:        desret_double(ret_val);
    #####:45968:        call_tests++;
    #####:45969:        des_xmlNodeSetPtr(n_ns, ns, 0);
    #####:45970:        xmlResetLastError();
    #####:45971:        if (mem_base != xmlMemBlocks()) {
    #####:45972:            printf("Leak of %d blocks found in xmlXPathCastNodeSetToNumber",
    #####:45973:	           xmlMemBlocks() - mem_base);
    #####:45974:	    test_ret++;
    #####:45975:            printf(" %d", n_ns);
    #####:45976:            printf("\n");
        -:45977:        }
        -:45978:    }
    #####:45979:    function_tests++;
        -:45980:#endif
        -:45981:
    #####:45982:    return(test_ret);
        -:45983:}
        -:45984:
        -:45985:
        -:45986:static int
    #####:45987:test_xmlXPathCastNodeSetToString(void) {
    #####:45988:    int test_ret = 0;
        -:45989:
        -:45990:#if defined(LIBXML_XPATH_ENABLED)
        -:45991:    int mem_base;
        -:45992:    xmlChar * ret_val;
        -:45993:    xmlNodeSetPtr ns; /* a node-set */
        -:45994:    int n_ns;
        -:45995:
    #####:45996:    for (n_ns = 0;n_ns < gen_nb_xmlNodeSetPtr;n_ns++) {
    #####:45997:        mem_base = xmlMemBlocks();
    #####:45998:        ns = gen_xmlNodeSetPtr(n_ns, 0);
        -:45999:
    #####:46000:        ret_val = xmlXPathCastNodeSetToString(ns);
    #####:46001:        desret_xmlChar_ptr(ret_val);
    #####:46002:        call_tests++;
    #####:46003:        des_xmlNodeSetPtr(n_ns, ns, 0);
    #####:46004:        xmlResetLastError();
    #####:46005:        if (mem_base != xmlMemBlocks()) {
    #####:46006:            printf("Leak of %d blocks found in xmlXPathCastNodeSetToString",
    #####:46007:	           xmlMemBlocks() - mem_base);
    #####:46008:	    test_ret++;
    #####:46009:            printf(" %d", n_ns);
    #####:46010:            printf("\n");
        -:46011:        }
        -:46012:    }
    #####:46013:    function_tests++;
        -:46014:#endif
        -:46015:
    #####:46016:    return(test_ret);
        -:46017:}
        -:46018:
        -:46019:
        -:46020:static int
    #####:46021:test_xmlXPathCastNodeToNumber(void) {
    #####:46022:    int test_ret = 0;
        -:46023:
        -:46024:#if defined(LIBXML_XPATH_ENABLED)
        -:46025:    int mem_base;
        -:46026:    double ret_val;
        -:46027:    xmlNodePtr node; /* a node */
        -:46028:    int n_node;
        -:46029:
    #####:46030:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:46031:        mem_base = xmlMemBlocks();
    #####:46032:        node = gen_xmlNodePtr(n_node, 0);
        -:46033:
    #####:46034:        ret_val = xmlXPathCastNodeToNumber(node);
    #####:46035:        desret_double(ret_val);
    #####:46036:        call_tests++;
    #####:46037:        des_xmlNodePtr(n_node, node, 0);
    #####:46038:        xmlResetLastError();
    #####:46039:        if (mem_base != xmlMemBlocks()) {
    #####:46040:            printf("Leak of %d blocks found in xmlXPathCastNodeToNumber",
    #####:46041:	           xmlMemBlocks() - mem_base);
    #####:46042:	    test_ret++;
    #####:46043:            printf(" %d", n_node);
    #####:46044:            printf("\n");
        -:46045:        }
        -:46046:    }
    #####:46047:    function_tests++;
        -:46048:#endif
        -:46049:
    #####:46050:    return(test_ret);
        -:46051:}
        -:46052:
        -:46053:
        -:46054:static int
    #####:46055:test_xmlXPathCastNodeToString(void) {
    #####:46056:    int test_ret = 0;
        -:46057:
        -:46058:#if defined(LIBXML_XPATH_ENABLED)
        -:46059:    int mem_base;
        -:46060:    xmlChar * ret_val;
        -:46061:    xmlNodePtr node; /* a node */
        -:46062:    int n_node;
        -:46063:
    #####:46064:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:46065:        mem_base = xmlMemBlocks();
    #####:46066:        node = gen_xmlNodePtr(n_node, 0);
        -:46067:
    #####:46068:        ret_val = xmlXPathCastNodeToString(node);
    #####:46069:        desret_xmlChar_ptr(ret_val);
    #####:46070:        call_tests++;
    #####:46071:        des_xmlNodePtr(n_node, node, 0);
    #####:46072:        xmlResetLastError();
    #####:46073:        if (mem_base != xmlMemBlocks()) {
    #####:46074:            printf("Leak of %d blocks found in xmlXPathCastNodeToString",
    #####:46075:	           xmlMemBlocks() - mem_base);
    #####:46076:	    test_ret++;
    #####:46077:            printf(" %d", n_node);
    #####:46078:            printf("\n");
        -:46079:        }
        -:46080:    }
    #####:46081:    function_tests++;
        -:46082:#endif
        -:46083:
    #####:46084:    return(test_ret);
        -:46085:}
        -:46086:
        -:46087:
        -:46088:static int
    #####:46089:test_xmlXPathCastNumberToBoolean(void) {
    #####:46090:    int test_ret = 0;
        -:46091:
        -:46092:#if defined(LIBXML_XPATH_ENABLED)
        -:46093:    int mem_base;
        -:46094:    int ret_val;
        -:46095:    double val; /* a number */
        -:46096:    int n_val;
        -:46097:
    #####:46098:    for (n_val = 0;n_val < gen_nb_double;n_val++) {
    #####:46099:        mem_base = xmlMemBlocks();
    #####:46100:        val = gen_double(n_val, 0);
        -:46101:
    #####:46102:        ret_val = xmlXPathCastNumberToBoolean(val);
    #####:46103:        desret_int(ret_val);
    #####:46104:        call_tests++;
    #####:46105:        des_double(n_val, val, 0);
    #####:46106:        xmlResetLastError();
    #####:46107:        if (mem_base != xmlMemBlocks()) {
    #####:46108:            printf("Leak of %d blocks found in xmlXPathCastNumberToBoolean",
    #####:46109:	           xmlMemBlocks() - mem_base);
    #####:46110:	    test_ret++;
    #####:46111:            printf(" %d", n_val);
    #####:46112:            printf("\n");
        -:46113:        }
        -:46114:    }
    #####:46115:    function_tests++;
        -:46116:#endif
        -:46117:
    #####:46118:    return(test_ret);
        -:46119:}
        -:46120:
        -:46121:
        -:46122:static int
    #####:46123:test_xmlXPathCastNumberToString(void) {
    #####:46124:    int test_ret = 0;
        -:46125:
        -:46126:#if defined(LIBXML_XPATH_ENABLED)
        -:46127:    int mem_base;
        -:46128:    xmlChar * ret_val;
        -:46129:    double val; /* a number */
        -:46130:    int n_val;
        -:46131:
    #####:46132:    for (n_val = 0;n_val < gen_nb_double;n_val++) {
    #####:46133:        mem_base = xmlMemBlocks();
    #####:46134:        val = gen_double(n_val, 0);
        -:46135:
    #####:46136:        ret_val = xmlXPathCastNumberToString(val);
    #####:46137:        desret_xmlChar_ptr(ret_val);
    #####:46138:        call_tests++;
    #####:46139:        des_double(n_val, val, 0);
    #####:46140:        xmlResetLastError();
    #####:46141:        if (mem_base != xmlMemBlocks()) {
    #####:46142:            printf("Leak of %d blocks found in xmlXPathCastNumberToString",
    #####:46143:	           xmlMemBlocks() - mem_base);
    #####:46144:	    test_ret++;
    #####:46145:            printf(" %d", n_val);
    #####:46146:            printf("\n");
        -:46147:        }
        -:46148:    }
    #####:46149:    function_tests++;
        -:46150:#endif
        -:46151:
    #####:46152:    return(test_ret);
        -:46153:}
        -:46154:
        -:46155:
        -:46156:static int
    #####:46157:test_xmlXPathCastStringToBoolean(void) {
    #####:46158:    int test_ret = 0;
        -:46159:
        -:46160:#if defined(LIBXML_XPATH_ENABLED)
        -:46161:    int mem_base;
        -:46162:    int ret_val;
        -:46163:    xmlChar * val; /* a string */
        -:46164:    int n_val;
        -:46165:
    #####:46166:    for (n_val = 0;n_val < gen_nb_const_xmlChar_ptr;n_val++) {
    #####:46167:        mem_base = xmlMemBlocks();
    #####:46168:        val = gen_const_xmlChar_ptr(n_val, 0);
        -:46169:
    #####:46170:        ret_val = xmlXPathCastStringToBoolean((const xmlChar *)val);
    #####:46171:        desret_int(ret_val);
    #####:46172:        call_tests++;
    #####:46173:        des_const_xmlChar_ptr(n_val, (const xmlChar *)val, 0);
    #####:46174:        xmlResetLastError();
    #####:46175:        if (mem_base != xmlMemBlocks()) {
    #####:46176:            printf("Leak of %d blocks found in xmlXPathCastStringToBoolean",
    #####:46177:	           xmlMemBlocks() - mem_base);
    #####:46178:	    test_ret++;
    #####:46179:            printf(" %d", n_val);
    #####:46180:            printf("\n");
        -:46181:        }
        -:46182:    }
    #####:46183:    function_tests++;
        -:46184:#endif
        -:46185:
    #####:46186:    return(test_ret);
        -:46187:}
        -:46188:
        -:46189:
        -:46190:static int
    #####:46191:test_xmlXPathCastStringToNumber(void) {
    #####:46192:    int test_ret = 0;
        -:46193:
        -:46194:#if defined(LIBXML_XPATH_ENABLED)
        -:46195:    int mem_base;
        -:46196:    double ret_val;
        -:46197:    xmlChar * val; /* a string */
        -:46198:    int n_val;
        -:46199:
    #####:46200:    for (n_val = 0;n_val < gen_nb_const_xmlChar_ptr;n_val++) {
    #####:46201:        mem_base = xmlMemBlocks();
    #####:46202:        val = gen_const_xmlChar_ptr(n_val, 0);
        -:46203:
    #####:46204:        ret_val = xmlXPathCastStringToNumber((const xmlChar *)val);
    #####:46205:        desret_double(ret_val);
    #####:46206:        call_tests++;
    #####:46207:        des_const_xmlChar_ptr(n_val, (const xmlChar *)val, 0);
    #####:46208:        xmlResetLastError();
    #####:46209:        if (mem_base != xmlMemBlocks()) {
    #####:46210:            printf("Leak of %d blocks found in xmlXPathCastStringToNumber",
    #####:46211:	           xmlMemBlocks() - mem_base);
    #####:46212:	    test_ret++;
    #####:46213:            printf(" %d", n_val);
    #####:46214:            printf("\n");
        -:46215:        }
        -:46216:    }
    #####:46217:    function_tests++;
        -:46218:#endif
        -:46219:
    #####:46220:    return(test_ret);
        -:46221:}
        -:46222:
        -:46223:
        -:46224:static int
    #####:46225:test_xmlXPathCastToBoolean(void) {
    #####:46226:    int test_ret = 0;
        -:46227:
        -:46228:#if defined(LIBXML_XPATH_ENABLED)
        -:46229:    int mem_base;
        -:46230:    int ret_val;
        -:46231:    xmlXPathObjectPtr val; /* an XPath object */
        -:46232:    int n_val;
        -:46233:
    #####:46234:    for (n_val = 0;n_val < gen_nb_xmlXPathObjectPtr;n_val++) {
    #####:46235:        mem_base = xmlMemBlocks();
    #####:46236:        val = gen_xmlXPathObjectPtr(n_val, 0);
        -:46237:
    #####:46238:        ret_val = xmlXPathCastToBoolean(val);
    #####:46239:        desret_int(ret_val);
    #####:46240:        call_tests++;
    #####:46241:        des_xmlXPathObjectPtr(n_val, val, 0);
    #####:46242:        xmlResetLastError();
    #####:46243:        if (mem_base != xmlMemBlocks()) {
    #####:46244:            printf("Leak of %d blocks found in xmlXPathCastToBoolean",
    #####:46245:	           xmlMemBlocks() - mem_base);
    #####:46246:	    test_ret++;
    #####:46247:            printf(" %d", n_val);
    #####:46248:            printf("\n");
        -:46249:        }
        -:46250:    }
    #####:46251:    function_tests++;
        -:46252:#endif
        -:46253:
    #####:46254:    return(test_ret);
        -:46255:}
        -:46256:
        -:46257:
        -:46258:static int
    #####:46259:test_xmlXPathCastToNumber(void) {
    #####:46260:    int test_ret = 0;
        -:46261:
        -:46262:#if defined(LIBXML_XPATH_ENABLED)
        -:46263:    int mem_base;
        -:46264:    double ret_val;
        -:46265:    xmlXPathObjectPtr val; /* an XPath object */
        -:46266:    int n_val;
        -:46267:
    #####:46268:    for (n_val = 0;n_val < gen_nb_xmlXPathObjectPtr;n_val++) {
    #####:46269:        mem_base = xmlMemBlocks();
    #####:46270:        val = gen_xmlXPathObjectPtr(n_val, 0);
        -:46271:
    #####:46272:        ret_val = xmlXPathCastToNumber(val);
    #####:46273:        desret_double(ret_val);
    #####:46274:        call_tests++;
    #####:46275:        des_xmlXPathObjectPtr(n_val, val, 0);
    #####:46276:        xmlResetLastError();
    #####:46277:        if (mem_base != xmlMemBlocks()) {
    #####:46278:            printf("Leak of %d blocks found in xmlXPathCastToNumber",
    #####:46279:	           xmlMemBlocks() - mem_base);
    #####:46280:	    test_ret++;
    #####:46281:            printf(" %d", n_val);
    #####:46282:            printf("\n");
        -:46283:        }
        -:46284:    }
    #####:46285:    function_tests++;
        -:46286:#endif
        -:46287:
    #####:46288:    return(test_ret);
        -:46289:}
        -:46290:
        -:46291:
        -:46292:static int
    #####:46293:test_xmlXPathCastToString(void) {
    #####:46294:    int test_ret = 0;
        -:46295:
        -:46296:#if defined(LIBXML_XPATH_ENABLED)
        -:46297:    int mem_base;
        -:46298:    xmlChar * ret_val;
        -:46299:    xmlXPathObjectPtr val; /* an XPath object */
        -:46300:    int n_val;
        -:46301:
    #####:46302:    for (n_val = 0;n_val < gen_nb_xmlXPathObjectPtr;n_val++) {
    #####:46303:        mem_base = xmlMemBlocks();
    #####:46304:        val = gen_xmlXPathObjectPtr(n_val, 0);
        -:46305:
    #####:46306:        ret_val = xmlXPathCastToString(val);
    #####:46307:        desret_xmlChar_ptr(ret_val);
    #####:46308:        call_tests++;
    #####:46309:        des_xmlXPathObjectPtr(n_val, val, 0);
    #####:46310:        xmlResetLastError();
    #####:46311:        if (mem_base != xmlMemBlocks()) {
    #####:46312:            printf("Leak of %d blocks found in xmlXPathCastToString",
    #####:46313:	           xmlMemBlocks() - mem_base);
    #####:46314:	    test_ret++;
    #####:46315:            printf(" %d", n_val);
    #####:46316:            printf("\n");
        -:46317:        }
        -:46318:    }
    #####:46319:    function_tests++;
        -:46320:#endif
        -:46321:
    #####:46322:    return(test_ret);
        -:46323:}
        -:46324:
        -:46325:
        -:46326:static int
    #####:46327:test_xmlXPathCmpNodes(void) {
    #####:46328:    int test_ret = 0;
        -:46329:
        -:46330:#if defined(LIBXML_XPATH_ENABLED)
        -:46331:    int mem_base;
        -:46332:    int ret_val;
        -:46333:    xmlNodePtr node1; /* the first node */
        -:46334:    int n_node1;
        -:46335:    xmlNodePtr node2; /* the second node */
        -:46336:    int n_node2;
        -:46337:
    #####:46338:    for (n_node1 = 0;n_node1 < gen_nb_xmlNodePtr;n_node1++) {
    #####:46339:    for (n_node2 = 0;n_node2 < gen_nb_xmlNodePtr;n_node2++) {
    #####:46340:        mem_base = xmlMemBlocks();
    #####:46341:        node1 = gen_xmlNodePtr(n_node1, 0);
    #####:46342:        node2 = gen_xmlNodePtr(n_node2, 1);
        -:46343:
    #####:46344:        ret_val = xmlXPathCmpNodes(node1, node2);
    #####:46345:        desret_int(ret_val);
    #####:46346:        call_tests++;
    #####:46347:        des_xmlNodePtr(n_node1, node1, 0);
    #####:46348:        des_xmlNodePtr(n_node2, node2, 1);
    #####:46349:        xmlResetLastError();
    #####:46350:        if (mem_base != xmlMemBlocks()) {
    #####:46351:            printf("Leak of %d blocks found in xmlXPathCmpNodes",
    #####:46352:	           xmlMemBlocks() - mem_base);
    #####:46353:	    test_ret++;
    #####:46354:            printf(" %d", n_node1);
    #####:46355:            printf(" %d", n_node2);
    #####:46356:            printf("\n");
        -:46357:        }
        -:46358:    }
        -:46359:    }
    #####:46360:    function_tests++;
        -:46361:#endif
        -:46362:
    #####:46363:    return(test_ret);
        -:46364:}
        -:46365:
        -:46366:
        -:46367:static int
    #####:46368:test_xmlXPathCompile(void) {
    #####:46369:    int test_ret = 0;
        -:46370:
        -:46371:
        -:46372:    /* missing type support */
    #####:46373:    return(test_ret);
        -:46374:}
        -:46375:
        -:46376:#ifdef LIBXML_XPATH_ENABLED
        -:46377:
        -:46378:#define gen_nb_xmlXPathCompExprPtr 1
    #####:46379:static xmlXPathCompExprPtr gen_xmlXPathCompExprPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:46380:    return(NULL);
        -:46381:}
    #####:46382:static void des_xmlXPathCompExprPtr(int no ATTRIBUTE_UNUSED, xmlXPathCompExprPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:46383:}
        -:46384:#endif
        -:46385:
        -:46386:#ifdef LIBXML_XPATH_ENABLED
        -:46387:
        -:46388:#define gen_nb_xmlXPathContextPtr 1
    #####:46389:static xmlXPathContextPtr gen_xmlXPathContextPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:46390:    return(NULL);
        -:46391:}
    #####:46392:static void des_xmlXPathContextPtr(int no ATTRIBUTE_UNUSED, xmlXPathContextPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:46393:}
        -:46394:#endif
        -:46395:
        -:46396:
        -:46397:static int
    #####:46398:test_xmlXPathCompiledEval(void) {
    #####:46399:    int test_ret = 0;
        -:46400:
        -:46401:#if defined(LIBXML_XPATH_ENABLED)
        -:46402:    int mem_base;
        -:46403:    xmlXPathObjectPtr ret_val;
        -:46404:    xmlXPathCompExprPtr comp; /* the compiled XPath expression */
        -:46405:    int n_comp;
        -:46406:    xmlXPathContextPtr ctx; /* the XPath context */
        -:46407:    int n_ctx;
        -:46408:
    #####:46409:    for (n_comp = 0;n_comp < gen_nb_xmlXPathCompExprPtr;n_comp++) {
    #####:46410:    for (n_ctx = 0;n_ctx < gen_nb_xmlXPathContextPtr;n_ctx++) {
    #####:46411:        mem_base = xmlMemBlocks();
    #####:46412:        comp = gen_xmlXPathCompExprPtr(n_comp, 0);
    #####:46413:        ctx = gen_xmlXPathContextPtr(n_ctx, 1);
        -:46414:
    #####:46415:        ret_val = xmlXPathCompiledEval(comp, ctx);
    #####:46416:        desret_xmlXPathObjectPtr(ret_val);
    #####:46417:        call_tests++;
    #####:46418:        des_xmlXPathCompExprPtr(n_comp, comp, 0);
    #####:46419:        des_xmlXPathContextPtr(n_ctx, ctx, 1);
    #####:46420:        xmlResetLastError();
    #####:46421:        if (mem_base != xmlMemBlocks()) {
    #####:46422:            printf("Leak of %d blocks found in xmlXPathCompiledEval",
    #####:46423:	           xmlMemBlocks() - mem_base);
    #####:46424:	    test_ret++;
    #####:46425:            printf(" %d", n_comp);
    #####:46426:            printf(" %d", n_ctx);
    #####:46427:            printf("\n");
        -:46428:        }
        -:46429:    }
        -:46430:    }
    #####:46431:    function_tests++;
        -:46432:#endif
        -:46433:
    #####:46434:    return(test_ret);
        -:46435:}
        -:46436:
        -:46437:
        -:46438:static int
    #####:46439:test_xmlXPathCompiledEvalToBoolean(void) {
    #####:46440:    int test_ret = 0;
        -:46441:
        -:46442:#if defined(LIBXML_XPATH_ENABLED)
        -:46443:    int mem_base;
        -:46444:    int ret_val;
        -:46445:    xmlXPathCompExprPtr comp; /* the compiled XPath expression */
        -:46446:    int n_comp;
        -:46447:    xmlXPathContextPtr ctxt; /* the XPath context */
        -:46448:    int n_ctxt;
        -:46449:
    #####:46450:    for (n_comp = 0;n_comp < gen_nb_xmlXPathCompExprPtr;n_comp++) {
    #####:46451:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathContextPtr;n_ctxt++) {
    #####:46452:        mem_base = xmlMemBlocks();
    #####:46453:        comp = gen_xmlXPathCompExprPtr(n_comp, 0);
    #####:46454:        ctxt = gen_xmlXPathContextPtr(n_ctxt, 1);
        -:46455:
    #####:46456:        ret_val = xmlXPathCompiledEvalToBoolean(comp, ctxt);
    #####:46457:        desret_int(ret_val);
    #####:46458:        call_tests++;
    #####:46459:        des_xmlXPathCompExprPtr(n_comp, comp, 0);
    #####:46460:        des_xmlXPathContextPtr(n_ctxt, ctxt, 1);
    #####:46461:        xmlResetLastError();
    #####:46462:        if (mem_base != xmlMemBlocks()) {
    #####:46463:            printf("Leak of %d blocks found in xmlXPathCompiledEvalToBoolean",
    #####:46464:	           xmlMemBlocks() - mem_base);
    #####:46465:	    test_ret++;
    #####:46466:            printf(" %d", n_comp);
    #####:46467:            printf(" %d", n_ctxt);
    #####:46468:            printf("\n");
        -:46469:        }
        -:46470:    }
        -:46471:    }
    #####:46472:    function_tests++;
        -:46473:#endif
        -:46474:
    #####:46475:    return(test_ret);
        -:46476:}
        -:46477:
        -:46478:
        -:46479:static int
    #####:46480:test_xmlXPathContextSetCache(void) {
    #####:46481:    int test_ret = 0;
        -:46482:
        -:46483:#if defined(LIBXML_XPATH_ENABLED)
        -:46484:    int mem_base;
        -:46485:    int ret_val;
        -:46486:    xmlXPathContextPtr ctxt; /* the XPath context */
        -:46487:    int n_ctxt;
        -:46488:    int active; /* enables/disables (creates/frees) the cache */
        -:46489:    int n_active;
        -:46490:    int value; /* a value with semantics dependant on @options */
        -:46491:    int n_value;
        -:46492:    int options; /* options (currently only the value 0 is used) */
        -:46493:    int n_options;
        -:46494:
    #####:46495:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathContextPtr;n_ctxt++) {
    #####:46496:    for (n_active = 0;n_active < gen_nb_int;n_active++) {
    #####:46497:    for (n_value = 0;n_value < gen_nb_int;n_value++) {
    #####:46498:    for (n_options = 0;n_options < gen_nb_int;n_options++) {
    #####:46499:        mem_base = xmlMemBlocks();
    #####:46500:        ctxt = gen_xmlXPathContextPtr(n_ctxt, 0);
    #####:46501:        active = gen_int(n_active, 1);
    #####:46502:        value = gen_int(n_value, 2);
    #####:46503:        options = gen_int(n_options, 3);
        -:46504:
    #####:46505:        ret_val = xmlXPathContextSetCache(ctxt, active, value, options);
    #####:46506:        desret_int(ret_val);
    #####:46507:        call_tests++;
    #####:46508:        des_xmlXPathContextPtr(n_ctxt, ctxt, 0);
    #####:46509:        des_int(n_active, active, 1);
    #####:46510:        des_int(n_value, value, 2);
    #####:46511:        des_int(n_options, options, 3);
    #####:46512:        xmlResetLastError();
    #####:46513:        if (mem_base != xmlMemBlocks()) {
    #####:46514:            printf("Leak of %d blocks found in xmlXPathContextSetCache",
    #####:46515:	           xmlMemBlocks() - mem_base);
    #####:46516:	    test_ret++;
    #####:46517:            printf(" %d", n_ctxt);
    #####:46518:            printf(" %d", n_active);
    #####:46519:            printf(" %d", n_value);
    #####:46520:            printf(" %d", n_options);
    #####:46521:            printf("\n");
        -:46522:        }
        -:46523:    }
        -:46524:    }
        -:46525:    }
        -:46526:    }
    #####:46527:    function_tests++;
        -:46528:#endif
        -:46529:
    #####:46530:    return(test_ret);
        -:46531:}
        -:46532:
        -:46533:
        -:46534:static int
    #####:46535:test_xmlXPathConvertBoolean(void) {
    #####:46536:    int test_ret = 0;
        -:46537:
        -:46538:#if defined(LIBXML_XPATH_ENABLED)
        -:46539:    int mem_base;
        -:46540:    xmlXPathObjectPtr ret_val;
        -:46541:    xmlXPathObjectPtr val; /* an XPath object */
        -:46542:    int n_val;
        -:46543:
    #####:46544:    for (n_val = 0;n_val < gen_nb_xmlXPathObjectPtr;n_val++) {
    #####:46545:        mem_base = xmlMemBlocks();
    #####:46546:        val = gen_xmlXPathObjectPtr(n_val, 0);
        -:46547:
    #####:46548:        ret_val = xmlXPathConvertBoolean(val);
    #####:46549:        val = NULL;
    #####:46550:        desret_xmlXPathObjectPtr(ret_val);
    #####:46551:        call_tests++;
    #####:46552:        des_xmlXPathObjectPtr(n_val, val, 0);
    #####:46553:        xmlResetLastError();
    #####:46554:        if (mem_base != xmlMemBlocks()) {
    #####:46555:            printf("Leak of %d blocks found in xmlXPathConvertBoolean",
    #####:46556:	           xmlMemBlocks() - mem_base);
    #####:46557:	    test_ret++;
    #####:46558:            printf(" %d", n_val);
    #####:46559:            printf("\n");
        -:46560:        }
        -:46561:    }
    #####:46562:    function_tests++;
        -:46563:#endif
        -:46564:
    #####:46565:    return(test_ret);
        -:46566:}
        -:46567:
        -:46568:
        -:46569:static int
    #####:46570:test_xmlXPathConvertNumber(void) {
    #####:46571:    int test_ret = 0;
        -:46572:
        -:46573:#if defined(LIBXML_XPATH_ENABLED)
        -:46574:    int mem_base;
        -:46575:    xmlXPathObjectPtr ret_val;
        -:46576:    xmlXPathObjectPtr val; /* an XPath object */
        -:46577:    int n_val;
        -:46578:
    #####:46579:    for (n_val = 0;n_val < gen_nb_xmlXPathObjectPtr;n_val++) {
    #####:46580:        mem_base = xmlMemBlocks();
    #####:46581:        val = gen_xmlXPathObjectPtr(n_val, 0);
        -:46582:
    #####:46583:        ret_val = xmlXPathConvertNumber(val);
    #####:46584:        val = NULL;
    #####:46585:        desret_xmlXPathObjectPtr(ret_val);
    #####:46586:        call_tests++;
    #####:46587:        des_xmlXPathObjectPtr(n_val, val, 0);
    #####:46588:        xmlResetLastError();
    #####:46589:        if (mem_base != xmlMemBlocks()) {
    #####:46590:            printf("Leak of %d blocks found in xmlXPathConvertNumber",
    #####:46591:	           xmlMemBlocks() - mem_base);
    #####:46592:	    test_ret++;
    #####:46593:            printf(" %d", n_val);
    #####:46594:            printf("\n");
        -:46595:        }
        -:46596:    }
    #####:46597:    function_tests++;
        -:46598:#endif
        -:46599:
    #####:46600:    return(test_ret);
        -:46601:}
        -:46602:
        -:46603:
        -:46604:static int
    #####:46605:test_xmlXPathConvertString(void) {
    #####:46606:    int test_ret = 0;
        -:46607:
        -:46608:#if defined(LIBXML_XPATH_ENABLED)
        -:46609:    int mem_base;
        -:46610:    xmlXPathObjectPtr ret_val;
        -:46611:    xmlXPathObjectPtr val; /* an XPath object */
        -:46612:    int n_val;
        -:46613:
    #####:46614:    for (n_val = 0;n_val < gen_nb_xmlXPathObjectPtr;n_val++) {
    #####:46615:        mem_base = xmlMemBlocks();
    #####:46616:        val = gen_xmlXPathObjectPtr(n_val, 0);
        -:46617:
    #####:46618:        ret_val = xmlXPathConvertString(val);
    #####:46619:        val = NULL;
    #####:46620:        desret_xmlXPathObjectPtr(ret_val);
    #####:46621:        call_tests++;
    #####:46622:        des_xmlXPathObjectPtr(n_val, val, 0);
    #####:46623:        xmlResetLastError();
    #####:46624:        if (mem_base != xmlMemBlocks()) {
    #####:46625:            printf("Leak of %d blocks found in xmlXPathConvertString",
    #####:46626:	           xmlMemBlocks() - mem_base);
    #####:46627:	    test_ret++;
    #####:46628:            printf(" %d", n_val);
    #####:46629:            printf("\n");
        -:46630:        }
        -:46631:    }
    #####:46632:    function_tests++;
        -:46633:#endif
        -:46634:
    #####:46635:    return(test_ret);
        -:46636:}
        -:46637:
        -:46638:
        -:46639:static int
    #####:46640:test_xmlXPathCtxtCompile(void) {
    #####:46641:    int test_ret = 0;
        -:46642:
        -:46643:
        -:46644:    /* missing type support */
    #####:46645:    return(test_ret);
        -:46646:}
        -:46647:
        -:46648:
        -:46649:static int
    #####:46650:test_xmlXPathEval(void) {
    #####:46651:    int test_ret = 0;
        -:46652:
        -:46653:#if defined(LIBXML_XPATH_ENABLED)
        -:46654:    int mem_base;
        -:46655:    xmlXPathObjectPtr ret_val;
        -:46656:    xmlChar * str; /* the XPath expression */
        -:46657:    int n_str;
        -:46658:    xmlXPathContextPtr ctx; /* the XPath context */
        -:46659:    int n_ctx;
        -:46660:
    #####:46661:    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    #####:46662:    for (n_ctx = 0;n_ctx < gen_nb_xmlXPathContextPtr;n_ctx++) {
    #####:46663:        mem_base = xmlMemBlocks();
    #####:46664:        str = gen_const_xmlChar_ptr(n_str, 0);
    #####:46665:        ctx = gen_xmlXPathContextPtr(n_ctx, 1);
        -:46666:
    #####:46667:        ret_val = xmlXPathEval((const xmlChar *)str, ctx);
    #####:46668:        desret_xmlXPathObjectPtr(ret_val);
    #####:46669:        call_tests++;
    #####:46670:        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 0);
    #####:46671:        des_xmlXPathContextPtr(n_ctx, ctx, 1);
    #####:46672:        xmlResetLastError();
    #####:46673:        if (mem_base != xmlMemBlocks()) {
    #####:46674:            printf("Leak of %d blocks found in xmlXPathEval",
    #####:46675:	           xmlMemBlocks() - mem_base);
    #####:46676:	    test_ret++;
    #####:46677:            printf(" %d", n_str);
    #####:46678:            printf(" %d", n_ctx);
    #####:46679:            printf("\n");
        -:46680:        }
        -:46681:    }
        -:46682:    }
    #####:46683:    function_tests++;
        -:46684:#endif
        -:46685:
    #####:46686:    return(test_ret);
        -:46687:}
        -:46688:
        -:46689:
        -:46690:static int
    #####:46691:test_xmlXPathEvalExpression(void) {
    #####:46692:    int test_ret = 0;
        -:46693:
        -:46694:#if defined(LIBXML_XPATH_ENABLED)
        -:46695:    int mem_base;
        -:46696:    xmlXPathObjectPtr ret_val;
        -:46697:    xmlChar * str; /* the XPath expression */
        -:46698:    int n_str;
        -:46699:    xmlXPathContextPtr ctxt; /* the XPath context */
        -:46700:    int n_ctxt;
        -:46701:
    #####:46702:    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    #####:46703:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathContextPtr;n_ctxt++) {
    #####:46704:        mem_base = xmlMemBlocks();
    #####:46705:        str = gen_const_xmlChar_ptr(n_str, 0);
    #####:46706:        ctxt = gen_xmlXPathContextPtr(n_ctxt, 1);
        -:46707:
    #####:46708:        ret_val = xmlXPathEvalExpression((const xmlChar *)str, ctxt);
    #####:46709:        desret_xmlXPathObjectPtr(ret_val);
    #####:46710:        call_tests++;
    #####:46711:        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 0);
    #####:46712:        des_xmlXPathContextPtr(n_ctxt, ctxt, 1);
    #####:46713:        xmlResetLastError();
    #####:46714:        if (mem_base != xmlMemBlocks()) {
    #####:46715:            printf("Leak of %d blocks found in xmlXPathEvalExpression",
    #####:46716:	           xmlMemBlocks() - mem_base);
    #####:46717:	    test_ret++;
    #####:46718:            printf(" %d", n_str);
    #####:46719:            printf(" %d", n_ctxt);
    #####:46720:            printf("\n");
        -:46721:        }
        -:46722:    }
        -:46723:    }
    #####:46724:    function_tests++;
        -:46725:#endif
        -:46726:
    #####:46727:    return(test_ret);
        -:46728:}
        -:46729:
        -:46730:
        -:46731:static int
    #####:46732:test_xmlXPathEvalPredicate(void) {
    #####:46733:    int test_ret = 0;
        -:46734:
        -:46735:#if defined(LIBXML_XPATH_ENABLED)
        -:46736:    int mem_base;
        -:46737:    int ret_val;
        -:46738:    xmlXPathContextPtr ctxt; /* the XPath context */
        -:46739:    int n_ctxt;
        -:46740:    xmlXPathObjectPtr res; /* the Predicate Expression evaluation result */
        -:46741:    int n_res;
        -:46742:
    #####:46743:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathContextPtr;n_ctxt++) {
    #####:46744:    for (n_res = 0;n_res < gen_nb_xmlXPathObjectPtr;n_res++) {
    #####:46745:        mem_base = xmlMemBlocks();
    #####:46746:        ctxt = gen_xmlXPathContextPtr(n_ctxt, 0);
    #####:46747:        res = gen_xmlXPathObjectPtr(n_res, 1);
        -:46748:
    #####:46749:        ret_val = xmlXPathEvalPredicate(ctxt, res);
    #####:46750:        desret_int(ret_val);
    #####:46751:        call_tests++;
    #####:46752:        des_xmlXPathContextPtr(n_ctxt, ctxt, 0);
    #####:46753:        des_xmlXPathObjectPtr(n_res, res, 1);
    #####:46754:        xmlResetLastError();
    #####:46755:        if (mem_base != xmlMemBlocks()) {
    #####:46756:            printf("Leak of %d blocks found in xmlXPathEvalPredicate",
    #####:46757:	           xmlMemBlocks() - mem_base);
    #####:46758:	    test_ret++;
    #####:46759:            printf(" %d", n_ctxt);
    #####:46760:            printf(" %d", n_res);
    #####:46761:            printf("\n");
        -:46762:        }
        -:46763:    }
        -:46764:    }
    #####:46765:    function_tests++;
        -:46766:#endif
        -:46767:
    #####:46768:    return(test_ret);
        -:46769:}
        -:46770:
        -:46771:
        -:46772:static int
    #####:46773:test_xmlXPathInit(void) {
    #####:46774:    int test_ret = 0;
        -:46775:
        -:46776:#if defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
        -:46777:    int mem_base;
        -:46778:
    #####:46779:        mem_base = xmlMemBlocks();
        -:46780:
    #####:46781:        xmlXPathInit();
    #####:46782:        call_tests++;
    #####:46783:        xmlResetLastError();
    #####:46784:        if (mem_base != xmlMemBlocks()) {
    #####:46785:            printf("Leak of %d blocks found in xmlXPathInit",
    #####:46786:	           xmlMemBlocks() - mem_base);
    #####:46787:	    test_ret++;
    #####:46788:            printf("\n");
        -:46789:        }
    #####:46790:    function_tests++;
        -:46791:#endif
        -:46792:
    #####:46793:    return(test_ret);
        -:46794:}
        -:46795:
        -:46796:
        -:46797:static int
    #####:46798:test_xmlXPathIsInf(void) {
    #####:46799:    int test_ret = 0;
        -:46800:
        -:46801:#if defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
        -:46802:    int mem_base;
        -:46803:    int ret_val;
        -:46804:    double val; /* a double value */
        -:46805:    int n_val;
        -:46806:
    #####:46807:    for (n_val = 0;n_val < gen_nb_double;n_val++) {
    #####:46808:        mem_base = xmlMemBlocks();
    #####:46809:        val = gen_double(n_val, 0);
        -:46810:
    #####:46811:        ret_val = xmlXPathIsInf(val);
    #####:46812:        desret_int(ret_val);
    #####:46813:        call_tests++;
    #####:46814:        des_double(n_val, val, 0);
    #####:46815:        xmlResetLastError();
    #####:46816:        if (mem_base != xmlMemBlocks()) {
    #####:46817:            printf("Leak of %d blocks found in xmlXPathIsInf",
    #####:46818:	           xmlMemBlocks() - mem_base);
    #####:46819:	    test_ret++;
    #####:46820:            printf(" %d", n_val);
    #####:46821:            printf("\n");
        -:46822:        }
        -:46823:    }
    #####:46824:    function_tests++;
        -:46825:#endif
        -:46826:
    #####:46827:    return(test_ret);
        -:46828:}
        -:46829:
        -:46830:
        -:46831:static int
    #####:46832:test_xmlXPathIsNaN(void) {
    #####:46833:    int test_ret = 0;
        -:46834:
        -:46835:#if defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
        -:46836:    int mem_base;
        -:46837:    int ret_val;
        -:46838:    double val; /* a double value */
        -:46839:    int n_val;
        -:46840:
    #####:46841:    for (n_val = 0;n_val < gen_nb_double;n_val++) {
    #####:46842:        mem_base = xmlMemBlocks();
    #####:46843:        val = gen_double(n_val, 0);
        -:46844:
    #####:46845:        ret_val = xmlXPathIsNaN(val);
    #####:46846:        desret_int(ret_val);
    #####:46847:        call_tests++;
    #####:46848:        des_double(n_val, val, 0);
    #####:46849:        xmlResetLastError();
    #####:46850:        if (mem_base != xmlMemBlocks()) {
    #####:46851:            printf("Leak of %d blocks found in xmlXPathIsNaN",
    #####:46852:	           xmlMemBlocks() - mem_base);
    #####:46853:	    test_ret++;
    #####:46854:            printf(" %d", n_val);
    #####:46855:            printf("\n");
        -:46856:        }
        -:46857:    }
    #####:46858:    function_tests++;
        -:46859:#endif
        -:46860:
    #####:46861:    return(test_ret);
        -:46862:}
        -:46863:
        -:46864:
        -:46865:static int
    #####:46866:test_xmlXPathNewContext(void) {
    #####:46867:    int test_ret = 0;
        -:46868:
        -:46869:
        -:46870:    /* missing type support */
    #####:46871:    return(test_ret);
        -:46872:}
        -:46873:
        -:46874:
        -:46875:static int
    #####:46876:test_xmlXPathNodeEval(void) {
    #####:46877:    int test_ret = 0;
        -:46878:
        -:46879:#if defined(LIBXML_XPATH_ENABLED)
        -:46880:    int mem_base;
        -:46881:    xmlXPathObjectPtr ret_val;
        -:46882:    xmlNodePtr node; /* the node to to use as the context node */
        -:46883:    int n_node;
        -:46884:    xmlChar * str; /* the XPath expression */
        -:46885:    int n_str;
        -:46886:    xmlXPathContextPtr ctx; /* the XPath context */
        -:46887:    int n_ctx;
        -:46888:
    #####:46889:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:46890:    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    #####:46891:    for (n_ctx = 0;n_ctx < gen_nb_xmlXPathContextPtr;n_ctx++) {
    #####:46892:        mem_base = xmlMemBlocks();
    #####:46893:        node = gen_xmlNodePtr(n_node, 0);
    #####:46894:        str = gen_const_xmlChar_ptr(n_str, 1);
    #####:46895:        ctx = gen_xmlXPathContextPtr(n_ctx, 2);
        -:46896:
    #####:46897:        ret_val = xmlXPathNodeEval(node, (const xmlChar *)str, ctx);
    #####:46898:        desret_xmlXPathObjectPtr(ret_val);
    #####:46899:        call_tests++;
    #####:46900:        des_xmlNodePtr(n_node, node, 0);
    #####:46901:        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 1);
    #####:46902:        des_xmlXPathContextPtr(n_ctx, ctx, 2);
    #####:46903:        xmlResetLastError();
    #####:46904:        if (mem_base != xmlMemBlocks()) {
    #####:46905:            printf("Leak of %d blocks found in xmlXPathNodeEval",
    #####:46906:	           xmlMemBlocks() - mem_base);
    #####:46907:	    test_ret++;
    #####:46908:            printf(" %d", n_node);
    #####:46909:            printf(" %d", n_str);
    #####:46910:            printf(" %d", n_ctx);
    #####:46911:            printf("\n");
        -:46912:        }
        -:46913:    }
        -:46914:    }
        -:46915:    }
    #####:46916:    function_tests++;
        -:46917:#endif
        -:46918:
    #####:46919:    return(test_ret);
        -:46920:}
        -:46921:
        -:46922:
        -:46923:static int
    #####:46924:test_xmlXPathNodeSetCreate(void) {
    #####:46925:    int test_ret = 0;
        -:46926:
        -:46927:#if defined(LIBXML_XPATH_ENABLED)
        -:46928:    int mem_base;
        -:46929:    xmlNodeSetPtr ret_val;
        -:46930:    xmlNodePtr val; /* an initial xmlNodePtr, or NULL */
        -:46931:    int n_val;
        -:46932:
    #####:46933:    for (n_val = 0;n_val < gen_nb_xmlNodePtr;n_val++) {
    #####:46934:        mem_base = xmlMemBlocks();
    #####:46935:        val = gen_xmlNodePtr(n_val, 0);
        -:46936:
    #####:46937:        ret_val = xmlXPathNodeSetCreate(val);
    #####:46938:        desret_xmlNodeSetPtr(ret_val);
    #####:46939:        call_tests++;
    #####:46940:        des_xmlNodePtr(n_val, val, 0);
    #####:46941:        xmlResetLastError();
    #####:46942:        if (mem_base != xmlMemBlocks()) {
    #####:46943:            printf("Leak of %d blocks found in xmlXPathNodeSetCreate",
    #####:46944:	           xmlMemBlocks() - mem_base);
    #####:46945:	    test_ret++;
    #####:46946:            printf(" %d", n_val);
    #####:46947:            printf("\n");
        -:46948:        }
        -:46949:    }
    #####:46950:    function_tests++;
        -:46951:#endif
        -:46952:
    #####:46953:    return(test_ret);
        -:46954:}
        -:46955:
        -:46956:
        -:46957:static int
    #####:46958:test_xmlXPathObjectCopy(void) {
    #####:46959:    int test_ret = 0;
        -:46960:
        -:46961:#if defined(LIBXML_XPATH_ENABLED)
        -:46962:    int mem_base;
        -:46963:    xmlXPathObjectPtr ret_val;
        -:46964:    xmlXPathObjectPtr val; /* the original object */
        -:46965:    int n_val;
        -:46966:
    #####:46967:    for (n_val = 0;n_val < gen_nb_xmlXPathObjectPtr;n_val++) {
    #####:46968:        mem_base = xmlMemBlocks();
    #####:46969:        val = gen_xmlXPathObjectPtr(n_val, 0);
        -:46970:
    #####:46971:        ret_val = xmlXPathObjectCopy(val);
    #####:46972:        desret_xmlXPathObjectPtr(ret_val);
    #####:46973:        call_tests++;
    #####:46974:        des_xmlXPathObjectPtr(n_val, val, 0);
    #####:46975:        xmlResetLastError();
    #####:46976:        if (mem_base != xmlMemBlocks()) {
    #####:46977:            printf("Leak of %d blocks found in xmlXPathObjectCopy",
    #####:46978:	           xmlMemBlocks() - mem_base);
    #####:46979:	    test_ret++;
    #####:46980:            printf(" %d", n_val);
    #####:46981:            printf("\n");
        -:46982:        }
        -:46983:    }
    #####:46984:    function_tests++;
        -:46985:#endif
        -:46986:
    #####:46987:    return(test_ret);
        -:46988:}
        -:46989:
        -:46990:
        -:46991:static int
    #####:46992:test_xmlXPathOrderDocElems(void) {
    #####:46993:    int test_ret = 0;
        -:46994:
        -:46995:#if defined(LIBXML_XPATH_ENABLED)
        -:46996:    int mem_base;
        -:46997:    long ret_val;
        -:46998:    xmlDocPtr doc; /* an input document */
        -:46999:    int n_doc;
        -:47000:
    #####:47001:    for (n_doc = 0;n_doc < gen_nb_xmlDocPtr;n_doc++) {
    #####:47002:        mem_base = xmlMemBlocks();
    #####:47003:        doc = gen_xmlDocPtr(n_doc, 0);
        -:47004:
    #####:47005:        ret_val = xmlXPathOrderDocElems(doc);
    #####:47006:        desret_long(ret_val);
    #####:47007:        call_tests++;
    #####:47008:        des_xmlDocPtr(n_doc, doc, 0);
    #####:47009:        xmlResetLastError();
    #####:47010:        if (mem_base != xmlMemBlocks()) {
    #####:47011:            printf("Leak of %d blocks found in xmlXPathOrderDocElems",
    #####:47012:	           xmlMemBlocks() - mem_base);
    #####:47013:	    test_ret++;
    #####:47014:            printf(" %d", n_doc);
    #####:47015:            printf("\n");
        -:47016:        }
        -:47017:    }
    #####:47018:    function_tests++;
        -:47019:#endif
        -:47020:
    #####:47021:    return(test_ret);
        -:47022:}
        -:47023:
        -:47024:
        -:47025:static int
    #####:47026:test_xmlXPathSetContextNode(void) {
    #####:47027:    int test_ret = 0;
        -:47028:
        -:47029:#if defined(LIBXML_XPATH_ENABLED)
        -:47030:    int mem_base;
        -:47031:    int ret_val;
        -:47032:    xmlNodePtr node; /* the node to to use as the context node */
        -:47033:    int n_node;
        -:47034:    xmlXPathContextPtr ctx; /* the XPath context */
        -:47035:    int n_ctx;
        -:47036:
    #####:47037:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:47038:    for (n_ctx = 0;n_ctx < gen_nb_xmlXPathContextPtr;n_ctx++) {
    #####:47039:        mem_base = xmlMemBlocks();
    #####:47040:        node = gen_xmlNodePtr(n_node, 0);
    #####:47041:        ctx = gen_xmlXPathContextPtr(n_ctx, 1);
        -:47042:
    #####:47043:        ret_val = xmlXPathSetContextNode(node, ctx);
    #####:47044:        desret_int(ret_val);
    #####:47045:        call_tests++;
    #####:47046:        des_xmlNodePtr(n_node, node, 0);
    #####:47047:        des_xmlXPathContextPtr(n_ctx, ctx, 1);
    #####:47048:        xmlResetLastError();
    #####:47049:        if (mem_base != xmlMemBlocks()) {
    #####:47050:            printf("Leak of %d blocks found in xmlXPathSetContextNode",
    #####:47051:	           xmlMemBlocks() - mem_base);
    #####:47052:	    test_ret++;
    #####:47053:            printf(" %d", n_node);
    #####:47054:            printf(" %d", n_ctx);
    #####:47055:            printf("\n");
        -:47056:        }
        -:47057:    }
        -:47058:    }
    #####:47059:    function_tests++;
        -:47060:#endif
        -:47061:
    #####:47062:    return(test_ret);
        -:47063:}
        -:47064:
        -:47065:static int
    #####:47066:test_xpath(void) {
    #####:47067:    int test_ret = 0;
        -:47068:
    #####:47069:    if (quiet == 0) printf("Testing xpath : 32 of 40 functions ...\n");
    #####:47070:    test_ret += test_xmlXPathCastBooleanToNumber();
    #####:47071:    test_ret += test_xmlXPathCastBooleanToString();
    #####:47072:    test_ret += test_xmlXPathCastNodeSetToBoolean();
    #####:47073:    test_ret += test_xmlXPathCastNodeSetToNumber();
    #####:47074:    test_ret += test_xmlXPathCastNodeSetToString();
    #####:47075:    test_ret += test_xmlXPathCastNodeToNumber();
    #####:47076:    test_ret += test_xmlXPathCastNodeToString();
    #####:47077:    test_ret += test_xmlXPathCastNumberToBoolean();
    #####:47078:    test_ret += test_xmlXPathCastNumberToString();
    #####:47079:    test_ret += test_xmlXPathCastStringToBoolean();
    #####:47080:    test_ret += test_xmlXPathCastStringToNumber();
    #####:47081:    test_ret += test_xmlXPathCastToBoolean();
    #####:47082:    test_ret += test_xmlXPathCastToNumber();
    #####:47083:    test_ret += test_xmlXPathCastToString();
    #####:47084:    test_ret += test_xmlXPathCmpNodes();
    #####:47085:    test_ret += test_xmlXPathCompile();
    #####:47086:    test_ret += test_xmlXPathCompiledEval();
    #####:47087:    test_ret += test_xmlXPathCompiledEvalToBoolean();
    #####:47088:    test_ret += test_xmlXPathContextSetCache();
    #####:47089:    test_ret += test_xmlXPathConvertBoolean();
    #####:47090:    test_ret += test_xmlXPathConvertNumber();
    #####:47091:    test_ret += test_xmlXPathConvertString();
    #####:47092:    test_ret += test_xmlXPathCtxtCompile();
    #####:47093:    test_ret += test_xmlXPathEval();
    #####:47094:    test_ret += test_xmlXPathEvalExpression();
    #####:47095:    test_ret += test_xmlXPathEvalPredicate();
    #####:47096:    test_ret += test_xmlXPathInit();
    #####:47097:    test_ret += test_xmlXPathIsInf();
    #####:47098:    test_ret += test_xmlXPathIsNaN();
    #####:47099:    test_ret += test_xmlXPathNewContext();
    #####:47100:    test_ret += test_xmlXPathNodeEval();
    #####:47101:    test_ret += test_xmlXPathNodeSetCreate();
    #####:47102:    test_ret += test_xmlXPathObjectCopy();
    #####:47103:    test_ret += test_xmlXPathOrderDocElems();
    #####:47104:    test_ret += test_xmlXPathSetContextNode();
        -:47105:
    #####:47106:    if (test_ret != 0)
    #####:47107:	printf("Module xpath: %d errors\n", test_ret);
    #####:47108:    return(test_ret);
        -:47109:}
        -:47110:#ifdef LIBXML_XPATH_ENABLED
        -:47111:
        -:47112:#define gen_nb_xmlXPathParserContextPtr 1
    #####:47113:static xmlXPathParserContextPtr gen_xmlXPathParserContextPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:47114:    return(NULL);
        -:47115:}
    #####:47116:static void des_xmlXPathParserContextPtr(int no ATTRIBUTE_UNUSED, xmlXPathParserContextPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:47117:}
        -:47118:#endif
        -:47119:
        -:47120:
        -:47121:static int
    #####:47122:test_valuePop(void) {
    #####:47123:    int test_ret = 0;
        -:47124:
        -:47125:#if defined(LIBXML_XPATH_ENABLED)
        -:47126:    int mem_base;
        -:47127:    xmlXPathObjectPtr ret_val;
        -:47128:    xmlXPathParserContextPtr ctxt; /* an XPath evaluation context */
        -:47129:    int n_ctxt;
        -:47130:
    #####:47131:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:47132:        mem_base = xmlMemBlocks();
    #####:47133:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        -:47134:
    #####:47135:        ret_val = valuePop(ctxt);
    #####:47136:        desret_xmlXPathObjectPtr(ret_val);
    #####:47137:        call_tests++;
    #####:47138:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:47139:        xmlResetLastError();
    #####:47140:        if (mem_base != xmlMemBlocks()) {
    #####:47141:            printf("Leak of %d blocks found in valuePop",
    #####:47142:	           xmlMemBlocks() - mem_base);
    #####:47143:	    test_ret++;
    #####:47144:            printf(" %d", n_ctxt);
    #####:47145:            printf("\n");
        -:47146:        }
        -:47147:    }
    #####:47148:    function_tests++;
        -:47149:#endif
        -:47150:
    #####:47151:    return(test_ret);
        -:47152:}
        -:47153:
        -:47154:
        -:47155:static int
    #####:47156:test_valuePush(void) {
    #####:47157:    int test_ret = 0;
        -:47158:
        -:47159:#if defined(LIBXML_XPATH_ENABLED)
        -:47160:    int mem_base;
        -:47161:    int ret_val;
        -:47162:    xmlXPathParserContextPtr ctxt; /* an XPath evaluation context */
        -:47163:    int n_ctxt;
        -:47164:    xmlXPathObjectPtr value; /* the XPath object */
        -:47165:    int n_value;
        -:47166:
    #####:47167:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:47168:    for (n_value = 0;n_value < gen_nb_xmlXPathObjectPtr;n_value++) {
    #####:47169:        mem_base = xmlMemBlocks();
    #####:47170:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:47171:        value = gen_xmlXPathObjectPtr(n_value, 1);
        -:47172:
    #####:47173:        ret_val = valuePush(ctxt, value);
    #####:47174:        desret_int(ret_val);
    #####:47175:        call_tests++;
    #####:47176:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:47177:        des_xmlXPathObjectPtr(n_value, value, 1);
    #####:47178:        xmlResetLastError();
    #####:47179:        if (mem_base != xmlMemBlocks()) {
    #####:47180:            printf("Leak of %d blocks found in valuePush",
    #####:47181:	           xmlMemBlocks() - mem_base);
    #####:47182:	    test_ret++;
    #####:47183:            printf(" %d", n_ctxt);
    #####:47184:            printf(" %d", n_value);
    #####:47185:            printf("\n");
        -:47186:        }
        -:47187:    }
        -:47188:    }
    #####:47189:    function_tests++;
        -:47190:#endif
        -:47191:
    #####:47192:    return(test_ret);
        -:47193:}
        -:47194:
        -:47195:
        -:47196:static int
    #####:47197:test_xmlXPathAddValues(void) {
    #####:47198:    int test_ret = 0;
        -:47199:
        -:47200:#if defined(LIBXML_XPATH_ENABLED)
        -:47201:    int mem_base;
        -:47202:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:47203:    int n_ctxt;
        -:47204:
    #####:47205:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:47206:        mem_base = xmlMemBlocks();
    #####:47207:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        -:47208:
    #####:47209:        xmlXPathAddValues(ctxt);
    #####:47210:        call_tests++;
    #####:47211:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:47212:        xmlResetLastError();
    #####:47213:        if (mem_base != xmlMemBlocks()) {
    #####:47214:            printf("Leak of %d blocks found in xmlXPathAddValues",
    #####:47215:	           xmlMemBlocks() - mem_base);
    #####:47216:	    test_ret++;
    #####:47217:            printf(" %d", n_ctxt);
    #####:47218:            printf("\n");
        -:47219:        }
        -:47220:    }
    #####:47221:    function_tests++;
        -:47222:#endif
        -:47223:
    #####:47224:    return(test_ret);
        -:47225:}
        -:47226:
        -:47227:
        -:47228:static int
    #####:47229:test_xmlXPathBooleanFunction(void) {
    #####:47230:    int test_ret = 0;
        -:47231:
        -:47232:#if defined(LIBXML_XPATH_ENABLED)
        -:47233:    int mem_base;
        -:47234:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:47235:    int n_ctxt;
        -:47236:    int nargs; /* the number of arguments */
        -:47237:    int n_nargs;
        -:47238:
    #####:47239:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:47240:    for (n_nargs = 0;n_nargs < gen_nb_int;n_nargs++) {
    #####:47241:        mem_base = xmlMemBlocks();
    #####:47242:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:47243:        nargs = gen_int(n_nargs, 1);
        -:47244:
    #####:47245:        xmlXPathBooleanFunction(ctxt, nargs);
    #####:47246:        call_tests++;
    #####:47247:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:47248:        des_int(n_nargs, nargs, 1);
    #####:47249:        xmlResetLastError();
    #####:47250:        if (mem_base != xmlMemBlocks()) {
    #####:47251:            printf("Leak of %d blocks found in xmlXPathBooleanFunction",
    #####:47252:	           xmlMemBlocks() - mem_base);
    #####:47253:	    test_ret++;
    #####:47254:            printf(" %d", n_ctxt);
    #####:47255:            printf(" %d", n_nargs);
    #####:47256:            printf("\n");
        -:47257:        }
        -:47258:    }
        -:47259:    }
    #####:47260:    function_tests++;
        -:47261:#endif
        -:47262:
    #####:47263:    return(test_ret);
        -:47264:}
        -:47265:
        -:47266:
        -:47267:static int
    #####:47268:test_xmlXPathCeilingFunction(void) {
    #####:47269:    int test_ret = 0;
        -:47270:
        -:47271:#if defined(LIBXML_XPATH_ENABLED)
        -:47272:    int mem_base;
        -:47273:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:47274:    int n_ctxt;
        -:47275:    int nargs; /* the number of arguments */
        -:47276:    int n_nargs;
        -:47277:
    #####:47278:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:47279:    for (n_nargs = 0;n_nargs < gen_nb_int;n_nargs++) {
    #####:47280:        mem_base = xmlMemBlocks();
    #####:47281:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:47282:        nargs = gen_int(n_nargs, 1);
        -:47283:
    #####:47284:        xmlXPathCeilingFunction(ctxt, nargs);
    #####:47285:        call_tests++;
    #####:47286:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:47287:        des_int(n_nargs, nargs, 1);
    #####:47288:        xmlResetLastError();
    #####:47289:        if (mem_base != xmlMemBlocks()) {
    #####:47290:            printf("Leak of %d blocks found in xmlXPathCeilingFunction",
    #####:47291:	           xmlMemBlocks() - mem_base);
    #####:47292:	    test_ret++;
    #####:47293:            printf(" %d", n_ctxt);
    #####:47294:            printf(" %d", n_nargs);
    #####:47295:            printf("\n");
        -:47296:        }
        -:47297:    }
        -:47298:    }
    #####:47299:    function_tests++;
        -:47300:#endif
        -:47301:
    #####:47302:    return(test_ret);
        -:47303:}
        -:47304:
        -:47305:
        -:47306:static int
    #####:47307:test_xmlXPathCompareValues(void) {
    #####:47308:    int test_ret = 0;
        -:47309:
        -:47310:#if defined(LIBXML_XPATH_ENABLED)
        -:47311:    int mem_base;
        -:47312:    int ret_val;
        -:47313:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:47314:    int n_ctxt;
        -:47315:    int inf; /* less than (1) or greater than (0) */
        -:47316:    int n_inf;
        -:47317:    int strict; /* is the comparison strict */
        -:47318:    int n_strict;
        -:47319:
    #####:47320:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:47321:    for (n_inf = 0;n_inf < gen_nb_int;n_inf++) {
    #####:47322:    for (n_strict = 0;n_strict < gen_nb_int;n_strict++) {
    #####:47323:        mem_base = xmlMemBlocks();
    #####:47324:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:47325:        inf = gen_int(n_inf, 1);
    #####:47326:        strict = gen_int(n_strict, 2);
        -:47327:
    #####:47328:        ret_val = xmlXPathCompareValues(ctxt, inf, strict);
    #####:47329:        desret_int(ret_val);
    #####:47330:        call_tests++;
    #####:47331:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:47332:        des_int(n_inf, inf, 1);
    #####:47333:        des_int(n_strict, strict, 2);
    #####:47334:        xmlResetLastError();
    #####:47335:        if (mem_base != xmlMemBlocks()) {
    #####:47336:            printf("Leak of %d blocks found in xmlXPathCompareValues",
    #####:47337:	           xmlMemBlocks() - mem_base);
    #####:47338:	    test_ret++;
    #####:47339:            printf(" %d", n_ctxt);
    #####:47340:            printf(" %d", n_inf);
    #####:47341:            printf(" %d", n_strict);
    #####:47342:            printf("\n");
        -:47343:        }
        -:47344:    }
        -:47345:    }
        -:47346:    }
    #####:47347:    function_tests++;
        -:47348:#endif
        -:47349:
    #####:47350:    return(test_ret);
        -:47351:}
        -:47352:
        -:47353:
        -:47354:static int
    #####:47355:test_xmlXPathConcatFunction(void) {
    #####:47356:    int test_ret = 0;
        -:47357:
        -:47358:#if defined(LIBXML_XPATH_ENABLED)
        -:47359:    int mem_base;
        -:47360:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:47361:    int n_ctxt;
        -:47362:    int nargs; /* the number of arguments */
        -:47363:    int n_nargs;
        -:47364:
    #####:47365:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:47366:    for (n_nargs = 0;n_nargs < gen_nb_int;n_nargs++) {
    #####:47367:        mem_base = xmlMemBlocks();
    #####:47368:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:47369:        nargs = gen_int(n_nargs, 1);
        -:47370:
    #####:47371:        xmlXPathConcatFunction(ctxt, nargs);
    #####:47372:        call_tests++;
    #####:47373:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:47374:        des_int(n_nargs, nargs, 1);
    #####:47375:        xmlResetLastError();
    #####:47376:        if (mem_base != xmlMemBlocks()) {
    #####:47377:            printf("Leak of %d blocks found in xmlXPathConcatFunction",
    #####:47378:	           xmlMemBlocks() - mem_base);
    #####:47379:	    test_ret++;
    #####:47380:            printf(" %d", n_ctxt);
    #####:47381:            printf(" %d", n_nargs);
    #####:47382:            printf("\n");
        -:47383:        }
        -:47384:    }
        -:47385:    }
    #####:47386:    function_tests++;
        -:47387:#endif
        -:47388:
    #####:47389:    return(test_ret);
        -:47390:}
        -:47391:
        -:47392:
        -:47393:static int
    #####:47394:test_xmlXPathContainsFunction(void) {
    #####:47395:    int test_ret = 0;
        -:47396:
        -:47397:#if defined(LIBXML_XPATH_ENABLED)
        -:47398:    int mem_base;
        -:47399:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:47400:    int n_ctxt;
        -:47401:    int nargs; /* the number of arguments */
        -:47402:    int n_nargs;
        -:47403:
    #####:47404:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:47405:    for (n_nargs = 0;n_nargs < gen_nb_int;n_nargs++) {
    #####:47406:        mem_base = xmlMemBlocks();
    #####:47407:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:47408:        nargs = gen_int(n_nargs, 1);
        -:47409:
    #####:47410:        xmlXPathContainsFunction(ctxt, nargs);
    #####:47411:        call_tests++;
    #####:47412:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:47413:        des_int(n_nargs, nargs, 1);
    #####:47414:        xmlResetLastError();
    #####:47415:        if (mem_base != xmlMemBlocks()) {
    #####:47416:            printf("Leak of %d blocks found in xmlXPathContainsFunction",
    #####:47417:	           xmlMemBlocks() - mem_base);
    #####:47418:	    test_ret++;
    #####:47419:            printf(" %d", n_ctxt);
    #####:47420:            printf(" %d", n_nargs);
    #####:47421:            printf("\n");
        -:47422:        }
        -:47423:    }
        -:47424:    }
    #####:47425:    function_tests++;
        -:47426:#endif
        -:47427:
    #####:47428:    return(test_ret);
        -:47429:}
        -:47430:
        -:47431:
        -:47432:static int
    #####:47433:test_xmlXPathCountFunction(void) {
    #####:47434:    int test_ret = 0;
        -:47435:
        -:47436:#if defined(LIBXML_XPATH_ENABLED)
        -:47437:    int mem_base;
        -:47438:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:47439:    int n_ctxt;
        -:47440:    int nargs; /* the number of arguments */
        -:47441:    int n_nargs;
        -:47442:
    #####:47443:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:47444:    for (n_nargs = 0;n_nargs < gen_nb_int;n_nargs++) {
    #####:47445:        mem_base = xmlMemBlocks();
    #####:47446:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:47447:        nargs = gen_int(n_nargs, 1);
        -:47448:
    #####:47449:        xmlXPathCountFunction(ctxt, nargs);
    #####:47450:        call_tests++;
    #####:47451:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:47452:        des_int(n_nargs, nargs, 1);
    #####:47453:        xmlResetLastError();
    #####:47454:        if (mem_base != xmlMemBlocks()) {
    #####:47455:            printf("Leak of %d blocks found in xmlXPathCountFunction",
    #####:47456:	           xmlMemBlocks() - mem_base);
    #####:47457:	    test_ret++;
    #####:47458:            printf(" %d", n_ctxt);
    #####:47459:            printf(" %d", n_nargs);
    #####:47460:            printf("\n");
        -:47461:        }
        -:47462:    }
        -:47463:    }
    #####:47464:    function_tests++;
        -:47465:#endif
        -:47466:
    #####:47467:    return(test_ret);
        -:47468:}
        -:47469:
        -:47470:
        -:47471:static int
    #####:47472:test_xmlXPathDebugDumpCompExpr(void) {
    #####:47473:    int test_ret = 0;
        -:47474:
        -:47475:#if defined(LIBXML_XPATH_ENABLED) && defined(LIBXML_DEBUG_ENABLED)
        -:47476:    int mem_base;
        -:47477:    FILE * output; /* the FILE * for the output */
        -:47478:    int n_output;
        -:47479:    xmlXPathCompExprPtr comp; /* the precompiled XPath expression */
        -:47480:    int n_comp;
        -:47481:    int depth; /* the indentation level. */
        -:47482:    int n_depth;
        -:47483:
    #####:47484:    for (n_output = 0;n_output < gen_nb_FILE_ptr;n_output++) {
    #####:47485:    for (n_comp = 0;n_comp < gen_nb_xmlXPathCompExprPtr;n_comp++) {
    #####:47486:    for (n_depth = 0;n_depth < gen_nb_int;n_depth++) {
    #####:47487:        mem_base = xmlMemBlocks();
    #####:47488:        output = gen_FILE_ptr(n_output, 0);
    #####:47489:        comp = gen_xmlXPathCompExprPtr(n_comp, 1);
    #####:47490:        depth = gen_int(n_depth, 2);
        -:47491:
    #####:47492:        xmlXPathDebugDumpCompExpr(output, comp, depth);
    #####:47493:        call_tests++;
    #####:47494:        des_FILE_ptr(n_output, output, 0);
    #####:47495:        des_xmlXPathCompExprPtr(n_comp, comp, 1);
    #####:47496:        des_int(n_depth, depth, 2);
    #####:47497:        xmlResetLastError();
    #####:47498:        if (mem_base != xmlMemBlocks()) {
    #####:47499:            printf("Leak of %d blocks found in xmlXPathDebugDumpCompExpr",
    #####:47500:	           xmlMemBlocks() - mem_base);
    #####:47501:	    test_ret++;
    #####:47502:            printf(" %d", n_output);
    #####:47503:            printf(" %d", n_comp);
    #####:47504:            printf(" %d", n_depth);
    #####:47505:            printf("\n");
        -:47506:        }
        -:47507:    }
        -:47508:    }
        -:47509:    }
    #####:47510:    function_tests++;
        -:47511:#endif
        -:47512:
    #####:47513:    return(test_ret);
        -:47514:}
        -:47515:
        -:47516:
        -:47517:static int
    #####:47518:test_xmlXPathDebugDumpObject(void) {
    #####:47519:    int test_ret = 0;
        -:47520:
        -:47521:#if defined(LIBXML_XPATH_ENABLED) && defined(LIBXML_DEBUG_ENABLED)
        -:47522:    int mem_base;
        -:47523:    FILE * output; /* the FILE * to dump the output */
        -:47524:    int n_output;
        -:47525:    xmlXPathObjectPtr cur; /* the object to inspect */
        -:47526:    int n_cur;
        -:47527:    int depth; /* indentation level */
        -:47528:    int n_depth;
        -:47529:
    #####:47530:    for (n_output = 0;n_output < gen_nb_FILE_ptr;n_output++) {
    #####:47531:    for (n_cur = 0;n_cur < gen_nb_xmlXPathObjectPtr;n_cur++) {
    #####:47532:    for (n_depth = 0;n_depth < gen_nb_int;n_depth++) {
    #####:47533:        mem_base = xmlMemBlocks();
    #####:47534:        output = gen_FILE_ptr(n_output, 0);
    #####:47535:        cur = gen_xmlXPathObjectPtr(n_cur, 1);
    #####:47536:        depth = gen_int(n_depth, 2);
        -:47537:
    #####:47538:        xmlXPathDebugDumpObject(output, cur, depth);
    #####:47539:        call_tests++;
    #####:47540:        des_FILE_ptr(n_output, output, 0);
    #####:47541:        des_xmlXPathObjectPtr(n_cur, cur, 1);
    #####:47542:        des_int(n_depth, depth, 2);
    #####:47543:        xmlResetLastError();
    #####:47544:        if (mem_base != xmlMemBlocks()) {
    #####:47545:            printf("Leak of %d blocks found in xmlXPathDebugDumpObject",
    #####:47546:	           xmlMemBlocks() - mem_base);
    #####:47547:	    test_ret++;
    #####:47548:            printf(" %d", n_output);
    #####:47549:            printf(" %d", n_cur);
    #####:47550:            printf(" %d", n_depth);
    #####:47551:            printf("\n");
        -:47552:        }
        -:47553:    }
        -:47554:    }
        -:47555:    }
    #####:47556:    function_tests++;
        -:47557:#endif
        -:47558:
    #####:47559:    return(test_ret);
        -:47560:}
        -:47561:
        -:47562:
        -:47563:static int
    #####:47564:test_xmlXPathDifference(void) {
    #####:47565:    int test_ret = 0;
        -:47566:
        -:47567:#if defined(LIBXML_XPATH_ENABLED)
        -:47568:    int mem_base;
        -:47569:    xmlNodeSetPtr ret_val;
        -:47570:    xmlNodeSetPtr nodes1; /* a node-set */
        -:47571:    int n_nodes1;
        -:47572:    xmlNodeSetPtr nodes2; /* a node-set */
        -:47573:    int n_nodes2;
        -:47574:
    #####:47575:    for (n_nodes1 = 0;n_nodes1 < gen_nb_xmlNodeSetPtr;n_nodes1++) {
    #####:47576:    for (n_nodes2 = 0;n_nodes2 < gen_nb_xmlNodeSetPtr;n_nodes2++) {
    #####:47577:        mem_base = xmlMemBlocks();
    #####:47578:        nodes1 = gen_xmlNodeSetPtr(n_nodes1, 0);
    #####:47579:        nodes2 = gen_xmlNodeSetPtr(n_nodes2, 1);
        -:47580:
    #####:47581:        ret_val = xmlXPathDifference(nodes1, nodes2);
    #####:47582:        desret_xmlNodeSetPtr(ret_val);
    #####:47583:        call_tests++;
    #####:47584:        des_xmlNodeSetPtr(n_nodes1, nodes1, 0);
    #####:47585:        des_xmlNodeSetPtr(n_nodes2, nodes2, 1);
    #####:47586:        xmlResetLastError();
    #####:47587:        if (mem_base != xmlMemBlocks()) {
    #####:47588:            printf("Leak of %d blocks found in xmlXPathDifference",
    #####:47589:	           xmlMemBlocks() - mem_base);
    #####:47590:	    test_ret++;
    #####:47591:            printf(" %d", n_nodes1);
    #####:47592:            printf(" %d", n_nodes2);
    #####:47593:            printf("\n");
        -:47594:        }
        -:47595:    }
        -:47596:    }
    #####:47597:    function_tests++;
        -:47598:#endif
        -:47599:
    #####:47600:    return(test_ret);
        -:47601:}
        -:47602:
        -:47603:
        -:47604:static int
    #####:47605:test_xmlXPathDistinct(void) {
    #####:47606:    int test_ret = 0;
        -:47607:
        -:47608:#if defined(LIBXML_XPATH_ENABLED)
        -:47609:    int mem_base;
        -:47610:    xmlNodeSetPtr ret_val;
        -:47611:    xmlNodeSetPtr nodes; /* a node-set */
        -:47612:    int n_nodes;
        -:47613:
    #####:47614:    for (n_nodes = 0;n_nodes < gen_nb_xmlNodeSetPtr;n_nodes++) {
    #####:47615:        mem_base = xmlMemBlocks();
    #####:47616:        nodes = gen_xmlNodeSetPtr(n_nodes, 0);
        -:47617:
    #####:47618:        ret_val = xmlXPathDistinct(nodes);
    #####:47619:        desret_xmlNodeSetPtr(ret_val);
    #####:47620:        call_tests++;
    #####:47621:        des_xmlNodeSetPtr(n_nodes, nodes, 0);
    #####:47622:        xmlResetLastError();
    #####:47623:        if (mem_base != xmlMemBlocks()) {
    #####:47624:            printf("Leak of %d blocks found in xmlXPathDistinct",
    #####:47625:	           xmlMemBlocks() - mem_base);
    #####:47626:	    test_ret++;
    #####:47627:            printf(" %d", n_nodes);
    #####:47628:            printf("\n");
        -:47629:        }
        -:47630:    }
    #####:47631:    function_tests++;
        -:47632:#endif
        -:47633:
    #####:47634:    return(test_ret);
        -:47635:}
        -:47636:
        -:47637:
        -:47638:static int
    #####:47639:test_xmlXPathDistinctSorted(void) {
    #####:47640:    int test_ret = 0;
        -:47641:
        -:47642:#if defined(LIBXML_XPATH_ENABLED)
        -:47643:    int mem_base;
        -:47644:    xmlNodeSetPtr ret_val;
        -:47645:    xmlNodeSetPtr nodes; /* a node-set, sorted by document order */
        -:47646:    int n_nodes;
        -:47647:
    #####:47648:    for (n_nodes = 0;n_nodes < gen_nb_xmlNodeSetPtr;n_nodes++) {
    #####:47649:        mem_base = xmlMemBlocks();
    #####:47650:        nodes = gen_xmlNodeSetPtr(n_nodes, 0);
        -:47651:
    #####:47652:        ret_val = xmlXPathDistinctSorted(nodes);
    #####:47653:        desret_xmlNodeSetPtr(ret_val);
    #####:47654:        call_tests++;
    #####:47655:        des_xmlNodeSetPtr(n_nodes, nodes, 0);
    #####:47656:        xmlResetLastError();
    #####:47657:        if (mem_base != xmlMemBlocks()) {
    #####:47658:            printf("Leak of %d blocks found in xmlXPathDistinctSorted",
    #####:47659:	           xmlMemBlocks() - mem_base);
    #####:47660:	    test_ret++;
    #####:47661:            printf(" %d", n_nodes);
    #####:47662:            printf("\n");
        -:47663:        }
        -:47664:    }
    #####:47665:    function_tests++;
        -:47666:#endif
        -:47667:
    #####:47668:    return(test_ret);
        -:47669:}
        -:47670:
        -:47671:
        -:47672:static int
    #####:47673:test_xmlXPathDivValues(void) {
    #####:47674:    int test_ret = 0;
        -:47675:
        -:47676:#if defined(LIBXML_XPATH_ENABLED)
        -:47677:    int mem_base;
        -:47678:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:47679:    int n_ctxt;
        -:47680:
    #####:47681:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:47682:        mem_base = xmlMemBlocks();
    #####:47683:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        -:47684:
    #####:47685:        xmlXPathDivValues(ctxt);
    #####:47686:        call_tests++;
    #####:47687:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:47688:        xmlResetLastError();
    #####:47689:        if (mem_base != xmlMemBlocks()) {
    #####:47690:            printf("Leak of %d blocks found in xmlXPathDivValues",
    #####:47691:	           xmlMemBlocks() - mem_base);
    #####:47692:	    test_ret++;
    #####:47693:            printf(" %d", n_ctxt);
    #####:47694:            printf("\n");
        -:47695:        }
        -:47696:    }
    #####:47697:    function_tests++;
        -:47698:#endif
        -:47699:
    #####:47700:    return(test_ret);
        -:47701:}
        -:47702:
        -:47703:
        -:47704:static int
    #####:47705:test_xmlXPathEqualValues(void) {
    #####:47706:    int test_ret = 0;
        -:47707:
        -:47708:#if defined(LIBXML_XPATH_ENABLED)
        -:47709:    int mem_base;
        -:47710:    int ret_val;
        -:47711:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:47712:    int n_ctxt;
        -:47713:
    #####:47714:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:47715:        mem_base = xmlMemBlocks();
    #####:47716:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        -:47717:
    #####:47718:        ret_val = xmlXPathEqualValues(ctxt);
    #####:47719:        desret_int(ret_val);
    #####:47720:        call_tests++;
    #####:47721:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:47722:        xmlResetLastError();
    #####:47723:        if (mem_base != xmlMemBlocks()) {
    #####:47724:            printf("Leak of %d blocks found in xmlXPathEqualValues",
    #####:47725:	           xmlMemBlocks() - mem_base);
    #####:47726:	    test_ret++;
    #####:47727:            printf(" %d", n_ctxt);
    #####:47728:            printf("\n");
        -:47729:        }
        -:47730:    }
    #####:47731:    function_tests++;
        -:47732:#endif
        -:47733:
    #####:47734:    return(test_ret);
        -:47735:}
        -:47736:
        -:47737:
        -:47738:static int
    #####:47739:test_xmlXPathErr(void) {
    #####:47740:    int test_ret = 0;
        -:47741:
        -:47742:#if defined(LIBXML_XPATH_ENABLED)
        -:47743:    int mem_base;
        -:47744:    xmlXPathParserContextPtr ctxt; /* a XPath parser context */
        -:47745:    int n_ctxt;
        -:47746:    int error; /* the error code */
        -:47747:    int n_error;
        -:47748:
    #####:47749:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:47750:    for (n_error = 0;n_error < gen_nb_int;n_error++) {
    #####:47751:        mem_base = xmlMemBlocks();
    #####:47752:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:47753:        error = gen_int(n_error, 1);
        -:47754:
    #####:47755:        xmlXPathErr(ctxt, error);
    #####:47756:        call_tests++;
    #####:47757:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:47758:        des_int(n_error, error, 1);
    #####:47759:        xmlResetLastError();
    #####:47760:        if (mem_base != xmlMemBlocks()) {
    #####:47761:            printf("Leak of %d blocks found in xmlXPathErr",
    #####:47762:	           xmlMemBlocks() - mem_base);
    #####:47763:	    test_ret++;
    #####:47764:            printf(" %d", n_ctxt);
    #####:47765:            printf(" %d", n_error);
    #####:47766:            printf("\n");
        -:47767:        }
        -:47768:    }
        -:47769:    }
    #####:47770:    function_tests++;
        -:47771:#endif
        -:47772:
    #####:47773:    return(test_ret);
        -:47774:}
        -:47775:
        -:47776:
        -:47777:static int
    #####:47778:test_xmlXPathEvalExpr(void) {
    #####:47779:    int test_ret = 0;
        -:47780:
        -:47781:#if defined(LIBXML_XPATH_ENABLED)
        -:47782:    int mem_base;
        -:47783:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:47784:    int n_ctxt;
        -:47785:
    #####:47786:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:47787:        mem_base = xmlMemBlocks();
    #####:47788:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        -:47789:
    #####:47790:        xmlXPathEvalExpr(ctxt);
    #####:47791:        call_tests++;
    #####:47792:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:47793:        xmlResetLastError();
    #####:47794:        if (mem_base != xmlMemBlocks()) {
    #####:47795:            printf("Leak of %d blocks found in xmlXPathEvalExpr",
    #####:47796:	           xmlMemBlocks() - mem_base);
    #####:47797:	    test_ret++;
    #####:47798:            printf(" %d", n_ctxt);
    #####:47799:            printf("\n");
        -:47800:        }
        -:47801:    }
    #####:47802:    function_tests++;
        -:47803:#endif
        -:47804:
    #####:47805:    return(test_ret);
        -:47806:}
        -:47807:
        -:47808:
        -:47809:static int
    #####:47810:test_xmlXPathEvaluatePredicateResult(void) {
    #####:47811:    int test_ret = 0;
        -:47812:
        -:47813:#if defined(LIBXML_XPATH_ENABLED)
        -:47814:    int mem_base;
        -:47815:    int ret_val;
        -:47816:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:47817:    int n_ctxt;
        -:47818:    xmlXPathObjectPtr res; /* the Predicate Expression evaluation result */
        -:47819:    int n_res;
        -:47820:
    #####:47821:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:47822:    for (n_res = 0;n_res < gen_nb_xmlXPathObjectPtr;n_res++) {
    #####:47823:        mem_base = xmlMemBlocks();
    #####:47824:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:47825:        res = gen_xmlXPathObjectPtr(n_res, 1);
        -:47826:
    #####:47827:        ret_val = xmlXPathEvaluatePredicateResult(ctxt, res);
    #####:47828:        desret_int(ret_val);
    #####:47829:        call_tests++;
    #####:47830:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:47831:        des_xmlXPathObjectPtr(n_res, res, 1);
    #####:47832:        xmlResetLastError();
    #####:47833:        if (mem_base != xmlMemBlocks()) {
    #####:47834:            printf("Leak of %d blocks found in xmlXPathEvaluatePredicateResult",
    #####:47835:	           xmlMemBlocks() - mem_base);
    #####:47836:	    test_ret++;
    #####:47837:            printf(" %d", n_ctxt);
    #####:47838:            printf(" %d", n_res);
    #####:47839:            printf("\n");
        -:47840:        }
        -:47841:    }
        -:47842:    }
    #####:47843:    function_tests++;
        -:47844:#endif
        -:47845:
    #####:47846:    return(test_ret);
        -:47847:}
        -:47848:
        -:47849:
        -:47850:static int
    #####:47851:test_xmlXPathFalseFunction(void) {
    #####:47852:    int test_ret = 0;
        -:47853:
        -:47854:#if defined(LIBXML_XPATH_ENABLED)
        -:47855:    int mem_base;
        -:47856:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:47857:    int n_ctxt;
        -:47858:    int nargs; /* the number of arguments */
        -:47859:    int n_nargs;
        -:47860:
    #####:47861:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:47862:    for (n_nargs = 0;n_nargs < gen_nb_int;n_nargs++) {
    #####:47863:        mem_base = xmlMemBlocks();
    #####:47864:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:47865:        nargs = gen_int(n_nargs, 1);
        -:47866:
    #####:47867:        xmlXPathFalseFunction(ctxt, nargs);
    #####:47868:        call_tests++;
    #####:47869:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:47870:        des_int(n_nargs, nargs, 1);
    #####:47871:        xmlResetLastError();
    #####:47872:        if (mem_base != xmlMemBlocks()) {
    #####:47873:            printf("Leak of %d blocks found in xmlXPathFalseFunction",
    #####:47874:	           xmlMemBlocks() - mem_base);
    #####:47875:	    test_ret++;
    #####:47876:            printf(" %d", n_ctxt);
    #####:47877:            printf(" %d", n_nargs);
    #####:47878:            printf("\n");
        -:47879:        }
        -:47880:    }
        -:47881:    }
    #####:47882:    function_tests++;
        -:47883:#endif
        -:47884:
    #####:47885:    return(test_ret);
        -:47886:}
        -:47887:
        -:47888:
        -:47889:static int
    #####:47890:test_xmlXPathFloorFunction(void) {
    #####:47891:    int test_ret = 0;
        -:47892:
        -:47893:#if defined(LIBXML_XPATH_ENABLED)
        -:47894:    int mem_base;
        -:47895:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:47896:    int n_ctxt;
        -:47897:    int nargs; /* the number of arguments */
        -:47898:    int n_nargs;
        -:47899:
    #####:47900:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:47901:    for (n_nargs = 0;n_nargs < gen_nb_int;n_nargs++) {
    #####:47902:        mem_base = xmlMemBlocks();
    #####:47903:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:47904:        nargs = gen_int(n_nargs, 1);
        -:47905:
    #####:47906:        xmlXPathFloorFunction(ctxt, nargs);
    #####:47907:        call_tests++;
    #####:47908:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:47909:        des_int(n_nargs, nargs, 1);
    #####:47910:        xmlResetLastError();
    #####:47911:        if (mem_base != xmlMemBlocks()) {
    #####:47912:            printf("Leak of %d blocks found in xmlXPathFloorFunction",
    #####:47913:	           xmlMemBlocks() - mem_base);
    #####:47914:	    test_ret++;
    #####:47915:            printf(" %d", n_ctxt);
    #####:47916:            printf(" %d", n_nargs);
    #####:47917:            printf("\n");
        -:47918:        }
        -:47919:    }
        -:47920:    }
    #####:47921:    function_tests++;
        -:47922:#endif
        -:47923:
    #####:47924:    return(test_ret);
        -:47925:}
        -:47926:
        -:47927:
        -:47928:static int
    #####:47929:test_xmlXPathFunctionLookup(void) {
    #####:47930:    int test_ret = 0;
        -:47931:
        -:47932:
        -:47933:    /* missing type support */
    #####:47934:    return(test_ret);
        -:47935:}
        -:47936:
        -:47937:
        -:47938:static int
    #####:47939:test_xmlXPathFunctionLookupNS(void) {
    #####:47940:    int test_ret = 0;
        -:47941:
        -:47942:
        -:47943:    /* missing type support */
    #####:47944:    return(test_ret);
        -:47945:}
        -:47946:
        -:47947:
        -:47948:static int
    #####:47949:test_xmlXPathHasSameNodes(void) {
    #####:47950:    int test_ret = 0;
        -:47951:
        -:47952:#if defined(LIBXML_XPATH_ENABLED)
        -:47953:    int mem_base;
        -:47954:    int ret_val;
        -:47955:    xmlNodeSetPtr nodes1; /* a node-set */
        -:47956:    int n_nodes1;
        -:47957:    xmlNodeSetPtr nodes2; /* a node-set */
        -:47958:    int n_nodes2;
        -:47959:
    #####:47960:    for (n_nodes1 = 0;n_nodes1 < gen_nb_xmlNodeSetPtr;n_nodes1++) {
    #####:47961:    for (n_nodes2 = 0;n_nodes2 < gen_nb_xmlNodeSetPtr;n_nodes2++) {
    #####:47962:        mem_base = xmlMemBlocks();
    #####:47963:        nodes1 = gen_xmlNodeSetPtr(n_nodes1, 0);
    #####:47964:        nodes2 = gen_xmlNodeSetPtr(n_nodes2, 1);
        -:47965:
    #####:47966:        ret_val = xmlXPathHasSameNodes(nodes1, nodes2);
    #####:47967:        desret_int(ret_val);
    #####:47968:        call_tests++;
    #####:47969:        des_xmlNodeSetPtr(n_nodes1, nodes1, 0);
    #####:47970:        des_xmlNodeSetPtr(n_nodes2, nodes2, 1);
    #####:47971:        xmlResetLastError();
    #####:47972:        if (mem_base != xmlMemBlocks()) {
    #####:47973:            printf("Leak of %d blocks found in xmlXPathHasSameNodes",
    #####:47974:	           xmlMemBlocks() - mem_base);
    #####:47975:	    test_ret++;
    #####:47976:            printf(" %d", n_nodes1);
    #####:47977:            printf(" %d", n_nodes2);
    #####:47978:            printf("\n");
        -:47979:        }
        -:47980:    }
        -:47981:    }
    #####:47982:    function_tests++;
        -:47983:#endif
        -:47984:
    #####:47985:    return(test_ret);
        -:47986:}
        -:47987:
        -:47988:
        -:47989:static int
    #####:47990:test_xmlXPathIdFunction(void) {
    #####:47991:    int test_ret = 0;
        -:47992:
        -:47993:#if defined(LIBXML_XPATH_ENABLED)
        -:47994:    int mem_base;
        -:47995:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:47996:    int n_ctxt;
        -:47997:    int nargs; /* the number of arguments */
        -:47998:    int n_nargs;
        -:47999:
    #####:48000:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:48001:    for (n_nargs = 0;n_nargs < gen_nb_int;n_nargs++) {
    #####:48002:        mem_base = xmlMemBlocks();
    #####:48003:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:48004:        nargs = gen_int(n_nargs, 1);
        -:48005:
    #####:48006:        xmlXPathIdFunction(ctxt, nargs);
    #####:48007:        call_tests++;
    #####:48008:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:48009:        des_int(n_nargs, nargs, 1);
    #####:48010:        xmlResetLastError();
    #####:48011:        if (mem_base != xmlMemBlocks()) {
    #####:48012:            printf("Leak of %d blocks found in xmlXPathIdFunction",
    #####:48013:	           xmlMemBlocks() - mem_base);
    #####:48014:	    test_ret++;
    #####:48015:            printf(" %d", n_ctxt);
    #####:48016:            printf(" %d", n_nargs);
    #####:48017:            printf("\n");
        -:48018:        }
        -:48019:    }
        -:48020:    }
    #####:48021:    function_tests++;
        -:48022:#endif
        -:48023:
    #####:48024:    return(test_ret);
        -:48025:}
        -:48026:
        -:48027:
        -:48028:static int
    #####:48029:test_xmlXPathIntersection(void) {
    #####:48030:    int test_ret = 0;
        -:48031:
        -:48032:#if defined(LIBXML_XPATH_ENABLED)
        -:48033:    int mem_base;
        -:48034:    xmlNodeSetPtr ret_val;
        -:48035:    xmlNodeSetPtr nodes1; /* a node-set */
        -:48036:    int n_nodes1;
        -:48037:    xmlNodeSetPtr nodes2; /* a node-set */
        -:48038:    int n_nodes2;
        -:48039:
    #####:48040:    for (n_nodes1 = 0;n_nodes1 < gen_nb_xmlNodeSetPtr;n_nodes1++) {
    #####:48041:    for (n_nodes2 = 0;n_nodes2 < gen_nb_xmlNodeSetPtr;n_nodes2++) {
    #####:48042:        mem_base = xmlMemBlocks();
    #####:48043:        nodes1 = gen_xmlNodeSetPtr(n_nodes1, 0);
    #####:48044:        nodes2 = gen_xmlNodeSetPtr(n_nodes2, 1);
        -:48045:
    #####:48046:        ret_val = xmlXPathIntersection(nodes1, nodes2);
    #####:48047:        desret_xmlNodeSetPtr(ret_val);
    #####:48048:        call_tests++;
    #####:48049:        des_xmlNodeSetPtr(n_nodes1, nodes1, 0);
    #####:48050:        des_xmlNodeSetPtr(n_nodes2, nodes2, 1);
    #####:48051:        xmlResetLastError();
    #####:48052:        if (mem_base != xmlMemBlocks()) {
    #####:48053:            printf("Leak of %d blocks found in xmlXPathIntersection",
    #####:48054:	           xmlMemBlocks() - mem_base);
    #####:48055:	    test_ret++;
    #####:48056:            printf(" %d", n_nodes1);
    #####:48057:            printf(" %d", n_nodes2);
    #####:48058:            printf("\n");
        -:48059:        }
        -:48060:    }
        -:48061:    }
    #####:48062:    function_tests++;
        -:48063:#endif
        -:48064:
    #####:48065:    return(test_ret);
        -:48066:}
        -:48067:
        -:48068:
        -:48069:static int
    #####:48070:test_xmlXPathIsNodeType(void) {
    #####:48071:    int test_ret = 0;
        -:48072:
        -:48073:#if defined(LIBXML_XPATH_ENABLED)
        -:48074:    int mem_base;
        -:48075:    int ret_val;
        -:48076:    xmlChar * name; /* a name string */
        -:48077:    int n_name;
        -:48078:
    #####:48079:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:48080:        mem_base = xmlMemBlocks();
    #####:48081:        name = gen_const_xmlChar_ptr(n_name, 0);
        -:48082:
    #####:48083:        ret_val = xmlXPathIsNodeType((const xmlChar *)name);
    #####:48084:        desret_int(ret_val);
    #####:48085:        call_tests++;
    #####:48086:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 0);
    #####:48087:        xmlResetLastError();
    #####:48088:        if (mem_base != xmlMemBlocks()) {
    #####:48089:            printf("Leak of %d blocks found in xmlXPathIsNodeType",
    #####:48090:	           xmlMemBlocks() - mem_base);
    #####:48091:	    test_ret++;
    #####:48092:            printf(" %d", n_name);
    #####:48093:            printf("\n");
        -:48094:        }
        -:48095:    }
    #####:48096:    function_tests++;
        -:48097:#endif
        -:48098:
    #####:48099:    return(test_ret);
        -:48100:}
        -:48101:
        -:48102:
        -:48103:static int
    #####:48104:test_xmlXPathLangFunction(void) {
    #####:48105:    int test_ret = 0;
        -:48106:
        -:48107:#if defined(LIBXML_XPATH_ENABLED)
        -:48108:    int mem_base;
        -:48109:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:48110:    int n_ctxt;
        -:48111:    int nargs; /* the number of arguments */
        -:48112:    int n_nargs;
        -:48113:
    #####:48114:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:48115:    for (n_nargs = 0;n_nargs < gen_nb_int;n_nargs++) {
    #####:48116:        mem_base = xmlMemBlocks();
    #####:48117:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:48118:        nargs = gen_int(n_nargs, 1);
        -:48119:
    #####:48120:        xmlXPathLangFunction(ctxt, nargs);
    #####:48121:        call_tests++;
    #####:48122:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:48123:        des_int(n_nargs, nargs, 1);
    #####:48124:        xmlResetLastError();
    #####:48125:        if (mem_base != xmlMemBlocks()) {
    #####:48126:            printf("Leak of %d blocks found in xmlXPathLangFunction",
    #####:48127:	           xmlMemBlocks() - mem_base);
    #####:48128:	    test_ret++;
    #####:48129:            printf(" %d", n_ctxt);
    #####:48130:            printf(" %d", n_nargs);
    #####:48131:            printf("\n");
        -:48132:        }
        -:48133:    }
        -:48134:    }
    #####:48135:    function_tests++;
        -:48136:#endif
        -:48137:
    #####:48138:    return(test_ret);
        -:48139:}
        -:48140:
        -:48141:
        -:48142:static int
    #####:48143:test_xmlXPathLastFunction(void) {
    #####:48144:    int test_ret = 0;
        -:48145:
        -:48146:#if defined(LIBXML_XPATH_ENABLED)
        -:48147:    int mem_base;
        -:48148:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:48149:    int n_ctxt;
        -:48150:    int nargs; /* the number of arguments */
        -:48151:    int n_nargs;
        -:48152:
    #####:48153:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:48154:    for (n_nargs = 0;n_nargs < gen_nb_int;n_nargs++) {
    #####:48155:        mem_base = xmlMemBlocks();
    #####:48156:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:48157:        nargs = gen_int(n_nargs, 1);
        -:48158:
    #####:48159:        xmlXPathLastFunction(ctxt, nargs);
    #####:48160:        call_tests++;
    #####:48161:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:48162:        des_int(n_nargs, nargs, 1);
    #####:48163:        xmlResetLastError();
    #####:48164:        if (mem_base != xmlMemBlocks()) {
    #####:48165:            printf("Leak of %d blocks found in xmlXPathLastFunction",
    #####:48166:	           xmlMemBlocks() - mem_base);
    #####:48167:	    test_ret++;
    #####:48168:            printf(" %d", n_ctxt);
    #####:48169:            printf(" %d", n_nargs);
    #####:48170:            printf("\n");
        -:48171:        }
        -:48172:    }
        -:48173:    }
    #####:48174:    function_tests++;
        -:48175:#endif
        -:48176:
    #####:48177:    return(test_ret);
        -:48178:}
        -:48179:
        -:48180:
        -:48181:static int
    #####:48182:test_xmlXPathLeading(void) {
    #####:48183:    int test_ret = 0;
        -:48184:
        -:48185:#if defined(LIBXML_XPATH_ENABLED)
        -:48186:    int mem_base;
        -:48187:    xmlNodeSetPtr ret_val;
        -:48188:    xmlNodeSetPtr nodes1; /* a node-set */
        -:48189:    int n_nodes1;
        -:48190:    xmlNodeSetPtr nodes2; /* a node-set */
        -:48191:    int n_nodes2;
        -:48192:
    #####:48193:    for (n_nodes1 = 0;n_nodes1 < gen_nb_xmlNodeSetPtr;n_nodes1++) {
    #####:48194:    for (n_nodes2 = 0;n_nodes2 < gen_nb_xmlNodeSetPtr;n_nodes2++) {
    #####:48195:        mem_base = xmlMemBlocks();
    #####:48196:        nodes1 = gen_xmlNodeSetPtr(n_nodes1, 0);
    #####:48197:        nodes2 = gen_xmlNodeSetPtr(n_nodes2, 1);
        -:48198:
    #####:48199:        ret_val = xmlXPathLeading(nodes1, nodes2);
    #####:48200:        desret_xmlNodeSetPtr(ret_val);
    #####:48201:        call_tests++;
    #####:48202:        des_xmlNodeSetPtr(n_nodes1, nodes1, 0);
    #####:48203:        des_xmlNodeSetPtr(n_nodes2, nodes2, 1);
    #####:48204:        xmlResetLastError();
    #####:48205:        if (mem_base != xmlMemBlocks()) {
    #####:48206:            printf("Leak of %d blocks found in xmlXPathLeading",
    #####:48207:	           xmlMemBlocks() - mem_base);
    #####:48208:	    test_ret++;
    #####:48209:            printf(" %d", n_nodes1);
    #####:48210:            printf(" %d", n_nodes2);
    #####:48211:            printf("\n");
        -:48212:        }
        -:48213:    }
        -:48214:    }
    #####:48215:    function_tests++;
        -:48216:#endif
        -:48217:
    #####:48218:    return(test_ret);
        -:48219:}
        -:48220:
        -:48221:
        -:48222:static int
    #####:48223:test_xmlXPathLeadingSorted(void) {
    #####:48224:    int test_ret = 0;
        -:48225:
        -:48226:#if defined(LIBXML_XPATH_ENABLED)
        -:48227:    int mem_base;
        -:48228:    xmlNodeSetPtr ret_val;
        -:48229:    xmlNodeSetPtr nodes1; /* a node-set, sorted by document order */
        -:48230:    int n_nodes1;
        -:48231:    xmlNodeSetPtr nodes2; /* a node-set, sorted by document order */
        -:48232:    int n_nodes2;
        -:48233:
    #####:48234:    for (n_nodes1 = 0;n_nodes1 < gen_nb_xmlNodeSetPtr;n_nodes1++) {
    #####:48235:    for (n_nodes2 = 0;n_nodes2 < gen_nb_xmlNodeSetPtr;n_nodes2++) {
    #####:48236:        mem_base = xmlMemBlocks();
    #####:48237:        nodes1 = gen_xmlNodeSetPtr(n_nodes1, 0);
    #####:48238:        nodes2 = gen_xmlNodeSetPtr(n_nodes2, 1);
        -:48239:
    #####:48240:        ret_val = xmlXPathLeadingSorted(nodes1, nodes2);
    #####:48241:        desret_xmlNodeSetPtr(ret_val);
    #####:48242:        call_tests++;
    #####:48243:        des_xmlNodeSetPtr(n_nodes1, nodes1, 0);
    #####:48244:        des_xmlNodeSetPtr(n_nodes2, nodes2, 1);
    #####:48245:        xmlResetLastError();
    #####:48246:        if (mem_base != xmlMemBlocks()) {
    #####:48247:            printf("Leak of %d blocks found in xmlXPathLeadingSorted",
    #####:48248:	           xmlMemBlocks() - mem_base);
    #####:48249:	    test_ret++;
    #####:48250:            printf(" %d", n_nodes1);
    #####:48251:            printf(" %d", n_nodes2);
    #####:48252:            printf("\n");
        -:48253:        }
        -:48254:    }
        -:48255:    }
    #####:48256:    function_tests++;
        -:48257:#endif
        -:48258:
    #####:48259:    return(test_ret);
        -:48260:}
        -:48261:
        -:48262:
        -:48263:static int
    #####:48264:test_xmlXPathLocalNameFunction(void) {
    #####:48265:    int test_ret = 0;
        -:48266:
        -:48267:#if defined(LIBXML_XPATH_ENABLED)
        -:48268:    int mem_base;
        -:48269:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:48270:    int n_ctxt;
        -:48271:    int nargs; /* the number of arguments */
        -:48272:    int n_nargs;
        -:48273:
    #####:48274:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:48275:    for (n_nargs = 0;n_nargs < gen_nb_int;n_nargs++) {
    #####:48276:        mem_base = xmlMemBlocks();
    #####:48277:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:48278:        nargs = gen_int(n_nargs, 1);
        -:48279:
    #####:48280:        xmlXPathLocalNameFunction(ctxt, nargs);
    #####:48281:        call_tests++;
    #####:48282:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:48283:        des_int(n_nargs, nargs, 1);
    #####:48284:        xmlResetLastError();
    #####:48285:        if (mem_base != xmlMemBlocks()) {
    #####:48286:            printf("Leak of %d blocks found in xmlXPathLocalNameFunction",
    #####:48287:	           xmlMemBlocks() - mem_base);
    #####:48288:	    test_ret++;
    #####:48289:            printf(" %d", n_ctxt);
    #####:48290:            printf(" %d", n_nargs);
    #####:48291:            printf("\n");
        -:48292:        }
        -:48293:    }
        -:48294:    }
    #####:48295:    function_tests++;
        -:48296:#endif
        -:48297:
    #####:48298:    return(test_ret);
        -:48299:}
        -:48300:
        -:48301:
        -:48302:static int
    #####:48303:test_xmlXPathModValues(void) {
    #####:48304:    int test_ret = 0;
        -:48305:
        -:48306:#if defined(LIBXML_XPATH_ENABLED)
        -:48307:    int mem_base;
        -:48308:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:48309:    int n_ctxt;
        -:48310:
    #####:48311:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:48312:        mem_base = xmlMemBlocks();
    #####:48313:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        -:48314:
    #####:48315:        xmlXPathModValues(ctxt);
    #####:48316:        call_tests++;
    #####:48317:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:48318:        xmlResetLastError();
    #####:48319:        if (mem_base != xmlMemBlocks()) {
    #####:48320:            printf("Leak of %d blocks found in xmlXPathModValues",
    #####:48321:	           xmlMemBlocks() - mem_base);
    #####:48322:	    test_ret++;
    #####:48323:            printf(" %d", n_ctxt);
    #####:48324:            printf("\n");
        -:48325:        }
        -:48326:    }
    #####:48327:    function_tests++;
        -:48328:#endif
        -:48329:
    #####:48330:    return(test_ret);
        -:48331:}
        -:48332:
        -:48333:
        -:48334:static int
    #####:48335:test_xmlXPathMultValues(void) {
    #####:48336:    int test_ret = 0;
        -:48337:
        -:48338:#if defined(LIBXML_XPATH_ENABLED)
        -:48339:    int mem_base;
        -:48340:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:48341:    int n_ctxt;
        -:48342:
    #####:48343:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:48344:        mem_base = xmlMemBlocks();
    #####:48345:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        -:48346:
    #####:48347:        xmlXPathMultValues(ctxt);
    #####:48348:        call_tests++;
    #####:48349:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:48350:        xmlResetLastError();
    #####:48351:        if (mem_base != xmlMemBlocks()) {
    #####:48352:            printf("Leak of %d blocks found in xmlXPathMultValues",
    #####:48353:	           xmlMemBlocks() - mem_base);
    #####:48354:	    test_ret++;
    #####:48355:            printf(" %d", n_ctxt);
    #####:48356:            printf("\n");
        -:48357:        }
        -:48358:    }
    #####:48359:    function_tests++;
        -:48360:#endif
        -:48361:
    #####:48362:    return(test_ret);
        -:48363:}
        -:48364:
        -:48365:
        -:48366:static int
    #####:48367:test_xmlXPathNamespaceURIFunction(void) {
    #####:48368:    int test_ret = 0;
        -:48369:
        -:48370:#if defined(LIBXML_XPATH_ENABLED)
        -:48371:    int mem_base;
        -:48372:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:48373:    int n_ctxt;
        -:48374:    int nargs; /* the number of arguments */
        -:48375:    int n_nargs;
        -:48376:
    #####:48377:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:48378:    for (n_nargs = 0;n_nargs < gen_nb_int;n_nargs++) {
    #####:48379:        mem_base = xmlMemBlocks();
    #####:48380:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:48381:        nargs = gen_int(n_nargs, 1);
        -:48382:
    #####:48383:        xmlXPathNamespaceURIFunction(ctxt, nargs);
    #####:48384:        call_tests++;
    #####:48385:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:48386:        des_int(n_nargs, nargs, 1);
    #####:48387:        xmlResetLastError();
    #####:48388:        if (mem_base != xmlMemBlocks()) {
    #####:48389:            printf("Leak of %d blocks found in xmlXPathNamespaceURIFunction",
    #####:48390:	           xmlMemBlocks() - mem_base);
    #####:48391:	    test_ret++;
    #####:48392:            printf(" %d", n_ctxt);
    #####:48393:            printf(" %d", n_nargs);
    #####:48394:            printf("\n");
        -:48395:        }
        -:48396:    }
        -:48397:    }
    #####:48398:    function_tests++;
        -:48399:#endif
        -:48400:
    #####:48401:    return(test_ret);
        -:48402:}
        -:48403:
        -:48404:
        -:48405:static int
    #####:48406:test_xmlXPathNewBoolean(void) {
    #####:48407:    int test_ret = 0;
        -:48408:
        -:48409:#if defined(LIBXML_XPATH_ENABLED)
        -:48410:    int mem_base;
        -:48411:    xmlXPathObjectPtr ret_val;
        -:48412:    int val; /* the boolean value */
        -:48413:    int n_val;
        -:48414:
    #####:48415:    for (n_val = 0;n_val < gen_nb_int;n_val++) {
    #####:48416:        mem_base = xmlMemBlocks();
    #####:48417:        val = gen_int(n_val, 0);
        -:48418:
    #####:48419:        ret_val = xmlXPathNewBoolean(val);
    #####:48420:        desret_xmlXPathObjectPtr(ret_val);
    #####:48421:        call_tests++;
    #####:48422:        des_int(n_val, val, 0);
    #####:48423:        xmlResetLastError();
    #####:48424:        if (mem_base != xmlMemBlocks()) {
    #####:48425:            printf("Leak of %d blocks found in xmlXPathNewBoolean",
    #####:48426:	           xmlMemBlocks() - mem_base);
    #####:48427:	    test_ret++;
    #####:48428:            printf(" %d", n_val);
    #####:48429:            printf("\n");
        -:48430:        }
        -:48431:    }
    #####:48432:    function_tests++;
        -:48433:#endif
        -:48434:
    #####:48435:    return(test_ret);
        -:48436:}
        -:48437:
        -:48438:
        -:48439:static int
    #####:48440:test_xmlXPathNewCString(void) {
    #####:48441:    int test_ret = 0;
        -:48442:
        -:48443:#if defined(LIBXML_XPATH_ENABLED)
        -:48444:    int mem_base;
        -:48445:    xmlXPathObjectPtr ret_val;
        -:48446:    char * val; /* the char * value */
        -:48447:    int n_val;
        -:48448:
    #####:48449:    for (n_val = 0;n_val < gen_nb_const_char_ptr;n_val++) {
    #####:48450:        mem_base = xmlMemBlocks();
    #####:48451:        val = gen_const_char_ptr(n_val, 0);
        -:48452:
    #####:48453:        ret_val = xmlXPathNewCString((const char *)val);
    #####:48454:        desret_xmlXPathObjectPtr(ret_val);
    #####:48455:        call_tests++;
    #####:48456:        des_const_char_ptr(n_val, (const char *)val, 0);
    #####:48457:        xmlResetLastError();
    #####:48458:        if (mem_base != xmlMemBlocks()) {
    #####:48459:            printf("Leak of %d blocks found in xmlXPathNewCString",
    #####:48460:	           xmlMemBlocks() - mem_base);
    #####:48461:	    test_ret++;
    #####:48462:            printf(" %d", n_val);
    #####:48463:            printf("\n");
        -:48464:        }
        -:48465:    }
    #####:48466:    function_tests++;
        -:48467:#endif
        -:48468:
    #####:48469:    return(test_ret);
        -:48470:}
        -:48471:
        -:48472:
        -:48473:static int
    #####:48474:test_xmlXPathNewFloat(void) {
    #####:48475:    int test_ret = 0;
        -:48476:
        -:48477:#if defined(LIBXML_XPATH_ENABLED)
        -:48478:    int mem_base;
        -:48479:    xmlXPathObjectPtr ret_val;
        -:48480:    double val; /* the double value */
        -:48481:    int n_val;
        -:48482:
    #####:48483:    for (n_val = 0;n_val < gen_nb_double;n_val++) {
    #####:48484:        mem_base = xmlMemBlocks();
    #####:48485:        val = gen_double(n_val, 0);
        -:48486:
    #####:48487:        ret_val = xmlXPathNewFloat(val);
    #####:48488:        desret_xmlXPathObjectPtr(ret_val);
    #####:48489:        call_tests++;
    #####:48490:        des_double(n_val, val, 0);
    #####:48491:        xmlResetLastError();
    #####:48492:        if (mem_base != xmlMemBlocks()) {
    #####:48493:            printf("Leak of %d blocks found in xmlXPathNewFloat",
    #####:48494:	           xmlMemBlocks() - mem_base);
    #####:48495:	    test_ret++;
    #####:48496:            printf(" %d", n_val);
    #####:48497:            printf("\n");
        -:48498:        }
        -:48499:    }
    #####:48500:    function_tests++;
        -:48501:#endif
        -:48502:
    #####:48503:    return(test_ret);
        -:48504:}
        -:48505:
        -:48506:
        -:48507:static int
    #####:48508:test_xmlXPathNewNodeSet(void) {
    #####:48509:    int test_ret = 0;
        -:48510:
        -:48511:#if defined(LIBXML_XPATH_ENABLED)
        -:48512:    int mem_base;
        -:48513:    xmlXPathObjectPtr ret_val;
        -:48514:    xmlNodePtr val; /* the NodePtr value */
        -:48515:    int n_val;
        -:48516:
    #####:48517:    for (n_val = 0;n_val < gen_nb_xmlNodePtr;n_val++) {
    #####:48518:        mem_base = xmlMemBlocks();
    #####:48519:        val = gen_xmlNodePtr(n_val, 0);
        -:48520:
    #####:48521:        ret_val = xmlXPathNewNodeSet(val);
    #####:48522:        desret_xmlXPathObjectPtr(ret_val);
    #####:48523:        call_tests++;
    #####:48524:        des_xmlNodePtr(n_val, val, 0);
    #####:48525:        xmlResetLastError();
    #####:48526:        if (mem_base != xmlMemBlocks()) {
    #####:48527:            printf("Leak of %d blocks found in xmlXPathNewNodeSet",
    #####:48528:	           xmlMemBlocks() - mem_base);
    #####:48529:	    test_ret++;
    #####:48530:            printf(" %d", n_val);
    #####:48531:            printf("\n");
        -:48532:        }
        -:48533:    }
    #####:48534:    function_tests++;
        -:48535:#endif
        -:48536:
    #####:48537:    return(test_ret);
        -:48538:}
        -:48539:
        -:48540:
        -:48541:static int
    #####:48542:test_xmlXPathNewNodeSetList(void) {
    #####:48543:    int test_ret = 0;
        -:48544:
        -:48545:#if defined(LIBXML_XPATH_ENABLED)
        -:48546:    int mem_base;
        -:48547:    xmlXPathObjectPtr ret_val;
        -:48548:    xmlNodeSetPtr val; /* an existing NodeSet */
        -:48549:    int n_val;
        -:48550:
    #####:48551:    for (n_val = 0;n_val < gen_nb_xmlNodeSetPtr;n_val++) {
    #####:48552:        mem_base = xmlMemBlocks();
    #####:48553:        val = gen_xmlNodeSetPtr(n_val, 0);
        -:48554:
    #####:48555:        ret_val = xmlXPathNewNodeSetList(val);
    #####:48556:        desret_xmlXPathObjectPtr(ret_val);
    #####:48557:        call_tests++;
    #####:48558:        des_xmlNodeSetPtr(n_val, val, 0);
    #####:48559:        xmlResetLastError();
    #####:48560:        if (mem_base != xmlMemBlocks()) {
    #####:48561:            printf("Leak of %d blocks found in xmlXPathNewNodeSetList",
    #####:48562:	           xmlMemBlocks() - mem_base);
    #####:48563:	    test_ret++;
    #####:48564:            printf(" %d", n_val);
    #####:48565:            printf("\n");
        -:48566:        }
        -:48567:    }
    #####:48568:    function_tests++;
        -:48569:#endif
        -:48570:
    #####:48571:    return(test_ret);
        -:48572:}
        -:48573:
        -:48574:
        -:48575:static int
    #####:48576:test_xmlXPathNewParserContext(void) {
    #####:48577:    int test_ret = 0;
        -:48578:
        -:48579:
        -:48580:    /* missing type support */
    #####:48581:    return(test_ret);
        -:48582:}
        -:48583:
        -:48584:
        -:48585:static int
    #####:48586:test_xmlXPathNewString(void) {
    #####:48587:    int test_ret = 0;
        -:48588:
        -:48589:#if defined(LIBXML_XPATH_ENABLED)
        -:48590:    int mem_base;
        -:48591:    xmlXPathObjectPtr ret_val;
        -:48592:    xmlChar * val; /* the xmlChar * value */
        -:48593:    int n_val;
        -:48594:
    #####:48595:    for (n_val = 0;n_val < gen_nb_const_xmlChar_ptr;n_val++) {
    #####:48596:        mem_base = xmlMemBlocks();
    #####:48597:        val = gen_const_xmlChar_ptr(n_val, 0);
        -:48598:
    #####:48599:        ret_val = xmlXPathNewString((const xmlChar *)val);
    #####:48600:        desret_xmlXPathObjectPtr(ret_val);
    #####:48601:        call_tests++;
    #####:48602:        des_const_xmlChar_ptr(n_val, (const xmlChar *)val, 0);
    #####:48603:        xmlResetLastError();
    #####:48604:        if (mem_base != xmlMemBlocks()) {
    #####:48605:            printf("Leak of %d blocks found in xmlXPathNewString",
    #####:48606:	           xmlMemBlocks() - mem_base);
    #####:48607:	    test_ret++;
    #####:48608:            printf(" %d", n_val);
    #####:48609:            printf("\n");
        -:48610:        }
        -:48611:    }
    #####:48612:    function_tests++;
        -:48613:#endif
        -:48614:
    #####:48615:    return(test_ret);
        -:48616:}
        -:48617:
        -:48618:
        -:48619:static int
    #####:48620:test_xmlXPathNextAncestor(void) {
    #####:48621:    int test_ret = 0;
        -:48622:
        -:48623:#if defined(LIBXML_XPATH_ENABLED)
        -:48624:    int mem_base;
        -:48625:    xmlNodePtr ret_val;
        -:48626:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:48627:    int n_ctxt;
        -:48628:    xmlNodePtr cur; /* the current node in the traversal */
        -:48629:    int n_cur;
        -:48630:
    #####:48631:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:48632:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####:48633:        mem_base = xmlMemBlocks();
    #####:48634:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:48635:        cur = gen_xmlNodePtr(n_cur, 1);
        -:48636:
    #####:48637:        ret_val = xmlXPathNextAncestor(ctxt, cur);
    #####:48638:        desret_xmlNodePtr(ret_val);
    #####:48639:        call_tests++;
    #####:48640:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:48641:        des_xmlNodePtr(n_cur, cur, 1);
    #####:48642:        xmlResetLastError();
    #####:48643:        if (mem_base != xmlMemBlocks()) {
    #####:48644:            printf("Leak of %d blocks found in xmlXPathNextAncestor",
    #####:48645:	           xmlMemBlocks() - mem_base);
    #####:48646:	    test_ret++;
    #####:48647:            printf(" %d", n_ctxt);
    #####:48648:            printf(" %d", n_cur);
    #####:48649:            printf("\n");
        -:48650:        }
        -:48651:    }
        -:48652:    }
    #####:48653:    function_tests++;
        -:48654:#endif
        -:48655:
    #####:48656:    return(test_ret);
        -:48657:}
        -:48658:
        -:48659:
        -:48660:static int
    #####:48661:test_xmlXPathNextAncestorOrSelf(void) {
    #####:48662:    int test_ret = 0;
        -:48663:
        -:48664:#if defined(LIBXML_XPATH_ENABLED)
        -:48665:    int mem_base;
        -:48666:    xmlNodePtr ret_val;
        -:48667:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:48668:    int n_ctxt;
        -:48669:    xmlNodePtr cur; /* the current node in the traversal */
        -:48670:    int n_cur;
        -:48671:
    #####:48672:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:48673:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####:48674:        mem_base = xmlMemBlocks();
    #####:48675:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:48676:        cur = gen_xmlNodePtr(n_cur, 1);
        -:48677:
    #####:48678:        ret_val = xmlXPathNextAncestorOrSelf(ctxt, cur);
    #####:48679:        desret_xmlNodePtr(ret_val);
    #####:48680:        call_tests++;
    #####:48681:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:48682:        des_xmlNodePtr(n_cur, cur, 1);
    #####:48683:        xmlResetLastError();
    #####:48684:        if (mem_base != xmlMemBlocks()) {
    #####:48685:            printf("Leak of %d blocks found in xmlXPathNextAncestorOrSelf",
    #####:48686:	           xmlMemBlocks() - mem_base);
    #####:48687:	    test_ret++;
    #####:48688:            printf(" %d", n_ctxt);
    #####:48689:            printf(" %d", n_cur);
    #####:48690:            printf("\n");
        -:48691:        }
        -:48692:    }
        -:48693:    }
    #####:48694:    function_tests++;
        -:48695:#endif
        -:48696:
    #####:48697:    return(test_ret);
        -:48698:}
        -:48699:
        -:48700:
        -:48701:static int
    #####:48702:test_xmlXPathNextAttribute(void) {
    #####:48703:    int test_ret = 0;
        -:48704:
        -:48705:#if defined(LIBXML_XPATH_ENABLED)
        -:48706:    int mem_base;
        -:48707:    xmlNodePtr ret_val;
        -:48708:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:48709:    int n_ctxt;
        -:48710:    xmlNodePtr cur; /* the current attribute in the traversal */
        -:48711:    int n_cur;
        -:48712:
    #####:48713:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:48714:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####:48715:        mem_base = xmlMemBlocks();
    #####:48716:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:48717:        cur = gen_xmlNodePtr(n_cur, 1);
        -:48718:
    #####:48719:        ret_val = xmlXPathNextAttribute(ctxt, cur);
    #####:48720:        desret_xmlNodePtr(ret_val);
    #####:48721:        call_tests++;
    #####:48722:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:48723:        des_xmlNodePtr(n_cur, cur, 1);
    #####:48724:        xmlResetLastError();
    #####:48725:        if (mem_base != xmlMemBlocks()) {
    #####:48726:            printf("Leak of %d blocks found in xmlXPathNextAttribute",
    #####:48727:	           xmlMemBlocks() - mem_base);
    #####:48728:	    test_ret++;
    #####:48729:            printf(" %d", n_ctxt);
    #####:48730:            printf(" %d", n_cur);
    #####:48731:            printf("\n");
        -:48732:        }
        -:48733:    }
        -:48734:    }
    #####:48735:    function_tests++;
        -:48736:#endif
        -:48737:
    #####:48738:    return(test_ret);
        -:48739:}
        -:48740:
        -:48741:
        -:48742:static int
    #####:48743:test_xmlXPathNextChild(void) {
    #####:48744:    int test_ret = 0;
        -:48745:
        -:48746:#if defined(LIBXML_XPATH_ENABLED)
        -:48747:    int mem_base;
        -:48748:    xmlNodePtr ret_val;
        -:48749:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:48750:    int n_ctxt;
        -:48751:    xmlNodePtr cur; /* the current node in the traversal */
        -:48752:    int n_cur;
        -:48753:
    #####:48754:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:48755:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####:48756:        mem_base = xmlMemBlocks();
    #####:48757:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:48758:        cur = gen_xmlNodePtr(n_cur, 1);
        -:48759:
    #####:48760:        ret_val = xmlXPathNextChild(ctxt, cur);
    #####:48761:        desret_xmlNodePtr(ret_val);
    #####:48762:        call_tests++;
    #####:48763:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:48764:        des_xmlNodePtr(n_cur, cur, 1);
    #####:48765:        xmlResetLastError();
    #####:48766:        if (mem_base != xmlMemBlocks()) {
    #####:48767:            printf("Leak of %d blocks found in xmlXPathNextChild",
    #####:48768:	           xmlMemBlocks() - mem_base);
    #####:48769:	    test_ret++;
    #####:48770:            printf(" %d", n_ctxt);
    #####:48771:            printf(" %d", n_cur);
    #####:48772:            printf("\n");
        -:48773:        }
        -:48774:    }
        -:48775:    }
    #####:48776:    function_tests++;
        -:48777:#endif
        -:48778:
    #####:48779:    return(test_ret);
        -:48780:}
        -:48781:
        -:48782:
        -:48783:static int
    #####:48784:test_xmlXPathNextDescendant(void) {
    #####:48785:    int test_ret = 0;
        -:48786:
        -:48787:#if defined(LIBXML_XPATH_ENABLED)
        -:48788:    int mem_base;
        -:48789:    xmlNodePtr ret_val;
        -:48790:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:48791:    int n_ctxt;
        -:48792:    xmlNodePtr cur; /* the current node in the traversal */
        -:48793:    int n_cur;
        -:48794:
    #####:48795:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:48796:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####:48797:        mem_base = xmlMemBlocks();
    #####:48798:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:48799:        cur = gen_xmlNodePtr(n_cur, 1);
        -:48800:
    #####:48801:        ret_val = xmlXPathNextDescendant(ctxt, cur);
    #####:48802:        desret_xmlNodePtr(ret_val);
    #####:48803:        call_tests++;
    #####:48804:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:48805:        des_xmlNodePtr(n_cur, cur, 1);
    #####:48806:        xmlResetLastError();
    #####:48807:        if (mem_base != xmlMemBlocks()) {
    #####:48808:            printf("Leak of %d blocks found in xmlXPathNextDescendant",
    #####:48809:	           xmlMemBlocks() - mem_base);
    #####:48810:	    test_ret++;
    #####:48811:            printf(" %d", n_ctxt);
    #####:48812:            printf(" %d", n_cur);
    #####:48813:            printf("\n");
        -:48814:        }
        -:48815:    }
        -:48816:    }
    #####:48817:    function_tests++;
        -:48818:#endif
        -:48819:
    #####:48820:    return(test_ret);
        -:48821:}
        -:48822:
        -:48823:
        -:48824:static int
    #####:48825:test_xmlXPathNextDescendantOrSelf(void) {
    #####:48826:    int test_ret = 0;
        -:48827:
        -:48828:#if defined(LIBXML_XPATH_ENABLED)
        -:48829:    int mem_base;
        -:48830:    xmlNodePtr ret_val;
        -:48831:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:48832:    int n_ctxt;
        -:48833:    xmlNodePtr cur; /* the current node in the traversal */
        -:48834:    int n_cur;
        -:48835:
    #####:48836:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:48837:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####:48838:        mem_base = xmlMemBlocks();
    #####:48839:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:48840:        cur = gen_xmlNodePtr(n_cur, 1);
        -:48841:
    #####:48842:        ret_val = xmlXPathNextDescendantOrSelf(ctxt, cur);
    #####:48843:        desret_xmlNodePtr(ret_val);
    #####:48844:        call_tests++;
    #####:48845:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:48846:        des_xmlNodePtr(n_cur, cur, 1);
    #####:48847:        xmlResetLastError();
    #####:48848:        if (mem_base != xmlMemBlocks()) {
    #####:48849:            printf("Leak of %d blocks found in xmlXPathNextDescendantOrSelf",
    #####:48850:	           xmlMemBlocks() - mem_base);
    #####:48851:	    test_ret++;
    #####:48852:            printf(" %d", n_ctxt);
    #####:48853:            printf(" %d", n_cur);
    #####:48854:            printf("\n");
        -:48855:        }
        -:48856:    }
        -:48857:    }
    #####:48858:    function_tests++;
        -:48859:#endif
        -:48860:
    #####:48861:    return(test_ret);
        -:48862:}
        -:48863:
        -:48864:
        -:48865:static int
    #####:48866:test_xmlXPathNextFollowing(void) {
    #####:48867:    int test_ret = 0;
        -:48868:
        -:48869:#if defined(LIBXML_XPATH_ENABLED)
        -:48870:    int mem_base;
        -:48871:    xmlNodePtr ret_val;
        -:48872:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:48873:    int n_ctxt;
        -:48874:    xmlNodePtr cur; /* the current node in the traversal */
        -:48875:    int n_cur;
        -:48876:
    #####:48877:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:48878:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####:48879:        mem_base = xmlMemBlocks();
    #####:48880:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:48881:        cur = gen_xmlNodePtr(n_cur, 1);
        -:48882:
    #####:48883:        ret_val = xmlXPathNextFollowing(ctxt, cur);
    #####:48884:        desret_xmlNodePtr(ret_val);
    #####:48885:        call_tests++;
    #####:48886:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:48887:        des_xmlNodePtr(n_cur, cur, 1);
    #####:48888:        xmlResetLastError();
    #####:48889:        if (mem_base != xmlMemBlocks()) {
    #####:48890:            printf("Leak of %d blocks found in xmlXPathNextFollowing",
    #####:48891:	           xmlMemBlocks() - mem_base);
    #####:48892:	    test_ret++;
    #####:48893:            printf(" %d", n_ctxt);
    #####:48894:            printf(" %d", n_cur);
    #####:48895:            printf("\n");
        -:48896:        }
        -:48897:    }
        -:48898:    }
    #####:48899:    function_tests++;
        -:48900:#endif
        -:48901:
    #####:48902:    return(test_ret);
        -:48903:}
        -:48904:
        -:48905:
        -:48906:static int
    #####:48907:test_xmlXPathNextFollowingSibling(void) {
    #####:48908:    int test_ret = 0;
        -:48909:
        -:48910:#if defined(LIBXML_XPATH_ENABLED)
        -:48911:    int mem_base;
        -:48912:    xmlNodePtr ret_val;
        -:48913:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:48914:    int n_ctxt;
        -:48915:    xmlNodePtr cur; /* the current node in the traversal */
        -:48916:    int n_cur;
        -:48917:
    #####:48918:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:48919:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####:48920:        mem_base = xmlMemBlocks();
    #####:48921:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:48922:        cur = gen_xmlNodePtr(n_cur, 1);
        -:48923:
    #####:48924:        ret_val = xmlXPathNextFollowingSibling(ctxt, cur);
    #####:48925:        desret_xmlNodePtr(ret_val);
    #####:48926:        call_tests++;
    #####:48927:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:48928:        des_xmlNodePtr(n_cur, cur, 1);
    #####:48929:        xmlResetLastError();
    #####:48930:        if (mem_base != xmlMemBlocks()) {
    #####:48931:            printf("Leak of %d blocks found in xmlXPathNextFollowingSibling",
    #####:48932:	           xmlMemBlocks() - mem_base);
    #####:48933:	    test_ret++;
    #####:48934:            printf(" %d", n_ctxt);
    #####:48935:            printf(" %d", n_cur);
    #####:48936:            printf("\n");
        -:48937:        }
        -:48938:    }
        -:48939:    }
    #####:48940:    function_tests++;
        -:48941:#endif
        -:48942:
    #####:48943:    return(test_ret);
        -:48944:}
        -:48945:
        -:48946:
        -:48947:static int
    #####:48948:test_xmlXPathNextNamespace(void) {
    #####:48949:    int test_ret = 0;
        -:48950:
        -:48951:#if defined(LIBXML_XPATH_ENABLED)
        -:48952:    int mem_base;
        -:48953:    xmlNodePtr ret_val;
        -:48954:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:48955:    int n_ctxt;
        -:48956:    xmlNodePtr cur; /* the current attribute in the traversal */
        -:48957:    int n_cur;
        -:48958:
    #####:48959:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:48960:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####:48961:        mem_base = xmlMemBlocks();
    #####:48962:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:48963:        cur = gen_xmlNodePtr(n_cur, 1);
        -:48964:
    #####:48965:        ret_val = xmlXPathNextNamespace(ctxt, cur);
    #####:48966:        desret_xmlNodePtr(ret_val);
    #####:48967:        call_tests++;
    #####:48968:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:48969:        des_xmlNodePtr(n_cur, cur, 1);
    #####:48970:        xmlResetLastError();
    #####:48971:        if (mem_base != xmlMemBlocks()) {
    #####:48972:            printf("Leak of %d blocks found in xmlXPathNextNamespace",
    #####:48973:	           xmlMemBlocks() - mem_base);
    #####:48974:	    test_ret++;
    #####:48975:            printf(" %d", n_ctxt);
    #####:48976:            printf(" %d", n_cur);
    #####:48977:            printf("\n");
        -:48978:        }
        -:48979:    }
        -:48980:    }
    #####:48981:    function_tests++;
        -:48982:#endif
        -:48983:
    #####:48984:    return(test_ret);
        -:48985:}
        -:48986:
        -:48987:
        -:48988:static int
    #####:48989:test_xmlXPathNextParent(void) {
    #####:48990:    int test_ret = 0;
        -:48991:
        -:48992:#if defined(LIBXML_XPATH_ENABLED)
        -:48993:    int mem_base;
        -:48994:    xmlNodePtr ret_val;
        -:48995:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:48996:    int n_ctxt;
        -:48997:    xmlNodePtr cur; /* the current node in the traversal */
        -:48998:    int n_cur;
        -:48999:
    #####:49000:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:49001:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####:49002:        mem_base = xmlMemBlocks();
    #####:49003:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:49004:        cur = gen_xmlNodePtr(n_cur, 1);
        -:49005:
    #####:49006:        ret_val = xmlXPathNextParent(ctxt, cur);
    #####:49007:        desret_xmlNodePtr(ret_val);
    #####:49008:        call_tests++;
    #####:49009:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:49010:        des_xmlNodePtr(n_cur, cur, 1);
    #####:49011:        xmlResetLastError();
    #####:49012:        if (mem_base != xmlMemBlocks()) {
    #####:49013:            printf("Leak of %d blocks found in xmlXPathNextParent",
    #####:49014:	           xmlMemBlocks() - mem_base);
    #####:49015:	    test_ret++;
    #####:49016:            printf(" %d", n_ctxt);
    #####:49017:            printf(" %d", n_cur);
    #####:49018:            printf("\n");
        -:49019:        }
        -:49020:    }
        -:49021:    }
    #####:49022:    function_tests++;
        -:49023:#endif
        -:49024:
    #####:49025:    return(test_ret);
        -:49026:}
        -:49027:
        -:49028:
        -:49029:static int
    #####:49030:test_xmlXPathNextPreceding(void) {
    #####:49031:    int test_ret = 0;
        -:49032:
        -:49033:#if defined(LIBXML_XPATH_ENABLED)
        -:49034:    int mem_base;
        -:49035:    xmlNodePtr ret_val;
        -:49036:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:49037:    int n_ctxt;
        -:49038:    xmlNodePtr cur; /* the current node in the traversal */
        -:49039:    int n_cur;
        -:49040:
    #####:49041:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:49042:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####:49043:        mem_base = xmlMemBlocks();
    #####:49044:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:49045:        cur = gen_xmlNodePtr(n_cur, 1);
        -:49046:
    #####:49047:        ret_val = xmlXPathNextPreceding(ctxt, cur);
    #####:49048:        desret_xmlNodePtr(ret_val);
    #####:49049:        call_tests++;
    #####:49050:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:49051:        des_xmlNodePtr(n_cur, cur, 1);
    #####:49052:        xmlResetLastError();
    #####:49053:        if (mem_base != xmlMemBlocks()) {
    #####:49054:            printf("Leak of %d blocks found in xmlXPathNextPreceding",
    #####:49055:	           xmlMemBlocks() - mem_base);
    #####:49056:	    test_ret++;
    #####:49057:            printf(" %d", n_ctxt);
    #####:49058:            printf(" %d", n_cur);
    #####:49059:            printf("\n");
        -:49060:        }
        -:49061:    }
        -:49062:    }
    #####:49063:    function_tests++;
        -:49064:#endif
        -:49065:
    #####:49066:    return(test_ret);
        -:49067:}
        -:49068:
        -:49069:
        -:49070:static int
    #####:49071:test_xmlXPathNextPrecedingSibling(void) {
    #####:49072:    int test_ret = 0;
        -:49073:
        -:49074:#if defined(LIBXML_XPATH_ENABLED)
        -:49075:    int mem_base;
        -:49076:    xmlNodePtr ret_val;
        -:49077:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:49078:    int n_ctxt;
        -:49079:    xmlNodePtr cur; /* the current node in the traversal */
        -:49080:    int n_cur;
        -:49081:
    #####:49082:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:49083:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####:49084:        mem_base = xmlMemBlocks();
    #####:49085:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:49086:        cur = gen_xmlNodePtr(n_cur, 1);
        -:49087:
    #####:49088:        ret_val = xmlXPathNextPrecedingSibling(ctxt, cur);
    #####:49089:        desret_xmlNodePtr(ret_val);
    #####:49090:        call_tests++;
    #####:49091:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:49092:        des_xmlNodePtr(n_cur, cur, 1);
    #####:49093:        xmlResetLastError();
    #####:49094:        if (mem_base != xmlMemBlocks()) {
    #####:49095:            printf("Leak of %d blocks found in xmlXPathNextPrecedingSibling",
    #####:49096:	           xmlMemBlocks() - mem_base);
    #####:49097:	    test_ret++;
    #####:49098:            printf(" %d", n_ctxt);
    #####:49099:            printf(" %d", n_cur);
    #####:49100:            printf("\n");
        -:49101:        }
        -:49102:    }
        -:49103:    }
    #####:49104:    function_tests++;
        -:49105:#endif
        -:49106:
    #####:49107:    return(test_ret);
        -:49108:}
        -:49109:
        -:49110:
        -:49111:static int
    #####:49112:test_xmlXPathNextSelf(void) {
    #####:49113:    int test_ret = 0;
        -:49114:
        -:49115:#if defined(LIBXML_XPATH_ENABLED)
        -:49116:    int mem_base;
        -:49117:    xmlNodePtr ret_val;
        -:49118:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:49119:    int n_ctxt;
        -:49120:    xmlNodePtr cur; /* the current node in the traversal */
        -:49121:    int n_cur;
        -:49122:
    #####:49123:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:49124:    for (n_cur = 0;n_cur < gen_nb_xmlNodePtr;n_cur++) {
    #####:49125:        mem_base = xmlMemBlocks();
    #####:49126:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:49127:        cur = gen_xmlNodePtr(n_cur, 1);
        -:49128:
    #####:49129:        ret_val = xmlXPathNextSelf(ctxt, cur);
    #####:49130:        desret_xmlNodePtr(ret_val);
    #####:49131:        call_tests++;
    #####:49132:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:49133:        des_xmlNodePtr(n_cur, cur, 1);
    #####:49134:        xmlResetLastError();
    #####:49135:        if (mem_base != xmlMemBlocks()) {
    #####:49136:            printf("Leak of %d blocks found in xmlXPathNextSelf",
    #####:49137:	           xmlMemBlocks() - mem_base);
    #####:49138:	    test_ret++;
    #####:49139:            printf(" %d", n_ctxt);
    #####:49140:            printf(" %d", n_cur);
    #####:49141:            printf("\n");
        -:49142:        }
        -:49143:    }
        -:49144:    }
    #####:49145:    function_tests++;
        -:49146:#endif
        -:49147:
    #####:49148:    return(test_ret);
        -:49149:}
        -:49150:
        -:49151:
        -:49152:static int
    #####:49153:test_xmlXPathNodeLeading(void) {
    #####:49154:    int test_ret = 0;
        -:49155:
        -:49156:#if defined(LIBXML_XPATH_ENABLED)
        -:49157:    int mem_base;
        -:49158:    xmlNodeSetPtr ret_val;
        -:49159:    xmlNodeSetPtr nodes; /* a node-set */
        -:49160:    int n_nodes;
        -:49161:    xmlNodePtr node; /* a node */
        -:49162:    int n_node;
        -:49163:
    #####:49164:    for (n_nodes = 0;n_nodes < gen_nb_xmlNodeSetPtr;n_nodes++) {
    #####:49165:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:49166:        mem_base = xmlMemBlocks();
    #####:49167:        nodes = gen_xmlNodeSetPtr(n_nodes, 0);
    #####:49168:        node = gen_xmlNodePtr(n_node, 1);
        -:49169:
    #####:49170:        ret_val = xmlXPathNodeLeading(nodes, node);
    #####:49171:        desret_xmlNodeSetPtr(ret_val);
    #####:49172:        call_tests++;
    #####:49173:        des_xmlNodeSetPtr(n_nodes, nodes, 0);
    #####:49174:        des_xmlNodePtr(n_node, node, 1);
    #####:49175:        xmlResetLastError();
    #####:49176:        if (mem_base != xmlMemBlocks()) {
    #####:49177:            printf("Leak of %d blocks found in xmlXPathNodeLeading",
    #####:49178:	           xmlMemBlocks() - mem_base);
    #####:49179:	    test_ret++;
    #####:49180:            printf(" %d", n_nodes);
    #####:49181:            printf(" %d", n_node);
    #####:49182:            printf("\n");
        -:49183:        }
        -:49184:    }
        -:49185:    }
    #####:49186:    function_tests++;
        -:49187:#endif
        -:49188:
    #####:49189:    return(test_ret);
        -:49190:}
        -:49191:
        -:49192:
        -:49193:static int
    #####:49194:test_xmlXPathNodeLeadingSorted(void) {
    #####:49195:    int test_ret = 0;
        -:49196:
        -:49197:#if defined(LIBXML_XPATH_ENABLED)
        -:49198:    int mem_base;
        -:49199:    xmlNodeSetPtr ret_val;
        -:49200:    xmlNodeSetPtr nodes; /* a node-set, sorted by document order */
        -:49201:    int n_nodes;
        -:49202:    xmlNodePtr node; /* a node */
        -:49203:    int n_node;
        -:49204:
    #####:49205:    for (n_nodes = 0;n_nodes < gen_nb_xmlNodeSetPtr;n_nodes++) {
    #####:49206:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:49207:        mem_base = xmlMemBlocks();
    #####:49208:        nodes = gen_xmlNodeSetPtr(n_nodes, 0);
    #####:49209:        node = gen_xmlNodePtr(n_node, 1);
        -:49210:
    #####:49211:        ret_val = xmlXPathNodeLeadingSorted(nodes, node);
    #####:49212:        desret_xmlNodeSetPtr(ret_val);
    #####:49213:        call_tests++;
    #####:49214:        des_xmlNodeSetPtr(n_nodes, nodes, 0);
    #####:49215:        des_xmlNodePtr(n_node, node, 1);
    #####:49216:        xmlResetLastError();
    #####:49217:        if (mem_base != xmlMemBlocks()) {
    #####:49218:            printf("Leak of %d blocks found in xmlXPathNodeLeadingSorted",
    #####:49219:	           xmlMemBlocks() - mem_base);
    #####:49220:	    test_ret++;
    #####:49221:            printf(" %d", n_nodes);
    #####:49222:            printf(" %d", n_node);
    #####:49223:            printf("\n");
        -:49224:        }
        -:49225:    }
        -:49226:    }
    #####:49227:    function_tests++;
        -:49228:#endif
        -:49229:
    #####:49230:    return(test_ret);
        -:49231:}
        -:49232:
        -:49233:
        -:49234:static int
    #####:49235:test_xmlXPathNodeSetAdd(void) {
    #####:49236:    int test_ret = 0;
        -:49237:
        -:49238:#if defined(LIBXML_XPATH_ENABLED)
        -:49239:    int mem_base;
        -:49240:    int ret_val;
        -:49241:    xmlNodeSetPtr cur; /* the initial node set */
        -:49242:    int n_cur;
        -:49243:    xmlNodePtr val; /* a new xmlNodePtr */
        -:49244:    int n_val;
        -:49245:
    #####:49246:    for (n_cur = 0;n_cur < gen_nb_xmlNodeSetPtr;n_cur++) {
    #####:49247:    for (n_val = 0;n_val < gen_nb_xmlNodePtr;n_val++) {
    #####:49248:        mem_base = xmlMemBlocks();
    #####:49249:        cur = gen_xmlNodeSetPtr(n_cur, 0);
    #####:49250:        val = gen_xmlNodePtr(n_val, 1);
        -:49251:
    #####:49252:        ret_val = xmlXPathNodeSetAdd(cur, val);
    #####:49253:        desret_int(ret_val);
    #####:49254:        call_tests++;
    #####:49255:        des_xmlNodeSetPtr(n_cur, cur, 0);
    #####:49256:        des_xmlNodePtr(n_val, val, 1);
    #####:49257:        xmlResetLastError();
    #####:49258:        if (mem_base != xmlMemBlocks()) {
    #####:49259:            printf("Leak of %d blocks found in xmlXPathNodeSetAdd",
    #####:49260:	           xmlMemBlocks() - mem_base);
    #####:49261:	    test_ret++;
    #####:49262:            printf(" %d", n_cur);
    #####:49263:            printf(" %d", n_val);
    #####:49264:            printf("\n");
        -:49265:        }
        -:49266:    }
        -:49267:    }
    #####:49268:    function_tests++;
        -:49269:#endif
        -:49270:
    #####:49271:    return(test_ret);
        -:49272:}
        -:49273:
        -:49274:
        -:49275:static int
    #####:49276:test_xmlXPathNodeSetAddNs(void) {
    #####:49277:    int test_ret = 0;
        -:49278:
        -:49279:#if defined(LIBXML_XPATH_ENABLED)
        -:49280:    int mem_base;
        -:49281:    int ret_val;
        -:49282:    xmlNodeSetPtr cur; /* the initial node set */
        -:49283:    int n_cur;
        -:49284:    xmlNodePtr node; /* the hosting node */
        -:49285:    int n_node;
        -:49286:    xmlNsPtr ns; /* a the namespace node */
        -:49287:    int n_ns;
        -:49288:
    #####:49289:    for (n_cur = 0;n_cur < gen_nb_xmlNodeSetPtr;n_cur++) {
    #####:49290:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:49291:    for (n_ns = 0;n_ns < gen_nb_xmlNsPtr;n_ns++) {
    #####:49292:        mem_base = xmlMemBlocks();
    #####:49293:        cur = gen_xmlNodeSetPtr(n_cur, 0);
    #####:49294:        node = gen_xmlNodePtr(n_node, 1);
    #####:49295:        ns = gen_xmlNsPtr(n_ns, 2);
        -:49296:
    #####:49297:        ret_val = xmlXPathNodeSetAddNs(cur, node, ns);
    #####:49298:        desret_int(ret_val);
    #####:49299:        call_tests++;
    #####:49300:        des_xmlNodeSetPtr(n_cur, cur, 0);
    #####:49301:        des_xmlNodePtr(n_node, node, 1);
    #####:49302:        des_xmlNsPtr(n_ns, ns, 2);
    #####:49303:        xmlResetLastError();
    #####:49304:        if (mem_base != xmlMemBlocks()) {
    #####:49305:            printf("Leak of %d blocks found in xmlXPathNodeSetAddNs",
    #####:49306:	           xmlMemBlocks() - mem_base);
    #####:49307:	    test_ret++;
    #####:49308:            printf(" %d", n_cur);
    #####:49309:            printf(" %d", n_node);
    #####:49310:            printf(" %d", n_ns);
    #####:49311:            printf("\n");
        -:49312:        }
        -:49313:    }
        -:49314:    }
        -:49315:    }
    #####:49316:    function_tests++;
        -:49317:#endif
        -:49318:
    #####:49319:    return(test_ret);
        -:49320:}
        -:49321:
        -:49322:
        -:49323:static int
    #####:49324:test_xmlXPathNodeSetAddUnique(void) {
    #####:49325:    int test_ret = 0;
        -:49326:
        -:49327:#if defined(LIBXML_XPATH_ENABLED)
        -:49328:    int mem_base;
        -:49329:    int ret_val;
        -:49330:    xmlNodeSetPtr cur; /* the initial node set */
        -:49331:    int n_cur;
        -:49332:    xmlNodePtr val; /* a new xmlNodePtr */
        -:49333:    int n_val;
        -:49334:
    #####:49335:    for (n_cur = 0;n_cur < gen_nb_xmlNodeSetPtr;n_cur++) {
    #####:49336:    for (n_val = 0;n_val < gen_nb_xmlNodePtr;n_val++) {
    #####:49337:        mem_base = xmlMemBlocks();
    #####:49338:        cur = gen_xmlNodeSetPtr(n_cur, 0);
    #####:49339:        val = gen_xmlNodePtr(n_val, 1);
        -:49340:
    #####:49341:        ret_val = xmlXPathNodeSetAddUnique(cur, val);
    #####:49342:        desret_int(ret_val);
    #####:49343:        call_tests++;
    #####:49344:        des_xmlNodeSetPtr(n_cur, cur, 0);
    #####:49345:        des_xmlNodePtr(n_val, val, 1);
    #####:49346:        xmlResetLastError();
    #####:49347:        if (mem_base != xmlMemBlocks()) {
    #####:49348:            printf("Leak of %d blocks found in xmlXPathNodeSetAddUnique",
    #####:49349:	           xmlMemBlocks() - mem_base);
    #####:49350:	    test_ret++;
    #####:49351:            printf(" %d", n_cur);
    #####:49352:            printf(" %d", n_val);
    #####:49353:            printf("\n");
        -:49354:        }
        -:49355:    }
        -:49356:    }
    #####:49357:    function_tests++;
        -:49358:#endif
        -:49359:
    #####:49360:    return(test_ret);
        -:49361:}
        -:49362:
        -:49363:
        -:49364:static int
    #####:49365:test_xmlXPathNodeSetContains(void) {
    #####:49366:    int test_ret = 0;
        -:49367:
        -:49368:#if defined(LIBXML_XPATH_ENABLED)
        -:49369:    int mem_base;
        -:49370:    int ret_val;
        -:49371:    xmlNodeSetPtr cur; /* the node-set */
        -:49372:    int n_cur;
        -:49373:    xmlNodePtr val; /* the node */
        -:49374:    int n_val;
        -:49375:
    #####:49376:    for (n_cur = 0;n_cur < gen_nb_xmlNodeSetPtr;n_cur++) {
    #####:49377:    for (n_val = 0;n_val < gen_nb_xmlNodePtr;n_val++) {
    #####:49378:        mem_base = xmlMemBlocks();
    #####:49379:        cur = gen_xmlNodeSetPtr(n_cur, 0);
    #####:49380:        val = gen_xmlNodePtr(n_val, 1);
        -:49381:
    #####:49382:        ret_val = xmlXPathNodeSetContains(cur, val);
    #####:49383:        desret_int(ret_val);
    #####:49384:        call_tests++;
    #####:49385:        des_xmlNodeSetPtr(n_cur, cur, 0);
    #####:49386:        des_xmlNodePtr(n_val, val, 1);
    #####:49387:        xmlResetLastError();
    #####:49388:        if (mem_base != xmlMemBlocks()) {
    #####:49389:            printf("Leak of %d blocks found in xmlXPathNodeSetContains",
    #####:49390:	           xmlMemBlocks() - mem_base);
    #####:49391:	    test_ret++;
    #####:49392:            printf(" %d", n_cur);
    #####:49393:            printf(" %d", n_val);
    #####:49394:            printf("\n");
        -:49395:        }
        -:49396:    }
        -:49397:    }
    #####:49398:    function_tests++;
        -:49399:#endif
        -:49400:
    #####:49401:    return(test_ret);
        -:49402:}
        -:49403:
        -:49404:
        -:49405:static int
    #####:49406:test_xmlXPathNodeSetDel(void) {
    #####:49407:    int test_ret = 0;
        -:49408:
        -:49409:#if defined(LIBXML_XPATH_ENABLED)
        -:49410:    int mem_base;
        -:49411:    xmlNodeSetPtr cur; /* the initial node set */
        -:49412:    int n_cur;
        -:49413:    xmlNodePtr val; /* an xmlNodePtr */
        -:49414:    int n_val;
        -:49415:
    #####:49416:    for (n_cur = 0;n_cur < gen_nb_xmlNodeSetPtr;n_cur++) {
    #####:49417:    for (n_val = 0;n_val < gen_nb_xmlNodePtr;n_val++) {
    #####:49418:        mem_base = xmlMemBlocks();
    #####:49419:        cur = gen_xmlNodeSetPtr(n_cur, 0);
    #####:49420:        val = gen_xmlNodePtr(n_val, 1);
        -:49421:
    #####:49422:        xmlXPathNodeSetDel(cur, val);
    #####:49423:        call_tests++;
    #####:49424:        des_xmlNodeSetPtr(n_cur, cur, 0);
    #####:49425:        des_xmlNodePtr(n_val, val, 1);
    #####:49426:        xmlResetLastError();
    #####:49427:        if (mem_base != xmlMemBlocks()) {
    #####:49428:            printf("Leak of %d blocks found in xmlXPathNodeSetDel",
    #####:49429:	           xmlMemBlocks() - mem_base);
    #####:49430:	    test_ret++;
    #####:49431:            printf(" %d", n_cur);
    #####:49432:            printf(" %d", n_val);
    #####:49433:            printf("\n");
        -:49434:        }
        -:49435:    }
        -:49436:    }
    #####:49437:    function_tests++;
        -:49438:#endif
        -:49439:
    #####:49440:    return(test_ret);
        -:49441:}
        -:49442:
        -:49443:
        -:49444:static int
    #####:49445:test_xmlXPathNodeSetMerge(void) {
    #####:49446:    int test_ret = 0;
        -:49447:
        -:49448:#if defined(LIBXML_XPATH_ENABLED)
        -:49449:    int mem_base;
        -:49450:    xmlNodeSetPtr ret_val;
        -:49451:    xmlNodeSetPtr val1; /* the first NodeSet or NULL */
        -:49452:    int n_val1;
        -:49453:    xmlNodeSetPtr val2; /* the second NodeSet */
        -:49454:    int n_val2;
        -:49455:
    #####:49456:    for (n_val1 = 0;n_val1 < gen_nb_xmlNodeSetPtr;n_val1++) {
    #####:49457:    for (n_val2 = 0;n_val2 < gen_nb_xmlNodeSetPtr;n_val2++) {
    #####:49458:        mem_base = xmlMemBlocks();
    #####:49459:        val1 = gen_xmlNodeSetPtr(n_val1, 0);
    #####:49460:        val2 = gen_xmlNodeSetPtr(n_val2, 1);
        -:49461:
    #####:49462:        ret_val = xmlXPathNodeSetMerge(val1, val2);
    #####:49463:        desret_xmlNodeSetPtr(ret_val);
    #####:49464:        call_tests++;
    #####:49465:        des_xmlNodeSetPtr(n_val1, val1, 0);
    #####:49466:        des_xmlNodeSetPtr(n_val2, val2, 1);
    #####:49467:        xmlResetLastError();
    #####:49468:        if (mem_base != xmlMemBlocks()) {
    #####:49469:            printf("Leak of %d blocks found in xmlXPathNodeSetMerge",
    #####:49470:	           xmlMemBlocks() - mem_base);
    #####:49471:	    test_ret++;
    #####:49472:            printf(" %d", n_val1);
    #####:49473:            printf(" %d", n_val2);
    #####:49474:            printf("\n");
        -:49475:        }
        -:49476:    }
        -:49477:    }
    #####:49478:    function_tests++;
        -:49479:#endif
        -:49480:
    #####:49481:    return(test_ret);
        -:49482:}
        -:49483:
        -:49484:
        -:49485:static int
    #####:49486:test_xmlXPathNodeSetRemove(void) {
    #####:49487:    int test_ret = 0;
        -:49488:
        -:49489:#if defined(LIBXML_XPATH_ENABLED)
        -:49490:    int mem_base;
        -:49491:    xmlNodeSetPtr cur; /* the initial node set */
        -:49492:    int n_cur;
        -:49493:    int val; /* the index to remove */
        -:49494:    int n_val;
        -:49495:
    #####:49496:    for (n_cur = 0;n_cur < gen_nb_xmlNodeSetPtr;n_cur++) {
    #####:49497:    for (n_val = 0;n_val < gen_nb_int;n_val++) {
    #####:49498:        mem_base = xmlMemBlocks();
    #####:49499:        cur = gen_xmlNodeSetPtr(n_cur, 0);
    #####:49500:        val = gen_int(n_val, 1);
        -:49501:
    #####:49502:        xmlXPathNodeSetRemove(cur, val);
    #####:49503:        call_tests++;
    #####:49504:        des_xmlNodeSetPtr(n_cur, cur, 0);
    #####:49505:        des_int(n_val, val, 1);
    #####:49506:        xmlResetLastError();
    #####:49507:        if (mem_base != xmlMemBlocks()) {
    #####:49508:            printf("Leak of %d blocks found in xmlXPathNodeSetRemove",
    #####:49509:	           xmlMemBlocks() - mem_base);
    #####:49510:	    test_ret++;
    #####:49511:            printf(" %d", n_cur);
    #####:49512:            printf(" %d", n_val);
    #####:49513:            printf("\n");
        -:49514:        }
        -:49515:    }
        -:49516:    }
    #####:49517:    function_tests++;
        -:49518:#endif
        -:49519:
    #####:49520:    return(test_ret);
        -:49521:}
        -:49522:
        -:49523:
        -:49524:static int
    #####:49525:test_xmlXPathNodeSetSort(void) {
    #####:49526:    int test_ret = 0;
        -:49527:
        -:49528:#if defined(LIBXML_XPATH_ENABLED)
        -:49529:    int mem_base;
        -:49530:    xmlNodeSetPtr set; /* the node set */
        -:49531:    int n_set;
        -:49532:
    #####:49533:    for (n_set = 0;n_set < gen_nb_xmlNodeSetPtr;n_set++) {
    #####:49534:        mem_base = xmlMemBlocks();
    #####:49535:        set = gen_xmlNodeSetPtr(n_set, 0);
        -:49536:
    #####:49537:        xmlXPathNodeSetSort(set);
    #####:49538:        call_tests++;
    #####:49539:        des_xmlNodeSetPtr(n_set, set, 0);
    #####:49540:        xmlResetLastError();
    #####:49541:        if (mem_base != xmlMemBlocks()) {
    #####:49542:            printf("Leak of %d blocks found in xmlXPathNodeSetSort",
    #####:49543:	           xmlMemBlocks() - mem_base);
    #####:49544:	    test_ret++;
    #####:49545:            printf(" %d", n_set);
    #####:49546:            printf("\n");
        -:49547:        }
        -:49548:    }
    #####:49549:    function_tests++;
        -:49550:#endif
        -:49551:
    #####:49552:    return(test_ret);
        -:49553:}
        -:49554:
        -:49555:
        -:49556:static int
    #####:49557:test_xmlXPathNodeTrailing(void) {
    #####:49558:    int test_ret = 0;
        -:49559:
        -:49560:#if defined(LIBXML_XPATH_ENABLED)
        -:49561:    int mem_base;
        -:49562:    xmlNodeSetPtr ret_val;
        -:49563:    xmlNodeSetPtr nodes; /* a node-set */
        -:49564:    int n_nodes;
        -:49565:    xmlNodePtr node; /* a node */
        -:49566:    int n_node;
        -:49567:
    #####:49568:    for (n_nodes = 0;n_nodes < gen_nb_xmlNodeSetPtr;n_nodes++) {
    #####:49569:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:49570:        mem_base = xmlMemBlocks();
    #####:49571:        nodes = gen_xmlNodeSetPtr(n_nodes, 0);
    #####:49572:        node = gen_xmlNodePtr(n_node, 1);
        -:49573:
    #####:49574:        ret_val = xmlXPathNodeTrailing(nodes, node);
    #####:49575:        desret_xmlNodeSetPtr(ret_val);
    #####:49576:        call_tests++;
    #####:49577:        des_xmlNodeSetPtr(n_nodes, nodes, 0);
    #####:49578:        des_xmlNodePtr(n_node, node, 1);
    #####:49579:        xmlResetLastError();
    #####:49580:        if (mem_base != xmlMemBlocks()) {
    #####:49581:            printf("Leak of %d blocks found in xmlXPathNodeTrailing",
    #####:49582:	           xmlMemBlocks() - mem_base);
    #####:49583:	    test_ret++;
    #####:49584:            printf(" %d", n_nodes);
    #####:49585:            printf(" %d", n_node);
    #####:49586:            printf("\n");
        -:49587:        }
        -:49588:    }
        -:49589:    }
    #####:49590:    function_tests++;
        -:49591:#endif
        -:49592:
    #####:49593:    return(test_ret);
        -:49594:}
        -:49595:
        -:49596:
        -:49597:static int
    #####:49598:test_xmlXPathNodeTrailingSorted(void) {
    #####:49599:    int test_ret = 0;
        -:49600:
        -:49601:#if defined(LIBXML_XPATH_ENABLED)
        -:49602:    int mem_base;
        -:49603:    xmlNodeSetPtr ret_val;
        -:49604:    xmlNodeSetPtr nodes; /* a node-set, sorted by document order */
        -:49605:    int n_nodes;
        -:49606:    xmlNodePtr node; /* a node */
        -:49607:    int n_node;
        -:49608:
    #####:49609:    for (n_nodes = 0;n_nodes < gen_nb_xmlNodeSetPtr;n_nodes++) {
    #####:49610:    for (n_node = 0;n_node < gen_nb_xmlNodePtr;n_node++) {
    #####:49611:        mem_base = xmlMemBlocks();
    #####:49612:        nodes = gen_xmlNodeSetPtr(n_nodes, 0);
    #####:49613:        node = gen_xmlNodePtr(n_node, 1);
        -:49614:
    #####:49615:        ret_val = xmlXPathNodeTrailingSorted(nodes, node);
    #####:49616:        desret_xmlNodeSetPtr(ret_val);
    #####:49617:        call_tests++;
    #####:49618:        des_xmlNodeSetPtr(n_nodes, nodes, 0);
    #####:49619:        des_xmlNodePtr(n_node, node, 1);
    #####:49620:        xmlResetLastError();
    #####:49621:        if (mem_base != xmlMemBlocks()) {
    #####:49622:            printf("Leak of %d blocks found in xmlXPathNodeTrailingSorted",
    #####:49623:	           xmlMemBlocks() - mem_base);
    #####:49624:	    test_ret++;
    #####:49625:            printf(" %d", n_nodes);
    #####:49626:            printf(" %d", n_node);
    #####:49627:            printf("\n");
        -:49628:        }
        -:49629:    }
        -:49630:    }
    #####:49631:    function_tests++;
        -:49632:#endif
        -:49633:
    #####:49634:    return(test_ret);
        -:49635:}
        -:49636:
        -:49637:
        -:49638:static int
    #####:49639:test_xmlXPathNormalizeFunction(void) {
    #####:49640:    int test_ret = 0;
        -:49641:
        -:49642:#if defined(LIBXML_XPATH_ENABLED)
        -:49643:    int mem_base;
        -:49644:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:49645:    int n_ctxt;
        -:49646:    int nargs; /* the number of arguments */
        -:49647:    int n_nargs;
        -:49648:
    #####:49649:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:49650:    for (n_nargs = 0;n_nargs < gen_nb_int;n_nargs++) {
    #####:49651:        mem_base = xmlMemBlocks();
    #####:49652:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:49653:        nargs = gen_int(n_nargs, 1);
        -:49654:
    #####:49655:        xmlXPathNormalizeFunction(ctxt, nargs);
    #####:49656:        call_tests++;
    #####:49657:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:49658:        des_int(n_nargs, nargs, 1);
    #####:49659:        xmlResetLastError();
    #####:49660:        if (mem_base != xmlMemBlocks()) {
    #####:49661:            printf("Leak of %d blocks found in xmlXPathNormalizeFunction",
    #####:49662:	           xmlMemBlocks() - mem_base);
    #####:49663:	    test_ret++;
    #####:49664:            printf(" %d", n_ctxt);
    #####:49665:            printf(" %d", n_nargs);
    #####:49666:            printf("\n");
        -:49667:        }
        -:49668:    }
        -:49669:    }
    #####:49670:    function_tests++;
        -:49671:#endif
        -:49672:
    #####:49673:    return(test_ret);
        -:49674:}
        -:49675:
        -:49676:
        -:49677:static int
    #####:49678:test_xmlXPathNotEqualValues(void) {
    #####:49679:    int test_ret = 0;
        -:49680:
        -:49681:#if defined(LIBXML_XPATH_ENABLED)
        -:49682:    int mem_base;
        -:49683:    int ret_val;
        -:49684:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:49685:    int n_ctxt;
        -:49686:
    #####:49687:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:49688:        mem_base = xmlMemBlocks();
    #####:49689:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        -:49690:
    #####:49691:        ret_val = xmlXPathNotEqualValues(ctxt);
    #####:49692:        desret_int(ret_val);
    #####:49693:        call_tests++;
    #####:49694:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:49695:        xmlResetLastError();
    #####:49696:        if (mem_base != xmlMemBlocks()) {
    #####:49697:            printf("Leak of %d blocks found in xmlXPathNotEqualValues",
    #####:49698:	           xmlMemBlocks() - mem_base);
    #####:49699:	    test_ret++;
    #####:49700:            printf(" %d", n_ctxt);
    #####:49701:            printf("\n");
        -:49702:        }
        -:49703:    }
    #####:49704:    function_tests++;
        -:49705:#endif
        -:49706:
    #####:49707:    return(test_ret);
        -:49708:}
        -:49709:
        -:49710:
        -:49711:static int
    #####:49712:test_xmlXPathNotFunction(void) {
    #####:49713:    int test_ret = 0;
        -:49714:
        -:49715:#if defined(LIBXML_XPATH_ENABLED)
        -:49716:    int mem_base;
        -:49717:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:49718:    int n_ctxt;
        -:49719:    int nargs; /* the number of arguments */
        -:49720:    int n_nargs;
        -:49721:
    #####:49722:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:49723:    for (n_nargs = 0;n_nargs < gen_nb_int;n_nargs++) {
    #####:49724:        mem_base = xmlMemBlocks();
    #####:49725:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:49726:        nargs = gen_int(n_nargs, 1);
        -:49727:
    #####:49728:        xmlXPathNotFunction(ctxt, nargs);
    #####:49729:        call_tests++;
    #####:49730:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:49731:        des_int(n_nargs, nargs, 1);
    #####:49732:        xmlResetLastError();
    #####:49733:        if (mem_base != xmlMemBlocks()) {
    #####:49734:            printf("Leak of %d blocks found in xmlXPathNotFunction",
    #####:49735:	           xmlMemBlocks() - mem_base);
    #####:49736:	    test_ret++;
    #####:49737:            printf(" %d", n_ctxt);
    #####:49738:            printf(" %d", n_nargs);
    #####:49739:            printf("\n");
        -:49740:        }
        -:49741:    }
        -:49742:    }
    #####:49743:    function_tests++;
        -:49744:#endif
        -:49745:
    #####:49746:    return(test_ret);
        -:49747:}
        -:49748:
        -:49749:
        -:49750:static int
    #####:49751:test_xmlXPathNsLookup(void) {
    #####:49752:    int test_ret = 0;
        -:49753:
        -:49754:#if defined(LIBXML_XPATH_ENABLED)
        -:49755:    int mem_base;
        -:49756:    const xmlChar * ret_val;
        -:49757:    xmlXPathContextPtr ctxt; /* the XPath context */
        -:49758:    int n_ctxt;
        -:49759:    xmlChar * prefix; /* the namespace prefix value */
        -:49760:    int n_prefix;
        -:49761:
    #####:49762:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathContextPtr;n_ctxt++) {
    #####:49763:    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    #####:49764:        mem_base = xmlMemBlocks();
    #####:49765:        ctxt = gen_xmlXPathContextPtr(n_ctxt, 0);
    #####:49766:        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
        -:49767:
    #####:49768:        ret_val = xmlXPathNsLookup(ctxt, (const xmlChar *)prefix);
    #####:49769:        desret_const_xmlChar_ptr(ret_val);
    #####:49770:        call_tests++;
    #####:49771:        des_xmlXPathContextPtr(n_ctxt, ctxt, 0);
    #####:49772:        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 1);
    #####:49773:        xmlResetLastError();
    #####:49774:        if (mem_base != xmlMemBlocks()) {
    #####:49775:            printf("Leak of %d blocks found in xmlXPathNsLookup",
    #####:49776:	           xmlMemBlocks() - mem_base);
    #####:49777:	    test_ret++;
    #####:49778:            printf(" %d", n_ctxt);
    #####:49779:            printf(" %d", n_prefix);
    #####:49780:            printf("\n");
        -:49781:        }
        -:49782:    }
        -:49783:    }
    #####:49784:    function_tests++;
        -:49785:#endif
        -:49786:
    #####:49787:    return(test_ret);
        -:49788:}
        -:49789:
        -:49790:
        -:49791:static int
    #####:49792:test_xmlXPathNumberFunction(void) {
    #####:49793:    int test_ret = 0;
        -:49794:
        -:49795:#if defined(LIBXML_XPATH_ENABLED)
        -:49796:    int mem_base;
        -:49797:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:49798:    int n_ctxt;
        -:49799:    int nargs; /* the number of arguments */
        -:49800:    int n_nargs;
        -:49801:
    #####:49802:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:49803:    for (n_nargs = 0;n_nargs < gen_nb_int;n_nargs++) {
    #####:49804:        mem_base = xmlMemBlocks();
    #####:49805:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:49806:        nargs = gen_int(n_nargs, 1);
        -:49807:
    #####:49808:        xmlXPathNumberFunction(ctxt, nargs);
    #####:49809:        call_tests++;
    #####:49810:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:49811:        des_int(n_nargs, nargs, 1);
    #####:49812:        xmlResetLastError();
    #####:49813:        if (mem_base != xmlMemBlocks()) {
    #####:49814:            printf("Leak of %d blocks found in xmlXPathNumberFunction",
    #####:49815:	           xmlMemBlocks() - mem_base);
    #####:49816:	    test_ret++;
    #####:49817:            printf(" %d", n_ctxt);
    #####:49818:            printf(" %d", n_nargs);
    #####:49819:            printf("\n");
        -:49820:        }
        -:49821:    }
        -:49822:    }
    #####:49823:    function_tests++;
        -:49824:#endif
        -:49825:
    #####:49826:    return(test_ret);
        -:49827:}
        -:49828:
        -:49829:
        -:49830:static int
    #####:49831:test_xmlXPathParseNCName(void) {
    #####:49832:    int test_ret = 0;
        -:49833:
        -:49834:#if defined(LIBXML_XPATH_ENABLED)
        -:49835:    int mem_base;
        -:49836:    xmlChar * ret_val;
        -:49837:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:49838:    int n_ctxt;
        -:49839:
    #####:49840:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:49841:        mem_base = xmlMemBlocks();
    #####:49842:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        -:49843:
    #####:49844:        ret_val = xmlXPathParseNCName(ctxt);
    #####:49845:        desret_xmlChar_ptr(ret_val);
    #####:49846:        call_tests++;
    #####:49847:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:49848:        xmlResetLastError();
    #####:49849:        if (mem_base != xmlMemBlocks()) {
    #####:49850:            printf("Leak of %d blocks found in xmlXPathParseNCName",
    #####:49851:	           xmlMemBlocks() - mem_base);
    #####:49852:	    test_ret++;
    #####:49853:            printf(" %d", n_ctxt);
    #####:49854:            printf("\n");
        -:49855:        }
        -:49856:    }
    #####:49857:    function_tests++;
        -:49858:#endif
        -:49859:
    #####:49860:    return(test_ret);
        -:49861:}
        -:49862:
        -:49863:
        -:49864:static int
    #####:49865:test_xmlXPathParseName(void) {
    #####:49866:    int test_ret = 0;
        -:49867:
        -:49868:#if defined(LIBXML_XPATH_ENABLED)
        -:49869:    int mem_base;
        -:49870:    xmlChar * ret_val;
        -:49871:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:49872:    int n_ctxt;
        -:49873:
    #####:49874:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:49875:        mem_base = xmlMemBlocks();
    #####:49876:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        -:49877:
    #####:49878:        ret_val = xmlXPathParseName(ctxt);
    #####:49879:        desret_xmlChar_ptr(ret_val);
    #####:49880:        call_tests++;
    #####:49881:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:49882:        xmlResetLastError();
    #####:49883:        if (mem_base != xmlMemBlocks()) {
    #####:49884:            printf("Leak of %d blocks found in xmlXPathParseName",
    #####:49885:	           xmlMemBlocks() - mem_base);
    #####:49886:	    test_ret++;
    #####:49887:            printf(" %d", n_ctxt);
    #####:49888:            printf("\n");
        -:49889:        }
        -:49890:    }
    #####:49891:    function_tests++;
        -:49892:#endif
        -:49893:
    #####:49894:    return(test_ret);
        -:49895:}
        -:49896:
        -:49897:
        -:49898:static int
    #####:49899:test_xmlXPathPopBoolean(void) {
    #####:49900:    int test_ret = 0;
        -:49901:
        -:49902:#if defined(LIBXML_XPATH_ENABLED)
        -:49903:    int mem_base;
        -:49904:    int ret_val;
        -:49905:    xmlXPathParserContextPtr ctxt; /* an XPath parser context */
        -:49906:    int n_ctxt;
        -:49907:
    #####:49908:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:49909:        mem_base = xmlMemBlocks();
    #####:49910:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        -:49911:
    #####:49912:        ret_val = xmlXPathPopBoolean(ctxt);
    #####:49913:        desret_int(ret_val);
    #####:49914:        call_tests++;
    #####:49915:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:49916:        xmlResetLastError();
    #####:49917:        if (mem_base != xmlMemBlocks()) {
    #####:49918:            printf("Leak of %d blocks found in xmlXPathPopBoolean",
    #####:49919:	           xmlMemBlocks() - mem_base);
    #####:49920:	    test_ret++;
    #####:49921:            printf(" %d", n_ctxt);
    #####:49922:            printf("\n");
        -:49923:        }
        -:49924:    }
    #####:49925:    function_tests++;
        -:49926:#endif
        -:49927:
    #####:49928:    return(test_ret);
        -:49929:}
        -:49930:
        -:49931:
        -:49932:static int
    #####:49933:test_xmlXPathPopExternal(void) {
    #####:49934:    int test_ret = 0;
        -:49935:
        -:49936:#if defined(LIBXML_XPATH_ENABLED)
        -:49937:    int mem_base;
        -:49938:    void * ret_val;
        -:49939:    xmlXPathParserContextPtr ctxt; /* an XPath parser context */
        -:49940:    int n_ctxt;
        -:49941:
    #####:49942:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:49943:        mem_base = xmlMemBlocks();
    #####:49944:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        -:49945:
    #####:49946:        ret_val = xmlXPathPopExternal(ctxt);
    #####:49947:        desret_void_ptr(ret_val);
    #####:49948:        call_tests++;
    #####:49949:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:49950:        xmlResetLastError();
    #####:49951:        if (mem_base != xmlMemBlocks()) {
    #####:49952:            printf("Leak of %d blocks found in xmlXPathPopExternal",
    #####:49953:	           xmlMemBlocks() - mem_base);
    #####:49954:	    test_ret++;
    #####:49955:            printf(" %d", n_ctxt);
    #####:49956:            printf("\n");
        -:49957:        }
        -:49958:    }
    #####:49959:    function_tests++;
        -:49960:#endif
        -:49961:
    #####:49962:    return(test_ret);
        -:49963:}
        -:49964:
        -:49965:
        -:49966:static int
    #####:49967:test_xmlXPathPopNodeSet(void) {
    #####:49968:    int test_ret = 0;
        -:49969:
        -:49970:#if defined(LIBXML_XPATH_ENABLED)
        -:49971:    int mem_base;
        -:49972:    xmlNodeSetPtr ret_val;
        -:49973:    xmlXPathParserContextPtr ctxt; /* an XPath parser context */
        -:49974:    int n_ctxt;
        -:49975:
    #####:49976:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:49977:        mem_base = xmlMemBlocks();
    #####:49978:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        -:49979:
    #####:49980:        ret_val = xmlXPathPopNodeSet(ctxt);
    #####:49981:        desret_xmlNodeSetPtr(ret_val);
    #####:49982:        call_tests++;
    #####:49983:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:49984:        xmlResetLastError();
    #####:49985:        if (mem_base != xmlMemBlocks()) {
    #####:49986:            printf("Leak of %d blocks found in xmlXPathPopNodeSet",
    #####:49987:	           xmlMemBlocks() - mem_base);
    #####:49988:	    test_ret++;
    #####:49989:            printf(" %d", n_ctxt);
    #####:49990:            printf("\n");
        -:49991:        }
        -:49992:    }
    #####:49993:    function_tests++;
        -:49994:#endif
        -:49995:
    #####:49996:    return(test_ret);
        -:49997:}
        -:49998:
        -:49999:
        -:50000:static int
    #####:50001:test_xmlXPathPopNumber(void) {
    #####:50002:    int test_ret = 0;
        -:50003:
        -:50004:#if defined(LIBXML_XPATH_ENABLED)
        -:50005:    int mem_base;
        -:50006:    double ret_val;
        -:50007:    xmlXPathParserContextPtr ctxt; /* an XPath parser context */
        -:50008:    int n_ctxt;
        -:50009:
    #####:50010:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:50011:        mem_base = xmlMemBlocks();
    #####:50012:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        -:50013:
    #####:50014:        ret_val = xmlXPathPopNumber(ctxt);
    #####:50015:        desret_double(ret_val);
    #####:50016:        call_tests++;
    #####:50017:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:50018:        xmlResetLastError();
    #####:50019:        if (mem_base != xmlMemBlocks()) {
    #####:50020:            printf("Leak of %d blocks found in xmlXPathPopNumber",
    #####:50021:	           xmlMemBlocks() - mem_base);
    #####:50022:	    test_ret++;
    #####:50023:            printf(" %d", n_ctxt);
    #####:50024:            printf("\n");
        -:50025:        }
        -:50026:    }
    #####:50027:    function_tests++;
        -:50028:#endif
        -:50029:
    #####:50030:    return(test_ret);
        -:50031:}
        -:50032:
        -:50033:
        -:50034:static int
    #####:50035:test_xmlXPathPopString(void) {
    #####:50036:    int test_ret = 0;
        -:50037:
        -:50038:#if defined(LIBXML_XPATH_ENABLED)
        -:50039:    int mem_base;
        -:50040:    xmlChar * ret_val;
        -:50041:    xmlXPathParserContextPtr ctxt; /* an XPath parser context */
        -:50042:    int n_ctxt;
        -:50043:
    #####:50044:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:50045:        mem_base = xmlMemBlocks();
    #####:50046:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        -:50047:
    #####:50048:        ret_val = xmlXPathPopString(ctxt);
    #####:50049:        desret_xmlChar_ptr(ret_val);
    #####:50050:        call_tests++;
    #####:50051:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:50052:        xmlResetLastError();
    #####:50053:        if (mem_base != xmlMemBlocks()) {
    #####:50054:            printf("Leak of %d blocks found in xmlXPathPopString",
    #####:50055:	           xmlMemBlocks() - mem_base);
    #####:50056:	    test_ret++;
    #####:50057:            printf(" %d", n_ctxt);
    #####:50058:            printf("\n");
        -:50059:        }
        -:50060:    }
    #####:50061:    function_tests++;
        -:50062:#endif
        -:50063:
    #####:50064:    return(test_ret);
        -:50065:}
        -:50066:
        -:50067:
        -:50068:static int
    #####:50069:test_xmlXPathPositionFunction(void) {
    #####:50070:    int test_ret = 0;
        -:50071:
        -:50072:#if defined(LIBXML_XPATH_ENABLED)
        -:50073:    int mem_base;
        -:50074:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:50075:    int n_ctxt;
        -:50076:    int nargs; /* the number of arguments */
        -:50077:    int n_nargs;
        -:50078:
    #####:50079:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:50080:    for (n_nargs = 0;n_nargs < gen_nb_int;n_nargs++) {
    #####:50081:        mem_base = xmlMemBlocks();
    #####:50082:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:50083:        nargs = gen_int(n_nargs, 1);
        -:50084:
    #####:50085:        xmlXPathPositionFunction(ctxt, nargs);
    #####:50086:        call_tests++;
    #####:50087:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:50088:        des_int(n_nargs, nargs, 1);
    #####:50089:        xmlResetLastError();
    #####:50090:        if (mem_base != xmlMemBlocks()) {
    #####:50091:            printf("Leak of %d blocks found in xmlXPathPositionFunction",
    #####:50092:	           xmlMemBlocks() - mem_base);
    #####:50093:	    test_ret++;
    #####:50094:            printf(" %d", n_ctxt);
    #####:50095:            printf(" %d", n_nargs);
    #####:50096:            printf("\n");
        -:50097:        }
        -:50098:    }
        -:50099:    }
    #####:50100:    function_tests++;
        -:50101:#endif
        -:50102:
    #####:50103:    return(test_ret);
        -:50104:}
        -:50105:
        -:50106:
        -:50107:static int
    #####:50108:test_xmlXPathRegisterAllFunctions(void) {
    #####:50109:    int test_ret = 0;
        -:50110:
        -:50111:#if defined(LIBXML_XPATH_ENABLED)
        -:50112:    int mem_base;
        -:50113:    xmlXPathContextPtr ctxt; /* the XPath context */
        -:50114:    int n_ctxt;
        -:50115:
    #####:50116:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathContextPtr;n_ctxt++) {
    #####:50117:        mem_base = xmlMemBlocks();
    #####:50118:        ctxt = gen_xmlXPathContextPtr(n_ctxt, 0);
        -:50119:
    #####:50120:        xmlXPathRegisterAllFunctions(ctxt);
    #####:50121:        call_tests++;
    #####:50122:        des_xmlXPathContextPtr(n_ctxt, ctxt, 0);
    #####:50123:        xmlResetLastError();
    #####:50124:        if (mem_base != xmlMemBlocks()) {
    #####:50125:            printf("Leak of %d blocks found in xmlXPathRegisterAllFunctions",
    #####:50126:	           xmlMemBlocks() - mem_base);
    #####:50127:	    test_ret++;
    #####:50128:            printf(" %d", n_ctxt);
    #####:50129:            printf("\n");
        -:50130:        }
        -:50131:    }
    #####:50132:    function_tests++;
        -:50133:#endif
        -:50134:
    #####:50135:    return(test_ret);
        -:50136:}
        -:50137:
        -:50138:
        -:50139:static int
    #####:50140:test_xmlXPathRegisterFunc(void) {
    #####:50141:    int test_ret = 0;
        -:50142:
        -:50143:
        -:50144:    /* missing type support */
    #####:50145:    return(test_ret);
        -:50146:}
        -:50147:
        -:50148:
        -:50149:static int
    #####:50150:test_xmlXPathRegisterFuncLookup(void) {
    #####:50151:    int test_ret = 0;
        -:50152:
        -:50153:
        -:50154:    /* missing type support */
    #####:50155:    return(test_ret);
        -:50156:}
        -:50157:
        -:50158:
        -:50159:static int
    #####:50160:test_xmlXPathRegisterFuncNS(void) {
    #####:50161:    int test_ret = 0;
        -:50162:
        -:50163:
        -:50164:    /* missing type support */
    #####:50165:    return(test_ret);
        -:50166:}
        -:50167:
        -:50168:
        -:50169:static int
    #####:50170:test_xmlXPathRegisterNs(void) {
    #####:50171:    int test_ret = 0;
        -:50172:
        -:50173:#if defined(LIBXML_XPATH_ENABLED)
        -:50174:    int mem_base;
        -:50175:    int ret_val;
        -:50176:    xmlXPathContextPtr ctxt; /* the XPath context */
        -:50177:    int n_ctxt;
        -:50178:    xmlChar * prefix; /* the namespace prefix cannot be NULL or empty string */
        -:50179:    int n_prefix;
        -:50180:    xmlChar * ns_uri; /* the namespace name */
        -:50181:    int n_ns_uri;
        -:50182:
    #####:50183:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathContextPtr;n_ctxt++) {
    #####:50184:    for (n_prefix = 0;n_prefix < gen_nb_const_xmlChar_ptr;n_prefix++) {
    #####:50185:    for (n_ns_uri = 0;n_ns_uri < gen_nb_const_xmlChar_ptr;n_ns_uri++) {
    #####:50186:        mem_base = xmlMemBlocks();
    #####:50187:        ctxt = gen_xmlXPathContextPtr(n_ctxt, 0);
    #####:50188:        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
    #####:50189:        ns_uri = gen_const_xmlChar_ptr(n_ns_uri, 2);
        -:50190:
    #####:50191:        ret_val = xmlXPathRegisterNs(ctxt, (const xmlChar *)prefix, (const xmlChar *)ns_uri);
    #####:50192:        desret_int(ret_val);
    #####:50193:        call_tests++;
    #####:50194:        des_xmlXPathContextPtr(n_ctxt, ctxt, 0);
    #####:50195:        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 1);
    #####:50196:        des_const_xmlChar_ptr(n_ns_uri, (const xmlChar *)ns_uri, 2);
    #####:50197:        xmlResetLastError();
    #####:50198:        if (mem_base != xmlMemBlocks()) {
    #####:50199:            printf("Leak of %d blocks found in xmlXPathRegisterNs",
    #####:50200:	           xmlMemBlocks() - mem_base);
    #####:50201:	    test_ret++;
    #####:50202:            printf(" %d", n_ctxt);
    #####:50203:            printf(" %d", n_prefix);
    #####:50204:            printf(" %d", n_ns_uri);
    #####:50205:            printf("\n");
        -:50206:        }
        -:50207:    }
        -:50208:    }
        -:50209:    }
    #####:50210:    function_tests++;
        -:50211:#endif
        -:50212:
    #####:50213:    return(test_ret);
        -:50214:}
        -:50215:
        -:50216:
        -:50217:static int
    #####:50218:test_xmlXPathRegisterVariable(void) {
    #####:50219:    int test_ret = 0;
        -:50220:
        -:50221:#if defined(LIBXML_XPATH_ENABLED)
        -:50222:    int mem_base;
        -:50223:    int ret_val;
        -:50224:    xmlXPathContextPtr ctxt; /* the XPath context */
        -:50225:    int n_ctxt;
        -:50226:    xmlChar * name; /* the variable name */
        -:50227:    int n_name;
        -:50228:    xmlXPathObjectPtr value; /* the variable value or NULL */
        -:50229:    int n_value;
        -:50230:
    #####:50231:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathContextPtr;n_ctxt++) {
    #####:50232:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:50233:    for (n_value = 0;n_value < gen_nb_xmlXPathObjectPtr;n_value++) {
    #####:50234:        mem_base = xmlMemBlocks();
    #####:50235:        ctxt = gen_xmlXPathContextPtr(n_ctxt, 0);
    #####:50236:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:50237:        value = gen_xmlXPathObjectPtr(n_value, 2);
        -:50238:
    #####:50239:        ret_val = xmlXPathRegisterVariable(ctxt, (const xmlChar *)name, value);
    #####:50240:        desret_int(ret_val);
    #####:50241:        call_tests++;
    #####:50242:        des_xmlXPathContextPtr(n_ctxt, ctxt, 0);
    #####:50243:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:50244:        des_xmlXPathObjectPtr(n_value, value, 2);
    #####:50245:        xmlResetLastError();
    #####:50246:        if (mem_base != xmlMemBlocks()) {
    #####:50247:            printf("Leak of %d blocks found in xmlXPathRegisterVariable",
    #####:50248:	           xmlMemBlocks() - mem_base);
    #####:50249:	    test_ret++;
    #####:50250:            printf(" %d", n_ctxt);
    #####:50251:            printf(" %d", n_name);
    #####:50252:            printf(" %d", n_value);
    #####:50253:            printf("\n");
        -:50254:        }
        -:50255:    }
        -:50256:    }
        -:50257:    }
    #####:50258:    function_tests++;
        -:50259:#endif
        -:50260:
    #####:50261:    return(test_ret);
        -:50262:}
        -:50263:
        -:50264:
        -:50265:static int
    #####:50266:test_xmlXPathRegisterVariableLookup(void) {
    #####:50267:    int test_ret = 0;
        -:50268:
        -:50269:
        -:50270:    /* missing type support */
    #####:50271:    return(test_ret);
        -:50272:}
        -:50273:
        -:50274:
        -:50275:static int
    #####:50276:test_xmlXPathRegisterVariableNS(void) {
    #####:50277:    int test_ret = 0;
        -:50278:
        -:50279:#if defined(LIBXML_XPATH_ENABLED)
        -:50280:    int mem_base;
        -:50281:    int ret_val;
        -:50282:    xmlXPathContextPtr ctxt; /* the XPath context */
        -:50283:    int n_ctxt;
        -:50284:    xmlChar * name; /* the variable name */
        -:50285:    int n_name;
        -:50286:    xmlChar * ns_uri; /* the variable namespace URI */
        -:50287:    int n_ns_uri;
        -:50288:    xmlXPathObjectPtr value; /* the variable value or NULL */
        -:50289:    int n_value;
        -:50290:
    #####:50291:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathContextPtr;n_ctxt++) {
    #####:50292:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:50293:    for (n_ns_uri = 0;n_ns_uri < gen_nb_const_xmlChar_ptr;n_ns_uri++) {
    #####:50294:    for (n_value = 0;n_value < gen_nb_xmlXPathObjectPtr;n_value++) {
    #####:50295:        mem_base = xmlMemBlocks();
    #####:50296:        ctxt = gen_xmlXPathContextPtr(n_ctxt, 0);
    #####:50297:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:50298:        ns_uri = gen_const_xmlChar_ptr(n_ns_uri, 2);
    #####:50299:        value = gen_xmlXPathObjectPtr(n_value, 3);
        -:50300:
    #####:50301:        ret_val = xmlXPathRegisterVariableNS(ctxt, (const xmlChar *)name, (const xmlChar *)ns_uri, value);
    #####:50302:        desret_int(ret_val);
    #####:50303:        call_tests++;
    #####:50304:        des_xmlXPathContextPtr(n_ctxt, ctxt, 0);
    #####:50305:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:50306:        des_const_xmlChar_ptr(n_ns_uri, (const xmlChar *)ns_uri, 2);
    #####:50307:        des_xmlXPathObjectPtr(n_value, value, 3);
    #####:50308:        xmlResetLastError();
    #####:50309:        if (mem_base != xmlMemBlocks()) {
    #####:50310:            printf("Leak of %d blocks found in xmlXPathRegisterVariableNS",
    #####:50311:	           xmlMemBlocks() - mem_base);
    #####:50312:	    test_ret++;
    #####:50313:            printf(" %d", n_ctxt);
    #####:50314:            printf(" %d", n_name);
    #####:50315:            printf(" %d", n_ns_uri);
    #####:50316:            printf(" %d", n_value);
    #####:50317:            printf("\n");
        -:50318:        }
        -:50319:    }
        -:50320:    }
        -:50321:    }
        -:50322:    }
    #####:50323:    function_tests++;
        -:50324:#endif
        -:50325:
    #####:50326:    return(test_ret);
        -:50327:}
        -:50328:
        -:50329:
        -:50330:static int
    #####:50331:test_xmlXPathRegisteredFuncsCleanup(void) {
    #####:50332:    int test_ret = 0;
        -:50333:
        -:50334:#if defined(LIBXML_XPATH_ENABLED)
        -:50335:    int mem_base;
        -:50336:    xmlXPathContextPtr ctxt; /* the XPath context */
        -:50337:    int n_ctxt;
        -:50338:
    #####:50339:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathContextPtr;n_ctxt++) {
    #####:50340:        mem_base = xmlMemBlocks();
    #####:50341:        ctxt = gen_xmlXPathContextPtr(n_ctxt, 0);
        -:50342:
    #####:50343:        xmlXPathRegisteredFuncsCleanup(ctxt);
    #####:50344:        call_tests++;
    #####:50345:        des_xmlXPathContextPtr(n_ctxt, ctxt, 0);
    #####:50346:        xmlResetLastError();
    #####:50347:        if (mem_base != xmlMemBlocks()) {
    #####:50348:            printf("Leak of %d blocks found in xmlXPathRegisteredFuncsCleanup",
    #####:50349:	           xmlMemBlocks() - mem_base);
    #####:50350:	    test_ret++;
    #####:50351:            printf(" %d", n_ctxt);
    #####:50352:            printf("\n");
        -:50353:        }
        -:50354:    }
    #####:50355:    function_tests++;
        -:50356:#endif
        -:50357:
    #####:50358:    return(test_ret);
        -:50359:}
        -:50360:
        -:50361:
        -:50362:static int
    #####:50363:test_xmlXPathRegisteredNsCleanup(void) {
    #####:50364:    int test_ret = 0;
        -:50365:
        -:50366:#if defined(LIBXML_XPATH_ENABLED)
        -:50367:    int mem_base;
        -:50368:    xmlXPathContextPtr ctxt; /* the XPath context */
        -:50369:    int n_ctxt;
        -:50370:
    #####:50371:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathContextPtr;n_ctxt++) {
    #####:50372:        mem_base = xmlMemBlocks();
    #####:50373:        ctxt = gen_xmlXPathContextPtr(n_ctxt, 0);
        -:50374:
    #####:50375:        xmlXPathRegisteredNsCleanup(ctxt);
    #####:50376:        call_tests++;
    #####:50377:        des_xmlXPathContextPtr(n_ctxt, ctxt, 0);
    #####:50378:        xmlResetLastError();
    #####:50379:        if (mem_base != xmlMemBlocks()) {
    #####:50380:            printf("Leak of %d blocks found in xmlXPathRegisteredNsCleanup",
    #####:50381:	           xmlMemBlocks() - mem_base);
    #####:50382:	    test_ret++;
    #####:50383:            printf(" %d", n_ctxt);
    #####:50384:            printf("\n");
        -:50385:        }
        -:50386:    }
    #####:50387:    function_tests++;
        -:50388:#endif
        -:50389:
    #####:50390:    return(test_ret);
        -:50391:}
        -:50392:
        -:50393:
        -:50394:static int
    #####:50395:test_xmlXPathRegisteredVariablesCleanup(void) {
    #####:50396:    int test_ret = 0;
        -:50397:
        -:50398:#if defined(LIBXML_XPATH_ENABLED)
        -:50399:    int mem_base;
        -:50400:    xmlXPathContextPtr ctxt; /* the XPath context */
        -:50401:    int n_ctxt;
        -:50402:
    #####:50403:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathContextPtr;n_ctxt++) {
    #####:50404:        mem_base = xmlMemBlocks();
    #####:50405:        ctxt = gen_xmlXPathContextPtr(n_ctxt, 0);
        -:50406:
    #####:50407:        xmlXPathRegisteredVariablesCleanup(ctxt);
    #####:50408:        call_tests++;
    #####:50409:        des_xmlXPathContextPtr(n_ctxt, ctxt, 0);
    #####:50410:        xmlResetLastError();
    #####:50411:        if (mem_base != xmlMemBlocks()) {
    #####:50412:            printf("Leak of %d blocks found in xmlXPathRegisteredVariablesCleanup",
    #####:50413:	           xmlMemBlocks() - mem_base);
    #####:50414:	    test_ret++;
    #####:50415:            printf(" %d", n_ctxt);
    #####:50416:            printf("\n");
        -:50417:        }
        -:50418:    }
    #####:50419:    function_tests++;
        -:50420:#endif
        -:50421:
    #####:50422:    return(test_ret);
        -:50423:}
        -:50424:
        -:50425:
        -:50426:static int
    #####:50427:test_xmlXPathRoot(void) {
    #####:50428:    int test_ret = 0;
        -:50429:
        -:50430:#if defined(LIBXML_XPATH_ENABLED)
        -:50431:    int mem_base;
        -:50432:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:50433:    int n_ctxt;
        -:50434:
    #####:50435:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:50436:        mem_base = xmlMemBlocks();
    #####:50437:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        -:50438:
    #####:50439:        xmlXPathRoot(ctxt);
    #####:50440:        call_tests++;
    #####:50441:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:50442:        xmlResetLastError();
    #####:50443:        if (mem_base != xmlMemBlocks()) {
    #####:50444:            printf("Leak of %d blocks found in xmlXPathRoot",
    #####:50445:	           xmlMemBlocks() - mem_base);
    #####:50446:	    test_ret++;
    #####:50447:            printf(" %d", n_ctxt);
    #####:50448:            printf("\n");
        -:50449:        }
        -:50450:    }
    #####:50451:    function_tests++;
        -:50452:#endif
        -:50453:
    #####:50454:    return(test_ret);
        -:50455:}
        -:50456:
        -:50457:
        -:50458:static int
    #####:50459:test_xmlXPathRoundFunction(void) {
    #####:50460:    int test_ret = 0;
        -:50461:
        -:50462:#if defined(LIBXML_XPATH_ENABLED)
        -:50463:    int mem_base;
        -:50464:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:50465:    int n_ctxt;
        -:50466:    int nargs; /* the number of arguments */
        -:50467:    int n_nargs;
        -:50468:
    #####:50469:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:50470:    for (n_nargs = 0;n_nargs < gen_nb_int;n_nargs++) {
    #####:50471:        mem_base = xmlMemBlocks();
    #####:50472:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:50473:        nargs = gen_int(n_nargs, 1);
        -:50474:
    #####:50475:        xmlXPathRoundFunction(ctxt, nargs);
    #####:50476:        call_tests++;
    #####:50477:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:50478:        des_int(n_nargs, nargs, 1);
    #####:50479:        xmlResetLastError();
    #####:50480:        if (mem_base != xmlMemBlocks()) {
    #####:50481:            printf("Leak of %d blocks found in xmlXPathRoundFunction",
    #####:50482:	           xmlMemBlocks() - mem_base);
    #####:50483:	    test_ret++;
    #####:50484:            printf(" %d", n_ctxt);
    #####:50485:            printf(" %d", n_nargs);
    #####:50486:            printf("\n");
        -:50487:        }
        -:50488:    }
        -:50489:    }
    #####:50490:    function_tests++;
        -:50491:#endif
        -:50492:
    #####:50493:    return(test_ret);
        -:50494:}
        -:50495:
        -:50496:
        -:50497:static int
    #####:50498:test_xmlXPathStartsWithFunction(void) {
    #####:50499:    int test_ret = 0;
        -:50500:
        -:50501:#if defined(LIBXML_XPATH_ENABLED)
        -:50502:    int mem_base;
        -:50503:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:50504:    int n_ctxt;
        -:50505:    int nargs; /* the number of arguments */
        -:50506:    int n_nargs;
        -:50507:
    #####:50508:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:50509:    for (n_nargs = 0;n_nargs < gen_nb_int;n_nargs++) {
    #####:50510:        mem_base = xmlMemBlocks();
    #####:50511:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:50512:        nargs = gen_int(n_nargs, 1);
        -:50513:
    #####:50514:        xmlXPathStartsWithFunction(ctxt, nargs);
    #####:50515:        call_tests++;
    #####:50516:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:50517:        des_int(n_nargs, nargs, 1);
    #####:50518:        xmlResetLastError();
    #####:50519:        if (mem_base != xmlMemBlocks()) {
    #####:50520:            printf("Leak of %d blocks found in xmlXPathStartsWithFunction",
    #####:50521:	           xmlMemBlocks() - mem_base);
    #####:50522:	    test_ret++;
    #####:50523:            printf(" %d", n_ctxt);
    #####:50524:            printf(" %d", n_nargs);
    #####:50525:            printf("\n");
        -:50526:        }
        -:50527:    }
        -:50528:    }
    #####:50529:    function_tests++;
        -:50530:#endif
        -:50531:
    #####:50532:    return(test_ret);
        -:50533:}
        -:50534:
        -:50535:
        -:50536:static int
    #####:50537:test_xmlXPathStringEvalNumber(void) {
    #####:50538:    int test_ret = 0;
        -:50539:
        -:50540:#if defined(LIBXML_XPATH_ENABLED)
        -:50541:    int mem_base;
        -:50542:    double ret_val;
        -:50543:    xmlChar * str; /* A string to scan */
        -:50544:    int n_str;
        -:50545:
    #####:50546:    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    #####:50547:        mem_base = xmlMemBlocks();
    #####:50548:        str = gen_const_xmlChar_ptr(n_str, 0);
        -:50549:
    #####:50550:        ret_val = xmlXPathStringEvalNumber((const xmlChar *)str);
    #####:50551:        desret_double(ret_val);
    #####:50552:        call_tests++;
    #####:50553:        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 0);
    #####:50554:        xmlResetLastError();
    #####:50555:        if (mem_base != xmlMemBlocks()) {
    #####:50556:            printf("Leak of %d blocks found in xmlXPathStringEvalNumber",
    #####:50557:	           xmlMemBlocks() - mem_base);
    #####:50558:	    test_ret++;
    #####:50559:            printf(" %d", n_str);
    #####:50560:            printf("\n");
        -:50561:        }
        -:50562:    }
    #####:50563:    function_tests++;
        -:50564:#endif
        -:50565:
    #####:50566:    return(test_ret);
        -:50567:}
        -:50568:
        -:50569:
        -:50570:static int
    #####:50571:test_xmlXPathStringFunction(void) {
    #####:50572:    int test_ret = 0;
        -:50573:
        -:50574:#if defined(LIBXML_XPATH_ENABLED)
        -:50575:    int mem_base;
        -:50576:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:50577:    int n_ctxt;
        -:50578:    int nargs; /* the number of arguments */
        -:50579:    int n_nargs;
        -:50580:
    #####:50581:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:50582:    for (n_nargs = 0;n_nargs < gen_nb_int;n_nargs++) {
    #####:50583:        mem_base = xmlMemBlocks();
    #####:50584:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:50585:        nargs = gen_int(n_nargs, 1);
        -:50586:
    #####:50587:        xmlXPathStringFunction(ctxt, nargs);
    #####:50588:        call_tests++;
    #####:50589:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:50590:        des_int(n_nargs, nargs, 1);
    #####:50591:        xmlResetLastError();
    #####:50592:        if (mem_base != xmlMemBlocks()) {
    #####:50593:            printf("Leak of %d blocks found in xmlXPathStringFunction",
    #####:50594:	           xmlMemBlocks() - mem_base);
    #####:50595:	    test_ret++;
    #####:50596:            printf(" %d", n_ctxt);
    #####:50597:            printf(" %d", n_nargs);
    #####:50598:            printf("\n");
        -:50599:        }
        -:50600:    }
        -:50601:    }
    #####:50602:    function_tests++;
        -:50603:#endif
        -:50604:
    #####:50605:    return(test_ret);
        -:50606:}
        -:50607:
        -:50608:
        -:50609:static int
    #####:50610:test_xmlXPathStringLengthFunction(void) {
    #####:50611:    int test_ret = 0;
        -:50612:
        -:50613:#if defined(LIBXML_XPATH_ENABLED)
        -:50614:    int mem_base;
        -:50615:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:50616:    int n_ctxt;
        -:50617:    int nargs; /* the number of arguments */
        -:50618:    int n_nargs;
        -:50619:
    #####:50620:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:50621:    for (n_nargs = 0;n_nargs < gen_nb_int;n_nargs++) {
    #####:50622:        mem_base = xmlMemBlocks();
    #####:50623:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:50624:        nargs = gen_int(n_nargs, 1);
        -:50625:
    #####:50626:        xmlXPathStringLengthFunction(ctxt, nargs);
    #####:50627:        call_tests++;
    #####:50628:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:50629:        des_int(n_nargs, nargs, 1);
    #####:50630:        xmlResetLastError();
    #####:50631:        if (mem_base != xmlMemBlocks()) {
    #####:50632:            printf("Leak of %d blocks found in xmlXPathStringLengthFunction",
    #####:50633:	           xmlMemBlocks() - mem_base);
    #####:50634:	    test_ret++;
    #####:50635:            printf(" %d", n_ctxt);
    #####:50636:            printf(" %d", n_nargs);
    #####:50637:            printf("\n");
        -:50638:        }
        -:50639:    }
        -:50640:    }
    #####:50641:    function_tests++;
        -:50642:#endif
        -:50643:
    #####:50644:    return(test_ret);
        -:50645:}
        -:50646:
        -:50647:
        -:50648:static int
    #####:50649:test_xmlXPathSubValues(void) {
    #####:50650:    int test_ret = 0;
        -:50651:
        -:50652:#if defined(LIBXML_XPATH_ENABLED)
        -:50653:    int mem_base;
        -:50654:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:50655:    int n_ctxt;
        -:50656:
    #####:50657:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:50658:        mem_base = xmlMemBlocks();
    #####:50659:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        -:50660:
    #####:50661:        xmlXPathSubValues(ctxt);
    #####:50662:        call_tests++;
    #####:50663:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:50664:        xmlResetLastError();
    #####:50665:        if (mem_base != xmlMemBlocks()) {
    #####:50666:            printf("Leak of %d blocks found in xmlXPathSubValues",
    #####:50667:	           xmlMemBlocks() - mem_base);
    #####:50668:	    test_ret++;
    #####:50669:            printf(" %d", n_ctxt);
    #####:50670:            printf("\n");
        -:50671:        }
        -:50672:    }
    #####:50673:    function_tests++;
        -:50674:#endif
        -:50675:
    #####:50676:    return(test_ret);
        -:50677:}
        -:50678:
        -:50679:
        -:50680:static int
    #####:50681:test_xmlXPathSubstringAfterFunction(void) {
    #####:50682:    int test_ret = 0;
        -:50683:
        -:50684:#if defined(LIBXML_XPATH_ENABLED)
        -:50685:    int mem_base;
        -:50686:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:50687:    int n_ctxt;
        -:50688:    int nargs; /* the number of arguments */
        -:50689:    int n_nargs;
        -:50690:
    #####:50691:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:50692:    for (n_nargs = 0;n_nargs < gen_nb_int;n_nargs++) {
    #####:50693:        mem_base = xmlMemBlocks();
    #####:50694:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:50695:        nargs = gen_int(n_nargs, 1);
        -:50696:
    #####:50697:        xmlXPathSubstringAfterFunction(ctxt, nargs);
    #####:50698:        call_tests++;
    #####:50699:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:50700:        des_int(n_nargs, nargs, 1);
    #####:50701:        xmlResetLastError();
    #####:50702:        if (mem_base != xmlMemBlocks()) {
    #####:50703:            printf("Leak of %d blocks found in xmlXPathSubstringAfterFunction",
    #####:50704:	           xmlMemBlocks() - mem_base);
    #####:50705:	    test_ret++;
    #####:50706:            printf(" %d", n_ctxt);
    #####:50707:            printf(" %d", n_nargs);
    #####:50708:            printf("\n");
        -:50709:        }
        -:50710:    }
        -:50711:    }
    #####:50712:    function_tests++;
        -:50713:#endif
        -:50714:
    #####:50715:    return(test_ret);
        -:50716:}
        -:50717:
        -:50718:
        -:50719:static int
    #####:50720:test_xmlXPathSubstringBeforeFunction(void) {
    #####:50721:    int test_ret = 0;
        -:50722:
        -:50723:#if defined(LIBXML_XPATH_ENABLED)
        -:50724:    int mem_base;
        -:50725:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:50726:    int n_ctxt;
        -:50727:    int nargs; /* the number of arguments */
        -:50728:    int n_nargs;
        -:50729:
    #####:50730:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:50731:    for (n_nargs = 0;n_nargs < gen_nb_int;n_nargs++) {
    #####:50732:        mem_base = xmlMemBlocks();
    #####:50733:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:50734:        nargs = gen_int(n_nargs, 1);
        -:50735:
    #####:50736:        xmlXPathSubstringBeforeFunction(ctxt, nargs);
    #####:50737:        call_tests++;
    #####:50738:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:50739:        des_int(n_nargs, nargs, 1);
    #####:50740:        xmlResetLastError();
    #####:50741:        if (mem_base != xmlMemBlocks()) {
    #####:50742:            printf("Leak of %d blocks found in xmlXPathSubstringBeforeFunction",
    #####:50743:	           xmlMemBlocks() - mem_base);
    #####:50744:	    test_ret++;
    #####:50745:            printf(" %d", n_ctxt);
    #####:50746:            printf(" %d", n_nargs);
    #####:50747:            printf("\n");
        -:50748:        }
        -:50749:    }
        -:50750:    }
    #####:50751:    function_tests++;
        -:50752:#endif
        -:50753:
    #####:50754:    return(test_ret);
        -:50755:}
        -:50756:
        -:50757:
        -:50758:static int
    #####:50759:test_xmlXPathSubstringFunction(void) {
    #####:50760:    int test_ret = 0;
        -:50761:
        -:50762:#if defined(LIBXML_XPATH_ENABLED)
        -:50763:    int mem_base;
        -:50764:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:50765:    int n_ctxt;
        -:50766:    int nargs; /* the number of arguments */
        -:50767:    int n_nargs;
        -:50768:
    #####:50769:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:50770:    for (n_nargs = 0;n_nargs < gen_nb_int;n_nargs++) {
    #####:50771:        mem_base = xmlMemBlocks();
    #####:50772:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:50773:        nargs = gen_int(n_nargs, 1);
        -:50774:
    #####:50775:        xmlXPathSubstringFunction(ctxt, nargs);
    #####:50776:        call_tests++;
    #####:50777:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:50778:        des_int(n_nargs, nargs, 1);
    #####:50779:        xmlResetLastError();
    #####:50780:        if (mem_base != xmlMemBlocks()) {
    #####:50781:            printf("Leak of %d blocks found in xmlXPathSubstringFunction",
    #####:50782:	           xmlMemBlocks() - mem_base);
    #####:50783:	    test_ret++;
    #####:50784:            printf(" %d", n_ctxt);
    #####:50785:            printf(" %d", n_nargs);
    #####:50786:            printf("\n");
        -:50787:        }
        -:50788:    }
        -:50789:    }
    #####:50790:    function_tests++;
        -:50791:#endif
        -:50792:
    #####:50793:    return(test_ret);
        -:50794:}
        -:50795:
        -:50796:
        -:50797:static int
    #####:50798:test_xmlXPathSumFunction(void) {
    #####:50799:    int test_ret = 0;
        -:50800:
        -:50801:#if defined(LIBXML_XPATH_ENABLED)
        -:50802:    int mem_base;
        -:50803:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:50804:    int n_ctxt;
        -:50805:    int nargs; /* the number of arguments */
        -:50806:    int n_nargs;
        -:50807:
    #####:50808:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:50809:    for (n_nargs = 0;n_nargs < gen_nb_int;n_nargs++) {
    #####:50810:        mem_base = xmlMemBlocks();
    #####:50811:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:50812:        nargs = gen_int(n_nargs, 1);
        -:50813:
    #####:50814:        xmlXPathSumFunction(ctxt, nargs);
    #####:50815:        call_tests++;
    #####:50816:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:50817:        des_int(n_nargs, nargs, 1);
    #####:50818:        xmlResetLastError();
    #####:50819:        if (mem_base != xmlMemBlocks()) {
    #####:50820:            printf("Leak of %d blocks found in xmlXPathSumFunction",
    #####:50821:	           xmlMemBlocks() - mem_base);
    #####:50822:	    test_ret++;
    #####:50823:            printf(" %d", n_ctxt);
    #####:50824:            printf(" %d", n_nargs);
    #####:50825:            printf("\n");
        -:50826:        }
        -:50827:    }
        -:50828:    }
    #####:50829:    function_tests++;
        -:50830:#endif
        -:50831:
    #####:50832:    return(test_ret);
        -:50833:}
        -:50834:
        -:50835:
        -:50836:static int
    #####:50837:test_xmlXPathTrailing(void) {
    #####:50838:    int test_ret = 0;
        -:50839:
        -:50840:#if defined(LIBXML_XPATH_ENABLED)
        -:50841:    int mem_base;
        -:50842:    xmlNodeSetPtr ret_val;
        -:50843:    xmlNodeSetPtr nodes1; /* a node-set */
        -:50844:    int n_nodes1;
        -:50845:    xmlNodeSetPtr nodes2; /* a node-set */
        -:50846:    int n_nodes2;
        -:50847:
    #####:50848:    for (n_nodes1 = 0;n_nodes1 < gen_nb_xmlNodeSetPtr;n_nodes1++) {
    #####:50849:    for (n_nodes2 = 0;n_nodes2 < gen_nb_xmlNodeSetPtr;n_nodes2++) {
    #####:50850:        mem_base = xmlMemBlocks();
    #####:50851:        nodes1 = gen_xmlNodeSetPtr(n_nodes1, 0);
    #####:50852:        nodes2 = gen_xmlNodeSetPtr(n_nodes2, 1);
        -:50853:
    #####:50854:        ret_val = xmlXPathTrailing(nodes1, nodes2);
    #####:50855:        desret_xmlNodeSetPtr(ret_val);
    #####:50856:        call_tests++;
    #####:50857:        des_xmlNodeSetPtr(n_nodes1, nodes1, 0);
    #####:50858:        des_xmlNodeSetPtr(n_nodes2, nodes2, 1);
    #####:50859:        xmlResetLastError();
    #####:50860:        if (mem_base != xmlMemBlocks()) {
    #####:50861:            printf("Leak of %d blocks found in xmlXPathTrailing",
    #####:50862:	           xmlMemBlocks() - mem_base);
    #####:50863:	    test_ret++;
    #####:50864:            printf(" %d", n_nodes1);
    #####:50865:            printf(" %d", n_nodes2);
    #####:50866:            printf("\n");
        -:50867:        }
        -:50868:    }
        -:50869:    }
    #####:50870:    function_tests++;
        -:50871:#endif
        -:50872:
    #####:50873:    return(test_ret);
        -:50874:}
        -:50875:
        -:50876:
        -:50877:static int
    #####:50878:test_xmlXPathTrailingSorted(void) {
    #####:50879:    int test_ret = 0;
        -:50880:
        -:50881:#if defined(LIBXML_XPATH_ENABLED)
        -:50882:    int mem_base;
        -:50883:    xmlNodeSetPtr ret_val;
        -:50884:    xmlNodeSetPtr nodes1; /* a node-set, sorted by document order */
        -:50885:    int n_nodes1;
        -:50886:    xmlNodeSetPtr nodes2; /* a node-set, sorted by document order */
        -:50887:    int n_nodes2;
        -:50888:
    #####:50889:    for (n_nodes1 = 0;n_nodes1 < gen_nb_xmlNodeSetPtr;n_nodes1++) {
    #####:50890:    for (n_nodes2 = 0;n_nodes2 < gen_nb_xmlNodeSetPtr;n_nodes2++) {
    #####:50891:        mem_base = xmlMemBlocks();
    #####:50892:        nodes1 = gen_xmlNodeSetPtr(n_nodes1, 0);
    #####:50893:        nodes2 = gen_xmlNodeSetPtr(n_nodes2, 1);
        -:50894:
    #####:50895:        ret_val = xmlXPathTrailingSorted(nodes1, nodes2);
    #####:50896:        desret_xmlNodeSetPtr(ret_val);
    #####:50897:        call_tests++;
    #####:50898:        des_xmlNodeSetPtr(n_nodes1, nodes1, 0);
    #####:50899:        des_xmlNodeSetPtr(n_nodes2, nodes2, 1);
    #####:50900:        xmlResetLastError();
    #####:50901:        if (mem_base != xmlMemBlocks()) {
    #####:50902:            printf("Leak of %d blocks found in xmlXPathTrailingSorted",
    #####:50903:	           xmlMemBlocks() - mem_base);
    #####:50904:	    test_ret++;
    #####:50905:            printf(" %d", n_nodes1);
    #####:50906:            printf(" %d", n_nodes2);
    #####:50907:            printf("\n");
        -:50908:        }
        -:50909:    }
        -:50910:    }
    #####:50911:    function_tests++;
        -:50912:#endif
        -:50913:
    #####:50914:    return(test_ret);
        -:50915:}
        -:50916:
        -:50917:
        -:50918:static int
    #####:50919:test_xmlXPathTranslateFunction(void) {
    #####:50920:    int test_ret = 0;
        -:50921:
        -:50922:#if defined(LIBXML_XPATH_ENABLED)
        -:50923:    int mem_base;
        -:50924:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:50925:    int n_ctxt;
        -:50926:    int nargs; /* the number of arguments */
        -:50927:    int n_nargs;
        -:50928:
    #####:50929:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:50930:    for (n_nargs = 0;n_nargs < gen_nb_int;n_nargs++) {
    #####:50931:        mem_base = xmlMemBlocks();
    #####:50932:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:50933:        nargs = gen_int(n_nargs, 1);
        -:50934:
    #####:50935:        xmlXPathTranslateFunction(ctxt, nargs);
    #####:50936:        call_tests++;
    #####:50937:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:50938:        des_int(n_nargs, nargs, 1);
    #####:50939:        xmlResetLastError();
    #####:50940:        if (mem_base != xmlMemBlocks()) {
    #####:50941:            printf("Leak of %d blocks found in xmlXPathTranslateFunction",
    #####:50942:	           xmlMemBlocks() - mem_base);
    #####:50943:	    test_ret++;
    #####:50944:            printf(" %d", n_ctxt);
    #####:50945:            printf(" %d", n_nargs);
    #####:50946:            printf("\n");
        -:50947:        }
        -:50948:    }
        -:50949:    }
    #####:50950:    function_tests++;
        -:50951:#endif
        -:50952:
    #####:50953:    return(test_ret);
        -:50954:}
        -:50955:
        -:50956:
        -:50957:static int
    #####:50958:test_xmlXPathTrueFunction(void) {
    #####:50959:    int test_ret = 0;
        -:50960:
        -:50961:#if defined(LIBXML_XPATH_ENABLED)
        -:50962:    int mem_base;
        -:50963:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:50964:    int n_ctxt;
        -:50965:    int nargs; /* the number of arguments */
        -:50966:    int n_nargs;
        -:50967:
    #####:50968:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:50969:    for (n_nargs = 0;n_nargs < gen_nb_int;n_nargs++) {
    #####:50970:        mem_base = xmlMemBlocks();
    #####:50971:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:50972:        nargs = gen_int(n_nargs, 1);
        -:50973:
    #####:50974:        xmlXPathTrueFunction(ctxt, nargs);
    #####:50975:        call_tests++;
    #####:50976:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:50977:        des_int(n_nargs, nargs, 1);
    #####:50978:        xmlResetLastError();
    #####:50979:        if (mem_base != xmlMemBlocks()) {
    #####:50980:            printf("Leak of %d blocks found in xmlXPathTrueFunction",
    #####:50981:	           xmlMemBlocks() - mem_base);
    #####:50982:	    test_ret++;
    #####:50983:            printf(" %d", n_ctxt);
    #####:50984:            printf(" %d", n_nargs);
    #####:50985:            printf("\n");
        -:50986:        }
        -:50987:    }
        -:50988:    }
    #####:50989:    function_tests++;
        -:50990:#endif
        -:50991:
    #####:50992:    return(test_ret);
        -:50993:}
        -:50994:
        -:50995:
        -:50996:static int
    #####:50997:test_xmlXPathValueFlipSign(void) {
    #####:50998:    int test_ret = 0;
        -:50999:
        -:51000:#if defined(LIBXML_XPATH_ENABLED)
        -:51001:    int mem_base;
        -:51002:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:51003:    int n_ctxt;
        -:51004:
    #####:51005:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:51006:        mem_base = xmlMemBlocks();
    #####:51007:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        -:51008:
    #####:51009:        xmlXPathValueFlipSign(ctxt);
    #####:51010:        call_tests++;
    #####:51011:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:51012:        xmlResetLastError();
    #####:51013:        if (mem_base != xmlMemBlocks()) {
    #####:51014:            printf("Leak of %d blocks found in xmlXPathValueFlipSign",
    #####:51015:	           xmlMemBlocks() - mem_base);
    #####:51016:	    test_ret++;
    #####:51017:            printf(" %d", n_ctxt);
    #####:51018:            printf("\n");
        -:51019:        }
        -:51020:    }
    #####:51021:    function_tests++;
        -:51022:#endif
        -:51023:
    #####:51024:    return(test_ret);
        -:51025:}
        -:51026:
        -:51027:
        -:51028:static int
    #####:51029:test_xmlXPathVariableLookup(void) {
    #####:51030:    int test_ret = 0;
        -:51031:
        -:51032:#if defined(LIBXML_XPATH_ENABLED)
        -:51033:    int mem_base;
        -:51034:    xmlXPathObjectPtr ret_val;
        -:51035:    xmlXPathContextPtr ctxt; /* the XPath context */
        -:51036:    int n_ctxt;
        -:51037:    xmlChar * name; /* the variable name */
        -:51038:    int n_name;
        -:51039:
    #####:51040:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathContextPtr;n_ctxt++) {
    #####:51041:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:51042:        mem_base = xmlMemBlocks();
    #####:51043:        ctxt = gen_xmlXPathContextPtr(n_ctxt, 0);
    #####:51044:        name = gen_const_xmlChar_ptr(n_name, 1);
        -:51045:
    #####:51046:        ret_val = xmlXPathVariableLookup(ctxt, (const xmlChar *)name);
    #####:51047:        desret_xmlXPathObjectPtr(ret_val);
    #####:51048:        call_tests++;
    #####:51049:        des_xmlXPathContextPtr(n_ctxt, ctxt, 0);
    #####:51050:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:51051:        xmlResetLastError();
    #####:51052:        if (mem_base != xmlMemBlocks()) {
    #####:51053:            printf("Leak of %d blocks found in xmlXPathVariableLookup",
    #####:51054:	           xmlMemBlocks() - mem_base);
    #####:51055:	    test_ret++;
    #####:51056:            printf(" %d", n_ctxt);
    #####:51057:            printf(" %d", n_name);
    #####:51058:            printf("\n");
        -:51059:        }
        -:51060:    }
        -:51061:    }
    #####:51062:    function_tests++;
        -:51063:#endif
        -:51064:
    #####:51065:    return(test_ret);
        -:51066:}
        -:51067:
        -:51068:
        -:51069:static int
    #####:51070:test_xmlXPathVariableLookupNS(void) {
    #####:51071:    int test_ret = 0;
        -:51072:
        -:51073:#if defined(LIBXML_XPATH_ENABLED)
        -:51074:    int mem_base;
        -:51075:    xmlXPathObjectPtr ret_val;
        -:51076:    xmlXPathContextPtr ctxt; /* the XPath context */
        -:51077:    int n_ctxt;
        -:51078:    xmlChar * name; /* the variable name */
        -:51079:    int n_name;
        -:51080:    xmlChar * ns_uri; /* the variable namespace URI */
        -:51081:    int n_ns_uri;
        -:51082:
    #####:51083:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathContextPtr;n_ctxt++) {
    #####:51084:    for (n_name = 0;n_name < gen_nb_const_xmlChar_ptr;n_name++) {
    #####:51085:    for (n_ns_uri = 0;n_ns_uri < gen_nb_const_xmlChar_ptr;n_ns_uri++) {
    #####:51086:        mem_base = xmlMemBlocks();
    #####:51087:        ctxt = gen_xmlXPathContextPtr(n_ctxt, 0);
    #####:51088:        name = gen_const_xmlChar_ptr(n_name, 1);
    #####:51089:        ns_uri = gen_const_xmlChar_ptr(n_ns_uri, 2);
        -:51090:
    #####:51091:        ret_val = xmlXPathVariableLookupNS(ctxt, (const xmlChar *)name, (const xmlChar *)ns_uri);
    #####:51092:        desret_xmlXPathObjectPtr(ret_val);
    #####:51093:        call_tests++;
    #####:51094:        des_xmlXPathContextPtr(n_ctxt, ctxt, 0);
    #####:51095:        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
    #####:51096:        des_const_xmlChar_ptr(n_ns_uri, (const xmlChar *)ns_uri, 2);
    #####:51097:        xmlResetLastError();
    #####:51098:        if (mem_base != xmlMemBlocks()) {
    #####:51099:            printf("Leak of %d blocks found in xmlXPathVariableLookupNS",
    #####:51100:	           xmlMemBlocks() - mem_base);
    #####:51101:	    test_ret++;
    #####:51102:            printf(" %d", n_ctxt);
    #####:51103:            printf(" %d", n_name);
    #####:51104:            printf(" %d", n_ns_uri);
    #####:51105:            printf("\n");
        -:51106:        }
        -:51107:    }
        -:51108:    }
        -:51109:    }
    #####:51110:    function_tests++;
        -:51111:#endif
        -:51112:
    #####:51113:    return(test_ret);
        -:51114:}
        -:51115:
        -:51116:
        -:51117:static int
    #####:51118:test_xmlXPathWrapCString(void) {
    #####:51119:    int test_ret = 0;
        -:51120:
        -:51121:#if defined(LIBXML_XPATH_ENABLED)
        -:51122:    int mem_base;
        -:51123:    xmlXPathObjectPtr ret_val;
        -:51124:    char * val; /* the char * value */
        -:51125:    int n_val;
        -:51126:
    #####:51127:    for (n_val = 0;n_val < gen_nb_char_ptr;n_val++) {
    #####:51128:        mem_base = xmlMemBlocks();
    #####:51129:        val = gen_char_ptr(n_val, 0);
        -:51130:
    #####:51131:        ret_val = xmlXPathWrapCString(val);
    #####:51132:        desret_xmlXPathObjectPtr(ret_val);
    #####:51133:        call_tests++;
    #####:51134:        des_char_ptr(n_val, val, 0);
    #####:51135:        xmlResetLastError();
    #####:51136:        if (mem_base != xmlMemBlocks()) {
    #####:51137:            printf("Leak of %d blocks found in xmlXPathWrapCString",
    #####:51138:	           xmlMemBlocks() - mem_base);
    #####:51139:	    test_ret++;
    #####:51140:            printf(" %d", n_val);
    #####:51141:            printf("\n");
        -:51142:        }
        -:51143:    }
    #####:51144:    function_tests++;
        -:51145:#endif
        -:51146:
    #####:51147:    return(test_ret);
        -:51148:}
        -:51149:
        -:51150:
        -:51151:static int
    #####:51152:test_xmlXPathWrapExternal(void) {
    #####:51153:    int test_ret = 0;
        -:51154:
        -:51155:#if defined(LIBXML_XPATH_ENABLED)
        -:51156:    int mem_base;
        -:51157:    xmlXPathObjectPtr ret_val;
        -:51158:    void * val; /* the user data */
        -:51159:    int n_val;
        -:51160:
    #####:51161:    for (n_val = 0;n_val < gen_nb_void_ptr;n_val++) {
    #####:51162:        mem_base = xmlMemBlocks();
    #####:51163:        val = gen_void_ptr(n_val, 0);
        -:51164:
    #####:51165:        ret_val = xmlXPathWrapExternal(val);
    #####:51166:        desret_xmlXPathObjectPtr(ret_val);
    #####:51167:        call_tests++;
    #####:51168:        des_void_ptr(n_val, val, 0);
    #####:51169:        xmlResetLastError();
    #####:51170:        if (mem_base != xmlMemBlocks()) {
    #####:51171:            printf("Leak of %d blocks found in xmlXPathWrapExternal",
    #####:51172:	           xmlMemBlocks() - mem_base);
    #####:51173:	    test_ret++;
    #####:51174:            printf(" %d", n_val);
    #####:51175:            printf("\n");
        -:51176:        }
        -:51177:    }
    #####:51178:    function_tests++;
        -:51179:#endif
        -:51180:
    #####:51181:    return(test_ret);
        -:51182:}
        -:51183:
        -:51184:
        -:51185:static int
    #####:51186:test_xmlXPathWrapNodeSet(void) {
    #####:51187:    int test_ret = 0;
        -:51188:
        -:51189:#if defined(LIBXML_XPATH_ENABLED)
        -:51190:    int mem_base;
        -:51191:    xmlXPathObjectPtr ret_val;
        -:51192:    xmlNodeSetPtr val; /* the NodePtr value */
        -:51193:    int n_val;
        -:51194:
    #####:51195:    for (n_val = 0;n_val < gen_nb_xmlNodeSetPtr;n_val++) {
    #####:51196:        mem_base = xmlMemBlocks();
    #####:51197:        val = gen_xmlNodeSetPtr(n_val, 0);
        -:51198:
    #####:51199:        ret_val = xmlXPathWrapNodeSet(val);
    #####:51200:        desret_xmlXPathObjectPtr(ret_val);
    #####:51201:        call_tests++;
    #####:51202:        des_xmlNodeSetPtr(n_val, val, 0);
    #####:51203:        xmlResetLastError();
    #####:51204:        if (mem_base != xmlMemBlocks()) {
    #####:51205:            printf("Leak of %d blocks found in xmlXPathWrapNodeSet",
    #####:51206:	           xmlMemBlocks() - mem_base);
    #####:51207:	    test_ret++;
    #####:51208:            printf(" %d", n_val);
    #####:51209:            printf("\n");
        -:51210:        }
        -:51211:    }
    #####:51212:    function_tests++;
        -:51213:#endif
        -:51214:
    #####:51215:    return(test_ret);
        -:51216:}
        -:51217:
        -:51218:
        -:51219:static int
    #####:51220:test_xmlXPatherror(void) {
    #####:51221:    int test_ret = 0;
        -:51222:
        -:51223:#if defined(LIBXML_XPATH_ENABLED)
        -:51224:    int mem_base;
        -:51225:    xmlXPathParserContextPtr ctxt; /* the XPath Parser context */
        -:51226:    int n_ctxt;
        -:51227:    const char * file; /* the file name */
        -:51228:    int n_file;
        -:51229:    int line; /* the line number */
        -:51230:    int n_line;
        -:51231:    int no; /* the error number */
        -:51232:    int n_no;
        -:51233:
    #####:51234:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:51235:    for (n_file = 0;n_file < gen_nb_filepath;n_file++) {
    #####:51236:    for (n_line = 0;n_line < gen_nb_int;n_line++) {
    #####:51237:    for (n_no = 0;n_no < gen_nb_int;n_no++) {
    #####:51238:        mem_base = xmlMemBlocks();
    #####:51239:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:51240:        file = gen_filepath(n_file, 1);
    #####:51241:        line = gen_int(n_line, 2);
    #####:51242:        no = gen_int(n_no, 3);
        -:51243:
    #####:51244:        xmlXPatherror(ctxt, file, line, no);
    #####:51245:        call_tests++;
    #####:51246:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:51247:        des_filepath(n_file, file, 1);
    #####:51248:        des_int(n_line, line, 2);
    #####:51249:        des_int(n_no, no, 3);
    #####:51250:        xmlResetLastError();
    #####:51251:        if (mem_base != xmlMemBlocks()) {
    #####:51252:            printf("Leak of %d blocks found in xmlXPatherror",
    #####:51253:	           xmlMemBlocks() - mem_base);
    #####:51254:	    test_ret++;
    #####:51255:            printf(" %d", n_ctxt);
    #####:51256:            printf(" %d", n_file);
    #####:51257:            printf(" %d", n_line);
    #####:51258:            printf(" %d", n_no);
    #####:51259:            printf("\n");
        -:51260:        }
        -:51261:    }
        -:51262:    }
        -:51263:    }
        -:51264:    }
    #####:51265:    function_tests++;
        -:51266:#endif
        -:51267:
    #####:51268:    return(test_ret);
        -:51269:}
        -:51270:
        -:51271:static int
    #####:51272:test_xpathInternals(void) {
    #####:51273:    int test_ret = 0;
        -:51274:
    #####:51275:    if (quiet == 0) printf("Testing xpathInternals : 106 of 117 functions ...\n");
    #####:51276:    test_ret += test_valuePop();
    #####:51277:    test_ret += test_valuePush();
    #####:51278:    test_ret += test_xmlXPathAddValues();
    #####:51279:    test_ret += test_xmlXPathBooleanFunction();
    #####:51280:    test_ret += test_xmlXPathCeilingFunction();
    #####:51281:    test_ret += test_xmlXPathCompareValues();
    #####:51282:    test_ret += test_xmlXPathConcatFunction();
    #####:51283:    test_ret += test_xmlXPathContainsFunction();
    #####:51284:    test_ret += test_xmlXPathCountFunction();
    #####:51285:    test_ret += test_xmlXPathDebugDumpCompExpr();
    #####:51286:    test_ret += test_xmlXPathDebugDumpObject();
    #####:51287:    test_ret += test_xmlXPathDifference();
    #####:51288:    test_ret += test_xmlXPathDistinct();
    #####:51289:    test_ret += test_xmlXPathDistinctSorted();
    #####:51290:    test_ret += test_xmlXPathDivValues();
    #####:51291:    test_ret += test_xmlXPathEqualValues();
    #####:51292:    test_ret += test_xmlXPathErr();
    #####:51293:    test_ret += test_xmlXPathEvalExpr();
    #####:51294:    test_ret += test_xmlXPathEvaluatePredicateResult();
    #####:51295:    test_ret += test_xmlXPathFalseFunction();
    #####:51296:    test_ret += test_xmlXPathFloorFunction();
    #####:51297:    test_ret += test_xmlXPathFunctionLookup();
    #####:51298:    test_ret += test_xmlXPathFunctionLookupNS();
    #####:51299:    test_ret += test_xmlXPathHasSameNodes();
    #####:51300:    test_ret += test_xmlXPathIdFunction();
    #####:51301:    test_ret += test_xmlXPathIntersection();
    #####:51302:    test_ret += test_xmlXPathIsNodeType();
    #####:51303:    test_ret += test_xmlXPathLangFunction();
    #####:51304:    test_ret += test_xmlXPathLastFunction();
    #####:51305:    test_ret += test_xmlXPathLeading();
    #####:51306:    test_ret += test_xmlXPathLeadingSorted();
    #####:51307:    test_ret += test_xmlXPathLocalNameFunction();
    #####:51308:    test_ret += test_xmlXPathModValues();
    #####:51309:    test_ret += test_xmlXPathMultValues();
    #####:51310:    test_ret += test_xmlXPathNamespaceURIFunction();
    #####:51311:    test_ret += test_xmlXPathNewBoolean();
    #####:51312:    test_ret += test_xmlXPathNewCString();
    #####:51313:    test_ret += test_xmlXPathNewFloat();
    #####:51314:    test_ret += test_xmlXPathNewNodeSet();
    #####:51315:    test_ret += test_xmlXPathNewNodeSetList();
    #####:51316:    test_ret += test_xmlXPathNewParserContext();
    #####:51317:    test_ret += test_xmlXPathNewString();
    #####:51318:    test_ret += test_xmlXPathNextAncestor();
    #####:51319:    test_ret += test_xmlXPathNextAncestorOrSelf();
    #####:51320:    test_ret += test_xmlXPathNextAttribute();
    #####:51321:    test_ret += test_xmlXPathNextChild();
    #####:51322:    test_ret += test_xmlXPathNextDescendant();
    #####:51323:    test_ret += test_xmlXPathNextDescendantOrSelf();
    #####:51324:    test_ret += test_xmlXPathNextFollowing();
    #####:51325:    test_ret += test_xmlXPathNextFollowingSibling();
    #####:51326:    test_ret += test_xmlXPathNextNamespace();
    #####:51327:    test_ret += test_xmlXPathNextParent();
    #####:51328:    test_ret += test_xmlXPathNextPreceding();
    #####:51329:    test_ret += test_xmlXPathNextPrecedingSibling();
    #####:51330:    test_ret += test_xmlXPathNextSelf();
    #####:51331:    test_ret += test_xmlXPathNodeLeading();
    #####:51332:    test_ret += test_xmlXPathNodeLeadingSorted();
    #####:51333:    test_ret += test_xmlXPathNodeSetAdd();
    #####:51334:    test_ret += test_xmlXPathNodeSetAddNs();
    #####:51335:    test_ret += test_xmlXPathNodeSetAddUnique();
    #####:51336:    test_ret += test_xmlXPathNodeSetContains();
    #####:51337:    test_ret += test_xmlXPathNodeSetDel();
    #####:51338:    test_ret += test_xmlXPathNodeSetMerge();
    #####:51339:    test_ret += test_xmlXPathNodeSetRemove();
    #####:51340:    test_ret += test_xmlXPathNodeSetSort();
    #####:51341:    test_ret += test_xmlXPathNodeTrailing();
    #####:51342:    test_ret += test_xmlXPathNodeTrailingSorted();
    #####:51343:    test_ret += test_xmlXPathNormalizeFunction();
    #####:51344:    test_ret += test_xmlXPathNotEqualValues();
    #####:51345:    test_ret += test_xmlXPathNotFunction();
    #####:51346:    test_ret += test_xmlXPathNsLookup();
    #####:51347:    test_ret += test_xmlXPathNumberFunction();
    #####:51348:    test_ret += test_xmlXPathParseNCName();
    #####:51349:    test_ret += test_xmlXPathParseName();
    #####:51350:    test_ret += test_xmlXPathPopBoolean();
    #####:51351:    test_ret += test_xmlXPathPopExternal();
    #####:51352:    test_ret += test_xmlXPathPopNodeSet();
    #####:51353:    test_ret += test_xmlXPathPopNumber();
    #####:51354:    test_ret += test_xmlXPathPopString();
    #####:51355:    test_ret += test_xmlXPathPositionFunction();
    #####:51356:    test_ret += test_xmlXPathRegisterAllFunctions();
    #####:51357:    test_ret += test_xmlXPathRegisterFunc();
    #####:51358:    test_ret += test_xmlXPathRegisterFuncLookup();
    #####:51359:    test_ret += test_xmlXPathRegisterFuncNS();
    #####:51360:    test_ret += test_xmlXPathRegisterNs();
    #####:51361:    test_ret += test_xmlXPathRegisterVariable();
    #####:51362:    test_ret += test_xmlXPathRegisterVariableLookup();
    #####:51363:    test_ret += test_xmlXPathRegisterVariableNS();
    #####:51364:    test_ret += test_xmlXPathRegisteredFuncsCleanup();
    #####:51365:    test_ret += test_xmlXPathRegisteredNsCleanup();
    #####:51366:    test_ret += test_xmlXPathRegisteredVariablesCleanup();
    #####:51367:    test_ret += test_xmlXPathRoot();
    #####:51368:    test_ret += test_xmlXPathRoundFunction();
    #####:51369:    test_ret += test_xmlXPathStartsWithFunction();
    #####:51370:    test_ret += test_xmlXPathStringEvalNumber();
    #####:51371:    test_ret += test_xmlXPathStringFunction();
    #####:51372:    test_ret += test_xmlXPathStringLengthFunction();
    #####:51373:    test_ret += test_xmlXPathSubValues();
    #####:51374:    test_ret += test_xmlXPathSubstringAfterFunction();
    #####:51375:    test_ret += test_xmlXPathSubstringBeforeFunction();
    #####:51376:    test_ret += test_xmlXPathSubstringFunction();
    #####:51377:    test_ret += test_xmlXPathSumFunction();
    #####:51378:    test_ret += test_xmlXPathTrailing();
    #####:51379:    test_ret += test_xmlXPathTrailingSorted();
    #####:51380:    test_ret += test_xmlXPathTranslateFunction();
    #####:51381:    test_ret += test_xmlXPathTrueFunction();
    #####:51382:    test_ret += test_xmlXPathValueFlipSign();
    #####:51383:    test_ret += test_xmlXPathVariableLookup();
    #####:51384:    test_ret += test_xmlXPathVariableLookupNS();
    #####:51385:    test_ret += test_xmlXPathWrapCString();
    #####:51386:    test_ret += test_xmlXPathWrapExternal();
    #####:51387:    test_ret += test_xmlXPathWrapNodeSet();
    #####:51388:    test_ret += test_xmlXPatherror();
        -:51389:
    #####:51390:    if (test_ret != 0)
    #####:51391:	printf("Module xpathInternals: %d errors\n", test_ret);
    #####:51392:    return(test_ret);
        -:51393:}
        -:51394:
        -:51395:static int
    #####:51396:test_xmlXPtrBuildNodeList(void) {
    #####:51397:    int test_ret = 0;
        -:51398:
        -:51399:#if defined(LIBXML_XPTR_ENABLED)
        -:51400:    int mem_base;
        -:51401:    xmlNodePtr ret_val;
        -:51402:    xmlXPathObjectPtr obj; /* the XPointer result from the evaluation. */
        -:51403:    int n_obj;
        -:51404:
    #####:51405:    for (n_obj = 0;n_obj < gen_nb_xmlXPathObjectPtr;n_obj++) {
    #####:51406:        mem_base = xmlMemBlocks();
    #####:51407:        obj = gen_xmlXPathObjectPtr(n_obj, 0);
        -:51408:
    #####:51409:        ret_val = xmlXPtrBuildNodeList(obj);
    #####:51410:        desret_xmlNodePtr(ret_val);
    #####:51411:        call_tests++;
    #####:51412:        des_xmlXPathObjectPtr(n_obj, obj, 0);
    #####:51413:        xmlResetLastError();
    #####:51414:        if (mem_base != xmlMemBlocks()) {
    #####:51415:            printf("Leak of %d blocks found in xmlXPtrBuildNodeList",
    #####:51416:	           xmlMemBlocks() - mem_base);
    #####:51417:	    test_ret++;
    #####:51418:            printf(" %d", n_obj);
    #####:51419:            printf("\n");
        -:51420:        }
        -:51421:    }
    #####:51422:    function_tests++;
        -:51423:#endif
        -:51424:
    #####:51425:    return(test_ret);
        -:51426:}
        -:51427:
        -:51428:
        -:51429:static int
    #####:51430:test_xmlXPtrEval(void) {
    #####:51431:    int test_ret = 0;
        -:51432:
        -:51433:#if defined(LIBXML_XPTR_ENABLED)
        -:51434:    int mem_base;
        -:51435:    xmlXPathObjectPtr ret_val;
        -:51436:    xmlChar * str; /* the XPointer expression */
        -:51437:    int n_str;
        -:51438:    xmlXPathContextPtr ctx; /* the XPointer context */
        -:51439:    int n_ctx;
        -:51440:
    #####:51441:    for (n_str = 0;n_str < gen_nb_const_xmlChar_ptr;n_str++) {
    #####:51442:    for (n_ctx = 0;n_ctx < gen_nb_xmlXPathContextPtr;n_ctx++) {
    #####:51443:        mem_base = xmlMemBlocks();
    #####:51444:        str = gen_const_xmlChar_ptr(n_str, 0);
    #####:51445:        ctx = gen_xmlXPathContextPtr(n_ctx, 1);
        -:51446:
    #####:51447:        ret_val = xmlXPtrEval((const xmlChar *)str, ctx);
    #####:51448:        desret_xmlXPathObjectPtr(ret_val);
    #####:51449:        call_tests++;
    #####:51450:        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 0);
    #####:51451:        des_xmlXPathContextPtr(n_ctx, ctx, 1);
    #####:51452:        xmlResetLastError();
    #####:51453:        if (mem_base != xmlMemBlocks()) {
    #####:51454:            printf("Leak of %d blocks found in xmlXPtrEval",
    #####:51455:	           xmlMemBlocks() - mem_base);
    #####:51456:	    test_ret++;
    #####:51457:            printf(" %d", n_str);
    #####:51458:            printf(" %d", n_ctx);
    #####:51459:            printf("\n");
        -:51460:        }
        -:51461:    }
        -:51462:    }
    #####:51463:    function_tests++;
        -:51464:#endif
        -:51465:
    #####:51466:    return(test_ret);
        -:51467:}
        -:51468:
        -:51469:
        -:51470:static int
    #####:51471:test_xmlXPtrEvalRangePredicate(void) {
    #####:51472:    int test_ret = 0;
        -:51473:
        -:51474:#if defined(LIBXML_XPTR_ENABLED)
        -:51475:    int mem_base;
        -:51476:    xmlXPathParserContextPtr ctxt; /* the XPointer Parser context */
        -:51477:    int n_ctxt;
        -:51478:
    #####:51479:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:51480:        mem_base = xmlMemBlocks();
    #####:51481:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        -:51482:
    #####:51483:        xmlXPtrEvalRangePredicate(ctxt);
    #####:51484:        call_tests++;
    #####:51485:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:51486:        xmlResetLastError();
    #####:51487:        if (mem_base != xmlMemBlocks()) {
    #####:51488:            printf("Leak of %d blocks found in xmlXPtrEvalRangePredicate",
    #####:51489:	           xmlMemBlocks() - mem_base);
    #####:51490:	    test_ret++;
    #####:51491:            printf(" %d", n_ctxt);
    #####:51492:            printf("\n");
        -:51493:        }
        -:51494:    }
    #####:51495:    function_tests++;
        -:51496:#endif
        -:51497:
    #####:51498:    return(test_ret);
        -:51499:}
        -:51500:
        -:51501:#ifdef LIBXML_XPTR_ENABLED
        -:51502:
        -:51503:#define gen_nb_xmlLocationSetPtr 1
    #####:51504:static xmlLocationSetPtr gen_xmlLocationSetPtr(int no ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:51505:    return(NULL);
        -:51506:}
    #####:51507:static void des_xmlLocationSetPtr(int no ATTRIBUTE_UNUSED, xmlLocationSetPtr val ATTRIBUTE_UNUSED, int nr ATTRIBUTE_UNUSED) {
    #####:51508:}
        -:51509:#endif
        -:51510:
        -:51511:
        -:51512:static int
    #####:51513:test_xmlXPtrLocationSetAdd(void) {
    #####:51514:    int test_ret = 0;
        -:51515:
        -:51516:#if defined(LIBXML_XPTR_ENABLED)
        -:51517:    int mem_base;
        -:51518:    xmlLocationSetPtr cur; /* the initial range set */
        -:51519:    int n_cur;
        -:51520:    xmlXPathObjectPtr val; /* a new xmlXPathObjectPtr */
        -:51521:    int n_val;
        -:51522:
    #####:51523:    for (n_cur = 0;n_cur < gen_nb_xmlLocationSetPtr;n_cur++) {
    #####:51524:    for (n_val = 0;n_val < gen_nb_xmlXPathObjectPtr;n_val++) {
    #####:51525:        mem_base = xmlMemBlocks();
    #####:51526:        cur = gen_xmlLocationSetPtr(n_cur, 0);
    #####:51527:        val = gen_xmlXPathObjectPtr(n_val, 1);
        -:51528:
    #####:51529:        xmlXPtrLocationSetAdd(cur, val);
    #####:51530:        call_tests++;
    #####:51531:        des_xmlLocationSetPtr(n_cur, cur, 0);
    #####:51532:        des_xmlXPathObjectPtr(n_val, val, 1);
    #####:51533:        xmlResetLastError();
    #####:51534:        if (mem_base != xmlMemBlocks()) {
    #####:51535:            printf("Leak of %d blocks found in xmlXPtrLocationSetAdd",
    #####:51536:	           xmlMemBlocks() - mem_base);
    #####:51537:	    test_ret++;
    #####:51538:            printf(" %d", n_cur);
    #####:51539:            printf(" %d", n_val);
    #####:51540:            printf("\n");
        -:51541:        }
        -:51542:    }
        -:51543:    }
    #####:51544:    function_tests++;
        -:51545:#endif
        -:51546:
    #####:51547:    return(test_ret);
        -:51548:}
        -:51549:
        -:51550:
        -:51551:static int
    #####:51552:test_xmlXPtrLocationSetCreate(void) {
    #####:51553:    int test_ret = 0;
        -:51554:
        -:51555:
        -:51556:    /* missing type support */
    #####:51557:    return(test_ret);
        -:51558:}
        -:51559:
        -:51560:
        -:51561:static int
    #####:51562:test_xmlXPtrLocationSetDel(void) {
    #####:51563:    int test_ret = 0;
        -:51564:
        -:51565:#if defined(LIBXML_XPTR_ENABLED)
        -:51566:    int mem_base;
        -:51567:    xmlLocationSetPtr cur; /* the initial range set */
        -:51568:    int n_cur;
        -:51569:    xmlXPathObjectPtr val; /* an xmlXPathObjectPtr */
        -:51570:    int n_val;
        -:51571:
    #####:51572:    for (n_cur = 0;n_cur < gen_nb_xmlLocationSetPtr;n_cur++) {
    #####:51573:    for (n_val = 0;n_val < gen_nb_xmlXPathObjectPtr;n_val++) {
    #####:51574:        mem_base = xmlMemBlocks();
    #####:51575:        cur = gen_xmlLocationSetPtr(n_cur, 0);
    #####:51576:        val = gen_xmlXPathObjectPtr(n_val, 1);
        -:51577:
    #####:51578:        xmlXPtrLocationSetDel(cur, val);
    #####:51579:        call_tests++;
    #####:51580:        des_xmlLocationSetPtr(n_cur, cur, 0);
    #####:51581:        des_xmlXPathObjectPtr(n_val, val, 1);
    #####:51582:        xmlResetLastError();
    #####:51583:        if (mem_base != xmlMemBlocks()) {
    #####:51584:            printf("Leak of %d blocks found in xmlXPtrLocationSetDel",
    #####:51585:	           xmlMemBlocks() - mem_base);
    #####:51586:	    test_ret++;
    #####:51587:            printf(" %d", n_cur);
    #####:51588:            printf(" %d", n_val);
    #####:51589:            printf("\n");
        -:51590:        }
        -:51591:    }
        -:51592:    }
    #####:51593:    function_tests++;
        -:51594:#endif
        -:51595:
    #####:51596:    return(test_ret);
        -:51597:}
        -:51598:
        -:51599:
        -:51600:static int
    #####:51601:test_xmlXPtrLocationSetMerge(void) {
    #####:51602:    int test_ret = 0;
        -:51603:
        -:51604:
        -:51605:    /* missing type support */
    #####:51606:    return(test_ret);
        -:51607:}
        -:51608:
        -:51609:
        -:51610:static int
    #####:51611:test_xmlXPtrLocationSetRemove(void) {
    #####:51612:    int test_ret = 0;
        -:51613:
        -:51614:#if defined(LIBXML_XPTR_ENABLED)
        -:51615:    int mem_base;
        -:51616:    xmlLocationSetPtr cur; /* the initial range set */
        -:51617:    int n_cur;
        -:51618:    int val; /* the index to remove */
        -:51619:    int n_val;
        -:51620:
    #####:51621:    for (n_cur = 0;n_cur < gen_nb_xmlLocationSetPtr;n_cur++) {
    #####:51622:    for (n_val = 0;n_val < gen_nb_int;n_val++) {
    #####:51623:        mem_base = xmlMemBlocks();
    #####:51624:        cur = gen_xmlLocationSetPtr(n_cur, 0);
    #####:51625:        val = gen_int(n_val, 1);
        -:51626:
    #####:51627:        xmlXPtrLocationSetRemove(cur, val);
    #####:51628:        call_tests++;
    #####:51629:        des_xmlLocationSetPtr(n_cur, cur, 0);
    #####:51630:        des_int(n_val, val, 1);
    #####:51631:        xmlResetLastError();
    #####:51632:        if (mem_base != xmlMemBlocks()) {
    #####:51633:            printf("Leak of %d blocks found in xmlXPtrLocationSetRemove",
    #####:51634:	           xmlMemBlocks() - mem_base);
    #####:51635:	    test_ret++;
    #####:51636:            printf(" %d", n_cur);
    #####:51637:            printf(" %d", n_val);
    #####:51638:            printf("\n");
        -:51639:        }
        -:51640:    }
        -:51641:    }
    #####:51642:    function_tests++;
        -:51643:#endif
        -:51644:
    #####:51645:    return(test_ret);
        -:51646:}
        -:51647:
        -:51648:
        -:51649:static int
    #####:51650:test_xmlXPtrNewCollapsedRange(void) {
    #####:51651:    int test_ret = 0;
        -:51652:
        -:51653:#if defined(LIBXML_XPTR_ENABLED)
        -:51654:    int mem_base;
        -:51655:    xmlXPathObjectPtr ret_val;
        -:51656:    xmlNodePtr start; /* the starting and ending node */
        -:51657:    int n_start;
        -:51658:
    #####:51659:    for (n_start = 0;n_start < gen_nb_xmlNodePtr;n_start++) {
    #####:51660:        mem_base = xmlMemBlocks();
    #####:51661:        start = gen_xmlNodePtr(n_start, 0);
        -:51662:
    #####:51663:        ret_val = xmlXPtrNewCollapsedRange(start);
    #####:51664:        desret_xmlXPathObjectPtr(ret_val);
    #####:51665:        call_tests++;
    #####:51666:        des_xmlNodePtr(n_start, start, 0);
    #####:51667:        xmlResetLastError();
    #####:51668:        if (mem_base != xmlMemBlocks()) {
    #####:51669:            printf("Leak of %d blocks found in xmlXPtrNewCollapsedRange",
    #####:51670:	           xmlMemBlocks() - mem_base);
    #####:51671:	    test_ret++;
    #####:51672:            printf(" %d", n_start);
    #####:51673:            printf("\n");
        -:51674:        }
        -:51675:    }
    #####:51676:    function_tests++;
        -:51677:#endif
        -:51678:
    #####:51679:    return(test_ret);
        -:51680:}
        -:51681:
        -:51682:
        -:51683:static int
    #####:51684:test_xmlXPtrNewContext(void) {
    #####:51685:    int test_ret = 0;
        -:51686:
        -:51687:
        -:51688:    /* missing type support */
    #####:51689:    return(test_ret);
        -:51690:}
        -:51691:
        -:51692:
        -:51693:static int
    #####:51694:test_xmlXPtrNewLocationSetNodeSet(void) {
    #####:51695:    int test_ret = 0;
        -:51696:
        -:51697:#if defined(LIBXML_XPTR_ENABLED)
        -:51698:    int mem_base;
        -:51699:    xmlXPathObjectPtr ret_val;
        -:51700:    xmlNodeSetPtr set; /* a node set */
        -:51701:    int n_set;
        -:51702:
    #####:51703:    for (n_set = 0;n_set < gen_nb_xmlNodeSetPtr;n_set++) {
    #####:51704:        mem_base = xmlMemBlocks();
    #####:51705:        set = gen_xmlNodeSetPtr(n_set, 0);
        -:51706:
    #####:51707:        ret_val = xmlXPtrNewLocationSetNodeSet(set);
    #####:51708:        desret_xmlXPathObjectPtr(ret_val);
    #####:51709:        call_tests++;
    #####:51710:        des_xmlNodeSetPtr(n_set, set, 0);
    #####:51711:        xmlResetLastError();
    #####:51712:        if (mem_base != xmlMemBlocks()) {
    #####:51713:            printf("Leak of %d blocks found in xmlXPtrNewLocationSetNodeSet",
    #####:51714:	           xmlMemBlocks() - mem_base);
    #####:51715:	    test_ret++;
    #####:51716:            printf(" %d", n_set);
    #####:51717:            printf("\n");
        -:51718:        }
        -:51719:    }
    #####:51720:    function_tests++;
        -:51721:#endif
        -:51722:
    #####:51723:    return(test_ret);
        -:51724:}
        -:51725:
        -:51726:
        -:51727:static int
    #####:51728:test_xmlXPtrNewLocationSetNodes(void) {
    #####:51729:    int test_ret = 0;
        -:51730:
        -:51731:#if defined(LIBXML_XPTR_ENABLED)
        -:51732:    int mem_base;
        -:51733:    xmlXPathObjectPtr ret_val;
        -:51734:    xmlNodePtr start; /* the start NodePtr value */
        -:51735:    int n_start;
        -:51736:    xmlNodePtr end; /* the end NodePtr value or NULL */
        -:51737:    int n_end;
        -:51738:
    #####:51739:    for (n_start = 0;n_start < gen_nb_xmlNodePtr;n_start++) {
    #####:51740:    for (n_end = 0;n_end < gen_nb_xmlNodePtr;n_end++) {
    #####:51741:        mem_base = xmlMemBlocks();
    #####:51742:        start = gen_xmlNodePtr(n_start, 0);
    #####:51743:        end = gen_xmlNodePtr(n_end, 1);
        -:51744:
    #####:51745:        ret_val = xmlXPtrNewLocationSetNodes(start, end);
    #####:51746:        desret_xmlXPathObjectPtr(ret_val);
    #####:51747:        call_tests++;
    #####:51748:        des_xmlNodePtr(n_start, start, 0);
    #####:51749:        des_xmlNodePtr(n_end, end, 1);
    #####:51750:        xmlResetLastError();
    #####:51751:        if (mem_base != xmlMemBlocks()) {
    #####:51752:            printf("Leak of %d blocks found in xmlXPtrNewLocationSetNodes",
    #####:51753:	           xmlMemBlocks() - mem_base);
    #####:51754:	    test_ret++;
    #####:51755:            printf(" %d", n_start);
    #####:51756:            printf(" %d", n_end);
    #####:51757:            printf("\n");
        -:51758:        }
        -:51759:    }
        -:51760:    }
    #####:51761:    function_tests++;
        -:51762:#endif
        -:51763:
    #####:51764:    return(test_ret);
        -:51765:}
        -:51766:
        -:51767:
        -:51768:static int
    #####:51769:test_xmlXPtrNewRange(void) {
    #####:51770:    int test_ret = 0;
        -:51771:
        -:51772:#if defined(LIBXML_XPTR_ENABLED)
        -:51773:    int mem_base;
        -:51774:    xmlXPathObjectPtr ret_val;
        -:51775:    xmlNodePtr start; /* the starting node */
        -:51776:    int n_start;
        -:51777:    int startindex; /* the start index */
        -:51778:    int n_startindex;
        -:51779:    xmlNodePtr end; /* the ending point */
        -:51780:    int n_end;
        -:51781:    int endindex; /* the ending index */
        -:51782:    int n_endindex;
        -:51783:
    #####:51784:    for (n_start = 0;n_start < gen_nb_xmlNodePtr;n_start++) {
    #####:51785:    for (n_startindex = 0;n_startindex < gen_nb_int;n_startindex++) {
    #####:51786:    for (n_end = 0;n_end < gen_nb_xmlNodePtr;n_end++) {
    #####:51787:    for (n_endindex = 0;n_endindex < gen_nb_int;n_endindex++) {
    #####:51788:        mem_base = xmlMemBlocks();
    #####:51789:        start = gen_xmlNodePtr(n_start, 0);
    #####:51790:        startindex = gen_int(n_startindex, 1);
    #####:51791:        end = gen_xmlNodePtr(n_end, 2);
    #####:51792:        endindex = gen_int(n_endindex, 3);
        -:51793:
    #####:51794:        ret_val = xmlXPtrNewRange(start, startindex, end, endindex);
    #####:51795:        desret_xmlXPathObjectPtr(ret_val);
    #####:51796:        call_tests++;
    #####:51797:        des_xmlNodePtr(n_start, start, 0);
    #####:51798:        des_int(n_startindex, startindex, 1);
    #####:51799:        des_xmlNodePtr(n_end, end, 2);
    #####:51800:        des_int(n_endindex, endindex, 3);
    #####:51801:        xmlResetLastError();
    #####:51802:        if (mem_base != xmlMemBlocks()) {
    #####:51803:            printf("Leak of %d blocks found in xmlXPtrNewRange",
    #####:51804:	           xmlMemBlocks() - mem_base);
    #####:51805:	    test_ret++;
    #####:51806:            printf(" %d", n_start);
    #####:51807:            printf(" %d", n_startindex);
    #####:51808:            printf(" %d", n_end);
    #####:51809:            printf(" %d", n_endindex);
    #####:51810:            printf("\n");
        -:51811:        }
        -:51812:    }
        -:51813:    }
        -:51814:    }
        -:51815:    }
    #####:51816:    function_tests++;
        -:51817:#endif
        -:51818:
    #####:51819:    return(test_ret);
        -:51820:}
        -:51821:
        -:51822:
        -:51823:static int
    #####:51824:test_xmlXPtrNewRangeNodeObject(void) {
    #####:51825:    int test_ret = 0;
        -:51826:
        -:51827:#if defined(LIBXML_XPTR_ENABLED)
        -:51828:    int mem_base;
        -:51829:    xmlXPathObjectPtr ret_val;
        -:51830:    xmlNodePtr start; /* the starting node */
        -:51831:    int n_start;
        -:51832:    xmlXPathObjectPtr end; /* the ending object */
        -:51833:    int n_end;
        -:51834:
    #####:51835:    for (n_start = 0;n_start < gen_nb_xmlNodePtr;n_start++) {
    #####:51836:    for (n_end = 0;n_end < gen_nb_xmlXPathObjectPtr;n_end++) {
    #####:51837:        mem_base = xmlMemBlocks();
    #####:51838:        start = gen_xmlNodePtr(n_start, 0);
    #####:51839:        end = gen_xmlXPathObjectPtr(n_end, 1);
        -:51840:
    #####:51841:        ret_val = xmlXPtrNewRangeNodeObject(start, end);
    #####:51842:        desret_xmlXPathObjectPtr(ret_val);
    #####:51843:        call_tests++;
    #####:51844:        des_xmlNodePtr(n_start, start, 0);
    #####:51845:        des_xmlXPathObjectPtr(n_end, end, 1);
    #####:51846:        xmlResetLastError();
    #####:51847:        if (mem_base != xmlMemBlocks()) {
    #####:51848:            printf("Leak of %d blocks found in xmlXPtrNewRangeNodeObject",
    #####:51849:	           xmlMemBlocks() - mem_base);
    #####:51850:	    test_ret++;
    #####:51851:            printf(" %d", n_start);
    #####:51852:            printf(" %d", n_end);
    #####:51853:            printf("\n");
        -:51854:        }
        -:51855:    }
        -:51856:    }
    #####:51857:    function_tests++;
        -:51858:#endif
        -:51859:
    #####:51860:    return(test_ret);
        -:51861:}
        -:51862:
        -:51863:
        -:51864:static int
    #####:51865:test_xmlXPtrNewRangeNodePoint(void) {
    #####:51866:    int test_ret = 0;
        -:51867:
        -:51868:#if defined(LIBXML_XPTR_ENABLED)
        -:51869:    int mem_base;
        -:51870:    xmlXPathObjectPtr ret_val;
        -:51871:    xmlNodePtr start; /* the starting node */
        -:51872:    int n_start;
        -:51873:    xmlXPathObjectPtr end; /* the ending point */
        -:51874:    int n_end;
        -:51875:
    #####:51876:    for (n_start = 0;n_start < gen_nb_xmlNodePtr;n_start++) {
    #####:51877:    for (n_end = 0;n_end < gen_nb_xmlXPathObjectPtr;n_end++) {
    #####:51878:        mem_base = xmlMemBlocks();
    #####:51879:        start = gen_xmlNodePtr(n_start, 0);
    #####:51880:        end = gen_xmlXPathObjectPtr(n_end, 1);
        -:51881:
    #####:51882:        ret_val = xmlXPtrNewRangeNodePoint(start, end);
    #####:51883:        desret_xmlXPathObjectPtr(ret_val);
    #####:51884:        call_tests++;
    #####:51885:        des_xmlNodePtr(n_start, start, 0);
    #####:51886:        des_xmlXPathObjectPtr(n_end, end, 1);
    #####:51887:        xmlResetLastError();
    #####:51888:        if (mem_base != xmlMemBlocks()) {
    #####:51889:            printf("Leak of %d blocks found in xmlXPtrNewRangeNodePoint",
    #####:51890:	           xmlMemBlocks() - mem_base);
    #####:51891:	    test_ret++;
    #####:51892:            printf(" %d", n_start);
    #####:51893:            printf(" %d", n_end);
    #####:51894:            printf("\n");
        -:51895:        }
        -:51896:    }
        -:51897:    }
    #####:51898:    function_tests++;
        -:51899:#endif
        -:51900:
    #####:51901:    return(test_ret);
        -:51902:}
        -:51903:
        -:51904:
        -:51905:static int
    #####:51906:test_xmlXPtrNewRangeNodes(void) {
    #####:51907:    int test_ret = 0;
        -:51908:
        -:51909:#if defined(LIBXML_XPTR_ENABLED)
        -:51910:    int mem_base;
        -:51911:    xmlXPathObjectPtr ret_val;
        -:51912:    xmlNodePtr start; /* the starting node */
        -:51913:    int n_start;
        -:51914:    xmlNodePtr end; /* the ending node */
        -:51915:    int n_end;
        -:51916:
    #####:51917:    for (n_start = 0;n_start < gen_nb_xmlNodePtr;n_start++) {
    #####:51918:    for (n_end = 0;n_end < gen_nb_xmlNodePtr;n_end++) {
    #####:51919:        mem_base = xmlMemBlocks();
    #####:51920:        start = gen_xmlNodePtr(n_start, 0);
    #####:51921:        end = gen_xmlNodePtr(n_end, 1);
        -:51922:
    #####:51923:        ret_val = xmlXPtrNewRangeNodes(start, end);
    #####:51924:        desret_xmlXPathObjectPtr(ret_val);
    #####:51925:        call_tests++;
    #####:51926:        des_xmlNodePtr(n_start, start, 0);
    #####:51927:        des_xmlNodePtr(n_end, end, 1);
    #####:51928:        xmlResetLastError();
    #####:51929:        if (mem_base != xmlMemBlocks()) {
    #####:51930:            printf("Leak of %d blocks found in xmlXPtrNewRangeNodes",
    #####:51931:	           xmlMemBlocks() - mem_base);
    #####:51932:	    test_ret++;
    #####:51933:            printf(" %d", n_start);
    #####:51934:            printf(" %d", n_end);
    #####:51935:            printf("\n");
        -:51936:        }
        -:51937:    }
        -:51938:    }
    #####:51939:    function_tests++;
        -:51940:#endif
        -:51941:
    #####:51942:    return(test_ret);
        -:51943:}
        -:51944:
        -:51945:
        -:51946:static int
    #####:51947:test_xmlXPtrNewRangePointNode(void) {
    #####:51948:    int test_ret = 0;
        -:51949:
        -:51950:#if defined(LIBXML_XPTR_ENABLED)
        -:51951:    int mem_base;
        -:51952:    xmlXPathObjectPtr ret_val;
        -:51953:    xmlXPathObjectPtr start; /* the starting point */
        -:51954:    int n_start;
        -:51955:    xmlNodePtr end; /* the ending node */
        -:51956:    int n_end;
        -:51957:
    #####:51958:    for (n_start = 0;n_start < gen_nb_xmlXPathObjectPtr;n_start++) {
    #####:51959:    for (n_end = 0;n_end < gen_nb_xmlNodePtr;n_end++) {
    #####:51960:        mem_base = xmlMemBlocks();
    #####:51961:        start = gen_xmlXPathObjectPtr(n_start, 0);
    #####:51962:        end = gen_xmlNodePtr(n_end, 1);
        -:51963:
    #####:51964:        ret_val = xmlXPtrNewRangePointNode(start, end);
    #####:51965:        desret_xmlXPathObjectPtr(ret_val);
    #####:51966:        call_tests++;
    #####:51967:        des_xmlXPathObjectPtr(n_start, start, 0);
    #####:51968:        des_xmlNodePtr(n_end, end, 1);
    #####:51969:        xmlResetLastError();
    #####:51970:        if (mem_base != xmlMemBlocks()) {
    #####:51971:            printf("Leak of %d blocks found in xmlXPtrNewRangePointNode",
    #####:51972:	           xmlMemBlocks() - mem_base);
    #####:51973:	    test_ret++;
    #####:51974:            printf(" %d", n_start);
    #####:51975:            printf(" %d", n_end);
    #####:51976:            printf("\n");
        -:51977:        }
        -:51978:    }
        -:51979:    }
    #####:51980:    function_tests++;
        -:51981:#endif
        -:51982:
    #####:51983:    return(test_ret);
        -:51984:}
        -:51985:
        -:51986:
        -:51987:static int
    #####:51988:test_xmlXPtrNewRangePoints(void) {
    #####:51989:    int test_ret = 0;
        -:51990:
        -:51991:#if defined(LIBXML_XPTR_ENABLED)
        -:51992:    int mem_base;
        -:51993:    xmlXPathObjectPtr ret_val;
        -:51994:    xmlXPathObjectPtr start; /* the starting point */
        -:51995:    int n_start;
        -:51996:    xmlXPathObjectPtr end; /* the ending point */
        -:51997:    int n_end;
        -:51998:
    #####:51999:    for (n_start = 0;n_start < gen_nb_xmlXPathObjectPtr;n_start++) {
    #####:52000:    for (n_end = 0;n_end < gen_nb_xmlXPathObjectPtr;n_end++) {
    #####:52001:        mem_base = xmlMemBlocks();
    #####:52002:        start = gen_xmlXPathObjectPtr(n_start, 0);
    #####:52003:        end = gen_xmlXPathObjectPtr(n_end, 1);
        -:52004:
    #####:52005:        ret_val = xmlXPtrNewRangePoints(start, end);
    #####:52006:        desret_xmlXPathObjectPtr(ret_val);
    #####:52007:        call_tests++;
    #####:52008:        des_xmlXPathObjectPtr(n_start, start, 0);
    #####:52009:        des_xmlXPathObjectPtr(n_end, end, 1);
    #####:52010:        xmlResetLastError();
    #####:52011:        if (mem_base != xmlMemBlocks()) {
    #####:52012:            printf("Leak of %d blocks found in xmlXPtrNewRangePoints",
    #####:52013:	           xmlMemBlocks() - mem_base);
    #####:52014:	    test_ret++;
    #####:52015:            printf(" %d", n_start);
    #####:52016:            printf(" %d", n_end);
    #####:52017:            printf("\n");
        -:52018:        }
        -:52019:    }
        -:52020:    }
    #####:52021:    function_tests++;
        -:52022:#endif
        -:52023:
    #####:52024:    return(test_ret);
        -:52025:}
        -:52026:
        -:52027:
        -:52028:static int
    #####:52029:test_xmlXPtrRangeToFunction(void) {
    #####:52030:    int test_ret = 0;
        -:52031:
        -:52032:#if defined(LIBXML_XPTR_ENABLED)
        -:52033:    int mem_base;
        -:52034:    xmlXPathParserContextPtr ctxt; /* the XPointer Parser context */
        -:52035:    int n_ctxt;
        -:52036:    int nargs; /* the number of args */
        -:52037:    int n_nargs;
        -:52038:
    #####:52039:    for (n_ctxt = 0;n_ctxt < gen_nb_xmlXPathParserContextPtr;n_ctxt++) {
    #####:52040:    for (n_nargs = 0;n_nargs < gen_nb_int;n_nargs++) {
    #####:52041:        mem_base = xmlMemBlocks();
    #####:52042:        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
    #####:52043:        nargs = gen_int(n_nargs, 1);
        -:52044:
    #####:52045:        xmlXPtrRangeToFunction(ctxt, nargs);
    #####:52046:        call_tests++;
    #####:52047:        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
    #####:52048:        des_int(n_nargs, nargs, 1);
    #####:52049:        xmlResetLastError();
    #####:52050:        if (mem_base != xmlMemBlocks()) {
    #####:52051:            printf("Leak of %d blocks found in xmlXPtrRangeToFunction",
    #####:52052:	           xmlMemBlocks() - mem_base);
    #####:52053:	    test_ret++;
    #####:52054:            printf(" %d", n_ctxt);
    #####:52055:            printf(" %d", n_nargs);
    #####:52056:            printf("\n");
        -:52057:        }
        -:52058:    }
        -:52059:    }
    #####:52060:    function_tests++;
        -:52061:#endif
        -:52062:
    #####:52063:    return(test_ret);
        -:52064:}
        -:52065:
        -:52066:
        -:52067:static int
    #####:52068:test_xmlXPtrWrapLocationSet(void) {
    #####:52069:    int test_ret = 0;
        -:52070:
        -:52071:#if defined(LIBXML_XPTR_ENABLED)
        -:52072:    int mem_base;
        -:52073:    xmlXPathObjectPtr ret_val;
        -:52074:    xmlLocationSetPtr val; /* the LocationSet value */
        -:52075:    int n_val;
        -:52076:
    #####:52077:    for (n_val = 0;n_val < gen_nb_xmlLocationSetPtr;n_val++) {
    #####:52078:        mem_base = xmlMemBlocks();
    #####:52079:        val = gen_xmlLocationSetPtr(n_val, 0);
        -:52080:
    #####:52081:        ret_val = xmlXPtrWrapLocationSet(val);
    #####:52082:        desret_xmlXPathObjectPtr(ret_val);
    #####:52083:        call_tests++;
    #####:52084:        des_xmlLocationSetPtr(n_val, val, 0);
    #####:52085:        xmlResetLastError();
    #####:52086:        if (mem_base != xmlMemBlocks()) {
    #####:52087:            printf("Leak of %d blocks found in xmlXPtrWrapLocationSet",
    #####:52088:	           xmlMemBlocks() - mem_base);
    #####:52089:	    test_ret++;
    #####:52090:            printf(" %d", n_val);
    #####:52091:            printf("\n");
        -:52092:        }
        -:52093:    }
    #####:52094:    function_tests++;
        -:52095:#endif
        -:52096:
    #####:52097:    return(test_ret);
        -:52098:}
        -:52099:
        -:52100:static int
    #####:52101:test_xpointer(void) {
    #####:52102:    int test_ret = 0;
        -:52103:
    #####:52104:    if (quiet == 0) printf("Testing xpointer : 17 of 21 functions ...\n");
    #####:52105:    test_ret += test_xmlXPtrBuildNodeList();
    #####:52106:    test_ret += test_xmlXPtrEval();
    #####:52107:    test_ret += test_xmlXPtrEvalRangePredicate();
    #####:52108:    test_ret += test_xmlXPtrLocationSetAdd();
    #####:52109:    test_ret += test_xmlXPtrLocationSetCreate();
    #####:52110:    test_ret += test_xmlXPtrLocationSetDel();
    #####:52111:    test_ret += test_xmlXPtrLocationSetMerge();
    #####:52112:    test_ret += test_xmlXPtrLocationSetRemove();
    #####:52113:    test_ret += test_xmlXPtrNewCollapsedRange();
    #####:52114:    test_ret += test_xmlXPtrNewContext();
    #####:52115:    test_ret += test_xmlXPtrNewLocationSetNodeSet();
    #####:52116:    test_ret += test_xmlXPtrNewLocationSetNodes();
    #####:52117:    test_ret += test_xmlXPtrNewRange();
    #####:52118:    test_ret += test_xmlXPtrNewRangeNodeObject();
    #####:52119:    test_ret += test_xmlXPtrNewRangeNodePoint();
    #####:52120:    test_ret += test_xmlXPtrNewRangeNodes();
    #####:52121:    test_ret += test_xmlXPtrNewRangePointNode();
    #####:52122:    test_ret += test_xmlXPtrNewRangePoints();
    #####:52123:    test_ret += test_xmlXPtrRangeToFunction();
    #####:52124:    test_ret += test_xmlXPtrWrapLocationSet();
        -:52125:
    #####:52126:    if (test_ret != 0)
    #####:52127:	printf("Module xpointer: %d errors\n", test_ret);
    #####:52128:    return(test_ret);
        -:52129:}
        -:52130:static int
    #####:52131:test_module(const char *module) {
    #####:52132:    if (!strcmp(module, "HTMLparser")) return(test_HTMLparser());
    #####:52133:    if (!strcmp(module, "HTMLtree")) return(test_HTMLtree());
    #####:52134:    if (!strcmp(module, "SAX2")) return(test_SAX2());
    #####:52135:    if (!strcmp(module, "c14n")) return(test_c14n());
    #####:52136:    if (!strcmp(module, "catalog")) return(test_catalog());
    #####:52137:    if (!strcmp(module, "chvalid")) return(test_chvalid());
    #####:52138:    if (!strcmp(module, "debugXML")) return(test_debugXML());
    #####:52139:    if (!strcmp(module, "dict")) return(test_dict());
    #####:52140:    if (!strcmp(module, "encoding")) return(test_encoding());
    #####:52141:    if (!strcmp(module, "entities")) return(test_entities());
    #####:52142:    if (!strcmp(module, "hash")) return(test_hash());
    #####:52143:    if (!strcmp(module, "list")) return(test_list());
    #####:52144:    if (!strcmp(module, "nanoftp")) return(test_nanoftp());
    #####:52145:    if (!strcmp(module, "nanohttp")) return(test_nanohttp());
    #####:52146:    if (!strcmp(module, "parser")) return(test_parser());
    #####:52147:    if (!strcmp(module, "parserInternals")) return(test_parserInternals());
    #####:52148:    if (!strcmp(module, "pattern")) return(test_pattern());
    #####:52149:    if (!strcmp(module, "relaxng")) return(test_relaxng());
    #####:52150:    if (!strcmp(module, "schemasInternals")) return(test_schemasInternals());
    #####:52151:    if (!strcmp(module, "schematron")) return(test_schematron());
    #####:52152:    if (!strcmp(module, "tree")) return(test_tree());
    #####:52153:    if (!strcmp(module, "uri")) return(test_uri());
    #####:52154:    if (!strcmp(module, "valid")) return(test_valid());
    #####:52155:    if (!strcmp(module, "xinclude")) return(test_xinclude());
    #####:52156:    if (!strcmp(module, "xmlIO")) return(test_xmlIO());
    #####:52157:    if (!strcmp(module, "xmlautomata")) return(test_xmlautomata());
    #####:52158:    if (!strcmp(module, "xmlerror")) return(test_xmlerror());
    #####:52159:    if (!strcmp(module, "xmlmodule")) return(test_xmlmodule());
    #####:52160:    if (!strcmp(module, "xmlreader")) return(test_xmlreader());
    #####:52161:    if (!strcmp(module, "xmlregexp")) return(test_xmlregexp());
    #####:52162:    if (!strcmp(module, "xmlsave")) return(test_xmlsave());
    #####:52163:    if (!strcmp(module, "xmlschemas")) return(test_xmlschemas());
    #####:52164:    if (!strcmp(module, "xmlschemastypes")) return(test_xmlschemastypes());
    #####:52165:    if (!strcmp(module, "xmlstring")) return(test_xmlstring());
    #####:52166:    if (!strcmp(module, "xmlunicode")) return(test_xmlunicode());
    #####:52167:    if (!strcmp(module, "xmlwriter")) return(test_xmlwriter());
    #####:52168:    if (!strcmp(module, "xpath")) return(test_xpath());
    #####:52169:    if (!strcmp(module, "xpathInternals")) return(test_xpathInternals());
    #####:52170:    if (!strcmp(module, "xpointer")) return(test_xpointer());
    #####:52171:    return(0);
        -:52172:}
